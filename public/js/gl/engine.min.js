(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{"1YiZ5S":5,"buffer":2}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/index.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer")
},{"1YiZ5S":5,"base64-js":3,"buffer":2,"ieee754":4}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib")
},{"1YiZ5S":5,"buffer":2}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754")
},{"1YiZ5S":5,"buffer":2}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/process/browser.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/process")
},{"1YiZ5S":5,"buffer":2}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var self = self || {};/**
 * @author mrdoob / http://mrdoob.com/
 * @author Larry Battle / http://bateru.com/news
 * @author bhouston / http://exocortex.com
 */

var THREE = { REVISION: '66' };

self.console = self.console || {

	info: function () {},
	log: function () {},
	debug: function () {},
	warn: function () {},
	error: function () {}

};

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik MÃ¶ller
// fixes from Paul Irish and Tino Zijdel
// using 'self' instead of 'window' for compatibility with both NodeJS and IE10.
( function () {

	var lastTime = 0;
	var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

	for ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++ x ) {

		self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
		self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

	}

	if ( self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined ) {

		self.requestAnimationFrame = function ( callback ) {

			var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
			var id = self.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );
			lastTime = currTime + timeToCall;
			return id;

		};

	}

	if( self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined ) {

		self.cancelAnimationFrame = function ( id ) { self.clearTimeout( id ) };

	}

}() );

THREE.ExceptionErrorHandler = function( message, optionalData ) {
	console.error( message );
	console.error( optionalData );
	var error = new Error( message );
	error.optionalData = optionalData;
	throw error;
};

THREE.ConsoleErrorHandler = function( message, optionalData ) {
	console.error( message );
	console.error( optionalData );
};

THREE.ConsoleWarningHandler = function( message, optionalData ) {
	console.warn( message );
	console.warn( optionalData );
};

THREE.NullHandler = function( message, optionalData ) {
};

// the default error handler is exception
THREE.onerror = THREE.ExceptionErrorHandler;

THREE.onwarning = THREE.ConsoleWarningHandler;

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = function () {};

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;

// Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;

/*
// Potential future PVRTC compressed texture formats
THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
*/

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

	}

	return this.set( color )

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var hue2rgb = function ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			};

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		// rgb(255,0,0)

		if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

			var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

			return this;

		}

		// rgb(100%,0%,0%)

		if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

			var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

			return this;

		}

		// #ff0000

		if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

			var color = /^\#([0-9a-f]{6})$/i.exec( style );

			this.setHex( parseInt( color[ 1 ], 16 ) );

			return this;

		}

		// #f00

		if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

			var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

			return this;

		}

		// red

		if ( /^(\w+)$/i.test( style ) ) {

			this.setHex( THREE.ColorKeywords[ style ] );

			return this;

		}


	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array ) {

		this.r = array[ 0 ];
		this.g = array[ 1 ];
		this.b = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.r, this.g, this.b ];

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

};

THREE.ColorKeywords = { "aliceblue": 0xF0F8FF, "antiquewhite": 0xFAEBD7, "aqua": 0x00FFFF, "aquamarine": 0x7FFFD4, "azure": 0xF0FFFF,
"beige": 0xF5F5DC, "bisque": 0xFFE4C4, "black": 0x000000, "blanchedalmond": 0xFFEBCD, "blue": 0x0000FF, "blueviolet": 0x8A2BE2,
"brown": 0xA52A2A, "burlywood": 0xDEB887, "cadetblue": 0x5F9EA0, "chartreuse": 0x7FFF00, "chocolate": 0xD2691E, "coral": 0xFF7F50,
"cornflowerblue": 0x6495ED, "cornsilk": 0xFFF8DC, "crimson": 0xDC143C, "cyan": 0x00FFFF, "darkblue": 0x00008B, "darkcyan": 0x008B8B,
"darkgoldenrod": 0xB8860B, "darkgray": 0xA9A9A9, "darkgreen": 0x006400, "darkgrey": 0xA9A9A9, "darkkhaki": 0xBDB76B, "darkmagenta": 0x8B008B,
"darkolivegreen": 0x556B2F, "darkorange": 0xFF8C00, "darkorchid": 0x9932CC, "darkred": 0x8B0000, "darksalmon": 0xE9967A, "darkseagreen": 0x8FBC8F,
"darkslateblue": 0x483D8B, "darkslategray": 0x2F4F4F, "darkslategrey": 0x2F4F4F, "darkturquoise": 0x00CED1, "darkviolet": 0x9400D3,
"deeppink": 0xFF1493, "deepskyblue": 0x00BFFF, "dimgray": 0x696969, "dimgrey": 0x696969, "dodgerblue": 0x1E90FF, "firebrick": 0xB22222,
"floralwhite": 0xFFFAF0, "forestgreen": 0x228B22, "fuchsia": 0xFF00FF, "gainsboro": 0xDCDCDC, "ghostwhite": 0xF8F8FF, "gold": 0xFFD700,
"goldenrod": 0xDAA520, "gray": 0x808080, "green": 0x008000, "greenyellow": 0xADFF2F, "grey": 0x808080, "honeydew": 0xF0FFF0, "hotpink": 0xFF69B4,
"indianred": 0xCD5C5C, "indigo": 0x4B0082, "ivory": 0xFFFFF0, "khaki": 0xF0E68C, "lavender": 0xE6E6FA, "lavenderblush": 0xFFF0F5, "lawngreen": 0x7CFC00,
"lemonchiffon": 0xFFFACD, "lightblue": 0xADD8E6, "lightcoral": 0xF08080, "lightcyan": 0xE0FFFF, "lightgoldenrodyellow": 0xFAFAD2, "lightgray": 0xD3D3D3,
"lightgreen": 0x90EE90, "lightgrey": 0xD3D3D3, "lightpink": 0xFFB6C1, "lightsalmon": 0xFFA07A, "lightseagreen": 0x20B2AA, "lightskyblue": 0x87CEFA,
"lightslategray": 0x778899, "lightslategrey": 0x778899, "lightsteelblue": 0xB0C4DE, "lightyellow": 0xFFFFE0, "lime": 0x00FF00, "limegreen": 0x32CD32,
"linen": 0xFAF0E6, "magenta": 0xFF00FF, "maroon": 0x800000, "mediumaquamarine": 0x66CDAA, "mediumblue": 0x0000CD, "mediumorchid": 0xBA55D3,
"mediumpurple": 0x9370DB, "mediumseagreen": 0x3CB371, "mediumslateblue": 0x7B68EE, "mediumspringgreen": 0x00FA9A, "mediumturquoise": 0x48D1CC,
"mediumvioletred": 0xC71585, "midnightblue": 0x191970, "mintcream": 0xF5FFFA, "mistyrose": 0xFFE4E1, "moccasin": 0xFFE4B5, "navajowhite": 0xFFDEAD,
"navy": 0x000080, "oldlace": 0xFDF5E6, "olive": 0x808000, "olivedrab": 0x6B8E23, "orange": 0xFFA500, "orangered": 0xFF4500, "orchid": 0xDA70D6,
"palegoldenrod": 0xEEE8AA, "palegreen": 0x98FB98, "paleturquoise": 0xAFEEEE, "palevioletred": 0xDB7093, "papayawhip": 0xFFEFD5, "peachpuff": 0xFFDAB9,
"peru": 0xCD853F, "pink": 0xFFC0CB, "plum": 0xDDA0DD, "powderblue": 0xB0E0E6, "purple": 0x800080, "red": 0xFF0000, "rosybrown": 0xBC8F8F,
"royalblue": 0x4169E1, "saddlebrown": 0x8B4513, "salmon": 0xFA8072, "sandybrown": 0xF4A460, "seagreen": 0x2E8B57, "seashell": 0xFFF5EE,
"sienna": 0xA0522D, "silver": 0xC0C0C0, "skyblue": 0x87CEEB, "slateblue": 0x6A5ACD, "slategray": 0x708090, "slategrey": 0x708090, "snow": 0xFFFAFA,
"springgreen": 0x00FF7F, "steelblue": 0x4682B4, "tan": 0xD2B48C, "teal": 0x008080, "thistle": 0xD8BFD8, "tomato": 0xFF6347, "turquoise": 0x40E0D0,
"violet": 0xEE82EE, "wheat": 0xF5DEB3, "white": 0xFFFFFF, "whitesmoke": 0xF5F5F5, "yellow": 0xFFFF00, "yellowgreen": 0x9ACD32 };

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	_x: 0,_y: 0, _z: 0, _w: 0,

	_euler: undefined,

	_updateEuler: function ( callback ) {

		if ( this._euler !== undefined ) {

			this._euler.setFromQuaternion( this, undefined, false );

		}

	},

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this._updateEuler();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this._updateEuler();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this._updateEuler();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this._updateEuler();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._updateEuler();

		return this;

	},

	copy: function ( quaternion ) {

		this._x = quaternion._x;
		this._y = quaternion._y;
		this._z = quaternion._z;
		this._w = quaternion._w;

		this._updateEuler();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( ! ( euler instanceof THREE.Euler ) ) return THREE.onerror( 'expecting a Euler', euler );

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		if ( euler.order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this._updateEuler();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
		// axis have to be normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._updateEuler();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)	

		var te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = (m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = (m12 + m21 ) / s;
			this._z = (m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = (m13 - m31 ) / s;
			this._x = (m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = (m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._updateEuler();

		return this;

	},

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},
	
	add: function ( q ) {

		this._x += q._x;
		this._y += q._y;
		this._z += q._z;
		this._w += q._w;

		return this;

	},

	sub: function ( q ) {

		this._x -= q._x;
		this._y -= q._y;
		this._z -= q._z;
		this._w -= q._w;

		return this;

	},

	multiplyScalar: function ( s ) {

		this._x *= s;
		this._y *= s;
		this._z *= s;
		this._w *= s;

		return this;

	},

	conjugate: function () {

		this._x *= -1;
		this._y *= -1;
		this._z *= -1;

		this._updateEuler();

		return this;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			THREE.onwarning( 'DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._updateEuler();

		return this;

	},

	multiplyVector3: function ( vector ) {

		THREE.onwarning( 'DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = -qb._w;
			this._x = -qb._x;
			this._y = -qb._y;
			this._z = -qb._z;

			cosHalfTheta = -cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._updateEuler();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		this._w = array[ 3 ];

		this._updateEuler();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._w ];

	},

	clone: function () {

		return new THREE.Quaternion( this._x, this._y, this._z, this._w );

	}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},


	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: return THREE.onerror( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: return THREE.onerror( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			THREE.onwarning( 'DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			THREE.onwarning( 'DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;
	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};
		
	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y ];

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: return THREE.onerror( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: return THREE.onerror( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			THREE.onwarning( 'DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			THREE.onwarningn( 'DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			THREE.onwarning( 'DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function ( euler ) {

			if ( ! ( euler instanceof THREE.Euler ) ) return THREE.onerror( 'expecting an Euler', euler );

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function ( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		if ( ! ( m instanceof THREE.Matrix3 ) ) return THREE.onerror( 'expecting an Matrix3', m );

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[3] * y + e[6] * z;
		this.y = e[1] * x + e[4] * y + e[7] * z;
		this.z = e[2] * x + e[5] * y + e[8] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting an Matrix4', m );

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z + e[12];
		this.y = e[1] * x + e[5] * y + e[9]  * z + e[13];
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix
		if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting an Matrix4', m );

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide

		this.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;
		this.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;
		this.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = -qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

		return this;

	},

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z;
		this.y = e[1] * x + e[5] * y + e[9]  * z;
		this.z = e[2] * x + e[6] * y + e[10] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			THREE.onwarning( 'DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function ( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function ( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function ( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		THREE.onerror( "REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.");

	},

	setEulerFromQuaternion: function ( q, order ) {

		THREE.onerror( "REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.");

	},

	getPositionFromMatrix: function ( m ) {

		THREE.onwarning( "DEPRECATED: Vector3\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code." );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		THREE.onwarning( "DEPRECATED: Vector3\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code." );

		return this.setFromMatrixScale( m );
	},

	getColumnFromMatrix: function ( index, matrix ) {

		THREE.onwarning( "DEPRECATED: Vector3\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code." );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];
		this.z = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y, this.z ];

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

};
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: return THREE.onerror( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: return THREE.onerror( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			THREE.onwarning( 'DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			THREE.onwarning( 'DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
		this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
		this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;
			this.w *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		  && ( Math.abs( m13 - m31 ) < epsilon )
		  && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			  && ( Math.abs( m13 + m31 ) < epsilon2 )
			  && ( Math.abs( m23 + m32 ) < epsilon2 )
			  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) { // m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else { // m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						 + ( m13 - m31 ) * ( m13 - m31 )
						 + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		if ( this.w > v.w ) {

			this.w = v.w;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		if ( this.w < v.w ) {

			this.w = v.w;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		if ( this.w < min.w ) {

			this.w = min.w;

		} else if ( this.w > max.w ) {

			this.w = max.w;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

	negate: function () {

		return this.multiplyScalar( -1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );

		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];
		this.z = array[ 2 ];
		this.w = array[ 3 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y, this.z, this.w ];

	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

	_quaternion: undefined,

	_updateQuaternion: function () {

		if ( this._quaternion !== undefined ) {

			this._quaternion.setFromEuler( this, false );

		}

	},

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this._updateQuaternion();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this._updateQuaternion();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this._updateQuaternion();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this._updateQuaternion();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._updateQuaternion();

		return this;

	},

	setFromVector: function ( v, order ) {

		this._x = v.x;
		this._y = v.y;
		this._z = v.z;
		this._order = order || this._order;

		this._updateQuaternion();

		return this;

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._updateQuaternion();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		// clamp, to handle numerical problems

		function clamp( x ) {

			return Math.min( Math.max( x, -1 ), 1 );

		}

		var te = m.elements;
		var m11 = te[0], m12 = te[4], m13 = te[8];
		var m21 = te[1], m22 = te[5], m23 = te[9];
		var m31 = te[2], m32 = te[6], m33 = te[10];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			THREE.onwarning( 'WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this._updateQuaternion();

		return this;

	},

	setFromQuaternion: function() {

	   var mIntermediate = null;
	   
	   return function( q, order, update ) {
	   
	   	  mIntermediate = mIntermediate || new THREE.Matrix4();
	      mIntermediate.makeRotationFromQuaternion( q );
	      this.setFromRotationMatrix( mIntermediate, order, update );
	   
	      return this;
	   };

	}(),

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};


	}(),

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._updateQuaternion();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._order ];

	},

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},


	toVector3: function ( optionalResult ) {

		if( optionalResult ) {
			return optionalResult.set( this._x, this._y, this._z );
		}
		else {
			return new THREE.Vector3( this._x, this._y, this._z );
		}

	},

	clone: function () {

		return new THREE.Euler( this._x, this._y, this._z, this._order );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function() {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	},

	clone: function () {

		return new THREE.Line3().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				point = points[ i ];

				if ( point.x < this.min.x ) {

					this.min.x = point.x;

				} else if ( point.x > this.max.x ) {

					this.max.x = point.x;

				}

				if ( point.y < this.min.y ) {

					this.min.y = point.y;

				} else if ( point.y > this.max.y ) {

					this.max.y = point.y;

				}

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;
	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;
	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;
	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box2().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	addPoint: function ( point ) {

		if ( point.x < this.min.x ) {

			this.min.x = point.x;

		} else if ( point.x > this.max.x ) {

			this.max.x = point.x;

		}

		if ( point.y < this.min.y ) {

			this.min.y = point.y;

		} else if ( point.y > this.max.y ) {

			this.max.y = point.y;

		}

		if ( point.z < this.min.z ) {

			this.min.z = point.z;

		} else if ( point.z > this.max.z ) {

			this.max.z = point.z;

		}

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				this.addPoint( points[ i ] )

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function() {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function() {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and childrens', world transforms

		var v1 = new THREE.Vector3();

		return function( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				if ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {

					var vertices = node.geometry.vertices;

					for ( var i = 0, il = vertices.length; i < il; i++ ) {

						v1.copy( vertices[ i ] );

						v1.applyMatrix4( node.matrixWorld );

						scope.expandByPoint( v1 );

					}

				}

			} );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function() {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function() {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function() {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box3().copy( this );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

	this.elements = new Float32Array(9);

	this.set(

		( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,
		n21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,
		n31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1

	);
};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[0] = n11; te[3] = n12; te[6] = n13;
		te[1] = n21; te[4] = n22; te[7] = n23;
		te[2] = n31; te[5] = n32; te[8] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[0], me[3], me[6],
			me[1], me[4], me[7],
			me[2], me[5], me[8]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		THREE.onwarning( 'DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyMatrix3(this);

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[3] *= s; te[6] *= s;
		te[1] *= s; te[4] *= s; te[7] *= s;
		te[2] *= s; te[5] *= s; te[8] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[0], b = te[1], c = te[2],
			d = te[3], e = te[4], f = te[5],
			g = te[6], h = te[7], i = te[8];

		return a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;

	},

	getInverse: function ( matrix, errorOnInvertible ) {

		if ( ! ( matrix instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', matrix );
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[10] * me[5] - me[6] * me[9];
		te[ 1 ] = - me[10] * me[1] + me[2] * me[9];
		te[ 2 ] =   me[6] * me[1] - me[2] * me[5];
		te[ 3 ] = - me[10] * me[4] + me[6] * me[8];
		te[ 4 ] =   me[10] * me[0] - me[2] * me[8];
		te[ 5 ] = - me[6] * me[0] + me[2] * me[4];
		te[ 6 ] =   me[9] * me[4] - me[5] * me[8];
		te[ 7 ] = - me[9] * me[0] + me[1] * me[8];
		te[ 8 ] =   me[5] * me[0] - me[1] * me[4];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			if ( errorOnInvertible === true ) {

				return THREE.onerror( "Matrix3.getInverse(): can't invert matrix, determinant is 0", this );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[1]; m[1] = m[3]; m[3] = tmp;
		tmp = m[2]; m[2] = m[6]; m[6] = tmp;
		tmp = m[5]; m[5] = m[7]; m[7] = tmp;

		return this;

	},

	getNormalMatrix: function ( m ) {

		if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix3(

			te[0], te[3], te[6],
			te[1], te[4], te[7],
			te[2], te[5], te[8]

		);

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */


THREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

	this.elements = new Float32Array( 16 );

	// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix
	//   we should not support semi specification of Matrix4, it is just weird.

	var te = this.elements;

	te[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;
	te[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;
	te[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;
	te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
		te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
		te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
		te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		THREE.onwarning( 'DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		var te = this.elements;

		xAxis.set( te[0], te[1], te[2] );
		yAxis.set( te[4], te[5], te[6] );
		zAxis.set( te[8], te[9], te[10] );

		return this;
		
	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.identity();

		var te = this.elements;
	    te.elements[0] = xAxis.x; te.elements[1] = xAxis.y; te.elements[2] = xAxis.z;
	    te.elements[4] = yAxis.x; te.elements[5] = yAxis.y; te.elements[6] = yAxis.z;
	    te.elements[8] = zAxis.x; te.elements[9] = zAxis.y; te.elements[10] = zAxis.z;

	    return this;

	},

	extractRotation: function () {

		var v1 = new THREE.Vector3();

		return function ( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();
			var scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();
			var scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;

			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;

			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( ! ( euler instanceof THREE.Euler ) ) return THREE.onerror( 'expecting a Euler', euler );

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = - c * f;
			te[8] = d;

			te[1] = af + be * d;
			te[5] = ae - bf * d;
			te[9] = - b * c;

			te[2] = bf - ae * d;
			te[6] = be + af * d;
			te[10] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce + df * b;
			te[4] = de * b - cf;
			te[8] = a * d;

			te[1] = a * f;
			te[5] = a * e;
			te[9] = - b;

			te[2] = cf * b - de;
			te[6] = df + ce * b;
			te[10] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce - df * b;
			te[4] = - a * f;
			te[8] = de + cf * b;

			te[1] = cf + de * b;
			te[5] = a * e;
			te[9] = df - ce * b;

			te[2] = - a * d;
			te[6] = b;
			te[10] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = be * d - af;
			te[8] = ae * d + bf;

			te[1] = c * f;
			te[5] = bf * d + ae;
			te[9] = af * d - be;

			te[2] = - d;
			te[6] = b * c;
			te[10] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = bd - ac * f;
			te[8] = bc * f + ad;

			te[1] = f;
			te[5] = a * e;
			te[9] = - b * e;

			te[2] = - d * e;
			te[6] = ad * f + bc;
			te[10] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = - f;
			te[8] = d * e;

			te[1] = ac * f + bd;
			te[5] = a * e;
			te[9] = ad * f - bc;

			te[2] = bc * f - ad;
			te[6] = b * e;
			te[10] = bd * f + ac;

		}

		// last column
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// bottom row
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		THREE.onwarning( 'DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[0] = 1 - ( yy + zz );
		te[4] = xy - wz;
		te[8] = xz + wy;

		te[1] = xy + wz;
		te[5] = 1 - ( xx + zz );
		te[9] = yz - wx;

		te[2] = xz - wy;
		te[6] = yz + wx;
		te[10] = 1 - ( xx + yy );

		// last column
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// bottom row
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;

		return this;

	},

	lookAt: function() {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

		return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[0] = x.x; te[4] = y.x; te[8] = z.x;
			te[1] = x.y; te[5] = y.y; te[9] = z.y;
			te[2] = x.z; te[6] = y.z; te[10] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			THREE.onwarning( 'DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyList: function ( listOfMatrices ) {

		for (var i = 0, il = listOfMatrices.length; i < il ; i++) {
		  this.multiplyMatrices( this, listOfMatrices[ i ] );
		}

		return this;

	},

	multiplyMatricesList: function ( listOfMatrices ) {

		if( listOfMatrices.length > 0 ) {
		
			this.copy( listOfMatrices[0] );

			this.multiplyList( listOfMatrices.slice( 1 ) );

		}
		else {

			this.identity();
			
		}

		return this;

	},

	multiplyMatrices: function ( a, b ) {

		if ( ! ( a instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', a );
		if ( ! ( b instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', b );

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
		var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
		var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
		var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];

		var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
		var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
		var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
		var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];

		te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];
		r[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];
		r[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];
		r[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
		te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
		te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
		te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		THREE.onwarning( 'DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		THREE.onwarning( 'DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyProjection( this );

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	rotateAxis: function ( v ) {

		THREE.onwarning( 'DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		THREE.onwarning( 'DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
		var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
		var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
		var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+n14 * n23 * n32
				-n13 * n24 * n32
				-n14 * n22 * n33
				+n12 * n24 * n33
				+n13 * n22 * n34
				-n12 * n23 * n34
			) +
			n42 * (
				+n11 * n23 * n34
				-n11 * n24 * n33
				+n14 * n21 * n33
				-n13 * n21 * n34
				+n13 * n24 * n31
				-n14 * n23 * n31
			) +
			n43 * (
				+n11 * n24 * n32
				-n11 * n22 * n34
				-n14 * n21 * n32
				+n12 * n21 * n34
				+n14 * n22 * n31
				-n12 * n24 * n31
			) +
			n44 * (
				-n13 * n22 * n31
				-n11 * n23 * n32
				+n11 * n22 * n33
				+n13 * n21 * n32
				-n12 * n21 * n33
				+n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[1]; te[1] = te[4]; te[4] = tmp;
		tmp = te[2]; te[2] = te[8]; te[8] = tmp;
		tmp = te[6]; te[6] = te[9]; te[9] = tmp;

		tmp = te[3]; te[3] = te[12]; te[12] = tmp;
		tmp = te[7]; te[7] = te[13]; te[13] = tmp;
		tmp = te[11]; te[11] = te[14]; te[14] = tmp;

		return this;

	},

	flattenToArray: function ( flat ) {

		var te = this.elements;
		flat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];
		flat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];
		flat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];
		flat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];

		return flat;

	},

	flattenToArrayOffset: function( flat, offset ) {

		var te = this.elements;
		flat[ offset ] = te[0];
		flat[ offset + 1 ] = te[1];
		flat[ offset + 2 ] = te[2];
		flat[ offset + 3 ] = te[3];

		flat[ offset + 4 ] = te[4];
		flat[ offset + 5 ] = te[5];
		flat[ offset + 6 ] = te[6];
		flat[ offset + 7 ] = te[7];

		flat[ offset + 8 ]  = te[8];
		flat[ offset + 9 ]  = te[9];
		flat[ offset + 10 ] = te[10];
		flat[ offset + 11 ] = te[11];

		flat[ offset + 12 ] = te[12];
		flat[ offset + 13 ] = te[13];
		flat[ offset + 14 ] = te[14];
		flat[ offset + 15 ] = te[15];

		return flat;

	},

	getPosition: function() {

		var v1 = new THREE.Vector3();

		return function () {

			THREE.onwarning( 'DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[12], te[13], te[14] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[12] = v.x;
		te[13] = v.y;
		te[14] = v.z;

		return this;

	},

	getInverse: function ( m, errorOnInvertible ) {

		if ( ! ( m instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', m );

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
		var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
		var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
		var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];

		te[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
		te[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
		te[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
		te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
		te[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
		te[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
		te[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
		te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
		te[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
		te[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
		te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
		te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
		te[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
		te[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
		te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
		te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det == 0 ) {

			if ( errorOnInvertible === true ) {

				 return THREE.onerror( "Matrix4.getInverse(): can't invert matrix, determinant is 0", this );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		THREE.onerror( 'DEPRECATED: Matrix4\'s .translate() has been removed.');

	},

	rotateX: function ( angle ) {

		THREE.onerror( 'DEPRECATED: Matrix4\'s .rotateX() has been removed.');

	},

	rotateY: function ( angle ) {

		THREE.onerror( 'DEPRECATED: Matrix4\'s .rotateY() has been removed.');

	},

	rotateZ: function ( angle ) {

		THREE.onerror( 'DEPRECATED: Matrix4\'s .rotateZ() has been removed.');

	},

	rotateByAxis: function ( axis, angle ) {

		THREE.onerror( 'DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[0] *= x; te[4] *= y; te[8] *= z;
		te[1] *= x; te[5] *= y; te[9] *= z;
		te[2] *= x; te[6] *= y; te[10] *= z;
		te[3] *= x; te[7] *= y; te[11] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
		var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
		var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, -s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			-s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, -s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},


	makeShear: function ( vector3Shear, reverseStyle ) {

		var xy = vector3Shear.x;
    	var xz = vector3Shear.y;
    	var yz = vector3Shear.z;

		if ( reverseStyle ) {

		  this.set(
		    1,  0,  0,  0,
		    xy, 1,  0,  0,
		    xz, yz, 1,  0,
		    0,   0,  0,  1
		  );

		} else {
		  // Maya style
		  this.set(
		    1,  xy, xz, 0,
		    0,  1,  yz, 0,
		    0,  0,  1,  0,
		    0,  0,  0,  1
		  );
		}

	    return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector = new THREE.Vector3();
		var matrix = new THREE.Matrix4();

		return function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[0], te[1], te[2] ).length();
			var sy = vector.set( te[4], te[5], te[6] ).length();
			var sz = vector.set( te[8], te[9], te[10] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if( det < 0 ) {
				sx = -sx;
			}

			position.x = te[12];
			position.y = te[13];
			position.z = te[14];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[0] *= invSX;
			matrix.elements[1] *= invSX;
			matrix.elements[2] *= invSX;

			matrix.elements[4] *= invSY;
			matrix.elements[5] *= invSY;
			matrix.elements[6] *= invSY;

			matrix.elements[8] *= invSZ;
			matrix.elements[9] *= invSZ;
			matrix.elements[10] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[0] = x;	te[4] = 0;	te[8] = a;	te[12] = 0;
		te[1] = 0;	te[5] = y;	te[9] = b;	te[13] = 0;
		te[2] = 0;	te[6] = 0;	te[10] = c;	te[14] = d;
		te[3] = 0;	te[7] = 0;	te[11] = - 1;	te[15] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[0] = 2 / w;	te[4] = 0;	te[8] = 0;	te[12] = -x;
		te[1] = 0;	te[5] = 2 / h;	te[9] = 0;	te[13] = -y;
		te[2] = 0;	te[6] = 0;	te[10] = -2/p;	te[14] = -z;
		te[3] = 0;	te[7] = 0;	te[11] = 0;	te[15] = 1;

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix4(

			te[0], te[4], te[8], te[12],
			te[1], te[5], te[9], te[13],
			te[2], te[6], te[10], te[14],
			te[3], te[7], te[11], te[15]

		);

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceTo( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceTo( point );

		};

	}(),

	distanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
		var segDir = v1.clone().sub( v0 ).normalize();
		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var diff = this.origin.clone().sub( segCenter );
		var a01 = - this.direction.dot( segDir );
		var b0 = diff.dot( this.direction );
		var b1 = - diff.dot( segDir );
		var c = diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det >= 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

		}

		return sqrDist;

	},

	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator == 0 ) {

			// line is coplanar, return origin
			if( plane.distanceToPoint( this.origin ) == 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;
		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {
		
		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		}

	}(),

	intersectBox: function ( box , optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin,tmax,tymin,tymax,tzmin,tzmax;

		var invdirx = 1/this.direction.x,
			invdiry = 1/this.direction.y,
			invdirz = 1/this.direction.z;

		var origin = this.origin;

		if (invdirx >= 0) {
				
			tmin = (box.min.x - origin.x) * invdirx;
			tmax = (box.max.x - origin.x) * invdirx;

		} else { 

			tmin = (box.max.x - origin.x) * invdirx;
			tmax = (box.min.x - origin.x) * invdirx;
		}			

		if (invdiry >= 0) {
		
			tymin = (box.min.y - origin.y) * invdiry;
			tymax = (box.max.y - origin.y) * invdiry;

		} else {

			tymin = (box.max.y - origin.y) * invdiry;
			tymax = (box.min.y - origin.y) * invdiry;
		}

		if ((tmin > tymax) || (tymin > tmax)) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN
		
		if (tymin > tmin || tmin !== tmin ) tmin = tymin;

		if (tymax < tmax || tmax !== tmax ) tmax = tymax;

		if (invdirz >= 0) {
		
			tzmin = (box.min.z - origin.z) * invdirz;
			tzmax = (box.max.z - origin.z) * invdirz;

		} else {

			tzmin = (box.max.z - origin.z) * invdirz;
			tzmax = (box.min.z - origin.z) * invdirz;
		}

		if ((tmin > tzmax) || (tzmin > tmax)) return null;

		if (tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if (tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function() {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );
	
		}
	
	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;
	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	},

	clone: function () {

		return new THREE.Ray().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;
	},


	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter )  {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0, cx = center.x, cy = center.y, cz = center.z;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				var pt = points[ i ];
				var dx = cx - pt.x;
				var dy = cy - pt.y;
				var dz = cz - pt.z;

				var distanceSquared = dx * dx + dy * dy + dz * dz;

				maxRadiusSq = Math.max( maxRadiusSq, distanceSquared );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;			
 		
 		};

	}(),

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	},

	clone: function () {

		return new THREE.Sphere().copy( this );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[0].copy( p0 );
		planes[1].copy( p1 );
		planes[2].copy( p2 );
		planes[3].copy( p3 );
		planes[4].copy( p4 );
		planes[5].copy( p5 );

		return this;

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for( var i = 0; i < 6; i ++ ) {

			planes[i].copy( frustum.planes[i] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
		var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
		var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
		var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = -sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox : function() {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function( box ) {

			var planes = this.planes;
			
			for ( var i = 0; i < 6 ; i ++ ) {
			
				var plane = planes[i];
				
				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );
				
				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {
					
					return false;
		
				}
			}

			return true;
		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	clone: function () {

		return new THREE.Frustum().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),


	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= -1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function() {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if( this.distanceToPoint( line.start ) == 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			if ( ! ( matrix instanceof THREE.Matrix4 ) ) return THREE.onerror( 'expecting a Matrix4', matrix );

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );
			
			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

	},

	clone: function () {

		return new THREE.Plane().copy( this );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	PI2: Math.PI * 2,
	DegreeToRadiansFactor: Math.PI / 180,
	RadianToDegreesFactor: 180 / Math.PI,

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm
		
		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
		var uuid = new Array(36);
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {
			
					uuid[ i ] = '-';
			
				} else if ( i == 14 ) {
			
					uuid[ i ] = '4';
			
				} else {
			
					if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];

				}
			}
			
			return uuid.join('');

		};

	}(),

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*(3 - 2*x);

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*x*(x*(x*6 - 15) + 10);

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	sign: function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;

	},

	degToRad: function ( degrees ) {

		return degrees * this.DegreeToRadiansFactor;

	},

	radToDeg: function ( radians ) {

		return radians * this.RadianToDegreesFactor;

	},

	isPowerOfTwo: function ( value ) {
		return ( value & ( value - 1 ) ) === 0 && value !== 0;
	}

};

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( !nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function() {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function() {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// colinear or singular triangle
		if( denom == 0 ) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( -2, -1, -1 );
		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycoordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function() {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[i0] );
		this.b.copy( points[i1] );
		this.c.copy( points[i2] );

		return this;

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function() {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	},

	clone: function () {

		return new THREE.Triangle().copy( this );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Vertex = function ( v ) {

	return THREE.onerror( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.' );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.UV = function ( u, v ) {

	THREE.onerror( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')
	return new THREE.Vector2( u, v );

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {}

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function () {

		var array = [];

		return function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		};

	}()

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

	};

	var sphere = new THREE.Sphere();
	var localRay = new THREE.Ray();
	var facePlane = new THREE.Plane();
	var intersectPoint = new THREE.Vector3();
	var matrixPosition = new THREE.Vector3();

	var inverseMatrix = new THREE.Matrix4();

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	var intersectObject = function ( object, raycaster, intersects ) {

		if ( object instanceof THREE.Sprite ) {

			matrixPosition.setFromMatrixPosition( object.matrixWorld );
			
			var distance = raycaster.ray.distanceToPoint( matrixPosition );

			if ( distance > object.scale.x ) {

				return intersects;

			}

			intersects.push( {

				distance: distance,
				point: object.position,
				face: null,
				object: object

			} );

		} else if ( object instanceof THREE.LOD ) {

			matrixPosition.setFromMatrixPosition( object.matrixWorld );
			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			intersectObject( object.getObjectForDistance( distance ), raycaster, intersects );

		} else if ( object instanceof THREE.Mesh ) {

			var geometry = object.geometry;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return intersects;

			}

			// Check boundingBox before continuing
			
			inverseMatrix.getInverse( object.matrixWorld );  
			localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {

					return intersects;

				}

			} 

			if ( geometry instanceof THREE.BufferGeometry ) {

				var material = object.material;

				if ( material === undefined ) return intersects;

				var attributes = geometry.attributes;

				var a, b, c;
				var precision = raycaster.precision;

				if ( attributes.index !== undefined ) {

					var offsets = geometry.offsets;
					var indices = attributes.index.array;
					var positions = attributes.position.array;

					for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							a = index + indices[ i ];
							b = index + indices[ i + 1 ]; 
							c = index + indices[ i + 2 ];

							vA.set(
								positions[ a * 3 ],
								positions[ a * 3 + 1 ],
								positions[ a * 3 + 2 ]
							);
							vB.set(
								positions[ b * 3 ],
								positions[ b * 3 + 1 ],
								positions[ b * 3 + 2 ]
							);
							vC.set(
								positions[ c * 3 ],
								positions[ c * 3 + 1 ],
								positions[ c * 3 + 2 ]
							);

							
							if ( material.side === THREE.BackSide ) {
							
								var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); 

							} else {

								var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

							}

							if ( intersectionPoint === null ) continue;

							intersectionPoint.applyMatrix4( object.matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

							if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								point: intersectionPoint,
								indices: [a, b, c],
								face: null,
								faceIndex: null,
								object: object

							} );

						}

					}

				} else {

					var offsets = geometry.offsets;
					var positions = attributes.position.array;

					for ( var i = 0, il = attributes.position.array.length; i < il; i += 3 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						vA.set(
							positions[ a * 3 ],
							positions[ a * 3 + 1 ],
							positions[ a * 3 + 2 ]
						);
						vB.set(
							positions[ b * 3 ],
							positions[ b * 3 + 1 ],
							positions[ b * 3 + 2 ]
						);
						vC.set(
							positions[ c * 3 ],
							positions[ c * 3 + 1 ],
							positions[ c * 3 + 2 ]
						);

						
						if ( material.side === THREE.BackSide ) {
							
							var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); 

						} else {

							var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( object.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							indices: [a, b, c],
							face: null,
							faceIndex: null,
							object: object

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
				var objectMaterials = isFaceMaterial === true ? object.material.materials : null;

				var a, b, c, d;
				var precision = raycaster.precision;

				var vertices = geometry.vertices;

				for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

					var face = geometry.faces[ f ];

					var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;

					if ( material === undefined ) continue;

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( material.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = object.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.x += ( targets[ face.a ].x - a.x ) * influence;
							vA.y += ( targets[ face.a ].y - a.y ) * influence;
							vA.z += ( targets[ face.a ].z - a.z ) * influence;

							vB.x += ( targets[ face.b ].x - b.x ) * influence;
							vB.y += ( targets[ face.b ].y - b.y ) * influence;
							vB.z += ( targets[ face.b ].z - b.z ) * influence;

							vC.x += ( targets[ face.c ].x - c.x ) * influence;
							vC.y += ( targets[ face.c ].y - c.y ) * influence;
							vC.z += ( targets[ face.c ].z - c.z ) * influence;

						}

						vA.add( a );
						vB.add( b );
						vC.add( c );

						a = vA;
						b = vB;
						c = vC;

					}

					if ( material.side === THREE.BackSide ) {
							
						var intersectionPoint = localRay.intersectTriangle( c, b, a, true );

					} else {
								
						var intersectionPoint = localRay.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: face,
						faceIndex: f,
						object: object

					} );

				}

			}

		} else if ( object instanceof THREE.Line ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );
			
			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return intersects;

			}
			
			inverseMatrix.getInverse( object.matrixWorld );
			localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			/* if ( geometry instanceof THREE.BufferGeometry ) {

			} else */ if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
				var interSegment = new THREE.Vector3();
				var interRay = new THREE.Vector3();
				var step = object.type === THREE.LineStrip ? 1 : 2;

				for ( var i = 0; i < nbVertices - 1; i = i + step ) {

					var distSq = localRay.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					var distance = localRay.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( object.matrixWorld ),
						face: null,
						faceIndex: null,
						object: object

					} );

				}

			}

		}

	};

	var intersectDescendants = function ( object, raycaster, intersects ) {

		var descendants = object.getDescendants();

		for ( var i = 0, l = descendants.length; i < l; i ++ ) {

			intersectObject( descendants[ i ], raycaster, intersects );

		}
	};

	//

	THREE.Raycaster.prototype.precision = 0.0001;
	THREE.Raycaster.prototype.linePrecision = 1;

	THREE.Raycaster.prototype.set = function ( origin, direction ) {

		this.ray.set( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

	};

	THREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {

		var intersects = [];

		if ( recursive === true ) {

			intersectDescendants( object, this, intersects );

		}

		intersectObject( object, this, intersects );

		intersects.sort( descSort );

		return intersects;

	};

	THREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {

		var intersects = [];

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects );

			if ( recursive === true ) {

				intersectDescendants( objects[ i ], this, intersects );

			}

		}

		intersects.sort( descSort );

		return intersects;

	};

}( THREE ) );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Object3D = function () {

	this.id = THREE.Object3DIdCount ++;
	this.uuid = THREE.Math.generateUUID();
	this.className = "Object3D";

	this.name = '';

	this.parent = undefined;
	this.children = [];

	this.up = new THREE.Vector3( 0, 1, 0 );

	this.position = new THREE.Vector3();
	this._rotation = new THREE.Euler();
	this._quaternion = new THREE.Quaternion();
	this.scale = new THREE.Vector3( 1, 1, 1 );

	// keep rotation and quaternion in sync

	this._rotation._quaternion = this.quaternion;
	this._quaternion._euler = this.rotation;

	this.renderDepth = null;

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = true;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this.userData = {};

};


THREE.Object3D.prototype = {

	constructor: THREE.Object3D,
	
	get rotation () { 
		return this._rotation; 
	},

	set rotation ( value ) {
		
		this._rotation = value;
		this._rotation._quaternion = this._quaternion;
		this._quaternion._euler = this._rotation;
		this._rotation._updateQuaternion();
		
	},

	get quaternion () { 
		return this._quaternion; 
	},
	
	set quaternion ( value ) {
		
		this._quaternion = value;
		this._quaternion._euler = this._rotation;
		this._rotation._quaternion = this._quaternion;
		this._quaternion._updateEuler();
		
	},

	get eulerOrder () {

		THREE.onwarning( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		THREE.onwarning( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		THREE.onwarning( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		THREE.onwarning( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function() {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		}

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis );

			v1.applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		}

	}(),

	translate: function ( distance, axis ) {

		THREE.onwarning( 'DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( object === this ) {

			THREE.onwarning( 'THREE.Object3D.add: An object can\'t be added as a child of itself.' );
			return;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

			// add to scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene )  {

				scene.__addObject( object );

			}

		}

	},

	remove: function ( object ) {

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;
			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

			// remove from scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene ) {

				scene.__removeObject( object );

			}

		}

	},

	traverse: function ( callback ) {

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverse( callback );

		}

	},

	getObjectById: function ( id, recursive ) {

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child.id === id ) {

				return child;

			}

			if ( recursive === true ) {

				child = child.getObjectById( id, recursive );

				if ( child !== undefined ) {

					return child;

				}

			}

		}

		return undefined;

	},

	getObjectByName: function ( name, recursive ) {

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child.name === name ) {

				return child;

			}

			if ( recursive === true ) {

				child = child.getObjectByName( name, recursive );

				if ( child !== undefined ) {

					return child;

				}

			}

		}

		return undefined;

	},

	getChildByName: function ( name, recursive ) {

		THREE.onwarning( 'DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name, recursive );

	},

	getDescendants: function ( array ) {

		if ( array === undefined ) array = [];

		Array.prototype.push.apply( array, this.children );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].getDescendants( array );

		}

		return array;

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === undefined ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	clone: function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Object3D();
		if ( recursive === undefined ) recursive = true;

		object.name = this.name;

		object.up.copy( this.up );

		object.position.copy( this.position );
		object.quaternion.copy( this.quaternion );
		object.scale.copy( this.scale );

		object.renderDepth = this.renderDepth;

		object.rotationAutoUpdate = this.rotationAutoUpdate;

		object.matrix.copy( this.matrix );
		object.matrixWorld.copy( this.matrixWorld );

		object.matrixAutoUpdate = this.matrixAutoUpdate;
		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

		object.visible = this.visible;

		object.castShadow = this.castShadow;
		object.receiveShadow = this.receiveShadow;

		object.frustumCulled = this.frustumCulled;

		object.userData = JSON.parse( JSON.stringify( this.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < this.children.length; i ++ ) {

				var child = this.children[ i ];
				object.add( child.clone() );

			}

		}

		return object;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */

THREE.Projector = function () {

	var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
	_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
	_face, _faceCount, _facePool = [], _facePoolLength = 0,
	_line, _lineCount, _linePool = [], _linePoolLength = 0,
	_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,

	_renderData = { objects: [], lights: [], elements: [] },

	_vA = new THREE.Vector3(),
	_vB = new THREE.Vector3(),
	_vC = new THREE.Vector3(),

	_vector3 = new THREE.Vector3(),
	_vector4 = new THREE.Vector4(),

	_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),
	_boundingBox = new THREE.Box3(),
	_points3 = new Array( 3 ),
	_points4 = new Array( 4 ),

	_viewMatrix = new THREE.Matrix4(),
	_viewProjectionMatrix = new THREE.Matrix4(),

	_modelMatrix,
	_modelViewProjectionMatrix = new THREE.Matrix4(),

	_normalMatrix = new THREE.Matrix3(),

	_frustum = new THREE.Frustum(),

	_clippedVertex1PositionScreen = new THREE.Vector4(),
	_clippedVertex2PositionScreen = new THREE.Vector4();

	this.projectVector = function ( vector, camera ) {

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );

		return vector.applyProjection( _viewProjectionMatrix );

	};

	this.unprojectVector = function () {

		var projectionMatrixInverse = new THREE.Matrix4();

		return function ( vector, camera ) {

			projectionMatrixInverse.getInverse( camera.projectionMatrix );
			_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, projectionMatrixInverse );

			return vector.applyProjection( _viewProjectionMatrix );

		};

	}();

	this.pickingRay = function ( vector, camera ) {

		// set two vectors with opposing z values
		vector.z = -1.0;
		var end = new THREE.Vector3( vector.x, vector.y, 1.0 );

		this.unprojectVector( vector, camera );
		this.unprojectVector( end, camera );

		// find direction from vector to end
		end.sub( vector ).normalize();

		return new THREE.Raycaster( vector, end );

	};

	var projectObject = function ( object ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Light ) {

			_renderData.lights.push( object );

		} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite ) {

			if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

				_object = getNextObjectInPool();
				_object.id = object.id;
				_object.object = object;

				if ( object.renderDepth !== null ) {

					_object.z = object.renderDepth;

				} else {

					_vector3.setFromMatrixPosition( object.matrixWorld );
					_vector3.applyProjection( _viewProjectionMatrix );
					_object.z = _vector3.z;

				}

				_renderData.objects.push( _object );

			}

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			projectObject( object.children[ i ] );

		}

	};

	var projectGraph = function ( root, sortObjects ) {

		_objectCount = 0;

		_renderData.objects.length = 0;
		_renderData.lights.length = 0;

		projectObject( root );

		if ( sortObjects === true ) {

			_renderData.objects.sort( painterSort );

		}

	};

	var RenderList = function () {

		var normals = [];

		var object = null;
		var normalMatrix = new THREE.Matrix3();

		var setObject = function ( value ) {

			object = value;
			normalMatrix.getNormalMatrix( object.matrixWorld );

			normals.length = 0;

		};

		var projectVertex = function ( vertex ) {

			var position = vertex.position;
			var positionWorld = vertex.positionWorld;
			var positionScreen = vertex.positionScreen;

			positionWorld.copy( position ).applyMatrix4( _modelMatrix );
			positionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );

			var invW = 1 / positionScreen.w;

			positionScreen.x *= invW;
			positionScreen.y *= invW;
			positionScreen.z *= invW;

			vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 &&
					 positionScreen.y >= -1 && positionScreen.y <= 1 &&
					 positionScreen.z >= -1 && positionScreen.z <= 1;

		};

		var pushVertex = function ( x, y, z ) {

			_vertex = getNextVertexInPool();
			_vertex.position.set( x, y, z );

			projectVertex( _vertex );

		};

		var pushNormal = function ( x, y, z ) {

			normals.push( x, y, z );

		};

		var checkTriangleVisibility = function ( v1, v2, v3 ) {

			_points3[ 0 ] = v1.positionScreen;
			_points3[ 1 ] = v2.positionScreen;
			_points3[ 2 ] = v3.positionScreen;

			if ( v1.visible === true || v2.visible === true || v3.visible === true ||
				_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {

				return ( ( v3.positionScreen.x - v1.positionScreen.x ) *
					    ( v2.positionScreen.y - v1.positionScreen.y ) -
					    ( v3.positionScreen.y - v1.positionScreen.y ) *
					    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

			}

			return false;

		};

		var pushLine = function ( a, b ) {

			var v1 = _vertexPool[ a ];
			var v2 = _vertexPool[ b ];

			_line = getNextLineInPool();

			_line.id = object.id;
			_line.v1.copy( v1 );
			_line.v2.copy( v2 );
			_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;

			_line.material = object.material;

			_renderData.elements.push( _line );

		};

		var pushTriangle = function ( a, b, c ) {

			var v1 = _vertexPool[ a ];
			var v2 = _vertexPool[ b ];
			var v3 = _vertexPool[ c ];

			if ( checkTriangleVisibility( v1, v2, v3 ) === true ) {

				_face = getNextFaceInPool();

				_face.id = object.id;
				_face.v1.copy( v1 );
				_face.v2.copy( v2 );
				_face.v3.copy( v3 );
				_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;

				for ( var i = 0; i < 3; i ++ ) {

					var offset = arguments[ i ] * 3;
					var normal = _face.vertexNormalsModel[ i ];

					normal.set( normals[ offset + 0 ], normals[ offset + 1 ], normals[ offset + 2 ] );
					normal.applyMatrix3( normalMatrix ).normalize();

				}

				_face.vertexNormalsLength = 3;

				_face.material = object.material;

				_renderData.elements.push( _face );

			}

		};

		return {
			setObject: setObject,
			projectVertex: projectVertex,
			checkTriangleVisibility: checkTriangleVisibility,
			pushVertex: pushVertex,
			pushNormal: pushNormal,
			pushLine: pushLine,
			pushTriangle: pushTriangle
		}

	};

	var renderList = new RenderList();

	this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

		var object, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,
		isFaceMaterial, objectMaterials;

		_faceCount = 0;
		_lineCount = 0;
		_spriteCount = 0;

		_renderData.elements.length = 0;

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

		_frustum.setFromMatrix( _viewProjectionMatrix );

		projectGraph( scene, sortObjects );

		for ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {

			object = _renderData.objects[ o ].object;
			geometry = object.geometry;

			renderList.setObject( object );

			_modelMatrix = object.matrixWorld;

			_vertexCount = 0;

			if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					var attributes = geometry.attributes;
					var offsets = geometry.offsets;

					if ( attributes.position === undefined ) continue;

					var positions = attributes.position.array;

					for ( var i = 0, l = positions.length; i < l; i += 3 ) {

						renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

					}

					var normals = attributes.normal.array;

					for ( var i = 0, l = normals.length; i < l; i += 3 ) {

						renderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );

					}

					if ( attributes.index !== undefined ) {

						var indices = attributes.index.array;

						if ( offsets.length > 0 ) {

							for ( var o = 0; o < offsets.length; o ++ ) {

								var offset = offsets[ o ];
								var index = offset.index;

								for ( var i = offset.start, l = offset.start + offset.count; i < l; i += 3 ) {

									renderList.pushTriangle( indices[ i ] + index, indices[ i + 1 ] + index, indices[ i + 2 ] + index );

								}

							}

						} else {

							for ( var i = 0, l = indices.length; i < l; i += 3 ) {

								renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

							}

						}

					} else {

						for ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {

							renderList.pushTriangle( i, i + 1, i + 2 );

						}

					}

				} else if ( geometry instanceof THREE.Geometry ) {

					vertices = geometry.vertices;
					faces = geometry.faces;
					faceVertexUvs = geometry.faceVertexUvs;

					_normalMatrix.getNormalMatrix( _modelMatrix );

					isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
					objectMaterials = isFaceMaterial === true ? object.material : null;

					for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {

						var vertex = vertices[ v ];
						renderList.pushVertex( vertex.x, vertex.y, vertex.z );

					}

					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

						face = faces[ f ];

						var material = isFaceMaterial === true
							? objectMaterials.materials[ face.materialIndex ]
							: object.material;

						if ( material === undefined ) continue;

						var side = material.side;

						var v1 = _vertexPool[ face.a ];
						var v2 = _vertexPool[ face.b ];
						var v3 = _vertexPool[ face.c ];

						if ( material.morphTargets === true ) {

							var morphTargets = geometry.morphTargets;
							var morphInfluences = object.morphTargetInfluences;

							var v1p = v1.position;
							var v2p = v2.position;
							var v3p = v3.position;

							_vA.set( 0, 0, 0 );
							_vB.set( 0, 0, 0 );
							_vC.set( 0, 0, 0 );

							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

								var influence = morphInfluences[ t ];

								if ( influence === 0 ) continue;

								var targets = morphTargets[ t ].vertices;

								_vA.x += ( targets[ face.a ].x - v1p.x ) * influence;
								_vA.y += ( targets[ face.a ].y - v1p.y ) * influence;
								_vA.z += ( targets[ face.a ].z - v1p.z ) * influence;

								_vB.x += ( targets[ face.b ].x - v2p.x ) * influence;
								_vB.y += ( targets[ face.b ].y - v2p.y ) * influence;
								_vB.z += ( targets[ face.b ].z - v2p.z ) * influence;

								_vC.x += ( targets[ face.c ].x - v3p.x ) * influence;
								_vC.y += ( targets[ face.c ].y - v3p.y ) * influence;
								_vC.z += ( targets[ face.c ].z - v3p.z ) * influence;

							}

							v1.position.add( _vA );
							v2.position.add( _vB );
							v3.position.add( _vC );

							renderList.projectVertex( v1 );
							renderList.projectVertex( v2 );
							renderList.projectVertex( v3 );

						}

						var visible = renderList.checkTriangleVisibility( v1, v2, v3 );

						if ( ( visible === false && side === THREE.FrontSide ) ||
							 ( visible === true && side === THREE.BackSide ) ) continue;

						_face = getNextFaceInPool();

						_face.id = object.id;
						_face.v1.copy( v1 );
						_face.v2.copy( v2 );
						_face.v3.copy( v3 );

						_face.normalModel.copy( face.normal );

						if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

							_face.normalModel.negate();

						}

						_face.normalModel.applyMatrix3( _normalMatrix ).normalize();

						_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );

						faceVertexNormals = face.vertexNormals;

						for ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {

							var normalModel = _face.vertexNormalsModel[ n ];
							normalModel.copy( faceVertexNormals[ n ] );

							if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

								normalModel.negate();

							}

							normalModel.applyMatrix3( _normalMatrix ).normalize();

						}

						_face.vertexNormalsLength = faceVertexNormals.length;

						for ( var c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {

							uvs = faceVertexUvs[ c ][ f ];

							if ( uvs === undefined ) continue;

							for ( var u = 0, ul = uvs.length; u < ul; u ++ ) {

								_face.uvs[ c ][ u ] = uvs[ u ];

							}

						}

						_face.color = face.color;
						_face.material = material;

						_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;

						_renderData.elements.push( _face );

					}

				}

			} else if ( object instanceof THREE.Line ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					var attributes = geometry.attributes;

					if ( attributes.position !== undefined ) {

						var positions = attributes.position.array;

						for ( var i = 0, l = positions.length; i < l; i += 3 ) {

							renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

						}

						if ( attributes.index !== undefined ) {

							var indices = attributes.index.array;

							for ( var i = 0, l = indices.length; i < l; i += 2 ) {

								renderList.pushLine( indices[ i ], indices[ i + 1 ] );

							}

						} else {

							for ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i ++ ) {

								renderList.pushLine( i, i + 1 );

							}

						}

					}

				} else if ( geometry instanceof THREE.Geometry ) {

					_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

					vertices = object.geometry.vertices;

					if ( vertices.length === 0 ) continue;

					v1 = getNextVertexInPool();
					v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

					// Handle LineStrip and LinePieces
					var step = object.type === THREE.LinePieces ? 2 : 1;

					for ( var v = 1, vl = vertices.length; v < vl; v ++ ) {

						v1 = getNextVertexInPool();
						v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

						if ( ( v + 1 ) % step > 0 ) continue;

						v2 = _vertexPool[ _vertexCount - 2 ];

						_clippedVertex1PositionScreen.copy( v1.positionScreen );
						_clippedVertex2PositionScreen.copy( v2.positionScreen );

						if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

							// Perform the perspective divide
							_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
							_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

							_line = getNextLineInPool();

							_line.id = object.id;
							_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
							_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

							_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

							_line.material = object.material;

							if ( object.material.vertexColors === THREE.VertexColors ) {

								_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
								_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );

							}

							_renderData.elements.push( _line );

						}

					}

				}

			} else if ( object instanceof THREE.Sprite ) {

				_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );
				_vector4.applyMatrix4( _viewProjectionMatrix );

				var invW = 1 / _vector4.w;

				_vector4.z *= invW;

				if ( _vector4.z >= -1 && _vector4.z <= 1 ) {

					_sprite = getNextSpriteInPool();
					_sprite.id = object.id;
					_sprite.x = _vector4.x * invW;
					_sprite.y = _vector4.y * invW;
					_sprite.z = _vector4.z;
					_sprite.object = object;

					_sprite.rotation = object.rotation;

					_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );
					_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );

					_sprite.material = object.material;

					_renderData.elements.push( _sprite );

				}

			}

		}

		if ( sortElements === true ) _renderData.elements.sort( painterSort );

		return _renderData;

	};

	// Pools

	function getNextObjectInPool() {

		if ( _objectCount === _objectPoolLength ) {

			var object = new THREE.RenderableObject();
			_objectPool.push( object );
			_objectPoolLength ++;
			_objectCount ++;
			return object;

		}

		return _objectPool[ _objectCount ++ ];

	}

	function getNextVertexInPool() {

		if ( _vertexCount === _vertexPoolLength ) {

			var vertex = new THREE.RenderableVertex();
			_vertexPool.push( vertex );
			_vertexPoolLength ++;
			_vertexCount ++;
			return vertex;

		}

		return _vertexPool[ _vertexCount ++ ];

	}

	function getNextFaceInPool() {

		if ( _faceCount === _facePoolLength ) {

			var face = new THREE.RenderableFace();
			_facePool.push( face );
			_facePoolLength ++;
			_faceCount ++;
			return face;

		}

		return _facePool[ _faceCount ++ ];


	}

	function getNextLineInPool() {

		if ( _lineCount === _linePoolLength ) {

			var line = new THREE.RenderableLine();
			_linePool.push( line );
			_linePoolLength ++;
			_lineCount ++
			return line;

		}

		return _linePool[ _lineCount ++ ];

	}

	function getNextSpriteInPool() {

		if ( _spriteCount === _spritePoolLength ) {

			var sprite = new THREE.RenderableSprite();
			_spritePool.push( sprite );
			_spritePoolLength ++;
			_spriteCount ++
			return sprite;

		}

		return _spritePool[ _spriteCount ++ ];

	}

	//

	function painterSort( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else if ( a.id !== b.id ) {

			return a.id - b.id;

		} else {

			return 0;

		}

	}

	function clipLine( s1, s2 ) {

		var alpha1 = 0, alpha2 = 1,

		// Calculate the boundary coordinate of each vertex for the near and far clip planes,
		// Z = -1 and Z = +1, respectively.
		bc1near =  s1.z + s1.w,
		bc2near =  s2.z + s2.w,
		bc1far =  - s1.z + s1.w,
		bc2far =  - s2.z + s2.w;

		if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

			// Both vertices lie entirely within all clip planes.
			return true;

		} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {

			// Both vertices lie entirely outside one of the clip planes.
			return false;

		} else {

			// The line segment spans at least one clip plane.

			if ( bc1near < 0 ) {

				// v1 lies outside the near plane, v2 inside
				alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

			} else if ( bc2near < 0 ) {

				// v2 lies outside the near plane, v1 inside
				alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

			}

			if ( bc1far < 0 ) {

				// v1 lies outside the far plane, v2 inside
				alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

			} else if ( bc2far < 0 ) {

				// v2 lies outside the far plane, v2 inside
				alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

			}

			if ( alpha2 < alpha1 ) {

				// The line segment spans two boundaries, but is outside both of them.
				// (This can't happen when we're only clipping against just near/far but good
				//  to leave the check here for future usage if other clip planes are added.)
				return false;

			} else {

				// Update the s1 and s2 vertices to match the clipped line segment.
				s1.lerp( s2, alpha1 );
				s2.lerp( s1, 1 - alpha2 );

				return true;

			}

		}

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [ ];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	this.centroid = new THREE.Vector3();

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		var face = new THREE.Face3( this.a, this.b, this.c );

		face.normal.copy( this.normal );
		face.color.copy( this.color );
		face.centroid.copy( this.centroid );

		face.materialIndex = this.materialIndex;

		var i, il;
		for ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
		for ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();
		for ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		return face;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	THREE.onwarning( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.')

	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.BufferGeometry = function () {

	this.id = THREE.GeometryIdCount ++;
	this.uuid = THREE.Math.generateUUID();
	this.className = "BufferGeometry";
	this.name = '';

	// attributes

	this.attributes = {};

	// offsets for chunks when using indexed elements

	this.offsets = [];

	// boundings

	this.boundingBox = null;
	this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addAttribute: function ( name, type, numItems, itemSize ) {

		this.attributes[ name ] = {

			array: new type( numItems * itemSize ),
			itemSize: itemSize

		};

		return this.attributes[ name ];

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.multiplyVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.multiplyVector3Array( normal.array );
			normal.needsUpdate = true;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		var positions = this.attributes[ "position" ].array;

		if ( positions ) {

			var bb = this.boundingBox;

			if( positions.length >= 3 ) {
				bb.min.x = bb.max.x = positions[ 0 ];
				bb.min.y = bb.max.y = positions[ 1 ];
				bb.min.z = bb.max.z = positions[ 2 ];
			}

			for ( var i = 3, il = positions.length; i < il; i += 3 ) {

				var x = positions[ i ];
				var y = positions[ i + 1 ];
				var z = positions[ i + 2 ];

				// bounding box

				if ( x < bb.min.x ) {

					bb.min.x = x;

				} else if ( x > bb.max.x ) {

					bb.max.x = x;

				}

				if ( y < bb.min.y ) {

					bb.min.y = y;

				} else if ( y > bb.max.y ) {

					bb.max.y = y;

				}

				if ( z < bb.min.z ) {

					bb.min.z = z;

				} else if ( z > bb.max.z ) {

					bb.max.z = z;

				}

			}

		}

		if ( positions === undefined || positions.length === 0 ) {

			this.boundingBox.min.set( 0, 0, 0 );
			this.boundingBox.max.set( 0, 0, 0 );

		}

	},

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes[ "position" ].array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					box.addPoint( vector );

				}

				box.center( center );

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			}

		}

	}(),

	computeVertexNormals: function () {

		if ( this.attributes[ "position" ] ) {

			var i, il;
			var j, jl;

			var nVertexElements = this.attributes[ "position" ].array.length;

			if ( this.attributes[ "normal" ] === undefined ) {

				this.attributes[ "normal" ] = {

					itemSize: 3,
					array: new Float32Array( nVertexElements )

				};

			} else {

				// reset existing normals to zero

				for ( i = 0, il = this.attributes[ "normal" ].array.length; i < il; i ++ ) {

					this.attributes[ "normal" ].array[ i ] = 0;

				}

			}

			var positions = this.attributes[ "position" ].array;
			var normals = this.attributes[ "normal" ].array;

			var vA, vB, vC, x, y, z,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( this.attributes[ "index" ] ) {

				var indices = this.attributes[ "index" ].array;

				var offsets = this.offsets;

				for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

					var start = offsets[ j ].start;
					var count = offsets[ j ].count;
					var index = offsets[ j ].index;

					for ( i = start, il = start + count; i < il; i += 3 ) {

						vA = index + indices[ i ];
						vB = index + indices[ i + 1 ];
						vC = index + indices[ i + 2 ];

						x = positions[ vA * 3 ];
						y = positions[ vA * 3 + 1 ];
						z = positions[ vA * 3 + 2 ];
						pA.set( x, y, z );

						x = positions[ vB * 3 ];
						y = positions[ vB * 3 + 1 ];
						z = positions[ vB * 3 + 2 ];
						pB.set( x, y, z );

						x = positions[ vC * 3 ];
						y = positions[ vC * 3 + 1 ];
						z = positions[ vC * 3 + 2 ];
						pC.set( x, y, z );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA * 3     ] += cb.x;
						normals[ vA * 3 + 1 ] += cb.y;
						normals[ vA * 3 + 2 ] += cb.z;

						normals[ vB * 3     ] += cb.x;
						normals[ vB * 3 + 1 ] += cb.y;
						normals[ vB * 3 + 2 ] += cb.z;

						normals[ vC * 3     ] += cb.x;
						normals[ vC * 3 + 1 ] += cb.y;
						normals[ vC * 3 + 2 ] += cb.z;

					}

				}

			// non-indexed elements (unconnected triangle soup)

			} else {

				for ( i = 0, il = positions.length; i < il; i += 9 ) {

					x = positions[ i ];
					y = positions[ i + 1 ];
					z = positions[ i + 2 ];
					pA.set( x, y, z );

					x = positions[ i + 3 ];
					y = positions[ i + 4 ];
					z = positions[ i + 5 ];
					pB.set( x, y, z );

					x = positions[ i + 6 ];
					y = positions[ i + 7 ];
					z = positions[ i + 8 ];
					pC.set( x, y, z );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i     ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			this.normalsNeedUpdate = true;

		}

	},

	normalizeNormals: function () {

		var normals = this.attributes[ "normal" ].array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i     ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( this.attributes[ "index" ] === undefined ||
			 this.attributes[ "position" ] === undefined ||
			 this.attributes[ "normal" ] === undefined ||
			 this.attributes[ "uv" ] === undefined ) {

			THREE.onwarning( "Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()" );
			return;

		}

		var indices = this.attributes[ "index" ].array;
		var positions = this.attributes[ "position" ].array;
		var normals = this.attributes[ "normal" ].array;
		var uvs = this.attributes[ "uv" ].array;

		var nVertices = positions.length / 3;

		if ( this.attributes[ "tangent" ] === undefined ) {

			var nTangentElements = 4 * nVertices;

			this.attributes[ "tangent" ] = {

				itemSize: 4,
				array: new Float32Array( nTangentElements )

			};

		}

		var tangents = this.attributes[ "tangent" ].array;

		var tan1 = [], tan2 = [];

		for ( var k = 0; k < nVertices; k ++ ) {

			tan1[ k ] = new THREE.Vector3();
			tan2[ k ] = new THREE.Vector3();

		}

		var xA, yA, zA,
			xB, yB, zB,
			xC, yC, zC,

			uA, vA,
			uB, vB,
			uC, vC,

			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r;

		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

		function handleTriangle( a, b, c ) {

			xA = positions[ a * 3 ];
			yA = positions[ a * 3 + 1 ];
			zA = positions[ a * 3 + 2 ];

			xB = positions[ b * 3 ];
			yB = positions[ b * 3 + 1 ];
			zB = positions[ b * 3 + 2 ];

			xC = positions[ c * 3 ];
			yC = positions[ c * 3 + 1 ];
			zC = positions[ c * 3 + 2 ];

			uA = uvs[ a * 2 ];
			vA = uvs[ a * 2 + 1 ];

			uB = uvs[ b * 2 ];
			vB = uvs[ b * 2 + 1 ];

			uC = uvs[ c * 2 ];
			vC = uvs[ c * 2 + 1 ];

			x1 = xB - xA;
			x2 = xC - xA;

			y1 = yB - yA;
			y2 = yC - yA;

			z1 = zB - zA;
			z2 = zC - zA;

			s1 = uB - uA;
			s2 = uC - uA;

			t1 = vB - vA;
			t2 = vC - vA;

			r = 1.0 / ( s1 * t2 - s2 * t1 );

			sdir.set(
				( t2 * x1 - t1 * x2 ) * r,
				( t2 * y1 - t1 * y2 ) * r,
				( t2 * z1 - t1 * z2 ) * r
			);

			tdir.set(
				( s1 * x2 - s2 * x1 ) * r,
				( s1 * y2 - s2 * y1 ) * r,
				( s1 * z2 - s2 * z1 ) * r
			);

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		var i, il;
		var j, jl;
		var iA, iB, iC;

		var offsets = this.offsets;

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleTriangle( iA, iB, iC );

			}

		}

		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
		var n = new THREE.Vector3(), n2 = new THREE.Vector3();
		var w, t, test;

		function handleVertex( v ) {

			n.x = normals[ v * 3 ];
			n.y = normals[ v * 3 + 1 ];
			n.z = normals[ v * 3 + 2 ];

			n2.copy( n );

			t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			test = tmp2.dot( tan2[ v ] );
			w = ( test < 0.0 ) ? -1.0 : 1.0;

			tangents[ v * 4     ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleVertex( iA );
				handleVertex( iB );
				handleVertex( iC );

			}

		}

	},

	/*
		computeOffsets
		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
		indexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.
	*/
	computeOffsets: function(indexBufferSize) {

		var size = indexBufferSize;
		if(indexBufferSize === undefined)
			size = 65535; //WebGL limits type of index buffer values to 16-bit.

		var s = Date.now();

		var indices = this.attributes['index'].array;
		var vertices = this.attributes['position'].array;

		var verticesCount = (vertices.length/3);
		var facesCount = (indices.length/3);

		/*
		console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
		console.log("Faces to process: "+(indices.length/3));
		console.log("Reordering "+verticesCount+" vertices.");
		*/

		var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
		var indexPtr = 0;
		var vertexPtr = 0;

		var offsets = [ { start:0, count:0, index:0 } ];
		var offset = offsets[0];

		var duplicatedVertices = 0;
		var newVerticeMaps = 0;
		var faceVertices = new Int32Array(6);
		var vertexMap = new Int32Array( vertices.length );
		var revVertexMap = new Int32Array( vertices.length );
		for(var j = 0; j < vertices.length; j++) { vertexMap[j] = -1; revVertexMap[j] = -1; }

		/*
			Traverse every face and reorder vertices in the proper offsets of 65k.
			We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
		*/
		for(var findex = 0; findex < facesCount; findex++) {
			newVerticeMaps = 0;

			for(var vo = 0; vo < 3; vo++) {
				var vid = indices[ findex*3 + vo ];
				if(vertexMap[vid] == -1) {
					//Unmapped vertice
					faceVertices[vo*2] = vid;
					faceVertices[vo*2+1] = -1;
					newVerticeMaps++;
				} else if(vertexMap[vid] < offset.index) {
					//Reused vertices from previous block (duplicate)
					faceVertices[vo*2] = vid;
					faceVertices[vo*2+1] = -1;
					duplicatedVertices++;
				} else {
					//Reused vertice in the current block
					faceVertices[vo*2] = vid;
					faceVertices[vo*2+1] = vertexMap[vid];
				}
			}

			var faceMax = vertexPtr + newVerticeMaps;
			if(faceMax > (offset.index + size)) {
				var new_offset = { start:indexPtr, count:0, index:vertexPtr };
				offsets.push(new_offset);
				offset = new_offset;

				//Re-evaluate reused vertices in light of new offset.
				for(var v = 0; v < 6; v+=2) {
					var new_vid = faceVertices[v+1];
					if(new_vid > -1 && new_vid < offset.index)
						faceVertices[v+1] = -1;
				}
			}

			//Reindex the face.
			for(var v = 0; v < 6; v+=2) {
				var vid = faceVertices[v];
				var new_vid = faceVertices[v+1];

				if(new_vid === -1)
					new_vid = vertexPtr++;

				vertexMap[vid] = new_vid;
				revVertexMap[new_vid] = vid;
				sortedIndices[indexPtr++] = new_vid - offset.index; //XXX overflows at 16bit
				offset.count++;
			}
		}

		/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
		this.reorderBuffers(sortedIndices, revVertexMap, vertexPtr);
		this.offsets = offsets;

		/*
		var orderTime = Date.now();
		console.log("Reorder time: "+(orderTime-s)+"ms");
		console.log("Duplicated "+duplicatedVertices+" vertices.");
		console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
		console.log("Draw offsets: "+offsets.length);
		*/

		return offsets;
	},

	/*
		reoderBuffers:
		Reorder attributes based on a new indexBuffer and indexMap.
		indexBuffer - Uint16Array of the new ordered indices.
		indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
		vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
	*/
	reorderBuffers: function(indexBuffer, indexMap, vertexCount) {

		/* Create a copy of all attributes for reordering. */
		var sortedAttributes = {};
		var types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];
		for( var attr in this.attributes ) {
			if(attr == 'index')
				continue;
			var sourceArray = this.attributes[attr].array;
			for ( var i = 0, il = types.length; i < il; i++ ) {
				var type = types[i];
				if (sourceArray instanceof type) {
					sortedAttributes[attr] = new type( this.attributes[attr].itemSize * vertexCount );
					break;
				}
			}
		}

		/* Move attribute positions based on the new index map */
		for(var new_vid = 0; new_vid < vertexCount; new_vid++) {
			var vid = indexMap[new_vid];
			for ( var attr in this.attributes ) {
				if(attr == 'index')
					continue;
				var attrArray = this.attributes[attr].array;
				var attrSize = this.attributes[attr].itemSize;
				var sortedAttr = sortedAttributes[attr];
				for(var k = 0; k < attrSize; k++)
					sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
			}
		}

		/* Carry the new sorted buffers locally */
		this.attributes['index'].array = indexBuffer;
		for ( var attr in this.attributes ) {
			if(attr == 'index')
				continue;
			this.attributes[attr].array = sortedAttributes[attr];
			this.attributes[attr].numItems = this.attributes[attr].itemSize * vertexCount;
		}
	},

	clone: function () {

		var geometry = new THREE.BufferGeometry();

		var types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];

		for ( var attr in this.attributes ) {

			var sourceAttr = this.attributes[ attr ];
			var sourceArray = sourceAttr.array;

			var attribute = {

				itemSize: sourceAttr.itemSize,
				array: null

			};

			for ( var i = 0, il = types.length; i < il; i ++ ) {

				var type = types[ i ];

				if ( sourceArray instanceof type ) {

					attribute.array = new type( sourceArray );
					break;

				}

			}

			geometry.attributes[ attr ] = attribute;

		}

		for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

			var offset = this.offsets[ i ];

			geometry.offsets.push( {

				start: offset.start,
				index: offset.index,
				count: offset.count

			} );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

	this.id = THREE.GeometryIdCount ++;
	this.uuid = THREE.Math.generateUUID();
	this.className = "Geometry";

	this.name = '';

	this.vertices = [];
	this.colors = [];  // one-to-one vertex colors, used in ParticleSystem and Line

	this.faces = [];

	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphColors = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = true;

	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.tangentsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;

	this.buffersNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

			face.centroid.applyMatrix4( matrix );

		}

		if ( this.boundingBox instanceof THREE.Box3 ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere instanceof THREE.Sphere ) {

			this.computeBoundingSphere();

		}

	},

	computeCentroids: function () {

		var f, fl, face;

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			face.centroid.set( 0, 0, 0 );

			face.centroid.add( this.vertices[ face.a ] );
			face.centroid.add( this.vertices[ face.b ] );
			face.centroid.add( this.vertices[ face.c ] );
			face.centroid.divideScalar( 3 );

		}

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC, vD;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
			face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
			face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ];
			vB = context.vertices[ b ];
			vC = context.vertices[ c ];

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;
			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = (test < 0.0) ? -1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeLineDistances: function ( ) {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;
		var indices, k, j, jl, u;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = -1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {
				if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}
			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	// Geometry splitting

	makeGroups: ( function () {

		var geometryGroupCounter = 0;
		
		return function ( usesFaceMaterial ) {

			var f, fl, face, materialIndex,
				groupHash, hash_map = {};

			var numMorphTargets = this.morphTargets.length;
			var numMorphNormals = this.morphNormals.length;

			this.geometryGroups = {};

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];
				materialIndex = usesFaceMaterial ? face.materialIndex : 0;

				if ( ! ( materialIndex in hash_map ) ) {

					hash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };

				}

				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in this.geometryGroups ) ) {

					this.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

				}

				if ( this.geometryGroups[ groupHash ].vertices + 3 > 65535 ) {

					hash_map[ materialIndex ].counter += 1;
					groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

					if ( ! ( groupHash in this.geometryGroups ) ) {

						this.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

					}

				}

				this.geometryGroups[ groupHash ].faces3.push( f );
				this.geometryGroups[ groupHash ].vertices += 3;

			}

			this.geometryGroupsList = [];

			for ( var g in this.geometryGroups ) {

				this.geometryGroups[ g ].id = geometryGroupCounter ++;

				this.geometryGroupsList.push( this.geometryGroups[ g ] );

			}

		};
		
	} )(),

	clone: function () {

		var geometry = new THREE.Geometry();

		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			geometry.vertices.push( vertices[ i ].clone() );

		}

		var faces = this.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			geometry.faces.push( faces[ i ].clone() );

		}

		var uvs = this.faceVertexUvs[ 0 ];

		for ( var i = 0, il = uvs.length; i < il; i ++ ) {

			var uv = uvs[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			geometry.faceVertexUvs[ 0 ].push( uvCopy );

		}

		geometry.morphTargets = this.morphTargets.slice( 0 );
		geometry.morphColors = this.morphColors.slice( 0 );
		geometry.morphNormals = this.morphNormals.slice( 0 );
		geometry.skinWeights = this.skinWeights.slice( 0 );
		geometry.skinIndices = this.skinIndices.slice( 0 );
		geometry.lineDistances = this.lineDistances.slice( 0 );

		if( this.boundingBox )	geometry.boundingBox = this.boundingBox.clone();
		if( this.boundingSphere ) geometry.boundingSphere = this.boundingSphere.clone();

		geometry.hasTangents = this.hasTangents;

		geometry.dynamic = this.dynamic; // the intermediate typed arrays will be deleted when set to false

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Geometry2 = function ( size ) {

	THREE.BufferGeometry.call( this );
	this.className = "Geometry2";

	this.vertices = this.addAttribute( 'position', Float32Array, size, 3 ).array;
	this.normals = this.addAttribute( 'normal', Float32Array, size, 3 ).array;
	this.uvs = this.addAttribute( 'uv', Float32Array, size, 2 ).array;

	this.boundingBox = null;
	this.boundingSphere = null;

};

THREE.Geometry2.prototype = Object.create( THREE.BufferGeometry.prototype );
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function (camera) {

	if ( camera === undefined ) camera = new THREE.Camera();

	THREE.Object3D.prototype.clone.call( this, camera );

	camera.matrixWorldInverse.copy( this.matrixWorldInverse );
	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	this.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

	var camera = new THREE.OrthographicCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;
	
	camera.near = this.near;
	camera.far = this.far;

	return camera;
};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;
		var bottom = -top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.clone = function () {

	var camera = new THREE.PerspectiveCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.fov = this.fov;
	camera.aspect = this.aspect;
	camera.near = this.near;
	camera.far = this.far;

	return camera;
};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
 
THREE.Light = function ( color ) {

	THREE.Object3D.call( this );

	this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );

THREE.Light.prototype.clone = function ( light ) {

	if ( light === undefined ) light = new THREE.Light();

	THREE.Object3D.prototype.clone.call( this, light );

	light.color.copy( this.color );

	return light;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

	THREE.Light.call( this, color );

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );

THREE.AmbientLight.prototype.clone = function () {

	var light = new THREE.AmbientLight();

	THREE.Light.prototype.clone.call( this, light );

	return light;

};

/**
 * @author bhouston / http://clara.io/
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( color, intensity, distance, decayExponent ) {

	THREE.Light.call( this, color );

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decayExponent = ( decayExponent !== undefined ) ? decayExponent : 0;	// for physically correct lights, should be 2.

	this.width = 1.0;
	this.height = 1.0;

	// TODO: implement shadow maps.  -bhouston, Oct 15, 2014
};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );

THREE.AreaLight.prototype.clone = function () {

	var light = new THREE.AreaLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();
	
	light.intensity = this.intensity;
	light.distance = this.distance;
	light.decayExponent = this.decayExponent;

	light.width = this.width;
	light.height = this.height;

	return light;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;

	this.shadowCameraLeft = -500;
	this.shadowCameraRight = 500;
	this.shadowCameraTop = 500;
	this.shadowCameraBottom = -500;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowCascade = false;

	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );
	this.shadowCascadeCount = 2;

	this.shadowCascadeBias = [ 0, 0, 0 ];
	this.shadowCascadeWidth = [ 512, 512, 512 ];
	this.shadowCascadeHeight = [ 512, 512, 512 ];

	this.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];
	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

	this.shadowCascadeArray = [];

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );

THREE.DirectionalLight.prototype.clone = function () {

	var light = new THREE.DirectionalLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor );

	this.position.set( 0, 100, 0 );

	this.groundColor = new THREE.Color( groundColor );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );

THREE.HemisphereLight.prototype.clone = function () {

	var light = new THREE.HemisphereLight();

	THREE.Light.prototype.clone.call( this, light );

	light.groundColor.copy( this.groundColor );
	light.intensity = this.intensity;

	return light;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance, decayExponent ) {

	THREE.Light.call( this, color );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decayExponent = ( decayExponent !== undefined ) ? decayExponent : 0;;	// for physically correct lights, should be 2.
};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );

THREE.PointLight.prototype.clone = function () {

	var light = new THREE.PointLight();

	THREE.Light.prototype.clone.call( this, light );

	light.intensity = this.intensity;
	light.distance = this.distance;
	light.decayExponent = this.decayExponent;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decayExponent ) {

	THREE.Light.call( this, color );

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decayExponent = ( decayExponent !== undefined ) ? decayExponent : 0;;	// for physically correct lights, should be 2.

	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );

THREE.SpotLight.prototype.clone = function () {

	var light = new THREE.SpotLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;
	light.distance = this.distance;
	light.angle = this.angle;
	light.exponent = this.exponent;
	light.decayExponent = this.decayExponent;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	addStatusElement: function () {

		var e = document.createElement( "div" );

		e.style.position = "absolute";
		e.style.right = "0px";
		e.style.top = "0px";
		e.style.fontSize = "0.8em";
		e.style.textAlign = "left";
		e.style.background = "rgba(0,0,0,0.25)";
		e.style.color = "#fff";
		e.style.width = "120px";
		e.style.padding = "0.5em 0.5em 0.5em 0.5em";
		e.style.zIndex = 1000;

		e.innerHTML = "Loading ...";

		return e;

	},

	updateProgress: function ( progress ) {

		var message = "Loaded ";

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed(0) + "%";


		} else {

			message += ( progress.loaded / 1000 ).toFixed(2) + " KB";

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );

		}

		return array;

	},

	needsTangents: function ( materials ) {

		for( var i = 0, il = materials.length; i < il; i ++ ) {

			var m = materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texturePath ) {

		var _this = this;

		function is_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.floor( l ) == l;

		}

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function load_image( where, url ) {

			var image = new Image();

			image.onload = function () {

				if ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {

					var width = nearest_pow2( this.width );
					var height = nearest_pow2( this.height );

					where.image.width = width;
					where.image.height = height;
					where.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );

				} else {

					where.image = this;

				}

				where.needsUpdate = true;

			};

			if ( _this.crossOrigin !== undefined ) image.crossOrigin = _this.crossOrigin;
			image.src = url;

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

			var isCompressed = /\.dds$/i.test( sourceFile );

			var fullPath = texturePath + sourceFile;

			if ( isCompressed ) {

				var texture = THREE.ImageUtils.loadCompressedTexture( fullPath );

				where[ name ] = texture;

			} else {

				var texture = document.createElement( 'canvas' );

				where[ name ] = new THREE.Texture( texture );

			}

			where[ name ].sourceFile = sourceFile;

			if( repeat ) {

				where[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;

			}

			if ( offset ) {

				where[ name ].offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if ( wrap ) {

				var wrapMap = {
					"repeat": THREE.RepeatWrapping,
					"mirror": THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];

			}

			if ( anisotropy ) {

				where[ name ].anisotropy = anisotropy;

			}

			if ( ! isCompressed ) {

				load_image( where[ name ], fullPath );

			}

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		// defaults

		var mtype = "MeshLambertMaterial";
		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

		// parameters from model file

		if ( m.shading ) {

			var shading = m.shading.toLowerCase();

			if ( shading === "phong" ) mtype = "MeshPhongMaterial";
			else if ( shading === "basic" ) mtype = "MeshBasicMaterial";
			else if ( shading === "physical" ) mtype = "MeshPhysicalMaterial";

		}

		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

			mpars.blending = THREE[ m.blending ];

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.depthWrite !== undefined ) {

			mpars.depthWrite = m.depthWrite;

		}

		if ( m.visible !== undefined ) {

			mpars.visible = m.visible;

		}

		if ( m.flipSided !== undefined ) {

			mpars.side = THREE.BackSide;

		}

		if ( m.doubleSided !== undefined ) {

			mpars.side = THREE.DoubleSide;

		}

		if ( m.wireframe !== undefined ) {

			mpars.wireframe = m.wireframe;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors === "face" ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texturePath ) {

			create_texture( mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

		}

		if ( m.mapLight && texturePath ) {

			create_texture( mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

		}

		if ( m.mapBump && texturePath ) {

			create_texture( mpars, "bumpMap", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

		}

		if ( m.mapNormal && texturePath ) {

			create_texture( mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

		}

		if ( m.mapSpecular && texturePath ) {

			create_texture( mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

		}

		//

		if ( m.mapBumpScale ) {

			mpars.bumpScale = m.mapBumpScale;

		}

		// special case for normal mapped material

		if ( m.mapNormal ) {

			var shader = THREE.ShaderLib[ "normalmap" ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			uniforms[ "tNormal" ].value = mpars.normalMap;

			if ( m.mapNormalFactor ) {

				uniforms[ "uNormalScale" ].value.set( m.mapNormalFactor, m.mapNormalFactor );

			}

			if ( mpars.map ) {

				uniforms[ "tDiffuse" ].value = mpars.map;
				uniforms[ "enableDiffuse" ].value = true;

			}

			if ( mpars.specularMap ) {

				uniforms[ "tSpecular" ].value = mpars.specularMap;
				uniforms[ "enableSpecular" ].value = true;

			}

			if ( mpars.lightMap ) {

				uniforms[ "tAO" ].value = mpars.lightMap;
				uniforms[ "enableAO" ].value = true;

			}

			// for the moment don't handle displacement texture

			uniforms[ "diffuse" ].value.setHex( mpars.color );
			uniforms[ "specular" ].value.setHex( mpars.specular );
			uniforms[ "ambient" ].value.setHex( mpars.ambient );

			uniforms[ "shininess" ].value = mpars.shininess;

			if ( mpars.opacity !== undefined ) {

				uniforms[ "opacity" ].value = mpars.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
			var material = new THREE.ShaderMaterial( parameters );

			if ( mpars.transparent ) {

				material.transparent = true;

			}

		} else {

			var material = new THREE[ mtype ]( mpars );

		}

		if ( m.DbgName !== undefined ) material.name = m.DbgName;

		return material;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;
		var request = new XMLHttpRequest();

		if ( onLoad !== undefined ) {

			request.addEventListener( 'load', function ( event ) {

				onLoad( event.target.responseText );
				scope.manager.itemEnd( url );

			}, false );

		}

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			request.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;

		request.open( 'GET', url, true );
		request.send( null );

		scope.manager.itemStart( url );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;
		var image = document.createElement( 'img' );

		if ( onLoad !== undefined ) {

			image.addEventListener( 'load', function ( event ) {

				scope.manager.itemEnd( url );
				onLoad( this );

			}, false );

		}

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			image.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		image.src = url;

		scope.manager.itemStart( url );

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var scope = this;

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === xhr.DONE ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				if ( xhr.responseText ) {

					var json = JSON.parse( xhr.responseText );

					if ( json.metadata.type === 'scene' ) {

						THREE.onerror( 'THREE.JSONLoader: "' + url + '" seems to be a Scene. Use THREE.SceneLoader instead.' );
						return;

					}

					var result = context.parse( json, texturePath );
					callback( result.geometry, result.materials );

				} else {

					THREE.onerror( 'THREE.JSONLoader: "' + url + '" seems to be unreachable or the file is empty.' );

				}

				// in context of more complex asset initialization
				// do not block on single failed file
				// maybe should go even one more level up

				context.onLoadComplete();

			} else {

				THREE.onerror( 'THREE.JSONLoader: Couldn\'t load "' + url + '" (' + xhr.status + ')' );

			}

		} else if ( xhr.readyState === xhr.LOADING ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( 'Content-Length' );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

			if ( callbackProgress !== undefined ) {

				length = xhr.getResponseHeader( "Content-Length" );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.withCredentials = this.withCredentials;
	xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeCentroids();
	geometry.computeFaceNormals();
	geometry.computeBoundingSphere();

	function parseModel( scale ) {

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		}

		var i, j, fi,

		offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, color, hex, normal,

		uvLayer, uv, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		if ( json.uvs !== undefined ) {

			// disregard empty arrays

			for ( i = 0; i < json.uvs.length; i++ ) {

				if ( json.uvs[ i ].length ) nUvLayers ++;

			}

			for ( i = 0; i < nUvLayers; i++ ) {

				geometry.faceVertexUvs[ i ] = [];

			}

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vector3();

			vertex.x = vertices[ offset ++ ] * scale;
			vertex.y = vertices[ offset ++ ] * scale;
			vertex.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad              = isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	    = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				faceA = new THREE.Face3();
				faceA.a = faces[ offset ];
				faceA.b = faces[ offset + 1 ];
				faceA.c = faces[ offset + 3 ];

				faceB = new THREE.Face3();
				faceB.a = faces[ offset + 1 ];
				faceB.b = faces[ offset + 2 ];
				faceB.c = faces[ offset + 3 ];

				offset += 4;

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					faceA.materialIndex = materialIndex;
					faceB.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];
						geometry.faceVertexUvs[ i ][ fi + 1 ] = []

						for ( j = 0; j < 4; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
							if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					faceA.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

					faceB.normal.copy( faceA.normal );

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 4; i++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);


						if ( i !== 2 ) faceA.vertexNormals.push( normal );
						if ( i !== 0 ) faceB.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					hex = colors[ colorIndex ];

					faceA.color.setHex( hex );
					faceB.color.setHex( hex );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 4; i++ ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
						if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

					}

				}

				geometry.faces.push( faceA );
				geometry.faces.push( faceB );

			} else {

				face = new THREE.Face3();
				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					face.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];

						for ( j = 0; j < 3; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							geometry.faceVertexUvs[ i ][ fi ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					face.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 3; i++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						face.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					face.color.setHex( colors[ colorIndex ] );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 3; i++ ) {

						colorIndex = faces[ offset ++ ];
						face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

					}

				}

				geometry.faces.push( face );

			}

		}

	};

	function parseSkin() {

		if ( json.skinWeights ) {

			for ( var i = 0, l = json.skinWeights.length; i < l; i += 2 ) {

				var x = json.skinWeights[ i     ];
				var y = json.skinWeights[ i + 1 ];
				var z = 0;
				var w = 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( var i = 0, l = json.skinIndices.length; i < l; i += 2 ) {

				var a = json.skinIndices[ i     ];
				var b = json.skinIndices[ i + 1 ];
				var c = 0;
				var d = 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;

		if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				THREE.onwarning( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

		}


		// could change this to json.animations[0] or remove completely
		
		geometry.animation = json.animation;
		geometry.animations = json.animations;

	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					var vertex = new THREE.Vector3();
					vertex.x = srcVertices[ v ] * scale;
					vertex.y = srcVertices[ v + 1 ] * scale;
					vertex.z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( vertex );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	if ( json.materials === undefined ) {

		return { geometry: geometry };

	} else {

		var materials = this.initMaterials( json.materials, texturePath );

		if ( this.needsTangents( materials ) ) {

			geometry.computeTangents();

		}

		return { geometry: geometry, materials: materials };

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var loaded = 0, total = 0;

	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		total ++;

	};

	this.itemEnd = function ( url ) {

		loaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, loaded, total );

		}

		if ( loaded === total && scope.onLoad !== undefined ) {

			scope.onLoad();

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var attributes = json.attributes;
		var offsets = json.offsets;
		var boundingSphere = json.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			geometry.attributes[ key ] = {
				itemSize: attribute.itemSize,
				array: new self[ attribute.type ]( attribute.array )
			}

		}

		if ( offsets !== undefined ) {

			geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		if ( boundingSphere !== undefined ) {

			geometry.boundingSphere = new THREE.Sphere(
				new THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),
				boundingSphere.radius
			);

		}

		return geometry;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Geometry2Loader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.Geometry2Loader.prototype = {

	constructor: THREE.Geometry2Loader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.Geometry2( json.vertices.length / 3 );

		var attributes = [ 'vertices', 'normals', 'uvs' ];
		var boundingSphere = json.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			geometry[ attribute ].set( json[ attribute ] );

		}

		if ( boundingSphere !== undefined ) {

			geometry.boundingSphere = new THREE.Sphere(
				new THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),
				boundingSphere.radius
			);

		}

		return geometry;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];

		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.falloff !== undefined ) material.falloff = json.falloff;
		if ( json.falloffColor !== undefined ) material.falloffColor.setHex( json.falloffColor );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metallic !== undefined ) material.metallic = json.metallic;
		if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
		if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
		if ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;
		if ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;
		if ( json.translucency !== undefined ) material.translucency.setHex( json.translucency );
		if ( json.translucencyNormalAlpha !== undefined ) material.translucencyNormalAlpha = json.translucencyNormalAlpha;
		if ( json.translucencyNormalPower !== undefined ) material.translucencyNormalPower = json.translucencyNormalPower;
		if ( json.translucencyViewAlpha !== undefined ) material.translucencyViewAlpha = json.translucencyViewAlpha;
		if ( json.translucencyViewPower !== undefined ) material.translucencyViewPower = json.translucencyViewPower;
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometries = this.parseGeometries( json.geometries );
		var materials = this.parseMaterials( json.materials );
		var object = this.parseObject( json.object, geometries, materials );

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var geometry2Loader = new THREE.Geometry2Loader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':

						geometry = new THREE.PlaneGeometry(
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'CubeGeometry': // DEPRECATED

						geometry = new THREE.BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data.data );

						break;

					case 'Geometry2':

						geometry = geometry2Loader.parse( data.data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data ).geometry;

						break;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];
				var material = loader.parse( data );

				material.uuid = data.uuid;

				if ( data.name !== undefined ) material.name = data.name;

				materials[ data.uuid ] = material;

			}

		}

		return materials;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance );
					object.decayExponent = data.decayExponent || 0;

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );
					object.decayExponent = data.decayExponent || 0;

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'AreaLight':

					object = new THREE.AreaLight( data.color, data.intensity, data.distance, data.decayExponent );
					object.width = data.width || 1;
					object.height = data.height || 1;
					
					break;

				case 'Mesh':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						THREE.onerror( 'THREE.ObjectLoader: Undefined geometry ' + data.geometry );

					}

					if ( material === undefined ) {

						THREE.onerror( 'THREE.ObjectLoader: Undefined material ' + data.material );

					}

					object = new THREE.Mesh( geometry, material );

					break;

				case 'Sprite':

					var material = materials[ data.material ];

					if ( material === undefined ) {

						THREE.onerror( 'THREE.ObjectLoader: Undefined material ' + data.material );

					}

					object = new THREE.Sprite( material );

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			return object;

		}

	}()

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneLoader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function () {};

	this.callbackSync = function () {};
	this.callbackProgress = function () {};

	this.geometryHandlers = {};
	this.hierarchyHandlers = {};

	this.addGeometryHandler( "ascii", THREE.JSONLoader );

};

THREE.SceneLoader.prototype = {

	constructor: THREE.SceneLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			scope.parse( JSON.parse( text ), onLoad, url );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	addGeometryHandler: function ( typeID, loaderClass ) {

		this.geometryHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	addHierarchyHandler: function ( typeID, loaderClass ) {

		this.hierarchyHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	parse: function ( json, callbackFinished, url ) {

		var scope = this;

		var urlBase = THREE.Loader.prototype.extractUrlBase( url );

		var geometry, material, camera, fog,
			texture, images, color,
			light, hex, intensity,
			counter_models, counter_textures,
			total_models, total_textures,
			result;

		var target_array = [];

		var data = json;

		// async geometry loaders

		for ( var typeID in this.geometryHandlers ) {

			var loaderClass = this.geometryHandlers[ typeID ][ "loaderClass" ];
			this.geometryHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		// async hierachy loaders

		for ( var typeID in this.hierarchyHandlers ) {

			var loaderClass = this.hierarchyHandlers[ typeID ][ "loaderClass" ];
			this.hierarchyHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		counter_models = 0;
		counter_textures = 0;

		result = {

			scene: new THREE.Scene(),
			geometries: {},
			face_materials: {},
			materials: {},
			textures: {},
			objects: {},
			cameras: {},
			lights: {},
			fogs: {},
			empties: {},
			groups: {}

		};

		if ( data.transform ) {

			var position = data.transform.position,
				rotation = data.transform.rotation,
				scale = data.transform.scale;

			if ( position ) {

				result.scene.position.fromArray( position );

			}

			if ( rotation ) {

				result.scene.rotation.fromArray( rotation );

			}

			if ( scale ) {

				result.scene.scale.fromArray( scale );

			}

			if ( position || rotation || scale ) {

				result.scene.updateMatrix();
				result.scene.updateMatrixWorld();

			}

		}

		function get_url( source_url, url_type ) {

			if ( url_type == "relativeToHTML" ) {

				return source_url;

			} else {

				return urlBase + source_url;

			}

		};

		// toplevel loader function, delegates to handle_children

		function handle_objects() {

			handle_children( result.scene, data.objects );

		}

		// handle all the children from the loaded json and attach them to given parent

		function handle_children( parent, children ) {

			var mat, dst, pos, rot, scl, quat;

			for ( var objID in children ) {

				// check by id if child has already been handled,
				// if not, create new object

				var object = result.objects[ objID ];
				var objJSON = children[ objID ];

				if ( object === undefined ) {

					// meshes

					if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

						if ( objJSON.loading === undefined ) {

							var reservedTypes = {
								"type": 1, "url": 1, "material": 1,
								"position": 1, "rotation": 1, "scale" : 1,
								"visible": 1, "children": 1, "userData": 1,
								"skin": 1, "morph": 1, "mirroredLoop": 1, "duration": 1
							};

							var loaderParameters = {};

							for ( var parType in objJSON ) {

								if ( ! ( parType in reservedTypes ) ) {

									loaderParameters[ parType ] = objJSON[ parType ];

								}

							}

							material = result.materials[ objJSON.material ];

							objJSON.loading = true;

							var loader = scope.hierarchyHandlers[ objJSON.type ][ "loaderObject" ];

							// ColladaLoader

							if ( loader.options ) {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );

							// UTF8Loader
							// OBJLoader

							} else {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );

							}

						}

					} else if ( objJSON.geometry !== undefined ) {

						geometry = result.geometries[ objJSON.geometry ];

						// geometry already loaded

						if ( geometry ) {

							var needsTangents = false;

							material = result.materials[ objJSON.material ];
							needsTangents = material instanceof THREE.ShaderMaterial;

							pos = objJSON.position;
							rot = objJSON.rotation;
							scl = objJSON.scale;
							mat = objJSON.matrix;
							quat = objJSON.quaternion;

							// use materials from the model file
							// if there is no material specified in the object

							if ( ! objJSON.material ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							// use materials from the model file
							// if there is just empty face material
							// (must create new material as each model has its own face material)

							if ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							if ( material instanceof THREE.MeshFaceMaterial ) {

								for ( var i = 0; i < material.materials.length; i ++ ) {

									needsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );

								}

							}

							if ( needsTangents ) {

								geometry.computeTangents();

							}

							if ( objJSON.skin ) {

								object = new THREE.SkinnedMesh( geometry, material );

							} else if ( objJSON.morph ) {

								object = new THREE.MorphAnimMesh( geometry, material );

								if ( objJSON.duration !== undefined ) {

									object.duration = objJSON.duration;

								}

								if ( objJSON.time !== undefined ) {

									object.time = objJSON.time;

								}

								if ( objJSON.mirroredLoop !== undefined ) {

									object.mirroredLoop = objJSON.mirroredLoop;

								}

								if ( material.morphNormals ) {

									geometry.computeMorphNormals();

								}

							} else {

								object = new THREE.Mesh( geometry, material );

							}

							object.name = objID;

							if ( mat ) {

								object.matrixAutoUpdate = false;
								object.matrix.set(
									mat[0],  mat[1],  mat[2],  mat[3],
									mat[4],  mat[5],  mat[6],  mat[7],
									mat[8],  mat[9],  mat[10], mat[11],
									mat[12], mat[13], mat[14], mat[15]
								);

							} else {

								object.position.fromArray( pos );

								if ( quat ) {

									object.quaternion.fromArray( quat );

								} else {

									object.rotation.fromArray( rot );

								}

								object.scale.fromArray( scl );

							}

							object.visible = objJSON.visible;
							object.castShadow = objJSON.castShadow;
							object.receiveShadow = objJSON.receiveShadow;

							parent.add( object );

							result.objects[ objID ] = object;

						}

					// lights

					} else if ( objJSON.type === "AmbientLight" || objJSON.type === "PointLight" ||
						objJSON.type === "DirectionalLight" || objJSON.type === "SpotLight" ||
						objJSON.type === "HemisphereLight" || objJSON.type === "AreaLight" ) {

						var color = objJSON.color;
						var intensity = objJSON.intensity;
						var distance = objJSON.distance;
						var position = objJSON.position;
						var rotation = objJSON.rotation;

						switch ( objJSON.type ) {

							case 'AmbientLight':
								light = new THREE.AmbientLight( color );
								break;

							case 'PointLight':
								light = new THREE.PointLight( color, intensity, distance );
								light.position.fromArray( position );
								break;

							case 'DirectionalLight':
								light = new THREE.DirectionalLight( color, intensity );
								light.position.fromArray( objJSON.direction );
								break;

							case 'SpotLight':
								light = new THREE.SpotLight( color, intensity, distance, 1 );
								light.angle = objJSON.angle;
								light.position.fromArray( position );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'HemisphereLight':
								light = new THREE.DirectionalLight( color, intensity, distance );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'AreaLight':
								light = new THREE.AreaLight(color, intensity);
								light.position.fromArray( position );
								light.width = objJSON.size;
								light.height = objJSON.size_y;
								break;

						}

						parent.add( light );

						light.name = objID;
						result.lights[ objID ] = light;
						result.objects[ objID ] = light;

					// cameras

					} else if ( objJSON.type === "PerspectiveCamera" || objJSON.type === "OrthographicCamera" ) {

						pos = objJSON.position;
						rot = objJSON.rotation;
						quat = objJSON.quaternion;

						if ( objJSON.type === "PerspectiveCamera" ) {

							camera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );

						} else if ( objJSON.type === "OrthographicCamera" ) {

							camera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );

						}

						camera.name = objID;
						camera.position.fromArray( pos );

						if ( quat !== undefined ) {

							camera.quaternion.fromArray( quat );

						} else if ( rot !== undefined ) {

							camera.rotation.fromArray( rot );

						}

						parent.add( camera );

						result.cameras[ objID ] = camera;
						result.objects[ objID ] = camera;

					// pure Object3D

					} else {

						pos = objJSON.position;
						rot = objJSON.rotation;
						scl = objJSON.scale;
						quat = objJSON.quaternion;

						object = new THREE.Object3D();
						object.name = objID;
						object.position.fromArray( pos );

						if ( quat ) {

							object.quaternion.fromArray( quat );

						} else {

							object.rotation.fromArray( rot );

						}

						object.scale.fromArray( scl );
						object.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;

						parent.add( object );

						result.objects[ objID ] = object;
						result.empties[ objID ] = object;

					}

					if ( object ) {

						if ( objJSON.userData !== undefined ) {

							for ( var key in objJSON.userData ) {

								var value = objJSON.userData[ key ];
								object.userData[ key ] = value;

							}

						}

						if ( objJSON.groups !== undefined ) {

							for ( var i = 0; i < objJSON.groups.length; i ++ ) {

								var groupID = objJSON.groups[ i ];

								if ( result.groups[ groupID ] === undefined ) {

									result.groups[ groupID ] = [];

								}

								result.groups[ groupID ].push( objID );

							}

						}

					}

				}

				if ( object !== undefined && objJSON.children !== undefined ) {

					handle_children( object, objJSON.children );

				}

			}

		};

		function handle_mesh( geo, mat, id ) {

			result.geometries[ id ] = geo;
			result.face_materials[ id ] = mat;
			handle_objects();

		};

		function handle_hierarchy( node, id, parent, material, obj ) {

			var p = obj.position;
			var r = obj.rotation;
			var q = obj.quaternion;
			var s = obj.scale;

			node.position.fromArray( p );

			if ( q ) {

				node.quaternion.fromArray( q );

			} else {

				node.rotation.fromArray( r );

			}

			node.scale.fromArray( s );

			// override children materials
			// if object material was specified in JSON explicitly

			if ( material ) {

				node.traverse( function ( child ) {

					child.material = material;

				} );

			}

			// override children visibility
			// with root node visibility as specified in JSON

			var visible = ( obj.visible !== undefined ) ? obj.visible : true;

			node.traverse( function ( child ) {

				child.visible = visible;

			} );

			parent.add( node );

			node.name = id;

			result.objects[ id ] = node;
			handle_objects();

		};

		function create_callback_geometry( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				handle_mesh( geo, mat, id );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			}

		};

		function create_callback_hierachy( id, parent, material, obj ) {

			return function ( event ) {

				var result;

				// loaders which use EventDispatcher

				if ( event.content ) {

					result = event.content;

				// ColladaLoader

				} else if ( event.dae ) {

					result = event.scene;


				// UTF8Loader

				} else {

					result = event;

				}

				handle_hierarchy( result, id, parent, material, obj );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			}

		};

		function create_callback_embed( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				result.geometries[ id ] = geo;
				result.face_materials[ id ] = mat;

			}

		};

		function async_callback_gate() {

			var progress = {

				totalModels : total_models,
				totalTextures : total_textures,
				loadedModels : total_models - counter_models,
				loadedTextures : total_textures - counter_textures

			};

			scope.callbackProgress( progress, result );

			scope.onLoadProgress();

			if ( counter_models === 0 && counter_textures === 0 ) {

				finalize();
				callbackFinished( result );

			}

		};

		function finalize() {

			// take care of targets which could be asynchronously loaded objects

			for ( var i = 0; i < target_array.length; i ++ ) {

				var ta = target_array[ i ];

				var target = result.objects[ ta.targetName ];

				if ( target ) {

					ta.object.target = target;

				} else {

					// if there was error and target of specified name doesn't exist in the scene file
					// create instead dummy target
					// (target must be added to scene explicitly as parent is already added)

					ta.object.target = new THREE.Object3D();
					result.scene.add( ta.object.target );

				}

				ta.object.target.userData.targetInverse = ta.object;

			}

		};

		var callbackTexture = function ( count ) {

			counter_textures -= count;
			async_callback_gate();

			scope.onLoadComplete();

		};

		// must use this instead of just directly calling callbackTexture
		// because of closure in the calling context loop

		var generateTextureCallback = function ( count ) {

			return function () {

				callbackTexture( count );

			};

		};

		function traverse_json_hierarchy( objJSON, callback ) {

			callback( objJSON );

			if ( objJSON.children !== undefined ) {

				for ( var objChildID in objJSON.children ) {

					traverse_json_hierarchy( objJSON.children[ objChildID ], callback );

				}

			}

		};

		// first go synchronous elements

		// fogs

		var fogID, fogJSON;

		for ( fogID in data.fogs ) {

			fogJSON = data.fogs[ fogID ];

			if ( fogJSON.type === "linear" ) {

				fog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );

			} else if ( fogJSON.type === "exp2" ) {

				fog = new THREE.FogExp2( 0x000000, fogJSON.density );

			}

			color = fogJSON.color;
			fog.color.setRGB( color[0], color[1], color[2] );

			result.fogs[ fogID ] = fog;

		}

		// now come potentially asynchronous elements

		// geometries

		// count how many geometries will be loaded asynchronously

		var geoID, geoJSON;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type in this.geometryHandlers ) {

				counter_models += 1;

				scope.onLoadStart();

			}

		}

		// count how many hierarchies will be loaded asynchronously

		for ( var objID in data.objects ) {

			traverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {

				if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

					counter_models += 1;

					scope.onLoadStart();

				}

			});

		}

		total_models = counter_models;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type === "cube" ) {

				geometry = new THREE.BoxGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "plane" ) {

				geometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "sphere" ) {

				geometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "cylinder" ) {

				geometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "torus" ) {

				geometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "icosahedron" ) {

				geometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type in this.geometryHandlers ) {

				var loaderParameters = {};

				for ( var parType in geoJSON ) {

					if ( parType !== "type" && parType !== "url" ) {

						loaderParameters[ parType ] = geoJSON[ parType ];

					}

				}

				var loader = this.geometryHandlers[ geoJSON.type ][ "loaderObject" ];
				loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );

			} else if ( geoJSON.type === "embedded" ) {

				var modelJson = data.embeds[ geoJSON.id ],
					texture_path = "";

				// pass metadata along to jsonLoader so it knows the format version

				modelJson.metadata = data.metadata;

				if ( modelJson ) {

					var jsonLoader = this.geometryHandlers[ "ascii" ][ "loaderObject" ];
					var model = jsonLoader.parse( modelJson, texture_path );
					create_callback_embed( geoID )( model.geometry, model.materials );

				}

			}

		}

		// textures

		// count how many textures will be loaded asynchronously

		var textureID, textureJSON;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.url instanceof Array ) {

				counter_textures += textureJSON.url.length;

				for( var n = 0; n < textureJSON.url.length; n ++ ) {

					scope.onLoadStart();

				}

			} else {

				counter_textures += 1;

				scope.onLoadStart();

			}

		}

		total_textures = counter_textures;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {

				textureJSON.mapping = new THREE[ textureJSON.mapping ]();

			}

			if ( textureJSON.url instanceof Array ) {

				var count = textureJSON.url.length;
				var url_array = [];

				for( var i = 0; i < count; i ++ ) {

					url_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );

				}

				var isCompressed = /\.dds$/i.test( url_array[ 0 ] );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				} else {

					texture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				}

			} else {

				var isCompressed = /\.dds$/i.test( textureJSON.url );
				var fullUrl = get_url( textureJSON.url, data.urlBaseType );
				var textureCallback = generateTextureCallback( 1 );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );

				} else {

					texture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );

				}

				if ( THREE[ textureJSON.minFilter ] !== undefined )
					texture.minFilter = THREE[ textureJSON.minFilter ];

				if ( THREE[ textureJSON.magFilter ] !== undefined )
					texture.magFilter = THREE[ textureJSON.magFilter ];

				if ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;

				if ( textureJSON.repeat ) {

					texture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );

					if ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( textureJSON.offset ) {

					texture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );

				}

				// handle wrap after repeat so that default repeat can be overriden

				if ( textureJSON.wrap ) {

					var wrapMap = {
						"repeat": THREE.RepeatWrapping,
						"mirror": THREE.MirroredRepeatWrapping
					}

					if ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];
					if ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];

				}

			}

			result.textures[ textureID ] = texture;

		}

		// materials

		var matID, matJSON;
		var parID;

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			for ( parID in matJSON.parameters ) {

				if ( parID === "envMap" || parID === "map" || parID === "lightMap" || parID === "bumpMap" ) {

					matJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];

				} else if ( parID === "shading" ) {

					matJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === "flat" ) ? THREE.FlatShading : THREE.SmoothShading;

				} else if ( parID === "side" ) {

					if ( matJSON.parameters[ parID ] == "double" ) {

						matJSON.parameters[ parID ] = THREE.DoubleSide;

					} else if ( matJSON.parameters[ parID ] == "back" ) {

						matJSON.parameters[ parID ] = THREE.BackSide;

					} else {

						matJSON.parameters[ parID ] = THREE.FrontSide;

					}

				} else if ( parID === "blending" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;

				} else if ( parID === "combine" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;

				} else if ( parID === "vertexColors" ) {

					if ( matJSON.parameters[ parID ] == "face" ) {

						matJSON.parameters[ parID ] = THREE.FaceColors;

					// default to vertex colors if "vertexColors" is anything else face colors or 0 / null / false

					} else if ( matJSON.parameters[ parID ] ) {

						matJSON.parameters[ parID ] = THREE.VertexColors;

					}

				} else if ( parID === "wrapRGB" ) {

					var v3 = matJSON.parameters[ parID ];
					matJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );

				}

			}

			if ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {

				matJSON.parameters.transparent = true;

			}

			if ( matJSON.parameters.normalMap ) {

				var shader = THREE.ShaderLib[ "normalmap" ];
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

				var diffuse = matJSON.parameters.color;
				var specular = matJSON.parameters.specular;
				var ambient = matJSON.parameters.ambient;
				var shininess = matJSON.parameters.shininess;

				uniforms[ "tNormal" ].value = result.textures[ matJSON.parameters.normalMap ];

				if ( matJSON.parameters.normalScale ) {

					uniforms[ "uNormalScale" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );

				}

				if ( matJSON.parameters.map ) {

					uniforms[ "tDiffuse" ].value = matJSON.parameters.map;
					uniforms[ "enableDiffuse" ].value = true;

				}

				if ( matJSON.parameters.envMap ) {

					uniforms[ "tCube" ].value = matJSON.parameters.envMap;
					uniforms[ "enableReflection" ].value = true;
					uniforms[ "reflectivity" ].value = matJSON.parameters.reflectivity;

				}

				if ( matJSON.parameters.lightMap ) {

					uniforms[ "tAO" ].value = matJSON.parameters.lightMap;
					uniforms[ "enableAO" ].value = true;

				}

				if ( matJSON.parameters.specularMap ) {

					uniforms[ "tSpecular" ].value = result.textures[ matJSON.parameters.specularMap ];
					uniforms[ "enableSpecular" ].value = true;

				}

				if ( matJSON.parameters.displacementMap ) {

					uniforms[ "tDisplacement" ].value = result.textures[ matJSON.parameters.displacementMap ];
					uniforms[ "enableDisplacement" ].value = true;

					uniforms[ "uDisplacementBias" ].value = matJSON.parameters.displacementBias;
					uniforms[ "uDisplacementScale" ].value = matJSON.parameters.displacementScale;

				}

				uniforms[ "diffuse" ].value.setHex( diffuse );
				uniforms[ "specular" ].value.setHex( specular );
				uniforms[ "ambient" ].value.setHex( ambient );

				uniforms[ "shininess" ].value = shininess;

				if ( matJSON.parameters.opacity ) {

					uniforms[ "opacity" ].value = matJSON.parameters.opacity;

				}

				var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };

				material = new THREE.ShaderMaterial( parameters );

			} else {

				material = new THREE[ matJSON.type ]( matJSON.parameters );

			}

			material.name = matID;

			result.materials[ matID ] = material;

		}

		// second pass through all materials to initialize MeshFaceMaterials
		// that could be referring to other materials out of order

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			if ( matJSON.parameters.materials ) {

				var materialArray = [];

				for ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {

					var label = matJSON.parameters.materials[ i ];
					materialArray.push( result.materials[ label ] );

				}

				result.materials[ matID ].materials = materialArray;

			}

		}

		// objects ( synchronous init of procedural primitives )

		handle_objects();

		// defaults

		if ( result.cameras && data.defaults.camera ) {

			result.currentCamera = result.cameras[ data.defaults.camera ];

		}

		if ( result.fogs && data.defaults.fog ) {

			result.scene.fog = result.fogs[ data.defaults.fog ];

		}

		// synchronous callback

		scope.callbackSync( result );

		// just in case there are no async elements

		async_callback_gate();

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.ImageLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			var texture = new THREE.Texture( image );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	this.id = THREE.MaterialIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.depthTest = true;
	this.depthWrite = true;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				THREE.onwarning( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			if ( key in this ) {

				var currentValue = this[ key ];

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key == 'overdraw') {

					// ensure overdraw is backwards-compatable with legacy boolean type
					this[ key ] = Number(newValue);

				} else {

					this[ key ] = newValue;

				}

			}

		}

	},

	clone: function ( material ) {

		if ( material === undefined ) material = new THREE.Material();

		material.name = this.name;

		material.side = this.side;

		material.opacity = this.opacity;
		material.transparent = this.transparent;

		material.blending = this.blending;

		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;

		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;

		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;

		material.alphaTest = this.alphaTest;

		material.overdraw = this.overdraw;

		material.visible = this.visible;

		return material;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineBasicMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;
	material.linecap = this.linecap;
	material.linejoin = this.linejoin;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineDashedMaterial.prototype.clone = function () {

	var material = new THREE.LineDashedMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;

	material.scale = this.scale;
	material.dashSize = this.dashSize;
	material.gapSize = this.gapSize;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshBasicMaterial.prototype.clone = function () {

	var material = new THREE.MeshBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshLambertMaterial.prototype.clone = function () {

	var material = new THREE.MeshLambertMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0x000000 );
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0xffffff );
	this.shininess = 30;

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;
	this.opacityMap = null;

	this.lightMap = null;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhongMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhongMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );
	material.specular.copy( this.specular );
	material.shininess = this.shininess;

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;
	material.opacityMap = this.opacityMap;

	material.lightMap = this.lightMap;
	material.emissiveMap = this.emissiveMap;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 *
 * @author bhouston / http://clara.io/
 *
 */

THREE.MeshPhysicalMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.map = null;
	this.opacityMap = null;

	this.falloff = false;
	this.falloffColor = new THREE.Color( 0xffffff );
	this.falloffMap = null;
	this.falloffBlendParams = new THREE.Vector4( 1.0, 0.0, 0.0, 1.0 );

	this.specular = new THREE.Color( 0xffffff );
	this.specularMap = null;
	
	this.roughness = 0.5;
	this.roughnessMap = null;
	
	this.metallic = 0.0;
	this.metallicMap = null;

	this.clearCoat = 0.0;	// 0 means no clear coat, 1 means complete clear coat.
	this.clearCoatRoughness = 0.2;

	this.anisotropy = 0.0;	// valid range is [-1,1].-1 is max vertical elongation, 0 is normal, +1 is max horizontal elongation
	this.anisotropyMap = null;	// only R is read and considered to be anisotropy.  To get negative values, use texture brightness, gain
	this.anisotropyRotation = 0.0; // converted to radias via multiplication by 2*PI.  Thus the range [ 0 - 1 ] maps to radian [0, PI].
	this.anisotropyRotationMap = null;  // only R is read and considered to be anisotropyRotation.

	this.translucency = new THREE.Color( 0x000000 );
	this.translucencyMap = null;
	this.translucencyNormalAlpha = 0.75;
	this.translucencyNormalPower = 1.0;
	this.translucencyViewPower = 2.0;
	this.translucencyViewAlpha = 0.75;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.emissive = new THREE.Color( 0x000000 );
	this.emissiveMap = null; 	// given off arbitrarily by the object in all directions.  Basically GI.

	this.ambient = new THREE.Color( 0x000000 );
	this.lightMap = null; // incoming light

	this.envMap = null;  // Incoming environmental light.
	this.combine = THREE.AddOperation;

	this.shading = THREE.SmoothShading

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.blending = THREE.CustomBlending;
	this.blendSrc = THREE.OneFactor;	// output of shader must be premultiplied
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );
};

THREE.MeshPhysicalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhysicalMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhysicalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;
	material.opacityMap = this.opacityMap;

	material.falloff = this.falloff;
	material.falloffColor.copy( this.falloffColor );
	material.falloffMap = this.falloffMap;
	material.falloffBlendParams.copy( this.falloffBlendParams );

	material.specular.copy( this.specular );
	material.specularMap = this.specularMap;

	material.roughness = this.roughness;
	material.roughnessMap = this.roughnessMap;
	material.metallic = this.metallic;
	material.metallicMap = this.metallicMap;

	material.shading = this.shading;

	material.translucency.copy( this.translucency );
	material.translucencyMap = this.translucencyMap;
	material.translucencyNormalAlpha = this.translucencyNormalAlpha;
	material.translucencyNormalPower = this.translucencyNormalPower;
	material.translucencyViewPower = this.translucencyViewPower;
	material.translucencyViewAlpha = this.translucencyViewAlpha;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.emissive.copy( this.emissive );
	material.emissiveMap = this.emissiveMap;

	material.ambient.copy( this.ambient );
	material.lightMap = this.lightMap;

	material.envMap = this.envMap;
	material.combine = this.combine;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshDepthMaterial.prototype.clone = function () {

	var material = new THREE.MeshDepthMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.shading = THREE.FlatShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshNormalMaterial.prototype.clone = function () {

	var material = new THREE.MeshNormalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

	this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype.clone = function () {

	var material = new THREE.MeshFaceMaterial();

	for ( var i = 0; i < this.materials.length; i ++ ) {

		material.materials.push( this.materials[ i ].clone() );

	}

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ParticleSystemMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.ParticleSystemMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ParticleSystemMaterial.prototype.clone = function () {

	var material = new THREE.ParticleSystemMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.size = this.size;
	material.sizeAttenuation = this.sizeAttenuation;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  defines: { "label" : "value" },
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.fragmentShader = "void main() {}";
	this.vertexShader = "void main() {}";
	this.uniforms = {};
	this.defines = {};
	this.attributes = null;

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		"color" : [ 1, 1, 1],
		"uv" : [ 0, 0 ],
		"uv2" : [ 0, 0 ]
	};

	// By default, bind position to attribute index 0. In WebGL, attribute 0
	// should always be used to avoid potentially expensive emulation.
	this.index0AttributeName = "position";

	this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ShaderMaterial.prototype.clone = function () {

	var material = new THREE.ShaderMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.fragmentShader = this.fragmentShader;
	material.vertexShader = this.vertexShader;

	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

	material.attributes = this.attributes;
	material.defines = this.defines;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	material.fog = this.fog;

	material.lights = this.lights;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;

	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	// defaults

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteMaterial.prototype.clone = function () {

	var material = new THREE.SpriteMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;

	material.rotation = this.rotation;

	material.fog = this.fog;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <hex>,
 *  program: <function>,
 *  opacity: <float>,
 *  blending: THREE.NormalBlending
 * }
 */

THREE.SpriteCanvasMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );
	this.program = function ( context, color ) {};

	this.setValues( parameters );

};

THREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteCanvasMaterial.prototype.clone = function () {

	var material = new THREE.SpriteCanvasMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.program = this.program;

	return material;

};

// backwards compatibility

THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author bhouston / https://clara.io/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	this.id = THREE.TextureIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.image = image;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	// formula used
	// x' = ( x - gainPivot ) * gain + brightness + gainPivot
	// for standard contrast adjust, set gain to contrast, and gainPivot to 0.5
	this.gainPivot = 0.0;
	this.gain = 1.0;
	this.brightness = 0.0;

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this._needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	clone: function ( texture ) {

		if ( texture === undefined ) texture = new THREE.Texture();

		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice(0);

		texture.mapping = this.mapping;

		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;

		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;

		texture.anisotropy = this.anisotropy;

		texture.format = this.format;
		texture.type = this.type;

		texture.offset.copy( this.offset );
		texture.repeat.copy( this.repeat );

		texture.gainPivot = this.gainPivot;
		texture.gain = this.gain;
		texture.brightness = this.brightness;

		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;

		return texture;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	this.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CompressedTexture.prototype.clone = function () {

	var texture = new THREE.CompressedTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.DataTexture.prototype.clone = function () {

	var texture = new THREE.DataTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ParticleSystem = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.ParticleSystemMaterial( { color: Math.random() * 0xffffff } );

	this.sortParticles = false;
	this.frustumCulled = false;

};

THREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );

THREE.ParticleSystem.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );

	object.sortParticles = this.sortParticles;

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, type ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	this.type = ( type !== undefined ) ? type : THREE.LineStrip;

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

THREE.Line.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = -1;
		this.morphTargetForcedOrder = [];
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	THREE.onwarning( "THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0." );

	return 0;

};

THREE.Mesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Bone = function( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;
	this.skinMatrix = new THREE.Matrix4();

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );

THREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {

	// update local

	if ( this.matrixAutoUpdate ) {

		forceUpdate |= this.updateMatrix();

	}

	// update skin matrix

	if ( forceUpdate || this.matrixWorldNeedsUpdate ) {

		if( parentSkinMatrix ) {

			this.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );

		} else {

			this.skinMatrix.copy( this.matrix );

		}

		this.matrixWorldNeedsUpdate = false;
		forceUpdate = true;

	}

	// update children

	var child, i, l = this.children.length;

	for ( i = 0; i < l; i ++ ) {

		this.children[ i ].update( this.skinMatrix, forceUpdate );

	}

};


/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	//

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	// init bones

	this.identityMatrix = new THREE.Matrix4();

	this.bones = [];
	this.boneMatrices = [];

	var b, bone, gbone, p, q, s;

	if ( this.geometry && this.geometry.bones !== undefined ) {

		for ( b = 0; b < this.geometry.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = this.addBone();

			bone.name = gbone.name;
			bone.position.set( p[0], p[1], p[2] );
			bone.quaternion.set( q[0], q[1], q[2], q[3] );
		
			if ( s !== undefined ) {

				bone.scale.set( s[0], s[1], s[2] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( b = 0; b < this.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];
			bone = this.bones[ b ];

			if ( gbone.parent === -1 ) {

				this.add( bone );

			} else {

				this.bones[ gbone.parent ].add( bone );

			}

		}

		//

		var nBones = this.bones.length;

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//	RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
			//  	 16x16 pixel texture max   64 bones (16 * 16 / 4)
			//  	 32x32 pixel texture max  256 bones (32 * 32 / 4)
			//  	 64x64 pixel texture max 1024 bones (64 * 64 / 4)

			var size;

			if ( nBones > 256 )
				size = 64;
			else if ( nBones > 64 )
				size = 32;
			else if ( nBones > 16 )
				size = 16;
			else
				size = 8;

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
			this.boneTexture.minFilter = THREE.NearestFilter;
			this.boneTexture.magFilter = THREE.NearestFilter;
			this.boneTexture.generateMipmaps = false;
			this.boneTexture.flipY = false;

		} else {

			this.boneMatrices = new Float32Array( 16 * nBones );

		}

		this.pose();

	}

};

THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.SkinnedMesh.prototype.addBone = function( bone ) {

	if ( bone === undefined ) {

		bone = new THREE.Bone( this );

	}

	this.bones.push( bone );

	return bone;

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {

	var offsetMatrix = new THREE.Matrix4();

	return function ( force ) {

		this.matrixAutoUpdate && this.updateMatrix();

		// update matrixWorld

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent ) {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			} else {

				this.matrixWorld.copy( this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child instanceof THREE.Bone ) {

				child.update( this.identityMatrix, false );

			} else {

				child.updateMatrixWorld( true );

			}

		}

		// make a snapshot of the bones' rest position

		if ( this.boneInverses == undefined ) {

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				var inverse = new THREE.Matrix4();

				inverse.getInverse( this.bones[ b ].skinMatrix );

				this.boneInverses.push( inverse );

			}

		}

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform;

			// TODO: we could get rid of this multiplication step if the skinMatrix
			// was already representing the offset; however, this requires some
			// major changes to the animation system

			offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}

	};

}();

THREE.SkinnedMesh.prototype.pose = function () {

	this.updateMatrixWorld( true );

	this.normalizeSkinWeights();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) {

		object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

	}

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

	this.startKeyframe = start;
	this.endKeyframe = end;

	this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

	this.direction = -1;
	this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

	var geometry = this.geometry;

	if ( ! geometry.animations ) geometry.animations = {};

	var firstAnimation, animations = geometry.animations;

	var pattern = /([a-z]+)(\d+)/;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var parts = morph.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var label = parts[ 1 ];
			var num = parts[ 2 ];

			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };

			var animation = animations[ label ];

			if ( i < animation.start ) animation.start = i;
			if ( i > animation.end ) animation.end = i;

			if ( ! firstAnimation ) firstAnimation = label;

		}

	}

	geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

	if ( ! this.geometry.animations ) this.geometry.animations = {};

	this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

	var animation = this.geometry.animations[ label ];

	if ( animation ) {

		this.setFrameRange( animation.start, animation.end );
		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
		this.time = 0;

	} else {

		THREE.onwarning( "animation[" + label + "] undefined" );

	}

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / this.length;

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= -1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

		if ( this.time < 0 ) this.time += this.duration;

	}

	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

	if ( keyframe !== this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

	object.duration = this.duration;
	object.mirroredLoop = this.mirroredLoop;
	object.time = this.time;

	object.lastKeyframe = this.lastKeyframe;
	object.currentKeyframe = this.currentKeyframe;

	object.direction = this.direction;
	object.directionBackwards = this.directionBackwards;

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	for ( var l = 0; l < this.objects.length; l ++ ) {

		if ( distance < this.objects[ l ].distance ) {

			break;

		}

	}

	this.objects.splice( l, 0, { distance: distance, object: object } );
	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

		if ( distance < this.objects[ i ].distance ) {

			break;

		}

	}

	return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( camera ) {

		if ( this.objects.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			this.objects[ 0 ].object.visible = true;

			for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

				if ( distance >= this.objects[ i ].distance ) {

					this.objects[ i - 1 ].object.visible = false;
					this.objects[ i     ].object.visible = true;

				} else {

					break;

				}

			}

			for( ; i < l; i ++ ) {

				this.objects[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.LOD();

	THREE.Object3D.prototype.clone.call( this, object );

	for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
		var x = this.objects[i].object.clone();
		x.visible = i === 0;
		object.addLevel( x, this.objects[i].distance );
	}

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

	var geometry = new THREE.Geometry2( 3 );
	geometry.vertices.set( [ - 0.5, - 0.5, 0, 0.5, - 0.5, 0, 0.5, 0.5, 0 ] );

	return function ( material ) {

		THREE.Object3D.call( this );

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	};

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

/*
 * Custom update matrix
 */

THREE.Sprite.prototype.updateMatrix = function () {

	this.matrix.compose( this.position, this.quaternion, this.scale );

	this.matrixWorldNeedsUpdate = true;

};

THREE.Sprite.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Sprite( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer
	this.matrixAutoUpdate = false;

	this.__lights = [];

	this.__objectsAdded = [];
	this.__objectsRemoved = [];

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

THREE.Scene.prototype.__addObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		if ( this.__lights.indexOf( object ) === - 1 ) {

			this.__lights.push( object );

		}

		if ( object.target && object.target.parent === undefined ) {

			this.add( object.target );

		}

	} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {

		this.__objectsAdded.push( object );

		// check if previously removed

		var i = this.__objectsRemoved.indexOf( object );

		if ( i !== -1 ) {

			this.__objectsRemoved.splice( i, 1 );

		}

	}

	this.dispatchEvent( { type: 'objectAdded', object: object } );
	object.dispatchEvent( { type: 'addedToScene', scene: this } );

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__addObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.__removeObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		var i = this.__lights.indexOf( object );

		if ( i !== -1 ) {

			this.__lights.splice( i, 1 );

		}

		if ( object.shadowCascadeArray ) {

			for ( var x = 0; x < object.shadowCascadeArray.length; x ++ ) {

				this.__removeObject( object.shadowCascadeArray[ x ] );

			}

		}

	} else if ( !( object instanceof THREE.Camera ) ) {

		this.__objectsRemoved.push( object );

		// check if previously added

		var i = this.__objectsAdded.indexOf( object );

		if ( i !== -1 ) {

			this.__objectsAdded.splice( i, 1 );

		}

	}

	this.dispatchEvent( { type: 'objectRemoved', object: object } );
	object.dispatchEvent( { type: 'removedFromScene', scene: this } );

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__removeObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Scene();

	THREE.Object3D.prototype.clone.call(this, object);

	if ( this.fog !== null ) object.fog = this.fog.clone();
	if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

	object.autoUpdate = this.autoUpdate;
	object.matrixAutoUpdate = this.matrixAutoUpdate;

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasRenderer = function ( parameters ) {

	console.log( 'THREE.CanvasRenderer', THREE.REVISION );

	var smoothstep = THREE.Math.smoothstep;

	parameters = parameters || {};

	var _this = this,
	_renderData, _elements, _lights,
	_projector = new THREE.Projector(),

	_canvas = parameters.canvas !== undefined
			? parameters.canvas
			: document.createElement( 'canvas' ),

	_canvasWidth = _canvas.width,
	_canvasHeight = _canvas.height,
	_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),
	_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),
	
	_context = _canvas.getContext( '2d', {
		alpha: parameters.alpha === true
	} ),

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0,

	_contextGlobalAlpha = 1,
	_contextGlobalCompositeOperation = 0,
	_contextStrokeStyle = null,
	_contextFillStyle = null,
	_contextLineWidth = null,
	_contextLineCap = null,
	_contextLineJoin = null,
	_contextDashSize = null,
	_contextGapSize = 0,

	_camera,

	_v1, _v2, _v3, _v4,
	_v5 = new THREE.RenderableVertex(),
	_v6 = new THREE.RenderableVertex(),

	_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,
	_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,

	_color = new THREE.Color(),
	_color1 = new THREE.Color(),
	_color2 = new THREE.Color(),
	_color3 = new THREE.Color(),
	_color4 = new THREE.Color(),

	_diffuseColor = new THREE.Color(),
	_emissiveColor = new THREE.Color(),

	_lightColor = new THREE.Color(),

	_patterns = {},

	_near, _far,

	_image, _uvs,
	_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,

	_clipBox = new THREE.Box2(),
	_clearBox = new THREE.Box2(),
	_elemBox = new THREE.Box2(),

	_ambientLight = new THREE.Color(),
	_directionalLights = new THREE.Color(),
	_pointLights = new THREE.Color(),

	_vector3 = new THREE.Vector3(), // Needed for PointLight
	_normal = new THREE.Vector3(),
	_normalViewMatrix = new THREE.Matrix3(),

	_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,
	_gradientMap, _gradientMapContext, _gradientMapQuality = 16;

	_pixelMap = document.createElement( 'canvas' );
	_pixelMap.width = _pixelMap.height = 2;

	_pixelMapContext = _pixelMap.getContext( '2d' );
	_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
	_pixelMapContext.fillRect( 0, 0, 2, 2 );

	_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );
	_pixelMapData = _pixelMapImage.data;

	_gradientMap = document.createElement( 'canvas' );
	_gradientMap.width = _gradientMap.height = _gradientMapQuality;

	_gradientMapContext = _gradientMap.getContext( '2d' );
	_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );
	_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );

	_gradientMapQuality --; // Fix UVs

	// dash+gap fallbacks for Firefox and everything else

	if ( _context.setLineDash === undefined ) {

		if ( _context.mozDash !== undefined ) {

			_context.setLineDash = function ( values ) {

				_context.mozDash = values[ 0 ] !== null ? values : null;

			}

		} else {

			_context.setLineDash = function () {}

		}

	}

	this.domElement = _canvas;

	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: self.devicePixelRatio !== undefined
					? self.devicePixelRatio
					: 1;

	this.autoClear = true;
	this.sortObjects = true;
	this.sortElements = true;

	this.info = {

		render: {

			vertices: 0,
			faces: 0

		}

	}

	// WebGLRenderer compatibility

	this.supportsVertexTextures = function () {};
	this.setFaceCulling = function () {};

	this.setSize = function ( width, height, updateStyle ) {

		_canvasWidth = width * this.devicePixelRatio;
		_canvasHeight = height * this.devicePixelRatio;

		_canvasWidthHalf = Math.floor( _canvasWidth / 2 );
		_canvasHeightHalf = Math.floor( _canvasHeight / 2 );

		_canvas.width = _canvasWidth;
		_canvas.height = _canvasHeight;

		if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		_clipBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf ),
		_clipBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );

		_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );
		_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );

		_contextGlobalAlpha = 1;
		_contextGlobalCompositeOperation = 0;
		_contextStrokeStyle = null;
		_contextFillStyle = null;
		_contextLineWidth = null;
		_contextLineCap = null;
		_contextLineJoin = null;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );
		_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		THREE.onwarning( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getMaxAnisotropy = function () {

		return 0;

	};

	this.clear = function () {

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		if ( _clearBox.empty() === false ) {

			_clearBox.intersect( _clipBox );
			_clearBox.expandByScalar( 2 );

			if ( _clearAlpha < 1 ) {

				_context.clearRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			if ( _clearAlpha > 0 ) {

				setBlending( THREE.NormalBlending );
				setOpacity( 1 );

				setFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );

				_context.fillRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			_clearBox.makeEmpty();

		}

	};

	// compatibility

	this.clearColor = function () {};
	this.clearDepth = function () {};
	this.clearStencil = function () {};

	this.render = function ( scene, camera ) {

		if ( camera instanceof THREE.Camera === false ) {

			THREE.onerror( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( this.autoClear === true ) this.clear();

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;

		_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
		_elements = _renderData.elements;
		_lights = _renderData.lights;
		_camera = camera;

		_normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );

		/* DEBUG
		setFillStyle( 'rgba( 0, 255, 255, 0.5 )' );
		_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );
		*/

		calculateLights();

		for ( var e = 0, el = _elements.length; e < el; e ++ ) {

			var element = _elements[ e ];

			var material = element.material;

			if ( material === undefined || material.visible === false ) continue;

			_elemBox.makeEmpty();

			if ( element instanceof THREE.RenderableSprite ) {

				_v1 = element;
				_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;

				renderSprite( _v1, element, material );

			} else if ( element instanceof THREE.RenderableLine ) {

				_v1 = element.v1; _v2 = element.v2;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;

				_elemBox.setFromPoints( [
					_v1.positionScreen,
					_v2.positionScreen
				] );

				if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {

					renderLine( _v1, _v2, element, material );

				}

			} else if ( element instanceof THREE.RenderableFace ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

				if ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;
				if ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;
				if ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
				_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;

				if ( material.overdraw > 0 ) {

					expand( _v1.positionScreen, _v2.positionScreen, material.overdraw );
					expand( _v2.positionScreen, _v3.positionScreen, material.overdraw );
					expand( _v3.positionScreen, _v1.positionScreen, material.overdraw );

				}

				_elemBox.setFromPoints( [
					_v1.positionScreen,
					_v2.positionScreen,
					_v3.positionScreen
				] );

				if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {

					renderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );

				}

			}

			/* DEBUG
			setLineWidth( 1 );
			setStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );
			_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );
			*/

			_clearBox.union( _elemBox );

		}

		/* DEBUG
		setLineWidth( 1 );
		setStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );
		_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );
		*/

		_context.setTransform( 1, 0, 0, 1, 0, 0 );

	};

	//

	function calculateLights() {

		_ambientLight.setRGB( 0, 0, 0 );
		_directionalLights.setRGB( 0, 0, 0 );
		_pointLights.setRGB( 0, 0, 0 );

		for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

			var light = _lights[ l ];
			var lightColor = light.color;

			if ( light instanceof THREE.AmbientLight ) {

				_ambientLight.add( lightColor );

			} else if ( light instanceof THREE.DirectionalLight ) {

				// for sprites

				_directionalLights.add( lightColor );

			} else if ( light instanceof THREE.PointLight ) {

				// for sprites

				_pointLights.add( lightColor );

			}

		}

	}

	function calculateLight( position, normal, color ) {

		for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

			var light = _lights[ l ];

			_lightColor.copy( light.color );

			if ( light instanceof THREE.DirectionalLight ) {

				var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();

				var amount = normal.dot( lightPosition );

				if ( amount <= 0 ) continue;

				amount *= light.intensity;

				color.add( _lightColor.multiplyScalar( amount ) );

			} else if ( light instanceof THREE.PointLight ) {

				var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );

				var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );

				if ( amount <= 0 ) continue;

				amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

				if ( amount == 0 ) continue;

				amount *= light.intensity;

				color.add( _lightColor.multiplyScalar( amount ) );

			}

		}

	}

	function renderSprite( v1, element, material ) {

		setOpacity( material.opacity );
		setBlending( material.blending );

		var scaleX = element.scale.x * _canvasWidthHalf;
		var scaleY = element.scale.y * _canvasHeightHalf;

		var dist = 0.5 * Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite
		_elemBox.min.set( v1.x - dist, v1.y - dist );
		_elemBox.max.set( v1.x + dist, v1.y + dist );

		if ( material instanceof THREE.SpriteMaterial ||
			 material instanceof THREE.ParticleSystemMaterial ) { // Backwards compatibility

			var texture = material.map;

			if ( texture !== null ) {

				if ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {

					if ( texture.image !== undefined && texture.image.width > 0 ) {

						textureToPattern( texture );

					}

					texture.addEventListener( 'update', onTextureUpdate );

				}

				var pattern = _patterns[ texture.id ];

				if ( pattern !== undefined ) {

					setFillStyle( pattern );

				} else {

					setFillStyle( 'rgba( 0, 0, 0, 1 )' );

				}

				//

				var bitmap = texture.image;

				var ox = bitmap.width * texture.offset.x;
				var oy = bitmap.height * texture.offset.y;

				var sx = bitmap.width * texture.repeat.x;
				var sy = bitmap.height * texture.repeat.y;

				var cx = scaleX / sx;
				var cy = scaleY / sy;

				_context.save();
				_context.translate( v1.x, v1.y );
				if ( material.rotation !== 0 ) _context.rotate( material.rotation );
				_context.translate( - scaleX / 2, - scaleY / 2 );
				_context.scale( cx, cy );
				_context.translate( - ox, - oy );
				_context.fillRect( ox, oy, sx, sy );
				_context.restore();

			} else { // no texture

				setFillStyle( material.color.getStyle() );

				_context.save();
				_context.translate( v1.x, v1.y );
				if ( material.rotation !== 0 ) _context.rotate( material.rotation );
				_context.scale( scaleX, - scaleY );
				_context.fillRect( - 0.5, - 0.5, 1, 1 );
				_context.restore();

			}

		} else if ( material instanceof THREE.SpriteCanvasMaterial ) {

			setStrokeStyle( material.color.getStyle() );
			setFillStyle( material.color.getStyle() );

			_context.save();
			_context.translate( v1.x, v1.y );
			if ( material.rotation !== 0 ) _context.rotate( material.rotation );
			_context.scale( scaleX, scaleY );

			material.program( _context );

			_context.restore();

		}

		/* DEBUG
		setStrokeStyle( 'rgb(255,255,0)' );
		_context.beginPath();
		_context.moveTo( v1.x - 10, v1.y );
		_context.lineTo( v1.x + 10, v1.y );
		_context.moveTo( v1.x, v1.y - 10 );
		_context.lineTo( v1.x, v1.y + 10 );
		_context.stroke();
		*/

	}

	function renderLine( v1, v2, element, material ) {

		setOpacity( material.opacity );
		setBlending( material.blending );

		_context.beginPath();
		_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );
		_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );

		if ( material instanceof THREE.LineBasicMaterial ) {

			setLineWidth( material.linewidth );
			setLineCap( material.linecap );
			setLineJoin( material.linejoin );

			if ( material.vertexColors !== THREE.VertexColors ) {

				setStrokeStyle( material.color.getStyle() );

			} else {

				var colorStyle1 = element.vertexColors[0].getStyle();
				var colorStyle2 = element.vertexColors[1].getStyle();

				if ( colorStyle1 === colorStyle2 ) {

					setStrokeStyle( colorStyle1 );

				} else {

					try {

						var grad = _context.createLinearGradient(
							v1.positionScreen.x,
							v1.positionScreen.y,
							v2.positionScreen.x,
							v2.positionScreen.y
						);
						grad.addColorStop( 0, colorStyle1 );
						grad.addColorStop( 1, colorStyle2 );

					} catch ( exception ) {

						grad = colorStyle1;

					}

					setStrokeStyle( grad );

				}

			}

			_context.stroke();
			_elemBox.expandByScalar( material.linewidth * 2 );

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			setLineWidth( material.linewidth );
			setLineCap( material.linecap );
			setLineJoin( material.linejoin );
			setStrokeStyle( material.color.getStyle() );
			setDashAndGap( material.dashSize, material.gapSize );

			_context.stroke();

			_elemBox.expandByScalar( material.linewidth * 2 );

			setDashAndGap( null, null );

		}

	}

	function renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {

		_this.info.render.vertices += 3;
		_this.info.render.faces ++;

		setOpacity( material.opacity );
		setBlending( material.blending );

		_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
		_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
		_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;

		drawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );

		if ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshPhysicalMaterial ) && material.map === null ) {

			_diffuseColor.copy( material.color );
			_emissiveColor.copy( material.emissive );

			if ( material.vertexColors === THREE.FaceColors ) {

				_diffuseColor.multiply( element.color );

			}

			if ( material.wireframe === false && material.shading === THREE.SmoothShading && element.vertexNormalsLength === 3 ) {

				_color1.copy( _ambientLight );
				_color2.copy( _ambientLight );
				_color3.copy( _ambientLight );

				calculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );
				calculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );
				calculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );

				_color1.multiply( _diffuseColor ).add( _emissiveColor );
				_color2.multiply( _diffuseColor ).add( _emissiveColor );
				_color3.multiply( _diffuseColor ).add( _emissiveColor );
				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			} else {

				_color.copy( _ambientLight );

				calculateLight( element.centroidModel, element.normalModel, _color );

				_color.multiply( _diffuseColor ).add( _emissiveColor );

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			}

		} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {

			if ( material.map !== null ) {

				if ( material.map.mapping instanceof THREE.UVMapping ) {

					_uvs = element.uvs[ 0 ];
					patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );

				}


			} else if ( material.envMap !== null ) {

				if ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {

					_normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );
					_uv1x = 0.5 * _normal.x + 0.5;
					_uv1y = 0.5 * _normal.y + 0.5;

					_normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );
					_uv2x = 0.5 * _normal.x + 0.5;
					_uv2y = 0.5 * _normal.y + 0.5;

					_normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );
					_uv3x = 0.5 * _normal.x + 0.5;
					_uv3y = 0.5 * _normal.y + 0.5;

					patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );

				}/* else if ( material.envMap.mapping === THREE.SphericalRefractionMapping ) {



				}*/


			} else {

				_color.copy( material.color );

				if ( material.vertexColors === THREE.FaceColors ) {

					_color.multiply( element.color );

				}

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			}

		} else if ( material instanceof THREE.MeshDepthMaterial ) {

			_near = _camera.near;
			_far = _camera.far;

			_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );
			_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );
			_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );
			_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

			_image = getGradientTexture( _color1, _color2, _color3, _color4 );

			clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			if ( material.shading === THREE.FlatShading ) {

				_normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );

				_color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			} else if ( material.shading === THREE.SmoothShading ) {

				_normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );
				_color1.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				_normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );
				_color2.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				_normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );
				_color3.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			}

		}

	}

	//

	function drawTriangle( x0, y0, x1, y1, x2, y2 ) {

		_context.beginPath();
		_context.moveTo( x0, y0 );
		_context.lineTo( x1, y1 );
		_context.lineTo( x2, y2 );
		_context.closePath();

	}

	function strokePath( color, linewidth, linecap, linejoin ) {

		setLineWidth( linewidth );
		setLineCap( linecap );
		setLineJoin( linejoin );
		setStrokeStyle( color.getStyle() );

		_context.stroke();

		_elemBox.expandByScalar( linewidth * 2 );

	}

	function fillPath( color ) {

		setFillStyle( color.getStyle() );
		_context.fill();

	}

	function onTextureUpdate ( event ) {

		textureToPattern( event.target );

	}

	function textureToPattern( texture ) {

		var repeatX = texture.wrapS === THREE.RepeatWrapping;
		var repeatY = texture.wrapT === THREE.RepeatWrapping;

		var image = texture.image;

		var canvas = document.createElement( 'canvas' );
		canvas.width = image.width;
		canvas.height = image.height;

		var context = canvas.getContext( '2d' );
		context.setTransform( 1, 0, 0, - 1, 0, image.height );
		context.drawImage( image, 0, 0 );

		_patterns[ texture.id ] = _context.createPattern(
			canvas, repeatX === true && repeatY === true
				? 'repeat'
				: repeatX === true && repeatY === false
					? 'repeat-x'
					: repeatX === false && repeatY === true
						? 'repeat-y'
						: 'no-repeat'
		);

	}

	function patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {

		if ( texture instanceof THREE.DataTexture ) return;

		if ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {

			if ( texture.image !== undefined && texture.image.width > 0 ) {

				textureToPattern( texture );

			}

			texture.addEventListener( 'update', onTextureUpdate );

		}

		var pattern = _patterns[ texture.id ];

		if ( pattern !== undefined ) {

			setFillStyle( pattern );

		} else {

			setFillStyle( 'rgba(0,0,0,1)' );
			_context.fill();

			return;

		}	

		// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

		var a, b, c, d, e, f, det, idet,
		offsetX = texture.offset.x / texture.repeat.x,
		offsetY = texture.offset.y / texture.repeat.y,
		width = texture.image.width * texture.repeat.x,
		height = texture.image.height * texture.repeat.y;

		u0 = ( u0 + offsetX ) * width;
		v0 = ( v0 + offsetY ) * height;

		u1 = ( u1 + offsetX ) * width;
		v1 = ( v1 + offsetY ) * height;

		u2 = ( u2 + offsetX ) * width;
		v2 = ( v2 + offsetY ) * height;

		x1 -= x0; y1 -= y0;
		x2 -= x0; y2 -= y0;

		u1 -= u0; v1 -= v0;
		u2 -= u0; v2 -= v0;

		det = u1 * v2 - u2 * v1;

		if ( det === 0 ) return;

		idet = 1 / det;

		a = ( v2 * x1 - v1 * x2 ) * idet;
		b = ( v2 * y1 - v1 * y2 ) * idet;
		c = ( u1 * x2 - u2 * x1 ) * idet;
		d = ( u1 * y2 - u2 * y1 ) * idet;

		e = x0 - a * u0 - c * v0;
		f = y0 - b * u0 - d * v0;

		_context.save();
		_context.transform( a, b, c, d, e, f );
		_context.fill();
		_context.restore();

	}

	function clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {

		// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

		var a, b, c, d, e, f, det, idet,
		width = image.width - 1,
		height = image.height - 1;

		u0 *= width; v0 *= height;
		u1 *= width; v1 *= height;
		u2 *= width; v2 *= height;

		x1 -= x0; y1 -= y0;
		x2 -= x0; y2 -= y0;

		u1 -= u0; v1 -= v0;
		u2 -= u0; v2 -= v0;

		det = u1 * v2 - u2 * v1;

		idet = 1 / det;

		a = ( v2 * x1 - v1 * x2 ) * idet;
		b = ( v2 * y1 - v1 * y2 ) * idet;
		c = ( u1 * x2 - u2 * x1 ) * idet;
		d = ( u1 * y2 - u2 * y1 ) * idet;

		e = x0 - a * u0 - c * v0;
		f = y0 - b * u0 - d * v0;

		_context.save();
		_context.transform( a, b, c, d, e, f );
		_context.clip();
		_context.drawImage( image, 0, 0 );
		_context.restore();

	}

	function getGradientTexture( color1, color2, color3, color4 ) {

		// http://mrdoob.com/blog/post/710

		_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;
		_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;
		_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;

		_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;
		_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;
		_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;

		_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;
		_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;
		_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;

		_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;
		_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;
		_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;

		_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );
		_gradientMapContext.drawImage( _pixelMap, 0, 0 );

		return _gradientMap;

	}

	// Hide anti-alias gaps

	function expand( v1, v2, pixels ) {

		var x = v2.x - v1.x, y = v2.y - v1.y,
		det = x * x + y * y, idet;

		if ( det === 0 ) return;

		idet = pixels / Math.sqrt( det );

		x *= idet; y *= idet;

		v2.x += x; v2.y += y;
		v1.x -= x; v1.y -= y;

	}

	// Context cached methods.

	function setOpacity( value ) {

		if ( _contextGlobalAlpha !== value ) {

			_context.globalAlpha = value;
			_contextGlobalAlpha = value;

		}

	}

	function setBlending( value ) {

		if ( _contextGlobalCompositeOperation !== value ) {

			if ( value === THREE.NormalBlending ) {

				_context.globalCompositeOperation = 'source-over';

			} else if ( value === THREE.AdditiveBlending ) {

				_context.globalCompositeOperation = 'lighter';

			} else if ( value === THREE.SubtractiveBlending ) {

				_context.globalCompositeOperation = 'darker';

			}

			_contextGlobalCompositeOperation = value;

		}

	}

	function setLineWidth( value ) {

		if ( _contextLineWidth !== value ) {

			_context.lineWidth = value;
			_contextLineWidth = value;

		}

	}

	function setLineCap( value ) {

		// "butt", "round", "square"

		if ( _contextLineCap !== value ) {

			_context.lineCap = value;
			_contextLineCap = value;

		}

	}

	function setLineJoin( value ) {

		// "round", "bevel", "miter"

		if ( _contextLineJoin !== value ) {

			_context.lineJoin = value;
			_contextLineJoin = value;

		}

	}

	function setStrokeStyle( value ) {

		if ( _contextStrokeStyle !== value ) {

			_context.strokeStyle = value;
			_contextStrokeStyle = value;

		}

	}

	function setFillStyle( value ) {

		if ( _contextFillStyle !== value ) {

			_context.fillStyle = value;
			_contextFillStyle = value;

		}

	}

	function setDashAndGap( dashSizeValue, gapSizeValue ) {

		if ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {

			_context.setLineDash( [ dashSizeValue, gapSizeValue ] );
			_contextDashSize = dashSizeValue;
			_contextGapSize = gapSizeValue;

		}

	}

};

/**
 * Shader chunks for WebLG Shader library
 * 
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author bhouston / http://clara.io/ 
 */

THREE.ShaderChunk = {

	// FOG

	common: [

		"#define PI 3.14159",
		"#define PI2 6.28318",
		"#define LOG2 1.442695",
		"float square( in float a ) { return a*a; }",
		"vec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }",
		"vec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }",
		"vec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }",
		"float saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }",
		"vec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }",
		"vec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }",
		"vec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }",
		"float average( in float a ) { return a; }",
		"float average( in vec2 a )  { return ( a.x + a.y) * 0.5; }",
		"float average( in vec3 a )  { return ( a.x + a.y + a.z) * 0.3333333333; }",
		"float average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }",
		"float whiteCompliment( in float a ) { return saturate( 1.0 - a ); }",
		"vec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }",
		"vec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }",
		"vec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }",
		"vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {",
    		"float distance = dot( planeNormal, point-pointOnPlane );",
    		"return point - distance * planeNormal;",
		"}",
		"float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {",
   			"return sign( dot( point - pointOnPlane, planeNormal ) );",
		"}",
		"vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {",
   			"return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );",
		"}",
	].join("\n"),

	// FOG

	fog_pars_fragment: [

		"#ifdef USE_FOG",

			"uniform vec3 fogColor;",

			"#ifdef FOG_EXP2",

				"uniform float fogDensity;",

			"#else",

				"uniform float fogNear;",
				"uniform float fogFar;",

			"#endif",

		"#endif"

	].join("\n"),

	fog_fragment: [

		"#ifdef USE_FOG",

			"float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"#ifdef FOG_EXP2",

				"float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );",
				"fogFactor = 1.0 - saturate( fogFactor );",

			"#else",

				"float fogFactor = smoothstep( fogNear, fogFar, depth );",

			"#endif",

			"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

		"#endif"

	].join("\n"),

	// ENVIRONMENT MAP

	envmap_pars_fragment: [

		"#if defined( USE_ENVMAP )",

			"uniform float reflectivity;",

		"#endif",

		"#ifdef USE_ENVMAP",

			"uniform samplerCube envMap;",
			"uniform float flipEnvMap;",
			"uniform int combine;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"uniform bool useRefract;",
				"uniform float refractionRatio;",

			"#else",

				"varying vec3 vReflect;",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_fragment: [

		"#ifdef USE_ENVMAP",

			"vec3 reflectVec;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"if ( useRefract ) {",

					// viewPosition may inverted
					"reflectVec = refract( viewPosition, normal, refractionRatio );",

				"} else { ",

					"reflectVec = reflect( viewPosition, normal );",

				"}",

			"#else",

				"reflectVec = vReflect;",

			"#endif",

			"#ifdef DOUBLE_SIDED",

				"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
				"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#else",

				"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#endif",

			"#ifdef GAMMA_INPUT",

				"cubeColor.xyz *= cubeColor.xyz;",

			"#endif",

			"float fresnelReflectivity = saturate( reflectivity );",

			"#if defined( PHYSICAL )",

				// this uses reflectivityStrength because with physical we allow it to vary.
				"{",

					// diffuse			
					"float nDotL = saturate( dot( normal, viewPosition ) );",
			
				    "float fresnel = Fresnel_Schlick(reflectivityStrength, normal, viewPosition.xyz );",

	    			// fresnel becomes white at perpendicular angles
					"vec3 fresnelColor = mix( specular, diffuseColor, metallicStrength );",
				    "fresnelColor = mix( fresnelColor, vec3( 1.0 ), (fresnel - reflectivityStrength) );",
	    	
				    // Put it all together
				    "vec3 specularColorCoefficient = fresnel * fresnelColor;",

					"gl_FragColor.xyz += specularColorCoefficient * cubeColor.xyz * nDotL;",

				"}",

			"#else",			

				"if ( combine == 1 ) {",

					"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, fresnelReflectivity );",

				"} else if ( combine == 2 ) {",

					"gl_FragColor.xyz += cubeColor.xyz * fresnelReflectivity;",

				"} else {",

					"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, fresnelReflectivity );",

				"}",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_pars_vertex: [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"varying vec3 vReflect;",

			"uniform float refractionRatio;",
			"uniform bool useRefract;",

		"#endif"

	].join("\n"),

	worldpos_vertex : [

		"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",

			"#ifdef USE_SKINNING",

				"vec4 worldPosition = modelMatrix * skinned;",

			"#endif",

			"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",

			"#endif",

			"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_vertex : [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
			"worldNormal = normalize( worldNormal );",

			"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",

			"if ( useRefract ) {",

				"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",

			"} else {",

				"vReflect = reflect( cameraToVertex, worldNormal );",

			"}",

		"#endif"

	].join("\n"),

	// COLOR MAP (particles)

	map_particle_pars_fragment: [

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),


	map_particle_fragment: [

		"#ifdef USE_MAP",

			"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );",

		"#endif"

	].join("\n"),

	// COLOR MAP (triangles)

	map_pars_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )",

			"varying vec2 vUv;",
			"uniform vec4 offsetRepeat;",

		"#endif"

	].join("\n"),

	map_pars_fragment: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )",

			"varying vec2 vUv;",
			"uniform vec4 gainBrightness;",


			"vec4 applyGainBrightness( vec4 texel, vec4 gainBrightnessCoeff ) {",

				"texel.xyz = ( texel.xyz - vec3( gainBrightnessCoeff.x ) ) * gainBrightnessCoeff.y + vec3( gainBrightnessCoeff.z + gainBrightnessCoeff.x );",

				"return texel;",

			"}",		


		"#endif",

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),

	map_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )",

			"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",

		"#endif"

	].join("\n"),

	map_fragment: [

		"#ifdef USE_MAP",

			"vec4 texelColor = applyGainBrightness( texture2D( map, vUv ), gainBrightness );",		

			"#ifdef GAMMA_INPUT",

				"texelColor.xyz *= texelColor.xyz;",

			"#endif",

			"gl_FragColor = gl_FragColor * texelColor;",

			"#if defined( PHYSICAL ) || defined( PHONG )",

				"diffuseColor *= texelColor.xyz;",

			"#endif", // PHYSICAL

		"#endif"

	].join("\n"),

	// FALLOFF MAP

	falloffmap_pars_fragment: [

		"#ifdef USE_FALLOFFMAP",

			"uniform sampler2D falloffMap;",

		"#endif"

	].join("\n"),

	// OPACITY MAP

	opacitymap_pars_vertex: [

		"#ifdef USE_OPACITYMAP",

			"varying vec2 vOpacityUv;",
			"uniform vec4 opacityOffsetRepeat;",

		"#endif"

	].join("\n"),

	opacitymap_vertex: [

		"#ifdef USE_OPACITYMAP",

			"vOpacityUv = uv * opacityOffsetRepeat.zw + opacityOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	opacitymap_pars_fragment: [

		"#ifdef USE_OPACITYMAP",

			"uniform sampler2D opacityMap;",
			"varying vec2 vOpacityUv;",
			"uniform vec4 opacityGainBrightness;",

		"#endif"

	].join("\n"),


	opacitymap_fragment: [

		"#ifdef USE_OPACITYMAP",

			"vec4 texelOpacity = applyGainBrightness( texture2D( opacityMap, vOpacityUv ), opacityGainBrightness );",

			"gl_FragColor.w = gl_FragColor.w * texelOpacity.r;",

		"#endif"

	].join("\n"),

	// TRANSLUCENCY MAP

	translucencymap_pars_vertex: [

		"#ifdef USE_TRANSLUCENCYMAP",

			"varying vec2 vTranslucencyUv;",
			"uniform vec4 translucencyOffsetRepeat;",

		"#endif"

	].join("\n"),

	translucencymap_vertex: [

		"#ifdef USE_TRANSLUCENCYMAP",

			"vTranslucencyUv = uv * translucencyOffsetRepeat.zw + translucencyOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	translucencymap_pars_fragment: [

		"#ifdef USE_TRANSLUCENCYMAP",

			"uniform sampler2D translucencyMap;",
			"varying vec2 vTranslucencyUv;",
			"uniform vec4 translucencyGainBrightness;",

		"#endif"

	].join("\n"),

	translucencymap_fragment: [

		"#ifdef USE_TRANSLUCENCYMAP",

			"vec4 texelTranslucency = applyGainBrightness( texture2D( translucencyMap, vTranslucencyUv ), translucencyGainBrightness );",

			"#ifdef GAMMA_INPUT",

				"texelTranslucency.xyz *= texelTranslucency.xyz;",

			"#endif",

			"translucencyColor.xyz *= texelTranslucency.xyz;",

		"#endif"

	].join("\n"),

	// LIGHT MAP

	lightmap_pars_fragment: [

		"#if defined( USE_LIGHTMAP ) || defined( USE_EMISSIVEMAP )",

			"varying vec2 vUv2;",

		"#endif",

		"#if defined( USE_LIGHTMAP )",

			"uniform sampler2D lightMap;",

		"#endif",

		"#if defined( USE_EMISSIVEMAP )",

			"uniform sampler2D emissiveMap;",

		"#endif"

	].join("\n"),

	lightmap_pars_vertex: [

		"#if defined( USE_LIGHTMAP ) || defined( USE_EMISSIVEMAP )",

			"varying vec2 vUv2;",

		"#endif"

	].join("\n"),

	lightmap_fragment: [

		"#ifdef USE_LIGHTMAP",

			//"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );",

		"#endif"

	].join("\n"),

	lightmap_vertex: [

		"#if defined( USE_LIGHTMAP ) || defined( USE_EMISSIVEMAP )",

			"vUv2 = uv2;",

		"#endif"

	].join("\n"),


	// BUMP MAP

	bumpmap_pars_vertex: [

		"#ifdef USE_BUMPMAP",

			"varying vec2 vBumpUv;",
			"uniform vec4 bumpOffsetRepeat;",

		"#endif"

	].join("\n"),

	bumpmap_vertex: [

		"#ifdef USE_BUMPMAP",

			"vBumpUv = uv * bumpOffsetRepeat.zw + bumpOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	bumpmap_pars_fragment: [

		"#ifdef USE_BUMPMAP",

			"uniform sampler2D bumpMap;",
			"uniform float bumpScale;",
			"varying vec2 vBumpUv;",
	
			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html

			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

			"vec2 dHdxy_fwd() {",

				"vec2 dSTdx = dFdx( vBumpUv );",
				"vec2 dSTdy = dFdy( vBumpUv );",

				"float Hll = bumpScale * texture2D( bumpMap, vBumpUv ).x;",
				"float dBx = bumpScale * texture2D( bumpMap, vBumpUv + dSTdx ).x - Hll;",
				"float dBy = bumpScale * texture2D( bumpMap, vBumpUv + dSTdy ).x - Hll;",

				"return vec2( dBx, dBy );",

			"}",

			"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",

				"vec3 vSigmaX = dFdx( surf_pos );",
				"vec3 vSigmaY = dFdy( surf_pos );",
				"vec3 vN = surf_norm;",		// normalized

				"vec3 R1 = cross( vSigmaY, vN );",
				"vec3 R2 = cross( vN, vSigmaX );",

				"float fDet = dot( vSigmaX, R1 );",

				"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
				"return normalize( abs( fDet ) * surf_norm - vGrad );",

			"}",

		"#endif"

	].join("\n"),

	// LIGHT ATTENUATION function

	lightattenuation_func_fragment: [

		"float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {",
			"float distanceAttenuation = 1.0 / pow( lightDistance, decayExponent );",
			"if ( cutoffDistance > 0.0 ) {",
				"distanceAttenuation *= 1.0 - min( lightDistance / cutoffDistance, 1.0 );",
			"}",
			"return distanceAttenuation;",
		"}"

	].join("\n"),

	// NORMAL MAP

	normalmap_pars_vertex: [

		"#ifdef USE_NORMALMAP",

			"varying vec2 vNormalUv;",
			"uniform vec4 normalOffsetRepeat;",

		"#endif"

	].join("\n"),

	normalmap_vertex: [

		"#ifdef USE_NORMALMAP",

			"vNormalUv = uv * normalOffsetRepeat.zw + normalOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	normalmap_pars_fragment: [

		"#ifdef USE_NORMALMAP",

			"uniform sampler2D normalMap;",
			"varying vec2 vNormalUv;",
			"uniform vec2 normalScale;",

			// Per-Pixel Tangent Space Normal Mapping
			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

			"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",

				"vec3 q0 = dFdx( eye_pos.xyz );",
				"vec3 q1 = dFdy( eye_pos.xyz );",
				"vec2 st0 = dFdx( vNormalUv.st );",
				"vec2 st1 = dFdy( vNormalUv.st );",

				"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
				"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
				"vec3 N = normalize( surf_norm );",

				"vec3 mapN = texture2D( normalMap, vNormalUv ).xyz * 2.0 - 1.0;",
				"mapN.xy = normalScale * mapN.xy;",
				"mat3 tsn = mat3( S, T, N );",
				"return normalize( tsn * mapN );",

			"}",

		"#endif"

	].join("\n"),

	// ANISOTROPY MAP

	anisotropymap_pars_vertex: [

		"#ifdef USE_ANISOTROPYMAP",

			"varying vec2 vAnisotropyUv;",
			"uniform vec4 anisotropyOffsetRepeat;",

		"#else",

			"#ifdef ANISOTROPY",

				"varying vec2 vAnisotropyUv;",

			"#endif",

		"#endif"
	].join("\n"),

	anisotropymap_vertex: [

		"#ifdef USE_ANISOTROPYMAP",

			"vAnisotropyUv = uv * anisotropyOffsetRepeat.zw + anisotropyOffsetRepeat.xy;",

		"#else",

			"#ifdef ANISOTROPY",

				"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_REFLECTIVITYMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALLICMAP ) || defined( USE_OPACITYMAP ) || defined( USE_FALLOFFMAP ) || defined( USE_TRANSLUCENCYMAP ) || defined( USE_ANISOTROPYMAP ) || defined( USE_ANISOTROPYROTATIONMAP )",

					"vAnisotropyUv = vUv;",

				"#else",

					"vAnisotropyUv = vec2( 0, 0 );",

				"#endif",

			"#endif",

		"#endif"

	].join("\n"),


	anisotropymap_pars_fragment: [

		"#ifdef USE_ANISOTROPYMAP",

			"uniform sampler2D anisotropyMap;",
			"uniform vec4 anisotropyGainBrightness;",
			"varying vec2 vAnisotropyUv;",

		"#else",

			"#ifdef ANISOTROPY",

				"varying vec2 vAnisotropyUv;",

			"#endif",

		"#endif"
	].join("\n"),

	anisotropymap_fragment: [

		"float anisotropyStrength = anisotropy;",

		"#ifdef USE_ANISOTROPYMAP",

			"vec4 texelAnisotropy = applyGainBrightness( texture2D( anisotropyMap, vAnisotropyUv ), anisotropyGainBrightness );",
			"anisotropyStrength += texelAnisotropy.r;",

		"#endif"

	].join("\n"),

	// ANISOTROPY ROTATION MAP

	anisotropyrotationmap_pars_vertex: [

		"#ifdef USE_ANISOTROPYROTATIONMAP",

			"varying vec2 vAnisotropyRotationUv;",
			"uniform vec4 anisotropyRotationOffsetRepeat;",

		"#endif"

	].join("\n"),

	anisotropyrotationmap_vertex: [

		"#ifdef USE_ANISOTROPYROTATIONMAP",

			"vAnisotropyRotationUv = uv * anisotropyRotationOffsetRepeat.zw + anisotropyRotationOffsetRepeat.xy;",

		"#endif"

	].join("\n"),


	anisotropyrotationmap_pars_fragment: [

		"#ifdef USE_ANISOTROPYROTATIONMAP",

			"uniform sampler2D anisotropyRotationMap;",
			"uniform vec4 anisotropyRotationGainBrightness;",
			"varying vec2 vAnisotropyRotationUv;",

		"#endif"

	].join("\n"),

	anisotropyrotationmap_fragment: [

		"float anisotropyRotationStrength = anisotropyRotation;",

		"#ifdef USE_ANISOTROPYROTATIONMAP",

			"vec4 texelAnisotropyRotation = applyGainBrightness( texture2D( anisotropyRotationMap, vAnisotropyRotationUv ), anisotropyRotationGainBrightness );",
			"anisotropyRotationStrength += texelAnisotropyRotation.r;",

		"#endif"

	].join("\n"),

	// METALLIC MAP

	metallicmap_pars_vertex: [

		"#ifdef USE_METALLICMAP",

			"varying vec2 vMetallicUv;",
			"uniform vec4 metallicOffsetRepeat;",

		"#endif"

	].join("\n"),

	metallicmap_vertex: [

		"#ifdef USE_METALLICMAP",

			"vMetallicUv = uv * metallicOffsetRepeat.zw + metallicOffsetRepeat.xy;",

		"#endif"

	].join("\n"),


	metallicmap_pars_fragment: [

		"#ifdef USE_METALLICMAP",

			"uniform sampler2D metallicMap;",
			"uniform vec4 metallicGainBrightness;",
			"varying vec2 vMetallicUv;",

		"#endif"

	].join("\n"),

	metallicmap_fragment: [

		"float metallicStrength = metallic;",

		"#ifdef USE_METALLICMAP",

			"vec4 texelMetallic = applyGainBrightness( texture2D( metallicMap, vMetallicUv ), metallicGainBrightness );",
			"metallicStrength += texelMetallic.r;",

		"#endif"

	].join("\n"),

	// ROUGHNESS MAP

	roughnessmap_pars_vertex: [

		"#ifdef USE_ROUGHNESSMAP",

			"varying vec2 vRoughnessUv;",
			"uniform vec4 roughnessOffsetRepeat;",

		"#endif"

	].join("\n"),

	roughnessmap_vertex: [

		"#ifdef USE_ROUGHNESSMAP",

			"vRoughnessUv = uv * roughnessOffsetRepeat.zw + roughnessOffsetRepeat.xy;",

		"#endif"

	].join("\n"),


	roughnessmap_pars_fragment: [

		"#ifdef USE_ROUGHNESSMAP",

			"uniform sampler2D roughnessMap;",
			"varying vec2 vRoughnessUv;",
			"uniform vec4 roughnessGainBrightness;",

		"#endif"

	].join("\n"),

	roughnessmap_fragment: [

		"float roughnessStrength = roughness;",

		"#ifdef USE_ROUGHNESSMAP",

			"vec4 texelRoughness = applyGainBrightness( texture2D( roughnessMap, vRoughnessUv ), roughnessGainBrightness );",
			"roughnessStrength *= texelRoughness.r;",

		"#endif"

	].join("\n"),

	// SPECULAR MAP

	specularmap_pars_vertex: [

		"#ifdef USE_SPECULARMAP",

			"varying vec2 vSpecularUv;",
			"uniform vec4 specularOffsetRepeat;",

		"#endif"

	].join("\n"),

	specularmap_vertex: [

		"#ifdef USE_SPECULARMAP",

			"vSpecularUv = uv * specularOffsetRepeat.zw + specularOffsetRepeat.xy;",

		"#endif"

	].join("\n"),

	specularmap_pars_fragment: [

		"#ifdef USE_SPECULARMAP",

			"uniform sampler2D specularMap;",
			"uniform vec4 specularGainBrightness;",
			"varying vec2 vSpecularUv;",
	
		"#endif"

	].join("\n"),

	specularmap_fragment: [

		"float specularStrength;",

		"#ifdef USE_SPECULARMAP",

			"vec4 texelSpecular = applyGainBrightness( texture2D( specularMap, vUv ), specularGainBrightness );",
			"specularStrength = texelSpecular.r;",

		"#else",

			"specularStrength = 1.0;",

		"#endif"

	].join("\n"),

	// LIGHTS LAMBERT

	lights_lambert_pars_vertex: [

		"uniform vec3 ambient;",
		"uniform vec3 diffuse;",
		"uniform vec3 emissive;",

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDecayExponent[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDecayExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightWidth[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightHeight[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDistance[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDecayExponent[ MAX_AREA_LIGHTS ];",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif"

	].join("\n"),

	lights_lambert_vertex: [

		"vLightFront = vec3( 0.0 );",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vec3( 0.0 );",

		"#endif",

		"transformedNormal = normalize( transformedNormal );",

		"#if MAX_DIR_LIGHTS > 0",

		"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

			"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"vec3 dirVector = normalize( lDirection.xyz );",

			"float dotProduct = dot( transformedNormal, dirVector );",
			"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",

			"#ifdef DOUBLE_SIDED",

				"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

				"#ifdef WRAP_AROUND",

					"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

				"#endif",

			"#endif",

			"#ifdef WRAP_AROUND",

				"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
				"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",

				"#ifdef DOUBLE_SIDED",

					"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",

				"#endif",

			"#endif",

			"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",

			"#ifdef DOUBLE_SIDED",

				"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",

			"#endif",

		"}",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecayExponent[i] );",

				"lVector = normalize( lVector );",
				"float dotProduct = dot( transformedNormal, lVector );",

				"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",

				"#ifdef DOUBLE_SIDED",

					"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

					"#ifdef WRAP_AROUND",

						"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

					"#endif",

				"#endif",

				"#ifdef WRAP_AROUND",

					"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
					"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",

					"#ifdef DOUBLE_SIDED",

						"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",

					"#endif",

				"#endif",

				"vLightFront += pointLightColor[ i ] * pointLightWeighting * distanceAttenuation;",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * distanceAttenuation;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecayExponent[i] );",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
				
					"lVector = normalize( lVector );",

					"float dotProduct = dot( transformedNormal, lVector );",
					"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",

					"#ifdef DOUBLE_SIDED",

						"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

						"#ifdef WRAP_AROUND",

							"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

						"#endif",

					"#endif",

					"#ifdef WRAP_AROUND",

						"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
						"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",

						"#ifdef DOUBLE_SIDED",

							"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",

						"#endif",

					"#endif",

					"vLightFront += spotLightColor[ i ] * spotLightWeighting * distanceAttenuation * spotEffect;",

					"#ifdef DOUBLE_SIDED",

						"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * distanceAttenuation * spotEffect;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				"float dotProduct = dot( transformedNormal, lVector );",

				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
				"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",

				"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",

				"#endif",

			"}",

		"#endif",

		"vLightFront = ( vLightFront + ambientLightColor + ambient) * diffuse + emissive;",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = ( vLightFront + ambientLightColor + ambient) * diffuse + emissive;",

		"#endif"

	].join("\n"),

	// LIGHTS PHYSICAL

	lights_physical_pars_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )",

			"varying vec3 vWorldPosition;",

		"#endif"

	].join("\n"),


	lights_physical_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )",

			"vWorldPosition = worldPosition.xyz;",

		"#endif",

		"#ifdef USE_SKINNING",

			"vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

			"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
			"vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

		"#else",

			"vNormal = normalize( normalMatrix * normal );",
			"vTangent = normalize( normalMatrix * tangent.xyz );",

		"#endif",

		"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",


	].join("\n"),

	lights_physical_pars_fragment: [

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDecayExponent[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDecayExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightWidth[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightHeight[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDistance[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDecayExponent[ MAX_AREA_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif",

		"varying vec3 vViewPosition;",
		"varying vec3 vTangent;",
		"varying vec3 vBinormal;",
		"varying vec3 vNormal;",

		// classic Fresnel Schlick
		"float Fresnel_Schlick( float hDotV ) {",
			"float F0 = 0.04;",
			"return F0 + ( 1.0 - F0 ) * pow( 1.0 - hDotV, 5.0 );",
		"}",

		// Calcuate the Fresnel term using the Schlick approximation (using Unreal's blend to white method)  VALIDATED
		"vec3 Fresnel_Schlick_SpecularBlendToWhite(vec3 specularColor, float hDotV) {",
			"float Fc = pow(1.0 - hDotV, 5.0);",
    		"return saturate( 50.0 * average( specularColor ) ) * Fc + (1.0 - Fc) * specularColor;",
		"}",

	    // Calculate the distribution term  VALIDATED
		"float Distribution_GGX( float roughness2, float nDotH ) {",
			"float denom = nDotH * nDotH * (roughness2 - 1.0) + 1.0;",
    		"return roughness2 / ( PI * square( denom ) );",
		"}",

		// Calculated the anisotropic GGZ distrubtion term     VALIDATED
		"float Distribution_GGXAniso( vec2 anisotropicM, vec2 xyDotH, float nDotH ) {",
    		"float anisoTerm = ( xyDotH.x * xyDotH.x / ( anisotropicM.x * anisotropicM.x ) + xyDotH.y * xyDotH.y / ( anisotropicM.y * anisotropicM.y ) + nDotH * nDotH );",
    		"return 1.0 / ( PI * anisotropicM.x * anisotropicM.y * anisoTerm * anisoTerm );",
		"}",

		// useful for clear coat surfaces, use with Distribution_GGX.
		"float Visibility_Kelemen( float vDotH ) {",
			"return 1.0 / ( 4.0 * vDotH * vDotH );",
		"}",

		"float Visibility_Schlick(in float roughness2, in float nDotL, in float nDotV) {",
    		"float termL = (nDotL + sqrt(roughness2 + (1.0 - roughness2) * nDotL * nDotL));",
    		"float termV = (nDotV + sqrt(roughness2 + (1.0 - roughness2) * nDotV * nDotV));",
    		"return 1.0 / ( termL * termV );",
		"}",

		"float Diffuse_Lambert() {",
    		"return 1.0 / PI;",
		"}",

		"float Diffuse_OrenNayer(in float m2, in float nDotV, in float nDotL, in float vDotH ) {",
			"float termA = 1.0 - 0.5 * m2 / (m2 + 0.33);",
			"float Cosri = 2.0 * vDotH - 1.0 - nDotV * nDotL;",
			"float termB = 0.45 * m2 / (m2 + 0.09) * Cosri * ( Cosri >= 0.0 ? min( 1.0, nDotL / nDotV ) : nDotL );",
			"return 1.0 / PI * ( nDotL * termA + termB );",
		"}",

		// Helper for anisotropy rotation
		"mat2 createRotationMat2(in float rads) {",
			"float cos_rads = cos( rads );",
			"float sin_rads = sin( rads );",
    		"return mat2( vec2( cos_rads, sin_rads ), vec2( -sin_rads, cos_rads ) );",
		"}",

		// Helper for anisotropy rotation
		"vec2 calcAnisotropyUV(in float anisotropyLocal) {",
			"float oneMinusAbsAnisotropy = 1.0 - min( abs( anisotropyLocal ) * 0.9, 0.9 );",
			"vec2 anisotropyUV = vec2 ( 1.0 / oneMinusAbsAnisotropy, oneMinusAbsAnisotropy );",
			"if( anisotropy < 0.0 ) {",
				"anisotropyUV.xy = anisotropyUV.yx;", // swizzel
			"}",
    		"return anisotropyUV;",
		"}"


	].join("\n"),

	lights_physical_fragment: [

		"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normal );",

		"#ifdef USE_NORMALMAP",

			"normal = perturbNormal2Arb( -vViewPosition, normal );",

			/*"vec3 normalTex = texture2D( normalMap, vNormalUv ).xyz * 2.0 - 1.0;",
			"normalTex.xy *= normalScale;",
			"normalTex = perturbNormal2Arb( -ViewPosition, normal );",
			
			"normal = tsb * normalTex;",*/

		"#elif defined( USE_BUMPMAP )",

			"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",

		"#endif",

		"#ifdef DOUBLE_SIDED",

			"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

		"#endif",

		"#ifdef FALLOFF",

			"vec3 modulatedFalloffColor = falloffColor;",
			
			"#ifdef USE_FALLOFFMAP",

				"vec4 falloffTexelColor = texture2D( falloffMap, vUv );",

				"#ifdef GAMMA_INPUT",

					"falloffTexelColor.xyz *= falloffTexelColor.xyz;",

				"#endif",

				"modulatedFalloffColor = modulatedFalloffColor * falloffTexelColor.xyz;",

			"#endif",

			"float fm = abs( dot( normal, viewPosition ) );",

			// this is a hack, it needs to be fixed.
			"fm = /*falloffBlendParams.x * fm + falloffBlendParams.y * */ ( fm * fm * ( 3.0 - 2.0 * fm ) );",

			"diffuseColor = mix( modulatedFalloffColor, diffuseColor, fm );",

		"#endif",

		"float nDotV = saturate( dot( normal, viewPosition ) );",
		"float m2 = pow( clamp( roughnessStrength, 0.01, 1.0 ), 4.0 );",
		// specular is scaled by 0.08 per Disney PBR recommendations.
		"vec3 specularColor = mix( specular, diffuseColor, metallicStrength );",
		"float m2ClearCoat = pow( clamp( clearCoatRoughness, 0.01, 1.0 ), 4.0 );",
		"diffuseColor = mix( diffuseColor, vec3(0), metallicStrength );",

		"#ifdef ANISOTROPY",

			"vec2 anisotropicM = calcAnisotropyUV( anisotropyStrength ) * sqrt( m2 );",

			"#ifdef ANISOTROPYROTATION",
				"mat2 anisotropicRotationMatrix = createRotationMat2( anisotropyRotationStrength * 2.0 * PI );",
    		"#endif",
			
			"vec3 anisotropicS = tsb[1];",	// binormal in eye space.
			"vec3 anisotropicT = tsb[0];",	// tangent in eye space.

		"#endif",

		"vec3 totalLighting  = vec3( 0.0 );",

		"#if MAX_POINT_LIGHTS > 0",

			"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecayExponent[i] );",

				"vec3 incidentLight = pointLightColor[ i ] * distanceAttenuation;",

				"lVector = normalize( lVector );",

				// diffuse
		
				"vec3 hVector = normalize( viewPosition.xyz + lVector.xyz );",
				"float nDotH = saturate( dot( normal, hVector ) );",
				"float nDotL = saturate( dot( normal, lVector ) );",
				"float hDotV = saturate( dot( hVector, viewPosition ) );",

				"#ifdef CLEARCOAT",

					"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );",
					"float visClearCoat = Visibility_Kelemen( hDotV );",
					"float fresnelClearCoat = Fresnel_Schlick( hDotV );",
					"vec3 specClearCoat = vec3( 1.0 ) * ( dClearCoat * visClearCoat * fresnelClearCoat );",

				"#endif",

				"#ifdef ANISOTROPY",

					"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );",

					"#ifdef ANISOTROPYROTATION",
	    				"xyDotH = anisotropicRotationMatrix * xyDotH;",
		    		"#endif",
	
					"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );",

				"#else",

				    "float d = Distribution_GGX( m2, nDotH );",

				"#endif",

				"float vis = Visibility_Schlick(m2, nDotL, nDotV);",
			    "vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor * 0.18, hDotV );",
     	
			    // Put it all together
			    "vec3 spec = d * vis * fresnelColor;",
			    "vec3 diff = Diffuse_Lambert() * diffuseColor;",

				"#ifdef TRANSLUCENCY",

				    "diff *= whiteCompliment( translucencyColor.xyz );",

				"#endif",

			    "vec3 shadingResult = spec + diff;",

			    "#ifdef CLEARCOAT",

					"shadingResult = mix( shadingResult, specClearCoat, clearCoat );",

				"#endif",	
							    // diffuse
				"totalLighting  += incidentLight * nDotL * shadingResult;",

				"#ifdef TRANSLUCENCY",

					"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );",

					"float viewNormalTL = mix( 1.0, pow( abs( dot( viewPosition.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );",

					"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
				
				"float distanceAttenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecayExponent[i] );",
				
				"vec3 incidentLight = spotLightColor[ i ] * distanceAttenuation;",
			
				"lVector = normalize( lVector );",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					// diffuse

					"incidentLight *= spotEffect;",		
			
					"vec3 hVector = normalize( viewPosition.xyz + lVector.xyz );",
					"float nDotH = saturate( dot( normal, hVector ) );",
					"float nDotL = saturate( dot( normal, lVector ) );",
					"float hDotV = saturate( dot( hVector, viewPosition ) );",

					"#ifdef CLEARCOAT",

						"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );",
						"float visClearCoat = Visibility_Kelemen( hDotV );",
						"float fresnelClearCoat = Fresnel_Schlick( hDotV );",
						"vec3 specClearCoat = vec3( 1.0 ) * ( dClearCoat * visClearCoat * fresnelClearCoat );",

					"#endif",

					"#ifdef ANISOTROPY",

						"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );",

						"#ifdef ANISOTROPYROTATION",
		    				"xyDotH = anisotropicRotationMatrix * xyDotH;",
			    		"#endif",
		
						"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );",

					"#else",

					    "float d = Distribution_GGX( m2, nDotH );",

					"#endif",

					"float vis = Visibility_Schlick(m2, nDotL, nDotV);",
				    "vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor * 0.08, hDotV );",
	    	
		   			// Put it all together
				    "vec3 spec = d * vis * fresnelColor;",
				    "vec3 diff = Diffuse_Lambert() * diffuseColor;",

					"#ifdef TRANSLUCENCY",

					    "diff *= whiteCompliment( translucencyColor.xyz );",

					"#endif",

				    "vec3 shadingResult = spec + diff;",

				    "#ifdef CLEARCOAT",

						"shadingResult = mix( shadingResult, specClearCoat, clearCoat );",

					"#endif",	
								    // diffuse
					"totalLighting  += incidentLight * nDotL * shadingResult;",

					"#ifdef TRANSLUCENCY",

						"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );",

						"float viewNormalTL = mix( 1.0, pow( abs( dot( viewPosition.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );",

						"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				"vec3 incidentLight = directionalLightColor[ i ];",
	
				"vec3 hVector = normalize( viewPosition.xyz + lVector.xyz );",
				"float nDotH = saturate( dot( normal, hVector ) );",
				"float nDotL = saturate( dot( normal, lVector ) );",
				"float hDotV = saturate( dot( hVector, viewPosition ) );",

				"#ifdef CLEARCOAT",

					"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );",
					"float visClearCoat = Visibility_Kelemen( hDotV );",
					"float fresnelClearCoat = Fresnel_Schlick( hDotV );",
					"vec3 specClearCoat = vec3( 1.0 ) * ( dClearCoat * visClearCoat * fresnelClearCoat );",

				"#endif",

				"#ifdef ANISOTROPY",

					"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );",

					"#ifdef ANISOTROPYROTATION",
	    				"xyDotH = anisotropicRotationMatrix * xyDotH;",
		    		"#endif",
	
					"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );",

				"#else",

				    "float d = Distribution_GGX( m2, nDotH );",

				"#endif",

				"float vis = Visibility_Schlick(m2, nDotL, nDotV);",
			    "vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor * 0.08, hDotV );",
	        	
	   			// Put it all together
			    "vec3 spec = d * vis * fresnelColor;",
			    "vec3 diff = Diffuse_Lambert() * diffuseColor;",

				"#ifdef TRANSLUCENCY",

				    "diff *= whiteCompliment( translucencyColor.xyz );",

				"#endif",

			    "vec3 shadingResult = spec + diff;",

			    "#ifdef CLEARCOAT",

					"shadingResult = mix( shadingResult, specClearCoat, clearCoat );",

				"#endif",	
							    // diffuse
				"totalLighting  += incidentLight * nDotL * shadingResult;",

				"#ifdef TRANSLUCENCY",

					"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );",

					"float viewNormalTL = mix( 1.0, pow( abs( dot( viewPosition.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );",

					"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				// diffuse

				"float nDotL = dot( normal, lVector );",

				// based on page 325 of Real-Time Rendering., equation (8.43)
				"vec3 hemiColor = ( PI / 2.0 ) * ( ( 1.0 + nDotL ) * hemisphereLightSkyColor[ i ] + ( 1.0 - nDotL ) * hemisphereLightGroundColor[ i ] );",
								
				"totalLighting += diffuseColor * hemiColor;",
			
			"}",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"for( int i = 0; i < MAX_AREA_LIGHTS; i ++ ) {",

				"vec3 lPosition = ( viewMatrix * vec4( areaLightPosition[ i ], 1.0 ) ).xyz;",
				//"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
		
				"vec3 width = areaLightWidth[ i ];",
				"vec3 height = areaLightHeight[ i ];",
				"vec3 up = normalize( ( viewMatrix * vec4( height, 0.0 ) ).xyz );",
				"vec3 right = normalize( ( viewMatrix * vec4( width, 0.0 ) ).xyz );",
				"vec3 pnormal = normalize( cross( right, up ) );",

				"float widthScalar = length( width );",
				"float heightScalar = length( height );",

				//project onto plane and calculate direction from center to the projection.
				"vec3 projection = projectOnPlane( -vViewPosition.xyz, lPosition, pnormal );",  // projection in plane
				"vec3 dir = projection - lPosition;",

				//calculate distance from area:
				"vec2 diagonal = vec2( dot( dir, right ), dot( dir, up ) );",
				"vec2 nearest2D = vec2( clamp( diagonal.x, -widthScalar, widthScalar ), clamp( diagonal.y, -heightScalar, heightScalar ) );",
				"vec3 nearestPointInside = lPosition + ( right *nearest2D.x + up * nearest2D.y );",

				"vec3 lVector = ( nearestPointInside + vViewPosition.xyz );",
				"float distanceAttenuation = calcLightAttenuation( length( lVector ), areaLightDistance[ i ], areaLightDecayExponent[i] );",
				"lVector = normalize( lVector );",
			
				"vec3 incidentLight = areaLightColor[ i ] * distanceAttenuation * 0.01;", // the 0.01 is the area light intensity scaling.

				"float nDotLDiffuse = saturate( dot( normal, lVector ) );",

		   		"vec3 diff = Diffuse_Lambert() * diffuseColor * widthScalar * heightScalar;",

				"vec3 viewReflection = reflect( viewPosition.xyz, normal );",
				"vec3 reflectionLightPlaneIntersection = linePlaneIntersect( -vViewPosition.xyz, viewReflection, lPosition, pnormal );",

				"float specAngle = dot( viewReflection, pnormal );",

				"if ( specAngle < 0.0 ) {",

					"vec3 dirSpec = reflectionLightPlaneIntersection - lPosition;",
					"vec2 dirSpec2D = vec2( dot( dirSpec, right ), dot( dirSpec, up ) );",
					"vec2 nearestSpec2D = vec2( clamp( dirSpec2D.x, -widthScalar, widthScalar ), clamp( dirSpec2D.y, -heightScalar, heightScalar ) );",
					"lVector = normalize( lPosition + ( right *nearestSpec2D.x + up * nearestSpec2D.y ) + vViewPosition.xyz );",

				"} else { ",

					"lVector = vec3( 0 );",

				"}",
							
				"vec3 hVector = normalize( viewPosition.xyz + lVector.xyz );",
				"float nDotH = saturate( dot( normal, hVector ) );",
				"float nDotL = saturate( dot( normal, lVector ) );",
				"float hDotV = saturate( dot( hVector, viewPosition ) );",

				"#ifdef CLEARCOAT",

					"float dClearCoat = Distribution_GGX( m2ClearCoat, nDotH );",
					"float visClearCoat = Visibility_Kelemen( hDotV );",
					"float fresnelClearCoat = Fresnel_Schlick( hDotV );",
					"vec3 specClearCoat = vec3( 1.0 ) * ( dClearCoat * visClearCoat * fresnelClearCoat );",

				"#endif",

				"#ifdef TRANSLUCENCY",

				    "diff *= whiteCompliment( translucencyColor.xyz );",

				"#endif",

				"#ifdef CLEARCOAT",

					"diff = mix( diff, specClearCoat, clearCoat );",

				"#endif",

				"totalLighting  += incidentLight * nDotLDiffuse * diff;",

				"#ifdef ANISOTROPY",

					"vec2 xyDotH = vec2( dot( anisotropicS, hVector ), dot( anisotropicT, hVector ) );",

					"#ifdef ANISOTROPYROTATION",
	    				"xyDotH = anisotropicRotationMatrix * xyDotH;",
		    		"#endif",
	
					"float d = Distribution_GGXAniso( anisotropicM, xyDotH, nDotH );",

				"#else",

				    "float d = Distribution_GGX( m2, nDotH );",

				"#endif",

				"float vis = Visibility_Schlick(m2, nDotL, nDotV);",
				"vec3 fresnelColor = Fresnel_Schlick_SpecularBlendToWhite( specularColor * 0.08, hDotV );",
    
	   			// Put it all together
			    "vec3 spec = d * vis * fresnelColor;",

				"totalLighting  += incidentLight * nDotL * spec;",

				"#ifdef TRANSLUCENCY",

					"float lightNormalTL = mix( 1.0, pow( abs( dot( lVector.xyz, normal ) ), translucencyNormalPower ), translucencyNormalAlpha );",

					"float viewNormalTL = mix( 1.0, pow( abs( dot( viewPosition.xyz, lVector.xyz) ), translucencyViewPower ), translucencyViewAlpha );",

					"totalLighting += lightNormalTL * viewNormalTL * translucencyColor.rgb * incidentLight;",

				"#endif",
		
			"}",

		"#endif",

		"#ifdef CLEARCOAT",

			"totalLighting += diffuseColor * ( ambientLightColor * ( 1.0 - clearCoat ) );",
		
		"#else",

			"totalLighting += diffuseColor * ambientLightColor;",

		"#endif",

		"gl_FragColor.xyz += totalLighting;",

		"vec3 emissiveLocal = emissive;",

		"#ifdef USE_EMISSIVEMAP",

			"vec3 emissiveColor = texture2D( emissiveMap, vUv2 ).xyz;",

			"#ifdef GAMMA_INPUT",

				"emissiveColor *= emissiveColor;",

			"#endif",

			"emissiveLocal *= emissiveColor;",

		"#endif",

		"gl_FragColor.xyz += emissiveLocal;",

		"vec3 ambientLocal = ambient;",

		"#ifdef USE_LIGHTMAP",

			"vec3 ambientColor = texture2D( lightMap, vUv2 ).xyz;",

			"#ifdef GAMMA_INPUT",

				"ambientColor *= ambientColor;",

			"#endif",

			"ambientLocal *= ambientColor;",

			"#ifdef CLEARCOAT",

				"ambientLocal *= ( 1.0 - clearCoat );",

			"#endif",
	
		"#endif",

		"gl_FragColor.xyz += diffuseColor * ambientLocal;",

	].join("\n"),

	// LIGHTS PHONG

	lights_phong_pars_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )",

			"varying vec3 vWorldPosition;",

		"#endif"

	].join("\n"),


	lights_phong_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )",

			"vWorldPosition = worldPosition.xyz;",

		"#endif"

	].join("\n"),

	lights_phong_pars_fragment: [

		"uniform vec3 ambientLightColor;",

		"#ifndef USE_ENVMAP",

			"uniform float reflectivity;",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDecayExponent[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDecayExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"uniform vec3 areaLightColor[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightPosition[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightWidth[ MAX_AREA_LIGHTS ];",
			"uniform vec3 areaLightHeight[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDistance[ MAX_AREA_LIGHTS ];",
			"uniform float areaLightDecayExponent[ MAX_AREA_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || MAX_AREA_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif",

		"varying vec3 vViewPosition;",
		"varying vec3 vNormal;"

	].join("\n"),

	lights_phong_fragment: [

		"vec3 normal = normalize( vNormal );",
		"vec3 viewPosition = normalize( vViewPosition );",

		"#ifdef DOUBLE_SIDED",

			"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

		"#endif",

		"#ifdef USE_NORMALMAP",

			"normal = perturbNormal2Arb( -vViewPosition, normal );",

		"#elif defined( USE_BUMPMAP )",

			"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"vec3 pointDiffuse  = vec3( 0.0 );",
			"vec3 pointSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecayExponent[i] );",
				
				"lVector = normalize( lVector );",

				// diffuse

				"float dotProduct = dot( normal, lVector );",

				"float pointDiffuseWeight = max( dotProduct, 0.0 );",

				"pointDiffuse  += pointLightColor[ i ] * pointDiffuseWeight * distanceAttenuation;",

				// specular

				"vec3 pointHalfVector = normalize( lVector + viewPosition );",
				"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
				"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );",
				"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * distanceAttenuation * specularNormalization;",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"vec3 spotDiffuse  = vec3( 0.0 );",
			"vec3 spotSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"float distanceAttenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecayExponent[i] );",

				"lVector = normalize( lVector );",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					// diffuse

					"float dotProduct = dot( normal, lVector );",

					"#ifdef WRAP_AROUND",

						"float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

						"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

					"#else",

						"float spotDiffuseWeight = max( dotProduct, 0.0 );",

					"#endif",

					"spotDiffuse += spotLightColor[ i ] * spotDiffuseWeight * distanceAttenuation * spotEffect;",

					// specular

					"vec3 spotHalfVector = normalize( lVector + viewPosition );",
					"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
					"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );",
					"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * distanceAttenuation * specularNormalization * spotEffect;",

				"}",

			"}",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"vec3 dirDiffuse  = vec3( 0.0 );",
			"vec3 dirSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 dirVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, dirVector );",

				"#ifdef WRAP_AROUND",

					"float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float dirDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"dirDiffuse  += directionalLightColor[ i ] * dirDiffuseWeight;",

				// specular

				"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
				"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
				"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				//"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
				"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",


			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"vec3 hemiDiffuse  = vec3( 0.0 );",
			"vec3 hemiSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, lVector );",
				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

				"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"hemiDiffuse += hemiColor;",

				// specular (sky light)

				"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
				"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
				"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

				// specular (ground light)

				"vec3 lVectorGround = -lVector;",

				"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
				"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
				"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

				"float dotProductGround = dot( normal, lVectorGround );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
				"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
				"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

			"}",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"vec3 areaDiffuse  = vec3( 0.0 );",
			"vec3 areaSpecular = vec3( 0.0 );",

			"for( int i = 0; i < MAX_AREA_LIGHTS; i ++ ) {",

				"vec3 lPosition = ( viewMatrix * vec4( areaLightPosition[ i ], 1.0 ) ).xyz;",
				//"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
		
				"vec3 width = areaLightWidth[ i ];",
				"vec3 height = areaLightHeight[ i ];",
				"vec3 up = normalize( ( viewMatrix * vec4( height, 0.0 ) ).xyz );",
				"vec3 right = normalize( ( viewMatrix * vec4( width, 0.0 ) ).xyz );",
				"vec3 pnormal = normalize( cross( right, up ) );",

				"float widthScalar = length( width );",
				"float heightScalar = length( height );",

				//project onto plane and calculate direction from center to the projection.
				"vec3 projection = projectOnPlane( -vViewPosition.xyz, lPosition, pnormal );",  // projection in plane
				"vec3 dir = projection - lPosition;",

				//calculate distance from area:
				"vec2 diagonal = vec2( dot( dir, right ), dot( dir, up ) );",
				"vec2 nearest2D = vec2( clamp( diagonal.x, -widthScalar, widthScalar ), clamp( diagonal.y, -heightScalar, heightScalar ) );",
				"vec3 nearestPointInside = lPosition + ( right *nearest2D.x + up * nearest2D.y );",

				"vec3 lVector = ( nearestPointInside + vViewPosition.xyz );",
				"float distanceAttenuation = calcLightAttenuation( length( lVector ), areaLightDistance[ i ], areaLightDecayExponent[i] );",
				"lVector = normalize( lVector );",
			
				"float nDotLDiffuse = saturate( dot( normal, lVector ) );",
		   
				"vec3 viewReflection = reflect( viewPosition.xyz, normal );",
				"vec3 reflectionLightPlaneIntersection = linePlaneIntersect( -vViewPosition.xyz, viewReflection, lPosition, pnormal );",

				"float specAngle = dot( viewReflection, pnormal );",

				"if ( specAngle < 0.0 ) {",

					"vec3 dirSpec = reflectionLightPlaneIntersection - lPosition;",
					"vec2 dirSpec2D = vec2( dot( dirSpec, right ), dot( dirSpec, up ) );",
					"vec2 nearestSpec2D = vec2( clamp( dirSpec2D.x, -widthScalar, widthScalar ), clamp( dirSpec2D.y, -heightScalar, heightScalar ) );",
					"lVector = normalize( lPosition + ( right *nearestSpec2D.x + up * nearestSpec2D.y ) + vViewPosition.xyz );",

				"} else { ",

					"lVector = vec3( 0 );",

				"}",

				// diffuse

				"float dotProduct = nDotLDiffuse;",

				"float areaDiffuseWeight = max( dotProduct, 0.0 );",

				"areaDiffuse  += areaLightColor[ i ] * areaDiffuseWeight * distanceAttenuation * widthScalar * heightScalar * 0.01;",  // the 0.01 is the area light intensity scaling.

				// specular

				"vec3 areaHalfVector = normalize( lVector + viewPosition );",
				"float areaDotNormalHalf = max( dot( normal, areaHalfVector ), 0.0 );",
				"float areaSpecularWeight = specularStrength * max( pow( areaDotNormalHalf, shininess ), 0.0 );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, areaHalfVector ), 0.0 ), 5.0 );",
				"areaSpecular += schlick * areaLightColor[ i ] * areaSpecularWeight * areaDiffuseWeight * distanceAttenuation * specularNormalization * 0.01;",  // the 0.01 is the area light intensity scaling.

			"}",

		"#endif",

		"vec3 totalDiffuse = vec3( 0.0 );",
		"vec3 totalSpecular = vec3( 0.0 );",

		"#if MAX_DIR_LIGHTS > 0",

			"totalDiffuse += dirDiffuse;",
			"totalSpecular += dirSpecular;",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"totalDiffuse += hemiDiffuse;",
			"totalSpecular += hemiSpecular;",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"totalDiffuse += pointDiffuse;",
			"totalSpecular += pointSpecular;",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"totalDiffuse += spotDiffuse;",
			"totalSpecular += spotSpecular;",

		"#endif",

		"#if MAX_AREA_LIGHTS > 0",

			"totalDiffuse += areaDiffuse;",
			"totalSpecular += areaSpecular;",

		"#endif",
		"vec3 ambientLocal = ambient;",

		"#ifdef USE_LIGHTMAP",

			"vec3 ambientColor = texture2D( lightMap, vUv2 ).xyz;",

			"#ifdef GAMMA_INPUT",

				"ambientColor *= ambientColor;",

			"#endif",

			"ambientLocal *= ambientColor;",
	
		"#endif",

		"gl_FragColor.xyz = diffuseColor * ( totalDiffuse + ambientLightColor + ambientLocal ) + totalSpecular;",

		"vec3 emissiveLocal = emissive;",

		"#ifdef USE_EMISSIVEMAP",

			"vec3 emissiveColor = texture2D( emissiveMap, vUv2 ).xyz;",

			"#ifdef GAMMA_INPUT",

				"emissiveColor *= emissiveColor;",

			"#endif",

			"emissiveLocal *= emissiveColor;",

		"#endif",

		"gl_FragColor.xyz += emissiveLocal.xyz;",
		
	].join("\n"),

	// VERTEX COLORS

	color_pars_fragment: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_fragment: [

		"#ifdef USE_COLOR",

			"gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );",

		"#endif"

	].join("\n"),

	color_pars_vertex: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_vertex: [

		"#ifdef USE_COLOR",

			"#ifdef GAMMA_INPUT",

				"vColor = color * color;",

			"#else",

				"vColor = color;",

			"#endif",

		"#endif"

	].join("\n"),

	// SKINNING

	skinning_pars_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef BONE_TEXTURE",

				"uniform sampler2D boneTexture;",
				"uniform int boneTextureWidth;",
				"uniform int boneTextureHeight;",

				"mat4 getBoneMatrix( const in float i ) {",

					"float j = i * 4.0;",
					"float x = mod( j, float( boneTextureWidth ) );",
					"float y = floor( j / float( boneTextureWidth ) );",

					"float dx = 1.0 / float( boneTextureWidth );",
					"float dy = 1.0 / float( boneTextureHeight );",

					"y = dy * ( y + 0.5 );",

					"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
					"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
					"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
					"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",

					"mat4 bone = mat4( v1, v2, v3, v4 );",

					"return bone;",

				"}",

			"#else",

				"uniform mat4 boneGlobalMatrices[ MAX_BONES ];",

				"mat4 getBoneMatrix( const in float i ) {",

					"mat4 bone = boneGlobalMatrices[ int(i) ];",
					"return bone;",

				"}",

			"#endif",

		"#endif"

	].join("\n"),

	skinbase_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 boneMatX = getBoneMatrix( skinIndex.x );",
			"mat4 boneMatY = getBoneMatrix( skinIndex.y );",
			"mat4 boneMatZ = getBoneMatrix( skinIndex.z );",
			"mat4 boneMatW = getBoneMatrix( skinIndex.w );",

		"#endif"

	].join("\n"),

	skinning_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef USE_MORPHTARGETS",

			"vec4 skinVertex = vec4( morphed, 1.0 );",

			"#else",

			"vec4 skinVertex = vec4( position, 1.0 );",

			"#endif",

			"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
			"skinned      += boneMatY * skinVertex * skinWeight.y;",
			"skinned      += boneMatZ * skinVertex * skinWeight.z;",
			"skinned      += boneMatW * skinVertex * skinWeight.w;",

		"#endif"

	].join("\n"),

	// MORPHING

	morphtarget_pars_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"#ifndef USE_MORPHNORMALS",

			"uniform float morphTargetInfluences[ 8 ];",

			"#else",

			"uniform float morphTargetInfluences[ 4 ];",

			"#endif",

		"#endif"

	].join("\n"),

	morphtarget_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"vec3 morphed = vec3( 0.0 );",
			"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
			"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
			"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
			"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",

			"#ifndef USE_MORPHNORMALS",

			"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
			"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
			"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
			"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",

			"#endif",

			"morphed += position;",

		"#endif"

	].join("\n"),

	default_vertex : [

		"vec4 mvPosition;",

		"#ifdef USE_SKINNING",

			"mvPosition = modelViewMatrix * skinned;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( position, 1.0 );",

		"#endif",

		"gl_Position = projectionMatrix * mvPosition;"

	].join("\n"),

	morphnormal_vertex: [

		"#ifdef USE_MORPHNORMALS",

			"vec3 morphedNormal = vec3( 0.0 );",

			"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
			"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
			"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
			"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",

			"morphedNormal += normal;",

		"#endif"

	].join("\n"),

	skinnormal_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 skinMatrix = skinWeight.x * boneMatX;",
			"skinMatrix 	+= skinWeight.y * boneMatY;",

			"#ifdef USE_MORPHNORMALS",

			"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",

			"#else",

			"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	defaultnormal_vertex: [

		"vec3 objectNormal;",

		"#ifdef USE_SKINNING",

			"objectNormal = skinnedNormal.xyz;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",

			"objectNormal = morphedNormal;",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",

			"objectNormal = normal;",

		"#endif",

		"#ifdef FLIP_SIDED",

			"objectNormal = -objectNormal;",

		"#endif",

		"vec3 transformedNormal = normalMatrix * objectNormal;"

	].join("\n"),

	// SHADOW MAP

	// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples
	//  http://spidergl.org/example.php?id=6
	// 	http://fabiensanglard.net/shadowmapping

	shadowmap_pars_fragment: [

		"#ifdef USE_SHADOWMAP",

			"uniform sampler2D shadowMap[ MAX_SHADOWS ];",
			"uniform vec2 shadowMapSize[ MAX_SHADOWS ];",

			"uniform float shadowDarkness[ MAX_SHADOWS ];",
			"uniform float shadowBias[ MAX_SHADOWS ];",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",

			"float unpackDepth( const in vec4 rgba_depth ) {",

				"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"float depth = dot( rgba_depth, bit_shift );",
				"return depth;",

			"}",

		"#endif"

	].join("\n"),

	shadowmap_fragment: [

		"#ifdef USE_SHADOWMAP",

			"#ifdef SHADOWMAP_DEBUG",

				"vec3 frustumColors[3];",
				"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
				"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
				"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",

			"#endif",

			"#ifdef SHADOWMAP_CASCADE",

				"int inFrustumCount = 0;",

			"#endif",

			"float fDepth;",
			"vec3 shadowColor = vec3( 1.0 );",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",

				// "if ( something && something )" 		 breaks ATI OpenGL shader compiler
				// "if ( all( something, something ) )"  using this instead

				"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
				"bool inFrustum = all( inFrustumVec );",

				// don't shadow pixels outside of light frustum
				// use just first frustum (for cascades)
				// don't shadow pixels behind far plane of light frustum

				"#ifdef SHADOWMAP_CASCADE",

					"inFrustumCount += int( inFrustum );",
					"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",

				"#else",

					"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",

				"#endif",

				"bool frustumTest = all( frustumTestVec );",

				"if ( frustumTest ) {",

					"shadowCoord.z += shadowBias[ i ];",

					"#if defined( SHADOWMAP_TYPE_PCF )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						/*
						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL
						// must enroll loop manually

						"for ( float y = -1.25; y <= 1.25; y += 1.25 )",
							"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {",

								"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );",

								// doesn't seem to produce any noticeable visual difference compared to simple "texture2D" lookup
								//"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );",

								"float fDepth = unpackDepth( rgbaDepth );",

								"if ( fDepth < shadowCoord.z )",
									"shadow += 1.0;",

						"}",

						"shadow /= 9.0;",

						*/

						"const float shadowDelta = 1.0 / 9.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.25 * xPixelOffset;",
						"float dy0 = -1.25 * yPixelOffset;",
						"float dx1 = 1.25 * xPixelOffset;",
						"float dy1 = 1.25 * yPixelOffset;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.0 * xPixelOffset;",
						"float dy0 = -1.0 * yPixelOffset;",
						"float dx1 = 1.0 * xPixelOffset;",
						"float dy1 = 1.0 * yPixelOffset;",

						"mat3 shadowKernel;",
						"mat3 depthKernel;",

						"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",

						"vec3 shadowZ = vec3( shadowCoord.z );",
						"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));",
						"shadowKernel[0] *= vec3(0.25);",
													
						"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));",
						"shadowKernel[1] *= vec3(0.25);",

						"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));",
						"shadowKernel[2] *= vec3(0.25);",

						"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",

						"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
						"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",

						"vec4 shadowValues;",
						"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
						"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
						"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
						"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",

						"shadow = dot( shadowValues, vec4( 1.0 ) );",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#else",

						"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
						"float fDepth = unpackDepth( rgbaDepth );",

						"if ( fDepth < shadowCoord.z )",

							// spot with multiple shadows is darker

							"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",

							// spot with multiple shadows has the same color as single shadow spot

							//"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );",

					"#endif",

				"}",


				"#ifdef SHADOWMAP_DEBUG",

					"#ifdef SHADOWMAP_CASCADE",

						"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#else",

						"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#endif",

				"#endif",

			"}",

			"#ifdef GAMMA_OUTPUT",

				"shadowColor *= shadowColor;",

			"#endif",

			"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",

		"#endif"

	].join("\n"),

	shadowmap_pars_vertex: [

		"#ifdef USE_SHADOWMAP",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
			"uniform mat4 shadowMatrix[ MAX_SHADOWS ];",

		"#endif"

	].join("\n"),

	shadowmap_vertex: [

		"#ifdef USE_SHADOWMAP",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

			"}",

		"#endif"

	].join("\n"),

	// ALPHATEST

	alphatest_fragment: [

		"#ifdef ALPHATEST",

			"if ( gl_FragColor.a < ALPHATEST ) discard;",

		"#endif"

	].join("\n"),

	// LINEAR SPACE

	linear_to_gamma_fragment: [

		"#ifdef GAMMA_OUTPUT",

			"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",

		"#endif"

	].join("\n")


};
/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var u, p, tmp, merged = {};

		for ( u = 0; u < uniforms.length; u ++ ) {

			tmp = this.clone( uniforms[ u ] );

			for ( p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var u, p, parameter, parameter_src, uniforms_dst = {};

		for ( u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( p in uniforms_src[ u ] ) {

				parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};
/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
		"gainBrightness" : { type: "v4", value: new THREE.Vector4( 0, 1, 0, 1 ) },

		"lightMap" : { type: "t", value: null },
		"emissiveMap" : { type: "t", value: null },
	
		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: -1 },
		"useRefract" : { type: "i", value: 0 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },
		"combine" : { type: "i", value: 0 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	specularmap: {

		"specularMap" : { type: "t", value: null },
		"specularOffsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
		"specularGainBrightness" : { type: "v4", value: new THREE.Vector4( 0, 1, 0, 1 ) },

	},

	bumpmap: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }, // used instead of 'bumpGainBrightness'
		"bumpOffsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) }		

	},

	opacitymap: {

		"opacityMap" : { type: "t", value: null },
		"opacityOffsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
		"opacityGainBrightness" : { type: "v4", value: new THREE.Vector4( 0, 1, 0, 1 ) },

	},
	
	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }, // used instead of 'normalGainBrightness'
		"normalOffsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) }

	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },
		"pointLightDecayExponent" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightDecayExponent" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] },

		"areaLightColor" : { type: "fv", value: [] },
		"areaLightPosition" : { type: "fv", value: [] },
		"areaLightDistance" : { type: "fv1", value: [] },
		"areaLightDecayExponent" : { type: "fv1", value: [] },
		"areaLightWidth" : { type: "fv", value: [] },
		"areaLightHeight" : { type: "fv", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};
/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author bhouston / http://clara.io/ 
 */


THREE.ShaderLib = {


	'physical': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bumpmap" ],
			THREE.UniformsLib[ "normalmap" ],
			//THREE.UniformsLib[ "roughnessmap" ],  TODO: Implement me!
			//THREE.UniformsLib[ "metallicmap" ],  TODO: Implement me!
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],
			THREE.UniformsLib[ "opacitymap" ],
			THREE.UniformsLib[ "specularmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0xFFFFFF ) },
				"falloffColor" : { type: "c", value: new THREE.Color( 0xFFFFFF ) },
				"falloffMap" : { type: "t", value: null },
				"falloffBlendParams" : { type: "v4", value: new THREE.Vector4( 1, 0, 0, 1 ) },

				"clearCoat": { type: "f", value: 0.0 },
				"clearCoatRoughness": { type: "f", value: 0.25 },

				"roughness": { type: "f", value: 0.5 },
				"roughnessMap" : { type: "t", value: null },
				"roughnessOffsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
				"roughnessGainBrightness" : { type: "v4", value: new THREE.Vector4( 0, 1, 0, 1 ) },

				"metallic": { type: "f", value: 0.5 },
				"metallicMap" : { type: "t", value: null },
				"metallicOffsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
				"metallicGainBrightness" : { type: "v4", value: new THREE.Vector4( 0, 1, 0, 1 ) },

				"anisotropy": { type: "f", value: 0.0 },
				"anisotropyMap" : { type: "t", value: null },
				"anisotropyOffsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
				"anisotropyGainBrightness" : { type: "v4", value: new THREE.Vector4( 0, 1, 0, 1 ) },

				"anisotropyRotation": { type: "f", value: 0.0 },
				"anisotropyRotationMap" : { type: "t", value: null },
				"anisotropyRotationOffsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
				"anisotropyRotationGainBrightness" : { type: "v4", value: new THREE.Vector4( 0, 1, 0, 1 ) },

				"translucency" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"translucencyMap" : { type: "t", value: null },
				"translucencyNormalAlpha": { type: "f", value: 0.75 },
				"translucencyNormalPower": { type: "f", value: 2.0 },
				"translucencyViewAlpha": { type: "f", value: 0.75 },
				"translucencyViewPower": { type: "f", value: 2.0 },
				
			}

		] ),

		vertexShader: [

			"attribute vec4 tangent;",
			
			"#define PHONG",
			"#define PHYSICAL",

			"varying vec3 vViewPosition;",
			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
	
			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "normalmap_pars_vertex" ],
			THREE.ShaderChunk[ "roughnessmap_pars_vertex" ],
			THREE.ShaderChunk[ "specularmap_pars_vertex" ],
			THREE.ShaderChunk[ "opacitymap_pars_vertex" ],
			THREE.ShaderChunk[ "anisotropymap_pars_vertex" ],
			THREE.ShaderChunk[ "anisotropyrotationmap_pars_vertex" ],
			THREE.ShaderChunk[ "metallicmap_pars_vertex" ],
			THREE.ShaderChunk[ "translucencymap_pars_vertex" ],
			THREE.ShaderChunk[ "bumpmap_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_physical_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "normalmap_vertex" ],
				THREE.ShaderChunk[ "roughnessmap_vertex" ],
				THREE.ShaderChunk[ "opacitymap_vertex" ],
				THREE.ShaderChunk[ "specularmap_vertex" ],
				THREE.ShaderChunk[ "anisotropymap_vertex" ],
				THREE.ShaderChunk[ "anisotropyrotationmap_vertex" ],
				THREE.ShaderChunk[ "metallicmap_vertex" ],
				THREE.ShaderChunk[ "translucencymap_vertex" ],
				THREE.ShaderChunk[ "bumpmap_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				"vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_physical_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"#define PHYSICAL",
			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 falloffColor;",
			"uniform vec3 falloffBlendParams;",
			"uniform vec3 specular;",
			"uniform float roughness;",
			"uniform float metallic;",
			"uniform float clearCoat;",
			"uniform float clearCoatRoughness;",

			"uniform vec3 translucency;",
			"uniform float translucencyNormalAlpha;",
			"uniform float translucencyNormalPower;",
			"uniform float translucencyViewPower;",
			"uniform float translucencyViewAlpha;",

			"uniform float anisotropy;",
			"uniform float anisotropyRotation;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "falloffmap_pars_fragment" ],
			THREE.ShaderChunk[ "opacitymap_pars_fragment" ],
			THREE.ShaderChunk[ "translucencymap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_physical_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "anisotropymap_pars_fragment" ],
			THREE.ShaderChunk[ "anisotropyrotationmap_pars_fragment" ],
			THREE.ShaderChunk[ "metallicmap_pars_fragment" ],
			THREE.ShaderChunk[ "roughnessmap_pars_fragment" ],
			THREE.ShaderChunk[ "reflectivitymap_pars_fragment" ],
			THREE.ShaderChunk[ "lightattenuation_func_fragment" ],		

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 0.0 ), opacity );",
				"vec3 diffuseColor = diffuse;",
				"vec3 translucencyColor = translucency;",
				"vec3 normal = normalize( vNormal );",
				"vec3 viewPosition = normalize( vViewPosition );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "opacitymap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "anisotropymap_fragment" ],
				THREE.ShaderChunk[ "anisotropyrotationmap_fragment" ],
				THREE.ShaderChunk[ "roughnessmap_fragment" ],
				THREE.ShaderChunk[ "metallicmap_fragment" ],
				THREE.ShaderChunk[ "translucencymap_fragment" ],
				THREE.ShaderChunk[ "reflectivitymap_fragment" ],

				THREE.ShaderChunk[ "lights_physical_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

				"gl_FragColor.xyz *= gl_FragColor.w;",		// premultipled, must be used with CustomBlender, OneFactor, OneMinusSrcAlphaFactor, AddEquation.

			"}"

		].join("\n")

	},

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

				"#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( diffuse, opacity );",
		
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "lightattenuation_func_fragment" ],		

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
	
			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
	
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				"#ifdef DOUBLE_SIDED",

					//"float isFront = float( gl_FrontFacing );",
					//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

					"if ( gl_FrontFacing )",
						"gl_FragColor.xyz *= vLightFront;",
					"else",
						"gl_FragColor.xyz *= vLightBack;",

				"#else",

					"gl_FragColor.xyz *= vLightFront;",

				"#endif",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bumpmap" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "specularmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],
			THREE.UniformsLib[ "opacitymap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "normalmap_pars_vertex" ],
			THREE.ShaderChunk[ "bumpmap_pars_vertex" ],
			THREE.ShaderChunk[ "specularmap_pars_vertex" ],
			THREE.ShaderChunk[ "opacitymap_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "normalmap_vertex" ],
				THREE.ShaderChunk[ "bumpmap_vertex" ],
				THREE.ShaderChunk[ "opacitymap_vertex" ],
				THREE.ShaderChunk[ "specularmap_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				"vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"#define PHONG",
	
			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "opacitymap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "lightattenuation_func_fragment" ],		

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
				"vec3 diffuseColor = diffuse;",
			
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "opacitymap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms:  THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"#ifdef USE_SIZEATTENUATION",
					"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"#else",
					"gl_PointSize = size;",
				"#endif",

				"gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale":     { type: "f", value: 1 },
				"dashSize":  { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vLineDistance = scale * lineDistance;",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"gl_Position = projectionMatrix * mvPosition;",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"if ( mod( vLineDistance, totalSize ) > dashSize ) {",

					"discard;",

				"}",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"void main() {",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			"void main() {",

				"float depth = gl_FragCoord.z / gl_FragCoord.w;",
				"float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],

			"void main() {",

				"vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			"void main() {",

				"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Normal map shader
	//		- Blinn-Phong
	//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
	//		- point and directional lights (use with "lights: true" material option)
	 ------------------------------------------------------------------------- */

	'normalmap' : {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{

			"enableAO"		  : { type: "i", value: 0 },
			"enableDiffuse"	  : { type: "i", value: 0 },
			"enableSpecular"  : { type: "i", value: 0 },
			"enableReflection": { type: "i", value: 0 },
			"enableDisplacement": { type: "i", value: 0 },

			"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
			"tDiffuse"	   : { type: "t", value: null },
			"tCube"		   : { type: "t", value: null },
			"tNormal"	   : { type: "t", value: null },
			"tSpecular"	   : { type: "t", value: null },
			"tAO"		   : { type: "t", value: null },

			"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"uDisplacementBias": { type: "f", value: 0.0 },
			"uDisplacementScale": { type: "f", value: 1.0 },

			"diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
			"specular": { type: "c", value: new THREE.Color( 0x111111 ) },
			"ambient": { type: "c", value: new THREE.Color( 0xffffff ) },
			"shininess": { type: "f", value: 30 },
			"opacity": { type: "f", value: 1 },

			"useRefract": { type: "i", value: 0 },
			"refractionRatio": { type: "f", value: 0.98 },
			"reflectivity": { type: "f", value: 0.5 },

			"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
			"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

			}

		] ),

		fragmentShader: [

			"uniform vec3 ambient;",
			"uniform vec3 diffuse;",
			"uniform vec3 specular;",
			"uniform float shininess;",
			"uniform float opacity;",

			"uniform bool enableDiffuse;",
			"uniform bool enableSpecular;",
			"uniform bool enableAO;",
			"uniform bool enableReflection;",

			"uniform sampler2D tDiffuse;",
			"uniform sampler2D tNormal;",
			"uniform sampler2D tSpecular;",
			"uniform sampler2D tAO;",

			"uniform samplerCube tCube;",

			"uniform vec2 uNormalScale;",

			"uniform bool useRefract;",
			"uniform float refractionRatio;",
			"uniform float reflectivity;",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"uniform vec3 ambientLightColor;",

			"#if MAX_DIR_LIGHTS > 0",

				"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

			"#endif",

			"#if MAX_HEMI_LIGHTS > 0",

				"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

			"#endif",

			"#if MAX_POINT_LIGHTS > 0",

				"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#endif",

			"#if MAX_SPOT_LIGHTS > 0",

				"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#endif",

			"#ifdef WRAP_AROUND",

				"uniform vec3 wrapRGB;",

			"#endif",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				"vec3 specularTex = vec3( 1.0 );",

				"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
				"normalTex.xy *= uNormalScale;",
				"normalTex = normalize( normalTex );",

				"if( enableDiffuse ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 texelColor = texture2D( tDiffuse, vUv );",
						"texelColor.xyz *= texelColor.xyz;",

						"gl_FragColor = gl_FragColor * texelColor;",

					"#else",

						"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

					"#endif",

				"}",

				"if( enableAO ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 aoColor = texture2D( tAO, vUv );",
						"aoColor.xyz *= aoColor.xyz;",

						"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

					"#else",

						"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

					"#endif",

				"}",

				"if( enableSpecular )",
					"specularTex = texture2D( tSpecular, vUv ).xyz;",

				"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
				"vec3 finalNormal = tsb * normalTex;",

				"#ifdef FLIP_SIDED",

					"finalNormal = -finalNormal;",

				"#endif",

				"vec3 normal = normalize( finalNormal );",
				"vec3 viewPosition = normalize( vViewPosition );",

				// point lights

				"#if MAX_POINT_LIGHTS > 0",

					"vec3 pointDiffuse = vec3( 0.0 );",
					"vec3 pointSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
						"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

						"float pointDistance = 1.0;",
						"if ( pointLightDistance[ i ] > 0.0 )",
							"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

						"pointVector = normalize( pointVector );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
							"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

							"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

						"#else",

							"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

						"#endif",

						"pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;",

						// specular

						"vec3 pointHalfVector = normalize( pointVector + viewPosition );",
						"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
						"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );",
						"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

					"}",

				"#endif",

				// spot lights

				"#if MAX_SPOT_LIGHTS > 0",

					"vec3 spotDiffuse = vec3( 0.0 );",
					"vec3 spotSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
						"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

						"float spotDistance = 1.0;",
						"if ( spotLightDistance[ i ] > 0.0 )",
							"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

						"spotVector = normalize( spotVector );",

						"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

						"if ( spotEffect > spotLightAngleCos[ i ] ) {",

							"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

							// diffuse

							"#ifdef WRAP_AROUND",

								"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
								"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

								"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

							"#else",

								"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

							"#endif",

							"spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;",

							// specular

							"vec3 spotHalfVector = normalize( spotVector + viewPosition );",
							"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
							"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

							// 2.0 => 2.0001 is hack to work around ANGLE bug

							"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

							"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );",
							"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

						"}",

					"}",

				"#endif",

				// directional lights

				"#if MAX_DIR_LIGHTS > 0",

					"vec3 dirDiffuse = vec3( 0.0 );",
					"vec3 dirSpecular = vec3( 0.0 );",

					"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

						"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
						"vec3 dirVector = normalize( lDirection.xyz );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
							"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

							"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

						"#else",

							"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

						"#endif",

						"dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;",

						// specular

						"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
						"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
						"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
						"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

					"}",

				"#endif",

				// hemisphere lights

				"#if MAX_HEMI_LIGHTS > 0",

					"vec3 hemiDiffuse  = vec3( 0.0 );",
					"vec3 hemiSpecular = vec3( 0.0 );" ,

					"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

						"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
						"vec3 lVector = normalize( lDirection.xyz );",

						// diffuse

						"float dotProduct = dot( normal, lVector );",
						"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

						"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

						"hemiDiffuse += diffuse * hemiColor;",

						// specular (sky light)


						"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
						"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
						"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

						// specular (ground light)

						"vec3 lVectorGround = -lVector;",

						"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
						"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
						"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

						"float dotProductGround = dot( normal, lVectorGround );",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
						"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
						"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

					"}",

				"#endif",

				// all lights contribution summation

				"vec3 totalDiffuse = vec3( 0.0 );",
				"vec3 totalSpecular = vec3( 0.0 );",

				"#if MAX_DIR_LIGHTS > 0",

					"totalDiffuse += dirDiffuse;",
					"totalSpecular += dirSpecular;",

				"#endif",

				"#if MAX_HEMI_LIGHTS > 0",

					"totalDiffuse += hemiDiffuse;",
					"totalSpecular += hemiSpecular;",

				"#endif",

				"#if MAX_POINT_LIGHTS > 0",

					"totalDiffuse += pointDiffuse;",
					"totalSpecular += pointSpecular;",

				"#endif",

				"#if MAX_SPOT_LIGHTS > 0",

					"totalDiffuse += spotDiffuse;",
					"totalSpecular += spotSpecular;",

				"#endif",

				"#ifdef METAL",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",

				"#else",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

				"#endif",

				"if ( enableReflection ) {",

					"vec3 vReflect;",
					"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

					"if ( useRefract ) {",

						"vReflect = refract( cameraToVertex, normal, refractionRatio );",

					"} else {",

						"vReflect = reflect( cameraToVertex, normal );",

					"}",

					"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

					"#ifdef GAMMA_INPUT",

						"cubeColor.xyz *= cubeColor.xyz;",

					"#endif",

					"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );",

				"}",

				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n"),

		vertexShader: [

			"attribute vec4 tangent;",

			"uniform vec2 uOffset;",
			"uniform vec2 uRepeat;",

			"uniform bool enableDisplacement;",

			"#ifdef VERTEX_TEXTURES",

				"uniform sampler2D tDisplacement;",
				"uniform float uDisplacementScale;",
				"uniform float uDisplacementBias;",

			"#endif",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],

				// normal, tangent and binormal vectors

				"#ifdef USE_SKINNING",

					"vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

					"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
					"vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

				"#else",

					"vNormal = normalize( normalMatrix * normal );",
					"vTangent = normalize( normalMatrix * tangent.xyz );",

				"#endif",

				"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

				"vUv = uv * uRepeat + uOffset;",

				// displacement mapping

				"vec3 displacedPosition;",

				"#ifdef VERTEX_TEXTURES",

					"if ( enableDisplacement ) {",

						"vec3 dv = texture2D( tDisplacement, uv ).xyz;",
						"float df = uDisplacementScale * dv.x + uDisplacementBias;",
						"displacedPosition = position + normalize( normal ) * df;",

					"} else {",

						"#ifdef USE_SKINNING",

							"vec4 skinVertex = vec4( position, 1.0 );",

							"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
							"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

							"displacedPosition  = skinned.xyz;",

						"#else",

							"displacedPosition = position;",

						"#endif",

					"}",

				"#else",

					"#ifdef USE_SKINNING",

						"vec4 skinVertex = vec4( position, 1.0 );",

						"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
						"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

						"displacedPosition  = skinned.xyz;",

					"#else",

						"displacedPosition = position;",

					"#endif",

				"#endif",

				//

				"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
				"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

				"gl_Position = projectionMatrix * mvPosition;",

				//

				"vWorldPosition = worldPosition.xyz;",
				"vViewPosition = -mvPosition.xyz;",

				// shadows

				"#ifdef USE_SHADOWMAP",

					"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

						"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

					"}",

				"#endif",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: -1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			"void main() {",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
				"vWorldPosition = worldPosition.xyz;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			"void main() {",

				"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

			"}"

		].join("\n")

	},

	// Depth encoding into RGBA texture
	// 	based on SpiderGL shadow map example
	// 		http://spidergl.org/example.php?id=6
	// 	originally from
	//		http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	// 	see also here:
	//		http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"vec4 pack_depth( const in float depth ) {",

				"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"vec4 res = fract( depth * bit_shift );",
				"res -= res.xxyz * bit_mask;",
				"return res;",

			"}",

			"void main() {",

				"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author bhouston / http://clara.io/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_buffers = {},

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	// public properties

	this.domElement = _canvas;
	this.context = null;
	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: self.devicePixelRatio !== undefined
					? self.devicePixelRatio
					: 1;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;
	this.autoUpdateObjects = true;

	// physically based shading

	this.gammaInput = true;
	this.gammaOutput = true;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapAutoUpdate = true;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// custom render plugins

	this.renderPluginsPre = [];
	this.renderPluginsPost = [];

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],
	_programs_counter = 0,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentGeometryGroupHash = null,
	_currentCamera = null,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	_enabledAttributes = new Uint8Array( 16 ),

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenMatrixPS = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),
	_width = new THREE.Vector3(),
	_height = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: new Array(), positions: new Array() },
		point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), decayExponents: new Array() },
		spot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), decayExponents: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },
		hemi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() },
		area: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), decayExponents: new Array(), widths: new Array(), heights: new Array() }

	};

	// initialize

	var _gl;

	var _glExtensionTextureFloat;
	var _glExtensionTextureFloatLinear;
	var _glExtensionStandardDerivatives;
	var _glExtensionTextureFilterAnisotropic;
	var _glExtensionCompressedTextureS3TC;

	initGL();

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

	var _supportsVertexTextures = ( _maxVertexTextures > 0 );
	var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;

	var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );
	var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );
	var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );

	var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );
	var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );
	var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === "highp" && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = "mediump";
			THREE.onwarning( "WebGLRenderer: highp not supported, using mediump" );

		} else {

			_precision = "lowp";
			THREE.onwarning( "WebGLRenderer: highp and mediump not supported, using lowp" );

		}

	}

	if ( _precision === "mediump" && ! mediumpAvailable ) {

		_precision = "lowp";
		THREE.onwarning( "WebGLRenderer: mediump not supported, using lowp" );

	}

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return _glExtensionTextureFloat;

	};

	this.supportsStandardDerivatives = function () {

		return _glExtensionStandardDerivatives;

	};

	this.supportsCompressedTextureS3TC = function () {

		return _glExtensionCompressedTextureS3TC;

	};

	this.getMaxAnisotropy  = function () {

		return _maxAnisotropy;

	};

	this.getPrecision = function () {

		return _precision;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * this.devicePixelRatio;
		_canvas.height = height * this.devicePixelRatio;

		if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * this.devicePixelRatio;
		_viewportY = y * this.devicePixelRatio;

		_viewportWidth = width * this.devicePixelRatio;
		_viewportHeight = height * this.devicePixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * this.devicePixelRatio,
			y * this.devicePixelRatio,
			width * this.devicePixelRatio,
			height * this.devicePixelRatio
		);

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		THREE.onwarning( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Plugins

	this.addPostPlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPost.push( plugin );

	};

	this.addPrePlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPre.push( plugin );

	};

	// Rendering

	this.updateShadowMap = function ( scene, camera ) {

		_currentProgram = null;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;

		this.shadowMapPlugin.update( scene, camera );

	};

	// Internal functions

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Events

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {

		if ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
		if ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
		if ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
		if ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );
		if ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );
		if ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );

		if ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
		if ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );

		if ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
		if ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );

		if ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );
		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var id in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );

			}

		}

		_this.info.memory.geometries --;

	};

	var deallocateGeometry = function ( geometry ) {

		geometry.__webglInit = undefined;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;

			for ( var key in attributes ) {

				if ( attributes[ key ].buffer !== undefined ) {

					_gl.deleteBuffer( attributes[ key ].buffer );
		
				}

			}

			_this.info.memory.geometries --;

		} else {

			if ( geometry.geometryGroups !== undefined ) {

				for ( var g in geometry.geometryGroups ) {

					var geometryGroup = geometry.geometryGroups[ g ];

					if ( geometryGroup.numMorphTargets !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

						}

					}

					if ( geometryGroup.numMorphNormals !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

						}

					}

					deleteBuffers( geometryGroup );

				}

			} else {

				deleteBuffers( geometry );

			}

		}

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

		} else {

			// 2D texture

			if ( ! texture.__webglInit ) return;

			texture.__webglInit = false;
			_gl.deleteTexture( texture.__webglTexture );

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( !renderTarget || ! renderTarget.__webglTexture ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

	};

	var deallocateMaterial = function ( material, optionalDisconnectedProgram ) {

		var program = optionalDisconnectedProgram || material.program;

		if ( program === undefined ) return;

		if( ! optionalDisconnectedProgram ) {
			material.program = undefined;
		}

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}
		
			_programs = newPrograms;
			
			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		var material = object.material;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				var attribute = material.attributes[ a ];

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if ( attribute.type === "v2" ) size = 2;
					else if ( attribute.type === "v3" ) size = 3;
					else if ( attribute.type === "v4" ) size = 4;
					else if ( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup ),

			uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );

		if ( normalType ) {

			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceVertexUvs.length > 0 ) {

				geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			}

			if ( geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		geometryGroup.__faceArray = new Uint16Array( ntris * 3 );
		geometryGroup.__lineArray = new Uint16Array( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__morphNormalsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ a ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if( attribute.type === "v2" ) size = 2;
					else if( attribute.type === "v3" ) size = 3;
					else if( attribute.type === "v4" ) size = 4;
					else if( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ geometryGroup.materialIndex ]
			: object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	function bufferGuessNormalType ( material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {

			return false;

		}

		if ( materialNeedsSmoothNormals( material ) ) {

			return THREE.SmoothShading;

		} else {

			return THREE.FlatShading;

		}

	};

	function bufferGuessVertexColorType( material ) {

		if ( material.vertexColors ) {

			return material.vertexColors;

		}

		return false;

	};

	function bufferGuessUVType( material ) {

		// material must use some texture to require uvs

		if ( material.map ||
		     material.opacityMap ||
		     material.lightMap ||
		     material.emissiveMap ||
		     material.bumpMap ||
		     material.normalMap ||
		     material.specularMap ||
		     material.reflectivityMap ||
		     material.roughnessMap ||
		     material.falloffMap ||
		     material.anisotropyMap ||
		     material.anisotropyRotationMap ||
		     material.metallicMap ||
		     material.translucencyMap ||
		     ( material.anisotropy && material.anisotropy !== 0.0 ) ||
		     material instanceof THREE.ShaderMaterial ) {

			return true;

		}

		return false;

	};

	//

	function initDirectBuffers( geometry ) {

		var a, attribute, type;

		for ( a in geometry.attributes ) {

			if ( a === "index" ) {

				type = _gl.ELEMENT_ARRAY_BUFFER;

			} else {

				type = _gl.ARRAY_BUFFER;

			}

			attribute = geometry.attributes[ a ];

			attribute.buffer = _gl.createBuffer();

			_gl.bindBuffer( type, attribute.buffer );
			_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );

		}

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.copy( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.copy( vertex );
				_vector3.applyProjection( _projScreenMatrixPS );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ sortArray[v][1] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c < cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[c][1] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
						   customAttribute.boundTo === "vertices") ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === "c" ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}


	};

	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
					   customAttribute.boundTo === "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	};

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType === THREE.SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors && vertexColorType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			var tmp = new THREE.Vector3( 0, 0, 0 );

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ] || tmp;
				t2 = vertexTangents[ 1 ] || tmp;
				t3 = vertexTangents[ 2 ] || tmp;

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals && normalType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};

	// used by renderBufferDirect for THREE.Line
	function setupLinesVertexAttributes( material, programAttributes, geometryAttributes, startIndex ) {

		var attributeItem, attributeName, attributePointer, attributeSize;

		for ( attributeName in programAttributes ) {

			attributePointer = programAttributes[ attributeName ];
			attributeItem = geometryAttributes[ attributeName ];
			
			if ( attributePointer >= 0 ) {

				if ( attributeItem ) {

					attributeSize = attributeItem.itemSize;
					_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
					enableAttribute( attributePointer );
					_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32

				} else if ( material.defaultAttributeValues ) {

					if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

						_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

					} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

						_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

					}

				}

			}

		}

	}

	function setDirectBuffers( geometry, hint ) {

		var attributes = geometry.attributes;

		var attributeName, attributeItem;

		for ( attributeName in attributes ) {

			attributeItem = attributes[ attributeName ];

			if ( attributeItem.needsUpdate ) {

				if ( attributeName === 'index' ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );
					_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );

				} else {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );

				}

				attributeItem.needsUpdate = false;

			}

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( material.shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ] 	 = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.uv );
			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.color );
			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var linewidth, a, attribute;
		var attributeItem, attributeName, attributePointer, attributeSize;

		var program = setProgram( camera, lights, fog, material, object );

		var programAttributes = program.attributes;
		var geometryAttributes = geometry.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var index = geometryAttributes[ "index" ];

			// indexed triangles

			if ( index ) {

				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets.length > 1 ) updateBuffers = true;

				for ( var i = 0, il = offsets.length; i < il; i ++ ) {

					var startIndex = offsets[ i ].index;

					if ( updateBuffers ) {

						for ( attributeName in programAttributes ) {

							attributePointer = programAttributes[ attributeName ];
							attributeItem = geometryAttributes[ attributeName ];

							if ( attributePointer >= 0 ) {

								if ( attributeItem ) {

									attributeSize = attributeItem.itemSize;
									_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
									enableAttribute( attributePointer );
									_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32

								} else if ( material.defaultAttributeValues ) {

									if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

										_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

									} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

										_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

									}

								}

							}

						}

						// indices

						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					// render indexed triangles

					_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16

					_this.info.render.calls ++;
					_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
					_this.info.render.faces += offsets[ i ].count / 3;

				}

			// non-indexed triangles

			} else {

				if ( updateBuffers ) {

					for ( attributeName in programAttributes ) {

						if ( attributeName === 'index') continue;

						attributePointer = programAttributes[ attributeName ];
						attributeItem = geometryAttributes[ attributeName ];
						
						if ( attributePointer >= 0 ) {

							if ( attributeItem ) {

								attributeSize = attributeItem.itemSize;
								_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
								enableAttribute( attributePointer );
								_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

							} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

								if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

									_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

								} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

									_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

								}

							}

						}

					}

				}

				var position = geometry.attributes[ "position" ];

				// render non-indexed triangles

				_gl.drawArrays( _gl.TRIANGLES, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.vertices += position.array.length / 3;
				_this.info.render.faces += position.array.length / 3 / 3;

			}

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			if ( updateBuffers ) {

				for ( attributeName in programAttributes ) {

					attributePointer = programAttributes[ attributeName ];
					attributeItem = geometryAttributes[ attributeName ];
					
					if ( attributePointer >= 0 ) {

						if ( attributeItem ) {

							attributeSize = attributeItem.itemSize;
							_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
							enableAttribute( attributePointer );
							_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

						} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

							if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

								_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

								_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							}

						}

					}

				}

			}

			var position = geometryAttributes[ "position" ];

			// render particles

			_gl.drawArrays( _gl.POINTS, 0, position.array.length / 3 );

			_this.info.render.calls ++;
			_this.info.render.points += position.array.length / 3;

		} else if ( object instanceof THREE.Line ) {

			var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			var index = geometryAttributes[ "index" ];

			// indexed lines
			
			if ( index ) {

				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets.length > 1 ) updateBuffers = true;

				for ( var i = 0, il = offsets.length; i < il; i ++ ) {

					var startIndex = offsets[ i ].index;

					if ( updateBuffers ) {

						setupLinesVertexAttributes(material, programAttributes, geometryAttributes, startIndex);

						// indices
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					// render indexed lines

					_gl.drawElements( _gl.LINES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16Array

					_this.info.render.calls ++;
					_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

				}

			}

			// non-indexed lines

			else {

				if ( updateBuffers ) {

					setupLinesVertexAttributes(material, programAttributes, geometryAttributes, 0);
				}

				var position = geometryAttributes[ "position" ];

				_gl.drawArrays( primitives, 0, position.array.length / 3 );
				_this.info.render.calls ++;
				_this.info.render.points += position.array.length;
			}



		}

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		var linewidth, a, attribute, i, il;

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// vertices

		if ( !material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[0] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[1] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			if ( material.skinning &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes.skinIndex );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes.skinWeight );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;
			_this.info.render.points += geometryGroup.__webglParticleCount;

		}

	};

	function enableAttribute( attribute ) {

		if ( _enabledAttributes[ attribute ] === 0 ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = 1;

		}

	};

	function disableAttributes() {

		for ( var attribute in _enabledAttributes ) {

			if ( _enabledAttributes[ attribute ] === 1 ) {

				_gl.disableVertexAttribArray( attribute );
				_enabledAttributes[ attribute ] = 0;

			}

		}

	};

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				if ( attributes[ "morphTarget" + m ] >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphTarget" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphNormal" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find the most influencing

			var influence, activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i < il; i ++ ) {

				influence = influences[ i ];

				if ( influence > 0 ) {

					activeInfluenceIndices.push( [ influence, i ] );

				}

			}

			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.push( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m < material.numSupportedMorphTargets ) {

				if ( activeInfluenceIndices[ m ] ) {

					influenceIndex = activeInfluenceIndices[ m ][ 1 ];

					if ( attributes[ "morphTarget" + m ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphTarget" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphNormal" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );


					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					/*
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}
					*/

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	};

	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	};

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	};


	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			THREE.onerror( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var i, il,

		webglObject, object,
		renderList,

		lights = scene.__lights,
		fog = scene.fog;

		// reset caching for this frame

		_currentMaterialId = -1;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// update WebGL objects

		if ( this.autoUpdateObjects ) this.initWebGLObjects( scene );

		// custom render plugins (pre pass)

		renderPlugins( this.renderPluginsPre, scene, camera );

		//

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;
		_this.info.render.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for regular objects (frustum culled)

		renderList = scene.__webglObjects;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			webglObject.id = i;
			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					setupMatrices( object, camera );

					unrollBufferMaterial( webglObject );

					webglObject.render = true;

					if ( this.sortObjects === true ) {

						if ( object.renderDepth !== null ) {

							webglObject.z = object.renderDepth;

						} else {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

							webglObject.z = _vector3.z;

						}

					}

				}

			}

		}

		if ( this.sortObjects ) {

			renderList.sort( painterSortStable );

		}

		// set matrices for immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( object, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;

			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			this.setDepthTest( material.depthTest );
			this.setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( scene.__webglObjects, false, "", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "", camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( scene.__webglObjects, true, "opaque", camera, lights, fog, false, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "opaque", camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( scene.__webglObjects, false, "transparent", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "transparent", camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		renderPlugins( this.renderPluginsPost, scene, camera );


		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

	function renderPlugins( plugins, scene, camera ) {

		if ( ! plugins.length ) return;

		for ( var i = 0, il = plugins.length; i < il; i ++ ) {

			// reset state for plugin (to start from clean slate)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

			plugins[ i ].render( scene, camera, _currentWidth, _currentHeight );

			// reset state after plugin (anything could have changed)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

		}

	};

	function renderObjects( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, buffer, material, start, end, delta;

		if ( reverse ) {

			start = renderList.length - 1;
			end = -1;
			delta = -1;

		} else {

			start = 0;
			end = renderList.length;
			delta = 1;
		}

		for ( var i = start; i !== end; i += delta ) {

			webglObject = renderList[ i ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.setMaterialFaces( material );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

				} else {

					_this.renderBuffer( camera, lights, fog, material, buffer, object );

				}

			}

		}

	};

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, material, program;

		for ( var i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	};

	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = -1;

		_this.setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	};

	function unrollBufferMaterial ( globject ) {

		var object = globject.object;
		var buffer = globject.buffer;

		var geometry = object.geometry;
		var material = object.material;

		if ( material instanceof THREE.MeshFaceMaterial ) {

			var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

			material = material.materials[ materialIndex ];

			if ( material.transparent ) {

				globject.transparent = material;
				globject.opaque = null;

			} else {

				globject.opaque = material;
				globject.transparent = null;

			}

		} else {

			if ( material ) {

				if ( material.transparent ) {

					globject.transparent = material;
					globject.opaque = null;

				} else {

					globject.opaque = material;
					globject.transparent = null;

				}

			}

		}

	};

	// Objects refresh

	this.initWebGLObjects = function ( scene ) {

		if ( !scene.__webglObjects ) {

			scene.__webglObjects = [];
			scene.__webglObjectsImmediate = [];
			scene.__webglSprites = [];
			scene.__webglFlares = [];

		}

		while ( scene.__objectsAdded.length ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.splice( 0, 1 );

		}

		while ( scene.__objectsRemoved.length ) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.splice( 0, 1 );

		}

		// update must be called after objects adding / removal

		for ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {

			var object = scene.__webglObjects[ o ].object;

			// TODO: Remove this hack (WebGLRenderer refactoring)

			if ( object.__webglInit === undefined ) {

				if ( object.__webglActive !== undefined ) {

					removeObject( object, scene );

				}

				addObject( object, scene );

			}

			updateObject( object );

		}

	};

	// Objects adding

	function addObject( object, scene ) {

		var g, geometry, material, geometryGroup;

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;

			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

			if ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {

				object.geometry.__webglInit = true;
				object.geometry.addEventListener( 'dispose', onGeometryDispose );

			}

			geometry = object.geometry;

			if ( geometry === undefined ) {

				// fail silently for now

			} else if ( geometry instanceof THREE.BufferGeometry ) {

				initDirectBuffers( geometry );

			} else if ( object instanceof THREE.Mesh ) {

				material = object.material;

				if ( geometry.geometryGroups === undefined ) {

					geometry.makeGroups( material instanceof THREE.MeshFaceMaterial );

				}

				// create separate VBOs per geometry chunk

				for ( g in geometry.geometryGroups ) {

					geometryGroup = geometry.geometryGroups[ g ];

					// initialise VBO on the first access

					if ( ! geometryGroup.__webglVertexBuffer ) {

						createMeshBuffers( geometryGroup );
						initMeshBuffers( geometryGroup, object );

						geometry.verticesNeedUpdate = true;
						geometry.morphTargetsNeedUpdate = true;
						geometry.elementsNeedUpdate = true;
						geometry.uvsNeedUpdate = true;
						geometry.normalsNeedUpdate = true;
						geometry.tangentsNeedUpdate = true;

						geometry.colorsNeedUpdate = true;

					}

				}

			} else if ( object instanceof THREE.Line ) {

				if ( ! geometry.__webglVertexBuffer ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object instanceof THREE.ParticleSystem ) {

				if ( ! geometry.__webglVertexBuffer ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined ) {

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( scene.__webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					for ( g in geometry.geometryGroups ) {

						geometryGroup = geometry.geometryGroups[ g ];

						addBuffer( scene.__webglObjects, geometryGroup, object );

					}

				}

			} else if ( object instanceof THREE.Line ||
						object instanceof THREE.ParticleSystem ) {

				geometry = object.geometry;
				addBuffer( scene.__webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( scene.__webglObjectsImmediate, object );

			} else if ( object instanceof THREE.Sprite ) {

				scene.__webglSprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				scene.__webglFlares.push( object );

			}

			object.__webglActive = true;

		}

	};

	function addBuffer( objlist, buffer, object ) {

		objlist.push(
			{
				id: null,
				buffer: buffer,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	// Objects updates

	function updateObject( object ) {

		var geometry = object.geometry,
			geometryGroup, customAttributesDirty, material;

		if ( geometry instanceof THREE.BufferGeometry ) {

			setDirectBuffers( geometry, _gl.DYNAMIC_DRAW );

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			for( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {

				geometryGroup = geometry.geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				if ( geometry.buffersNeedUpdate ) {

					initMeshBuffers( geometryGroup, object );

				}

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			geometry.buffersNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );


		} else if ( object instanceof THREE.ParticleSystem ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	};

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var a in material.attributes ) {

			if ( material.attributes[ a ].needsUpdate ) return true;

		}

		return false;

	};

	function clearCustomAttributes( material ) {

		for ( var a in material.attributes ) {

			material.attributes[ a ].needsUpdate = false;

		}

	};

	// Objects removal

	function removeObject( object, scene ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.ParticleSystem ||
			 object instanceof THREE.Line ) {

			removeInstances( scene.__webglObjects, object );

		} else if ( object instanceof THREE.Sprite ) {

			removeInstancesDirect( scene.__webglSprites, object );

		} else if ( object instanceof THREE.LensFlare ) {

			removeInstancesDirect( scene.__webglFlares, object );

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( scene.__webglObjectsImmediate, object );

		}

		delete object.__webglActive;

	};

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	function removeInstancesDirect( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ] === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	// Materials

	this.initMaterial = function ( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material instanceof THREE.MeshPhysicalMaterial ) {

			shaderID = 'physical';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			shaderID = 'dashed';

		} else if ( material instanceof THREE.ParticleSystemMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID ) {

			setMaterialShaders( material, THREE.ShaderLib[ shaderID ] );

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = allocateBones( object );

		parameters = {

			map: !!material.map,
			opacityMap: !!material.opacityMap,
			envMap: !!material.envMap,
			lightMap: !!material.lightMap,
			emissiveMap: !!material.emissiveMap,
			bumpMap: !!material.bumpMap,
			normalMap: !!material.normalMap,
			specularMap: !!material.specularMap,
			reflectivityMap: !!material.reflectivityMap,
			roughnessMap: !!material.roughnessMap,
			translucencyMap: !!material.translucencyMap,
			metallicMap: !!material.metallicMap,
			falloffMap: !!material.falloffMap,

			clearCoat: (( material.clearCoat !== undefined )&&( material.clearCoat !== 0 )),

			anisotropy: (( material.anisotropy !== undefined )&&( material.anisotropy !== 0 ))||( !! material.anisotropyMap ),
			anisotropyMap: !! material.anisotropyMap,
			anisotropyRotation: (( material.anisotropyRotation !== undefined )&&( material.anisotropyRotation !== 0 ))||( !! material.anisotropyRotationMap ),
			anisotropyRotationMap: !! material.anisotropyRotationMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: !! material.sizeAttenuation,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: this.maxMorphTargets,
			maxMorphNormals: this.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,
			maxAreaLights: maxLightCount.area,

			maxShadows: maxShadows,
			shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
			shadowMapType: this.shadowMapType,
			shadowMapDebug: this.shadowMapDebug,
			shadowMapCascade: this.shadowMapCascade,

			translucency: material.translucency && ( material.translucency.getHex() > 0 ),

			alphaTest: material.alphaTest,
			falloff: ( material.falloff || false ),
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};
		
		material.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName );

		var attributes = material.program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = "morphTarget";

			for ( i = 0; i < this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = "morphNormal";

			for ( i = 0; i < this.maxMorphNormals; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		for ( u in material.uniforms ) {

			material.uniformsList.push( [ material.uniforms[ u ], u ] );

		}

	};

	function setMaterialShaders( material, shaders ) {

		material.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );
		material.vertexShader = shaders.vertexShader;
		material.fragmentShader = shaders.fragmentShader;

	};

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			var oldProgram = material.program;

			_this.initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

			if ( oldProgram ) deallocateMaterial( material, oldProgram );


		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

			}

		}

		var refreshMaterial = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.uniforms;

		if ( program !== _currentProgram ) {

			_gl.useProgram( program );
			_currentProgram = program;

			refreshMaterial = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;
			refreshMaterial = true;

		}

		if ( refreshMaterial || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( camera !== _currentCamera ) _currentCamera = camera;

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( _supportsBoneTextures && object.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.boneTextureHeight );

				}

			} else {

				if ( p_uniforms.boneGlobalMatrices !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhysicalMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					setupLights( program, lights );
					_lightsNeedUpdate = false;

				}

				refreshUniformsLights( m_uniforms, _lights );

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhysicalMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.ParticleSystemMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

 			} else if ( material instanceof THREE.MeshPhysicalMaterial ) {

				refreshUniformsPhysical( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( program, material.uniformsList );

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshPhysicalMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhysicalMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	};

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.emissiveMap.value = material.emissiveMap;
	
		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.map ) {

			var map = material.map;
			uniforms.offsetRepeat.value.set( map.offset.x, map.offset.y, map.repeat.x, map.repeat.y );
			uniforms.gainBrightness.value.set( map.gainPivot, map.gain, map.brightness, 1.0 );

		}

		if ( material.specularMap ) {

			var specularMap = material.specularMap;
			uniforms.specularMap.value = specularMap;
			uniforms.specularOffsetRepeat.value.set( specularMap.offset.x, specularMap.offset.y, specularMap.repeat.x, specularMap.repeat.y );
			uniforms.specularGainBrightness.value.set( specularMap.gainPivot, specularMap.gain, specularMap.brightness, 1.0 );

		}

		if ( material.opacityMap ) {

			var opacityMap = material.opacityMap;
			uniforms.opacityMap.value = opacityMap;
			uniforms.opacityOffsetRepeat.value.set( opacityMap.offset.x, opacityMap.offset.y, opacityMap.repeat.x, opacityMap.repeat.y );
			uniforms.opacityGainBrightness.value.set( opacityMap.gainPivot, opacityMap.gain, opacityMap.brightness, 1.0 );

		}

		if ( material.bumpMap ) {

			var bumpMap = material.bumpMap;
			uniforms.bumpOffsetRepeat.value.set( bumpMap.offset.x, bumpMap.offset.y, bumpMap.repeat.x, bumpMap.repeat.y );
			//uniforms.bumpGainBrightness.value.set( bumpMap.gainPivot, bumpMap.gain, bumpMap.brightness, 1.0 );

		}

		if ( material.normalMap ) {

			var normalMap = material.normalMap;
			uniforms.normalOffsetRepeat.value.set( normalMap.offset.x, normalMap.offset.y, normalMap.repeat.x, normalMap.repeat.y );
			//uniforms.normalGainBrightness.value.set( normalMap.gainPivot, normalMap.gain, normalMap.brightness, 1.0 );

		}

		if ( material.anisotropyMap ) {

			var anisotropyMap = material.anisotropyMap;
			uniforms.anisotropyOffsetRepeat.value.set( anisotropyMap.offset.x, anisotropyMap.offset.y, anisotropyMap.repeat.x, anisotropyMap.repeat.y );
			uniforms.anisotropyGainBrightness.value.set( anisotropyMap.gainPivot, anisotropyMap.gain, anisotropyMap.brightness, 1.0 );

		}

		if ( material.anisotropyRotationMap ) {

			var anisotropyRotationMap = material.anisotropyRotationMap;
			uniforms.anisotropyRotationOffsetRepeat.value.set( anisotropyRotationMap.offset.x, anisotropyRotationMap.offset.y, anisotropyRotationMap.repeat.x, anisotropyRotationMap.repeat.y );
			uniforms.anisotropyRotationGainBrightness.value.set( anisotropyRotationMap.gainPivot, anisotropyRotationMap.gain, anisotropyRotationMap.brightness, 1.0 );

		}

		if ( material.roughnessMap ) {

			var roughnessMap = material.roughnessMap;
			uniforms.roughnessOffsetRepeat.value.set( roughnessMap.offset.x, roughnessMap.offset.y, roughnessMap.repeat.x, roughnessMap.repeat.y );
			uniforms.roughnessGainBrightness.value.set( roughnessMap.gainPivot, roughnessMap.gain, roughnessMap.brightness, 1.0 );

		}

		if ( material.metallicMap ) {

			var metallicMap = material.metallicMap;
			uniforms.metallicOffsetRepeat.value.set( metallicMap.offset.x, metallicMap.offset.y, metallicMap.repeat.x, metallicMap.repeat.y );
			uniforms.metallicGainBrightness.value.set( metallicMap.gainPivot, metallicMap.gain, metallicMap.brightness, 1.0 );

		}
		
		if ( material.translucencyMap ) {

			var translucencyMap = material.translucencyMap;
			uniforms.translucencyMap.value = translucencyMap;
			//uniforms.translucencyOffsetRepeat.value.set( translucencyMap.offset.x, translucencyMap.offset.y, translucencyMap.repeat.x, translucencyMap.repeat.y );
			//uniforms.translucencyGainBrightness.value.set( translucencyMap.gainPivot, translucencyMap.gain, translucencyMap.brightness, 1.0 );

		}
		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	};

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	};

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	};

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

	};

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	};

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.opacityMap.value = material.opacityMap;

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsPhysical ( uniforms, material ) {

		uniforms.opacityMap.value = material.opacityMap;

		uniforms.falloffBlendParams.value = material.falloffBlendParams;
		uniforms.falloffMap.value = material.falloffMap;

		uniforms.roughness.value = material.roughness;
		uniforms.metallic.value = material.metallic;

		uniforms.clearCoat.value = material.clearCoat;
		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

		uniforms.roughnessMap.value = material.roughnessMap;
		uniforms.metallicMap.value = material.metallicMap;

		uniforms.translucencyMap.value = material.translucencyMap;
		uniforms.translucencyNormalAlpha.value = material.translucencyNormalAlpha;
		uniforms.translucencyNormalPower.value = material.translucencyNormalPower;
		uniforms.translucencyViewAlpha.value = material.translucencyViewAlpha;
		uniforms.translucencyViewPower.value = material.translucencyViewPower;

		uniforms.anisotropyMap.value = material.anisotropyMap;
		uniforms.anisotropy.value = material.anisotropy;
		uniforms.anisotropyRotation.value = material.anisotropyRotation;
		uniforms.anisotropyRotationMap.value = material.anisotropyRotationMap;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.falloffColor.value.copyGammaToLinear( material.falloffColor );
			uniforms.specular.value.copyGammaToLinear( material.specular );
			uniforms.translucency.value.copyGammaToLinear( material.translucency );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.falloffColor.value = material.falloffColor;
			uniforms.specular.value = material.specular;
			uniforms.translucency.value = material.translucency;

		}

	};

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;
		uniforms.pointLightDecayExponent.value = lights.point.decayExponents;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDecayExponent.value = lights.spot.decayExponents;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

		uniforms.areaLightColor.value = lights.area.colors;
		uniforms.areaLightPosition.value = lights.area.positions;
		uniforms.areaLightDistance.value = lights.area.distances;
		uniforms.areaLightDecayExponent.value = lights.area.decayExponents;
		uniforms.areaLightWidth.value = lights.area.widths;
		uniforms.areaLightHeight.value = lights.area.heights;

	};

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	};

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	};

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			THREE.onwarning( "WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	};

	function loadUniformsGeneric ( program, uniforms ) {

		var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;

		for ( j = 0, jl = uniforms.length; j < jl; j ++ ) {

			location = program.uniforms[ uniforms[ j ][ 1 ] ];
			if ( !location ) continue;

			uniform = uniforms[ j ][ 0 ];

			type = uniform.type;
			value = uniform.value;

			if ( type === "i" ) { // single integer

				_gl.uniform1i( location, value );

			} else if ( type === "f" ) { // single float

				_gl.uniform1f( location, value );

			} else if ( type === "v2" ) { // single THREE.Vector2

				_gl.uniform2f( location, value.x, value.y );

			} else if ( type === "v3" ) { // single THREE.Vector3

				_gl.uniform3f( location, value.x, value.y, value.z );

			} else if ( type === "v4" ) { // single THREE.Vector4

				_gl.uniform4f( location, value.x, value.y, value.z, value.w );

			} else if ( type === "c" ) { // single THREE.Color

				_gl.uniform3f( location, value.r, value.g, value.b );

			} else if ( type === "iv1" ) { // flat array of integers (JS or typed array)

				_gl.uniform1iv( location, value );

			} else if ( type === "iv" ) { // flat array of integers with 3 x N size (JS or typed array)

				_gl.uniform3iv( location, value );

			} else if ( type === "fv1" ) { // flat array of floats (JS or typed array)

				_gl.uniform1fv( location, value );

			} else if ( type === "fv" ) { // flat array of floats with 3 x N size (JS or typed array)

				_gl.uniform3fv( location, value );

			} else if ( type === "v2v" ) { // array of THREE.Vector2

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 2 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 2;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;

				}

				_gl.uniform2fv( location, uniform._array );

			} else if ( type === "v3v" ) { // array of THREE.Vector3

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 3 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 3;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;

				}

				_gl.uniform3fv( location, uniform._array );

			} else if ( type === "v4v" ) { // array of THREE.Vector4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 4 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 4;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;
					uniform._array[ offset + 3 ] = value[ i ].w;

				}

				_gl.uniform4fv( location, uniform._array );

			} else if ( type === "m4") { // single THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 );

				}

				value.flattenToArray( uniform._array );
				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "m4v" ) { // array of THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

				}

				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "t" ) { // single THREE.Texture (2d or cube)

				texture = value;
				textureUnit = getTextureUnit();

				_gl.uniform1i( location, textureUnit );

				if ( !texture ) continue;

				if ( texture.image instanceof Array && texture.image.length === 6 ) {

					setCubeTexture( texture, textureUnit );

				} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

					setCubeTextureDynamic( texture, textureUnit );

				} else {

					_this.setTexture( texture, textureUnit );

				}

			} else if ( type === "tv" ) { // array of THREE.Texture (2d)

				if ( uniform._array === undefined ) {

					uniform._array = [];

				}

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					uniform._array[ i ] = getTextureUnit();

				}

				_gl.uniform1iv( location, uniform._array );

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					texture = uniform.value[ i ];
					textureUnit = uniform._array[ i ];

					if ( !texture ) continue;

					_this.setTexture( texture, textureUnit );

				}

			} else {

				THREE.onwarning( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	};

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

	};

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	};

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	};

	function setupLights ( program, lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,
		pointDecayExponents = zlights.point.decayExponents,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDecayExponents = zlights.spot.decayExponents,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		areaColors = zlights.area.colors,
		areaPositions = zlights.area.positions,
		areaDistances = zlights.area.distances,
		areaDecayExponents = zlights.area.decayExponents,
		areaWidths = zlights.area.widths,
		areaHeights = zlights.area.heights,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,
		areaLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,
		areaCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0,
		areaOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;
				pointDecayExponents[ pointLength ] = light.decayExponent;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				spotPositions[ spotOffset ]     = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;
				spotDecayExponents[ spotLength ] = light.decayExponent;

				_direction.copy( _vector3 );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			} else if ( light instanceof THREE.AreaLight ) {

				areaCount += 1;

				if ( ! light.visible ) continue;

				areaOffset = areaLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( areaColors, areaOffset, color, intensity * intensity );

				} else {

					setColorLinear( areaColors, areaOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				areaPositions[ areaOffset ]     = _vector3.x;
				areaPositions[ areaOffset + 1 ] = _vector3.y;
				areaPositions[ areaOffset + 2 ] = _vector3.z;

				areaDistances[ areaLength ] = distance;
				areaDecayExponents[ areaLength ] = light.decayExponent;

				light.matrixWorld.extractBasis( _width, _height, _vector3 );
				_width.multiplyScalar( light.width );
				_height.multiplyScalar( light.height );

				areaWidths[ areaOffset ]     = _width.x;
				areaWidths[ areaOffset + 1 ] = _width.y;
				areaWidths[ areaOffset + 2 ] = _width.z;

				areaHeights[ areaOffset ]     = _height.x;
				areaHeights[ areaOffset + 1 ] = _height.y;
				areaHeights[ areaOffset + 2 ] = _height.z;

				areaLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;
		for ( l = areaLength * 3, ll = Math.max( areaColors.length, areaCount * 3 ); l < ll; l ++ ) areaColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;
		zlights.area.length = areaLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	};

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	};

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};

	// Defines

	function generateDefines ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	// Shaders

	function buildProgram( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName ) {

		var p, pl, d, program, code;
		var chunks = [];

		// Generate code

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( fragmentShader );
			chunks.push( vertexShader );

		}

		for ( d in defines ) {

			chunks.push( d );
			chunks.push( defines[ d ] );

		}

		for ( p in parameters ) {

			chunks.push( p );
			chunks.push( parameters[ p ] );

		}

		code = chunks.join();

		// Check if code has been already compiled

		for ( p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code.length === code.length && programInfo.code === code ) {

				programInfo.usedTimes ++;

				return programInfo.program;

			}

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		var customDefines = generateDefines( defines );

		program = _gl.createProgram();

		var prefix_vertex = [

			"precision " + _precision + " float;",
			"precision " + _precision + " int;",

			customDefines,

			_supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,
			"#define MAX_AREA_LIGHTS " + parameters.maxAreaLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			"#define MAX_BONES " + parameters.maxBones,

			parameters.map ? "#define USE_MAP" : "",
			parameters.opacityMap ? "#define USE_OPACITYMAP" : "",
			parameters.falloffMap ? "#define USE_FALLOFFMAP" : "",
			parameters.translucencyMap ? "#define USE_TRANSLUCENCYMAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.reflectivityMap ? "#define USE_REFLECTIVITYMAP" : "",
			parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
			parameters.metallicMap ? "#define USE_METALLICMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",
			parameters.clearCoat ? "#define CLEARCOAT" : "",

			parameters.anisotropy ? "#define ANISOTROPY" : "",
			parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
			( parameters.anisotropy && parameters.anisotropyRotation ) ? "#define ANISOTROPYROTATION" : "",
			( parameters.anisotropy && parameters.anisotropyRotationMap ) ? "#define USE_ANISOTROPYROTATIONMAP" : "",

			parameters.skinning ? "#define USE_SKINNING" : "",
			parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

			parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
			parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

			"uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",

			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"attribute vec2 uv2;",

			"#ifdef USE_COLOR",

				"attribute vec3 color;",

			"#endif",

			"#ifdef USE_MORPHTARGETS",

				"attribute vec3 morphTarget0;",
				"attribute vec3 morphTarget1;",
				"attribute vec3 morphTarget2;",
				"attribute vec3 morphTarget3;",

				"#ifdef USE_MORPHNORMALS",

					"attribute vec3 morphNormal0;",
					"attribute vec3 morphNormal1;",
					"attribute vec3 morphNormal2;",
					"attribute vec3 morphNormal3;",

				"#else",

					"attribute vec3 morphTarget4;",
					"attribute vec3 morphTarget5;",
					"attribute vec3 morphTarget6;",
					"attribute vec3 morphTarget7;",

				"#endif",

			"#endif",

			"#ifdef USE_SKINNING",

				"attribute vec4 skinIndex;",
				"attribute vec4 skinWeight;",

			"#endif",

			""

		].join("\n");

	
		var prefix_fragment = [

			"precision " + _precision + " float;",
			"precision " + _precision + " int;",

			( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

			customDefines,

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,
			"#define MAX_AREA_LIGHTS " + parameters.maxAreaLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

			( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
			( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

			parameters.map ? "#define USE_MAP" : "",
			parameters.opacityMap ? "#define USE_OPACITYMAP" : "",
			parameters.falloffMap ? "#define USE_FALLOFFMAP" : "",
			parameters.translucencyMap ? "#define USE_TRANSLUCENCYMAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.reflectivityMap ? "#define USE_REFLECTIVITYMAP" : "",
			parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
			parameters.metallicMap ? "#define USE_METALLICMAP" : "",	
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",
			parameters.clearCoat ? "#define CLEARCOAT" : "",

			parameters.translucency ? "#define TRANSLUCENCY" : "",

			parameters.anisotropy ? "#define ANISOTROPY" : "",
			parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
			( parameters.anisotropy && parameters.anisotropyRotation ) ? "#define ANISOTROPYROTATION" : "",
			( parameters.anisotropy && parameters.anisotropyRotationMap ) ? "#define USE_ANISOTROPYROTATIONMAP" : "",

			parameters.falloff ? "#define FALLOFF" : "",

			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			""

		].join("\n");

		var glVertexShader = getShader( "vertex", prefix_vertex + vertexShader );
		var glFragmentShader = getShader( "fragment", prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.
		// because potentially expensive emulation is done by browser if attribute 0 is disabled.
		// And, color, for example is often automatically bound to index 0 so disabling it
		if ( index0AttributeName !== undefined ) {

			_gl.bindAttribLocation( program, 0, index0AttributeName );

		}

		_gl.linkProgram( program );

		var programLogInfo = _gl.getProgramInfoLog( program );

		if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

			THREE.onerror( shaderID + ' shader program error: ' + _gl.getError() + '\n' + programLogInfo, { validationStatus: _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) } );

		}

		// clean up

		_gl.deleteShader( glFragmentShader );
		_gl.deleteShader( glVertexShader );

		program.uniforms = {};
		program.attributes = {};

		var identifiers, u, a, i;

		// cache uniform locations

		identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'morphTargetInfluences'

		];

		if ( parameters.useVertexTexture ) {

			identifiers.push( 'boneTexture' );
			identifiers.push( 'boneTextureWidth' );
			identifiers.push( 'boneTextureHeight' );

		} else {

			identifiers.push( 'boneGlobalMatrices' );

		}

		for ( u in uniforms ) {

			identifiers.push( u );

		}

		cacheUniformLocations( program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( "morphTarget" + i );

		}

		for ( i = 0; i < parameters.maxMorphNormals; i ++ ) {

			identifiers.push( "morphNormal" + i );

		}

		for ( a in attributes ) {

			identifiers.push( a );

		}

		cacheAttributeLocations( program, identifiers );

		program.id = _programs_counter ++;

		_programs.push( { program: program, code: code, usedTimes: 1 } );

		_this.info.memory.programs = _programs.length;

		return program;

	};

	// Shader parameters cache

	function cacheUniformLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.uniforms[ id ] = _gl.getUniformLocation( program, id );

		}

	};

	function cacheAttributeLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.attributes[ id ] = _gl.getAttribLocation( program, id );

		}

	};

	function addLineNumbers ( string ) {

		var chunks = string.split( "\n" );

		for ( var i = 0, il = chunks.length; i < il; i ++ ) {

			// Chrome reports shader errors on lines
			// starting counting from 1

			chunks[ i ] = ( i + 1 ) + ": " + chunks[ i ];

		}

		return chunks.join( "\n" );

	};

	function getShader ( type, string ) {

		var shader;

		if ( type === "fragment" ) {

			shader = _gl.createShader( _gl.FRAGMENT_SHADER );

		} else if ( type === "vertex" ) {

			shader = _gl.createShader( _gl.VERTEX_SHADER );

		}

		_gl.shaderSource( shader, string );
		_gl.compileShader( shader );

		if ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {

			THREE.onerror( "shader error", { shaderInfoLog: _gl.getShaderInfoLog( shader ), shaderCode: addLineNumbers( string ) } );
			return null;

		}

		return shader;

	};

	// Textures

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		if ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	};

	this.setTexture = function ( texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( ! texture.__webglInit ) {

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = texture.image,
			isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					if ( texture.format!==THREE.RGBAFormat ) {
						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
					} else {
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
					}

				}

			} else { // regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate ) texture.onUpdate();

		} else {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width <= maxSize && image.height <= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = Math.floor( image.width * maxSize / maxDimension );
		var newHeight = Math.floor( image.height * maxSize / maxDimension );

		var canvas = document.createElement( 'canvas' );
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.getContext( "2d" );
		ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if( !isCompressed ) {

						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

					} else {
						
						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];
							if ( texture.format!==THREE.RGBAFormat ) {

								_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {
								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
							}

						}
					}
				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	};

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	};

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	};

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	};

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && ! renderTarget.__webglFramebuffer ) {

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	};

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		if ( _glExtensionCompressedTextureS3TC !== undefined ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		return 0;

	};

	// Allocations

	function allocateBones ( object ) {

		if ( _supportsBoneTextures && object && object.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			// 	- leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.bones.length, maxBones );

				if ( maxBones < object.bones.length ) {

					THREE.onwarning( "WebGLRenderer: too many bones - " + object.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)" );

				}

			}

			return maxBones;

		}

	};

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;
		var areaLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow || light.visible === false ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;
			if ( light instanceof THREE.AreaLight ) areaLights ++;

		}

		return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights, 'area': areaLights };

	};

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	};

	// Initialization

	function initGL() {

		try {

			var attributes = {
				alpha: _alpha,
				premultipliedAlpha: _premultipliedAlpha,
				antialias: _antialias,
				stencil: _stencil,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				THREE.onerror( 'Error creating WebGL context.' );

			}

		} catch ( error ) {

			THREE.onerror( error );

		}

		_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
		_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );
		_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );

		_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );

		_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );

		if ( ! _glExtensionTextureFloat ) {

			console.log( 'THREE.WebGLRenderer: Float textures not supported.' );

		}

		if ( ! _glExtensionStandardDerivatives ) {

			console.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );

		}

		if ( ! _glExtensionTextureFilterAnisotropic ) {

			console.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );

		}

		if ( ! _glExtensionCompressedTextureS3TC ) {

			console.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );

		}

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function() {

				return {
					"rangeMin"  : 1,
					"rangeMax"  : 1,
					"precision" : 1
				};

			}
		}

	};

	function setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
		
		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	// default plugins (order is important)

	this.shadowMapPlugin = new THREE.ShadowMapPlugin();
	this.addPrePlugin( this.shadowMapPlugin );

	this.addPostPlugin( new THREE.SpritePlugin() );
	this.addPostPlugin( new THREE.LensFlarePlugin() );

};

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.generateMipmaps = true;

	this.shareDepthFrom = null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	clone: function () {

		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.offset.copy( this.offset );
		tmp.repeat.copy( this.repeat );

		tmp.format = this.format;
		tmp.type = this.type;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		tmp.generateMipmaps = this.generateMipmaps;

		tmp.shareDepthFrom = this.shareDepthFrom;

		return tmp;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableVertex = function () {

	this.position = new THREE.Vector3();
	this.positionWorld = new THREE.Vector3();
	this.positionScreen = new THREE.Vector4();

	this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function ( vertex ) {

	this.positionWorld.copy( vertex.positionWorld );
	this.positionScreen.copy( vertex.positionScreen );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableFace = function () {

	this.id = 0;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();
	this.v3 = new THREE.RenderableVertex();

	this.centroidModel = new THREE.Vector3();

	this.normalModel = new THREE.Vector3();

	this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	this.vertexNormalsLength = 0;

	this.color = null;
	this.material = null;
	this.uvs = [[]];

	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableObject = function () {

	this.id = 0;

	this.object = null;
	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableSprite = function () {

	this.id = 0;

	this.object = null;

	this.x = 0;
	this.y = 0;
	this.z = 0;

	this.rotation = 0;
	this.scale = new THREE.Vector2();

	this.material = null;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableLine = function () {

	this.id = 0;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();

	this.vertexColors = [ new THREE.Color(), new THREE.Color() ];
	this.material = null;

	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.GeometryUtils = {

	// Merge two geometries or geometry and geometry from object (using object's transform)

	merge: function ( geometry1, object2 /* mesh | geometry */, materialIndexOffset ) {

		var matrix, normalMatrix,
		vertexOffset = geometry1.vertices.length,
		uvPosition = geometry1.faceVertexUvs[ 0 ].length,
		geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,
		vertices1 = geometry1.vertices,
		vertices2 = geometry2.vertices,
		faces1 = geometry1.faces,
		faces2 = geometry2.faces,
		uvs1 = geometry1.faceVertexUvs[ 0 ],
		uvs2 = geometry2.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( object2 instanceof THREE.Mesh ) {

			object2.matrixAutoUpdate && object2.updateMatrix();

			matrix = object2.matrix;

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faceCopy.centroid.copy( face.centroid );

			if ( matrix ) {

				faceCopy.centroid.applyMatrix4( matrix );

			}

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			uvs1.push( uvCopy );

		}

	},

	// Get random point in triangle (via barycentric coordinates)
	// 	(uniform distribution)
	// 	http://www.cgafaq.info/wiki/Random_Point_In_Triangle

	randomPointInTriangle: function () {

		var vector = new THREE.Vector3();

		return function ( vectorA, vectorB, vectorC ) {

			var point = new THREE.Vector3();

			var a = THREE.Math.random16();
			var b = THREE.Math.random16();

			if ( ( a + b ) > 1 ) {

				a = 1 - a;
				b = 1 - b;

			}

			var c = 1 - a - b;

			point.copy( vectorA );
			point.multiplyScalar( a );

			vector.copy( vectorB );
			vector.multiplyScalar( b );

			point.add( vector );

			vector.copy( vectorC );
			vector.multiplyScalar( c );

			point.add( vector );

			return point;

		};

	}(),

	// Get random point in face (triangle / quad)
	// (uniform distribution)

	randomPointInFace: function ( face, geometry, useCachedAreas ) {

		var vA, vB, vC, vD;

		vA = geometry.vertices[ face.a ];
		vB = geometry.vertices[ face.b ];
		vC = geometry.vertices[ face.c ];

		return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );

	},

	// Get uniformly distributed random points in mesh
	// 	- create array with cumulative sums of face areas
	//  - pick random number from 0 to total area
	//  - find corresponding place in area array by binary search
	//	- get random point in face

	randomPointsInGeometry: function ( geometry, n ) {

		var face, i,
			faces = geometry.faces,
			vertices = geometry.vertices,
			il = faces.length,
			totalArea = 0,
			cumulativeAreas = [],
			vA, vB, vC, vD;

		// precompute face areas

		for ( i = 0; i < il; i ++ ) {

			face = faces[ i ];

			vA = vertices[ face.a ];
			vB = vertices[ face.b ];
			vC = vertices[ face.c ];

			face._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );

			totalArea += face._area;

			cumulativeAreas[ i ] = totalArea;

		}

		// binary search cumulative areas array

		function binarySearchIndices( value ) {

			function binarySearch( start, end ) {

				// return closest larger index
				// if exact number is not found

				if ( end < start )
					return start;

				var mid = start + Math.floor( ( end - start ) / 2 );

				if ( cumulativeAreas[ mid ] > value ) {

					return binarySearch( start, mid - 1 );

				} else if ( cumulativeAreas[ mid ] < value ) {

					return binarySearch( mid + 1, end );

				} else {

					return mid;

				}

			}

			var result = binarySearch( 0, cumulativeAreas.length - 1 )
			return result;

		}

		// pick random face weighted by face area

		var r, index,
			result = [];

		var stats = {};

		for ( i = 0; i < n; i ++ ) {

			r = THREE.Math.random16() * totalArea;

			index = binarySearchIndices( r );

			result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );

			if ( ! stats[ index ] ) {

				stats[ index ] = 1;

			} else {

				stats[ index ] += 1;

			}

		}

		return result;

	},

	// Get triangle area (half of parallelogram)
	//	http://mathworld.wolfram.com/TriangleArea.html

	triangleArea: function () {

		var vector1 = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function ( vectorA, vectorB, vectorC ) {

			vector1.subVectors( vectorB, vectorA );
			vector2.subVectors( vectorC, vectorA );
			vector1.cross( vector2 );

			return 0.5 * vector1.length();

		};

	}(),

	// Center geometry so that 0,0,0 is in center of bounding box

	center: function ( geometry ) {

		geometry.computeBoundingBox();

		var bb = geometry.boundingBox;

		var offset = new THREE.Vector3();

		offset.addVectors( bb.min, bb.max );
		offset.multiplyScalar( -0.5 );

		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
		geometry.computeBoundingBox();

		return offset;

	},

	triangulateQuads: function ( geometry ) {

		var i, il, j, jl;

		var faces = [];
		var faceVertexUvs = [];

		for ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

			faceVertexUvs[ i ] = [];

		}

		for ( i = 0, il = geometry.faces.length; i < il; i ++ ) {

			var face = geometry.faces[ i ];

			faces.push( face );

			for ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {

				faceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );

			}

		}

		geometry.faces = faces;
		geometry.faceVertexUvs = faceVertexUvs;

		geometry.computeCentroids();
		geometry.computeFaceNormals();
		geometry.computeVertexNormals();

		if ( geometry.hasTangents ) geometry.computeTangents();

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.Texture( undefined, mapping );

		var image = loader.load( url, function () {

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		} );

		texture.image = image;
		texture.sourceFile = url;

		return texture;

	},

	loadCompressedTexture: function ( url, mapping, onLoad, onError ) {

		var texture = new THREE.CompressedTexture();
		texture.mapping = mapping;

		var request = new XMLHttpRequest();

		request.onload = function () {

			var buffer = request.response;
			var dds = THREE.ImageUtils.parseDDS( buffer, true );

			texture.format = dds.format;

			texture.mipmaps = dds.mipmaps;
			texture.image.width = dds.width;
			texture.image.height = dds.height;

			// gl.generateMipmap fails for compressed textures
			// mipmaps must be embedded in the DDS file
			// or texture filters must not use mipmapping

			texture.generateMipmaps = false;

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		}

		request.onerror = onError;

		request.open( 'GET', url, true );
		request.responseType = "arraybuffer";
		request.send( null );

		return texture;

	},

	loadTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.Texture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping needed for cube textures

		texture.flipY = false;

		for ( var i = 0, il = array.length; i < il; ++ i ) {

			var cubeImage = new Image();
			images[ i ] = cubeImage;

			cubeImage.onload = function () {

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			};

			cubeImage.onerror = onError;

			cubeImage.crossOrigin = this.crossOrigin;
			cubeImage.src = array[ i ];

		}

		return texture;

	},

	loadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.CompressedTexture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		texture.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		texture.generateMipmaps = false;

		var generateCubeFaceCallback = function ( rq, img ) {

			return function () {

				var buffer = rq.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				img.format = dds.format;

				img.mipmaps = dds.mipmaps;
				img.width = dds.width;
				img.height = dds.height;

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

		}

		// compressed cubemap textures as 6 separate DDS files

		if ( array instanceof Array ) {

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				var cubeImage = {};
				images[ i ] = cubeImage;

				var request = new XMLHttpRequest();

				request.onload = generateCubeFaceCallback( request, cubeImage );
				request.onerror = onError;

				var url = array[ i ];

				request.open( 'GET', url, true );
				request.responseType = "arraybuffer";
				request.send( null );

			}

		// compressed cubemap texture stored in a single DDS file

		} else {

			var url = array;
			var request = new XMLHttpRequest();

			request.onload = function( ) {

				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				if ( dds.isCubemap ) {

					var faces = dds.mipmaps.length / dds.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < dds.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
							images[ f ].format = dds.format;
							images[ f ].width = dds.width;
							images[ f ].height = dds.height;

						}

					}

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

			request.onerror = onError;

			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );

		}

		return texture;

	},

	loadDDSTexture: function ( url, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.CompressedTexture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		texture.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		texture.generateMipmaps = false;

		{
			var request = new XMLHttpRequest();

			request.onload = function( ) {

				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				if ( dds.isCubemap ) {

					var faces = dds.mipmaps.length / dds.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < dds.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
							images[ f ].format = dds.format;
							images[ f ].width = dds.width;
							images[ f ].height = dds.height;

						}

					}


				} else {
					texture.image.width = dds.width;
					texture.image.height = dds.height;
					texture.mipmaps = dds.mipmaps;
				}

				texture.format = dds.format;
				texture.needsUpdate = true;
				if ( onLoad ) onLoad( texture );

			}

			request.onerror = onError;

			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );

		}

		return texture;

	},

	parseDDS: function ( buffer, loadMipmaps ) {

		var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

		// Adapted from @toji's DDS utils
		//	https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

		// All values and structures referenced from:
		// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

		var DDS_MAGIC = 0x20534444;

		var DDSD_CAPS = 0x1,
			DDSD_HEIGHT = 0x2,
			DDSD_WIDTH = 0x4,
			DDSD_PITCH = 0x8,
			DDSD_PIXELFORMAT = 0x1000,
			DDSD_MIPMAPCOUNT = 0x20000,
			DDSD_LINEARSIZE = 0x80000,
			DDSD_DEPTH = 0x800000;

		var DDSCAPS_COMPLEX = 0x8,
			DDSCAPS_MIPMAP = 0x400000,
			DDSCAPS_TEXTURE = 0x1000;

		var DDSCAPS2_CUBEMAP = 0x200,
			DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
			DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
			DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
			DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
			DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
			DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
			DDSCAPS2_VOLUME = 0x200000;

		var DDPF_ALPHAPIXELS = 0x1,
			DDPF_ALPHA = 0x2,
			DDPF_FOURCC = 0x4,
			DDPF_RGB = 0x40,
			DDPF_YUV = 0x200,
			DDPF_LUMINANCE = 0x20000;

		function fourCCToInt32( value ) {

			return value.charCodeAt(0) +
				(value.charCodeAt(1) << 8) +
				(value.charCodeAt(2) << 16) +
				(value.charCodeAt(3) << 24);

		}

		function int32ToFourCC( value ) {

			return String.fromCharCode(
				value & 0xff,
				(value >> 8) & 0xff,
				(value >> 16) & 0xff,
				(value >> 24) & 0xff
			);
		}

		function loadARGBMip( buffer, dataOffset, width, height ) {
			var dataLength = width*height*4;
			var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
			var byteArray = new Uint8Array( dataLength );
			var dst = 0;
			var src = 0;
			for ( var y = 0; y < height; y++ ) {
				for ( var x = 0; x < width; x++ ) {
					var b = srcBuffer[src]; src++;
					var g = srcBuffer[src]; src++;
					var r = srcBuffer[src]; src++;
					var a = srcBuffer[src]; src++;
					byteArray[dst] = r; dst++;	//r
					byteArray[dst] = g; dst++;	//g
					byteArray[dst] = b; dst++;	//b
					byteArray[dst] = a; dst++;	//a
				}
			}
			return byteArray;
		}

		var FOURCC_DXT1 = fourCCToInt32("DXT1");
		var FOURCC_DXT3 = fourCCToInt32("DXT3");
		var FOURCC_DXT5 = fourCCToInt32("DXT5");

		var headerLengthInt = 31; // The header length in 32 bit ints

		// Offsets into the header array

		var off_magic = 0;

		var off_size = 1;
		var off_flags = 2;
		var off_height = 3;
		var off_width = 4;

		var off_mipmapCount = 7;

		var off_pfFlags = 20;
		var off_pfFourCC = 21;
		var off_RGBBitCount = 22;
		var off_RBitMask = 23;
		var off_GBitMask = 24;
		var off_BBitMask = 25;
		var off_ABitMask = 26;

		var off_caps = 27;
		var off_caps2 = 28;
		var off_caps3 = 29;
		var off_caps4 = 30;

		// Parse header

		var header = new Int32Array( buffer, 0, headerLengthInt );

		if ( header[ off_magic ] !== DDS_MAGIC ) {

			THREE.onerror( "ImageUtils.parseDDS(): Invalid magic number in DDS header" );
			return dds;

		}

		if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

			THREE.onerror( "ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code" );
			return dds;

		}

		var blockBytes;

		var fourCC = header[ off_pfFourCC ];

		var isRGBAUncompressed = false;

		switch ( fourCC ) {

			case FOURCC_DXT1:

				blockBytes = 8;
				dds.format = THREE.RGB_S3TC_DXT1_Format;
				break;

			case FOURCC_DXT3:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT3_Format;
				break;

			case FOURCC_DXT5:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT5_Format;
				break;

			default:

				if( header[off_RGBBitCount] ==32 
					&& header[off_RBitMask]&0xff0000
					&& header[off_GBitMask]&0xff00 
					&& header[off_BBitMask]&0xff
					&& header[off_ABitMask]&0xff000000  ) {
					isRGBAUncompressed = true;
					blockBytes = 64;
					dds.format = THREE.RGBAFormat;
				} else {
					THREE.onerror( "ImageUtils.parseDDS(): Unsupported FourCC code: ", int32ToFourCC( fourCC ) );
					return dds;
				}
		}

		dds.mipmapCount = 1;

		if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

			dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

		}

		//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.

		dds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;

		dds.width = header[ off_width ];
		dds.height = header[ off_height ];

		var dataOffset = header[ off_size ] + 4;

		// Extract mipmaps buffers

		var width = dds.width;
		var height = dds.height;

		var faces = dds.isCubemap ? 6 : 1;

		for ( var face = 0; face < faces; face ++ ) {

			for ( var i = 0; i < dds.mipmapCount; i ++ ) {

				if( isRGBAUncompressed ) {
					var byteArray = loadARGBMip( buffer, dataOffset, width, height );
					var dataLength = byteArray.length;
				} else {
					var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
					var byteArray = new Uint8Array( buffer, dataOffset, dataLength );
				}
				
				var mipmap = { "data": byteArray, "width": width, "height": height };
				dds.mipmaps.push( mipmap );

				dataOffset += dataLength;

				width = Math.max( width * 0.5, 1 );
				height = Math.max( height * 0.5, 1 );

			}

			width = dds.width;
			height = dds.height;

		}

		return dds;

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		depth = depth | 1;

		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 0; y < height; y ++ ) {

				var ly = y - 1 < 0 ? 0 : y - 1;
				var uy = y + 1 > height - 1 ? height - 1 : y + 1;
				var lx = x - 1 < 0 ? 0 : x - 1;
				var ux = x + 1 > width - 1 ? width - 1 : x + 1;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	},

	generateDataTexture: function ( width, height, color ) {

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			data[ i * 3 ] 	  = r;
			data[ i * 3 + 1 ] = g;
			data[ i * 3 + 2 ] = b;

		}

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true;

		return texture;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Object3D();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach : function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

	faces : {},

	// Just for now. face[weight][style]

	face : "helvetiker",
	weight: "normal",
	style : "normal",
	size : 150,
	divisions : 10,

	getFace : function() {

		return this.faces[ this.face ][ this.weight ][ this.style ];

	},

	loadFace : function( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText : function( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;

			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths : fontPaths, offset : width };

	},




	extractGlyphPoints : function( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( !glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch( action ) {

				case 'm':

					// Move To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;
					path.lineTo(x,y);
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i++ ] * scaleX + offset;
					cpy  = outline[ i++ ] * scaleY;
					cpx1 = outline[ i++ ] * scaleX + offset;
					cpy1 = outline[ i++ ] * scaleY;

					path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i++ ] *  scaleX + offset;
					cpy  = outline[ i++ ] *  scaleY;
					cpx1 = outline[ i++ ] *  scaleX + offset;
					cpy1 = outline[ i++ ] * -scaleY;
					cpx2 = outline[ i++ ] *  scaleX + offset;
					cpy2 = outline[ i++ ] * -scaleY;

					path.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha*scale, path:path};
	}

};


THREE.FontUtils.generateShapes = function( text, parameters ) {

	// Parameters 

	parameters = parameters || {};

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;

	var font = parameters.font !== undefined ? parameters.font : "helvetiker";
	var weight = parameters.weight !== undefined ? parameters.weight : "normal";
	var style = parameters.style !== undefined ? parameters.style : "normal";

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count-- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				THREE.onwarning( "Warning, unable to triangulate polygon!" );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv--;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for( var p = n - 1, q = 0; q < n; p = q++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;

		var aX, aY, bX, bY, cX, cY;
		var apx, apy, bpx, bpy, cpx, cpy;
		var cCROSSap, bCROSScp, aCROSSbp;

		aX = cx - bx;  aY = cy - by;
		bX = ax - cx;  bY = ay - cy;
		cX = bx - ax;  cY = by - ay;

		for ( p = 0; p < n; p++ ) {

			px = contour[ verts[ p ] ].x
			py = contour[ verts[ p ] ].y

			if ( ( (px === ax) && (py === ay) ) ||
				 ( (px === bx) && (py === by) ) ||
				 ( (px === cx) && (py === cy) ) )	continue;

			apx = px - ax;  apy = py - ay;
			bpx = px - bx;  bpy = py - by;
			cpx = px - cx;  cpy = py - cy;

			// see if p is inside triangle abc

			aCROSSbp = aX*bpy - aY*bpx;
			cCROSSap = cX*apy - cY*apx;
			bCROSScp = bX*cpy - bY*cpx;

			if ( (aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON) ) return false;

		}

		return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

})(THREE.FontUtils);

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
THREE.typeface_js = self._typeface_js;

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	THREE.onwarning( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	}

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	}

	return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

	if ( this.cacheArcLengths
		&& ( this.cacheArcLengths.length == divisions + 1 )
		&& !this.needsUpdate) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	this.needsUpdate = false;

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
	this.needsUpdate = true;
	this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

		comparison = arcLengths[ i ] - targetArcLength;

		if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );

	var vec = pt2.clone().sub(pt1);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return -3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;
	},


	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 â 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 â 2t^2 + t
		var h01 = -6 * t * t + 6 * t; 	// â 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 â t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];
	
	this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[0].getPoint(0);
	var endPoint = this.curves[this.curves.length-1].getPoint(1);
	
	if (!startPoint.equals(endPoint)) {
		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
	}
	
};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates, as well as centroid

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY, maxZ;
	var minX, minY, minZ;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	var v3 = points[0] instanceof THREE.Vector3;

	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < minY ) minY = p.y;

		if ( v3 ) {

			if ( p.z > maxZ ) maxZ = p.z;
			else if ( p.z < minZ ) minZ = p.z;

		}

		sum.add( p );

	}

	var ret = {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY,
		centroid: sum.divideScalar( il )

	};

	if ( v3 ) {

		ret.maxZ = maxZ;
		ret.minZ = minZ;

	}

	return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or ParticleSystem objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < points.length; i ++ ) {

		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

	}

	return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		xNorm = oldX / bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getTangent( xNorm );
		normal.set( -normal.y, normal.x ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};


/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

	THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

THREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {

	this.matrixAutoUpdate && this.updateMatrix();

	// update matrixWorld

	if ( this.matrixWorldNeedsUpdate || force ) {

		if ( this.parent ) {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			this.matrixWorld.decompose( this.translationWorld, this.quaternionWorld, this.scaleWorld );
			this.matrix.decompose( this.translationObject, this.quaternionObject, this.scaleObject );

			this.matrixWorld.compose( this.translationWorld, this.quaternionObject, this.scaleWorld );


		} else {

			this.matrixWorld.copy( this.matrix );

		}


		this.matrixWorldNeedsUpdate = false;

		force = true;

	}

	// update children

	for ( var i = 0, l = this.children.length; i < l; i ++ ) {

		this.children[ i ].updateMatrixWorld( force );

	}

};

THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();


/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc',								// Circle
	ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
											   aCP2x, aCP2y,
											   aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc(aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {
	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
		aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );
	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	var lastPoint = curve.getPoint(1);
	args.push(lastPoint.x);
	args.push(lastPoint.y);

	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	if (this.useSpacedPoints) {
		console.log('tata');
		return this.getSpacedPoints( divisions, closedPath );
	}

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !!args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;
		  
		case THREE.PathActions.ELLIPSE:

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !!args[ 6 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1];
	var EPSILON = 0.0000000001;
	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
			 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
		points.splice( points.length - 1, 1);
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

// Breaks path into shapes

THREE.Path.prototype.toShapes = function( isCCW ) {

	function isPointInsidePolygon( inPt, inPolygon ) {
		var EPSILON = 0.0000000001;

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for( var p = polyLen - 1, q = 0; q < polyLen; p = q++ ) {
			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
				if ( edgeDy < 0 ) {
					edgeLowPt  = inPolygon[ q ]; edgeDx = -edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = -edgeDy;
				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y == edgeLowPt.y ) {
					if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!
				} else {
					var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
					if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = !inside;		// true intersection left of inPt
				}
			} else {		// parallel or colinear
				if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
				// egde lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;
			}
		}

		return	inside;
	}

	var i, il, item, action, args;

	var subPaths = [], lastPath = new THREE.Path();

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		args = item.args;
		action = item.action;

		if ( action == THREE.PathActions.MOVE_TO ) {

			if ( lastPath.actions.length != 0 ) {

				subPaths.push( lastPath );
				lastPath = new THREE.Path();

			}

		}

		lastPath[ action ].apply( lastPath, args );

	}

	if ( lastPath.actions.length != 0 ) {

		subPaths.push( lastPath );

	}

	// console.log(subPaths);

	if ( subPaths.length == 0 ) return [];

	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length == 1) {

		tmpPath = subPaths[0];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? !holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);
	
	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[mainIdx] = undefined;
	newShapeHoles[mainIdx] = [];

	for ( i = 0, il = subPaths.length; i < il; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = THREE.Shape.Utils.isClockWise( tmpPoints );
		solid = isCCW ? !solid : solid;

		if ( solid ) {

			if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx++;

			newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
			newShapes[mainIdx].s.actions = tmpPath.actions;
			newShapes[mainIdx].s.curves = tmpPath.curves;
			
			if ( holesFirst )	mainIdx++;
			newShapeHoles[mainIdx] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

			//console.log('ccw', i);

		}

	}

	if ( newShapes.length > 1 ) {
		var ambigious = false;
		var toChange = [];

		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {
			betterShapeHoles[sIdx] = [];
		}
		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {
			var sh = newShapes[sIdx];
			var sho = newShapeHoles[sIdx];
			for (var hIdx = 0; hIdx < sho.length; hIdx++ ) {
				var ho = sho[hIdx];
				var hole_unassigned = true;
				for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++ ) {
					if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
						if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {
							hole_unassigned = false;
							betterShapeHoles[s2Idx].push( ho );
						} else {
							ambigious = true;
						}
					}
				}
				if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
			}
		}
		// console.log("ambigious: ", ambigious);
		if ( toChange.length > 0 ) {
			// console.log("to change: ", toChange);
			if (! ambigious)	newShapeHoles = betterShapeHoles;
		}
	}

	var tmpHoles, j, jl;
	for ( i = 0, il = newShapes.length; i < il; i ++ ) {
		tmpShape = newShapes[i].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[i];
		for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
			tmpShape.holes.push( tmpHoles[j].h );
		}
	}

	//console.log("shape", shapes);

	return shapes;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	var geometry = new THREE.ShapeGeometry( this, options );
	return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	if (this.useSpacedPoints) {
		return this.extractAllSpacedPoints(divisions);
	}

	return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
			// inOtherPt needs to be colinear to the inSegment
			if ( inSegPt1.x != inSegPt2.x ) {
				if ( inSegPt1.x < inSegPt2.x ) {
					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
				} else {
					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
				}
			} else {
				if ( inSegPt1.y < inSegPt2.y ) {
					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
				} else {
					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
				}
			}
		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
			var EPSILON = 0.0000000001;

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs(limit) > EPSILON ) {			// not parallel

				var perpSeg2;
				if ( limit > 0 ) {
					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
				} else {
					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 == 0 ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt1 ];
				}
				if ( perpSeg2 == limit ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt2 ];
				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 == 0 )		return  [ inSeg2Pt1 ];
				if ( perpSeg1 == limit )	return  [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {		// parallel or colinear
				if ( ( perpSeg1 != 0 ) ||
					 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
				var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {
					if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
						 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
					return  [ inSeg1Pt1 ];                 					// they are the same point
				}
				// segment#1  is a single point
				if ( seg1Pt ) {
					if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return  [ inSeg1Pt1 ];
				}
				// segment#2  is a single point
				if ( seg2Pt ) {
					if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return  [ inSeg2Pt1 ];
				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if (seg1dx != 0) {		// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
					}
				} else {				// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
					}
				}
				if ( seg1minVal <= seg2minVal ) {
					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal == seg2minVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];
				} else {
					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal == seg2maxVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];
				}
			}
		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
			// The order of legs is important

			var EPSILON = 0.0000000001;

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {				// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
				} else {								// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
				}
			} else {										// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );
			}
		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;
				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;
				}

				return	true;
			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {
				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx++ ) {
					nextIdx = sIdx+1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
					if ( intersection.length > 0 )		return	true;
				}

				return	false;
			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {
				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx++ ) {
					chkHole = holes[indepHoles[ihIdx]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx++ ) {
						nextIdx = hIdx+1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}
				}
				return	false;
			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {
				counter --;
				if ( counter < 0 ) {
					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;
				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = 0; shapeIndex < shape.length; shapeIndex++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= -1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {
						holeIdx = indepHoles[h];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[cutKey] !== undefined )			continue;

						hole = holes[holeIdx];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
							holePt = hole[ h2 ];
							if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice(h,1);

							tmpShape1 = shape.slice( 0, shapeIndex+1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex+1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[cutKey] = true;			// remember failure
					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found
				}
			}

			return shape; 			/* shape with no holes */
		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[h] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};


/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub(this.v1);
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();

};
/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return new THREE.Vector2( tx, ty );

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};
/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};
/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = (points == undefined) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var v = new THREE.Vector2();
	var c = [];
	var points = this.points, point, intPoint, weight;
	point = ( points.length - 1 ) * t;

	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;
	c[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;

	v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
	v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );

	return v;

};
/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var angle;
	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}

	var tx = this.aX + this.xRadius * Math.cos( angle );
	var ty = this.aY + this.yRadius * Math.sin( angle );

	return new THREE.Vector2( tx, ty );

};

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var r = new THREE.Vector3();


		r.subVectors( this.v2, this.v1 ); // diff
		r.multiplyScalar( t );
		r.add( this.v1 );

		return r;

	}

);

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		tz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);
/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		tz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);
/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

	function ( t ) {

		var v = new THREE.Vector3();
		var c = [];
		var points = this.points, point, intPoint, weight;
		point = ( points.length - 1 ) * t;

		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

		var pt0 = points[ c[0] ],
			pt1 = points[ c[1] ],
			pt2 = points[ c[2] ],
			pt3 = points[ c[3] ];

		v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);
		v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);
		v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);

		return v;

	}

);


// THREE.SplineCurve3.prototype.getTangent = function(t) {
// 		var v = new THREE.Vector3();
// 		var c = [];
// 		var points = this.points, point, intPoint, weight;
// 		point = ( points.length - 1 ) * t;

// 		intPoint = Math.floor( point );
// 		weight = point - intPoint;

// 		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
// 		c[ 1 ] = intPoint;
// 		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
// 		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

// 		var pt0 = points[ c[0] ],
// 			pt1 = points[ c[1] ],
// 			pt2 = points[ c[2] ],
// 			pt3 = points[ c[3] ];

// 	// t = weight;
// 	v.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );
// 	v.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );
// 	v.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );

// 	return v;

// }
/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

    function ( t ) {

        var v = new THREE.Vector3();
        var c = [];
        var points = this.points, point, intPoint, weight;
        point = ( points.length - 0 ) * t;
            // This needs to be from 0-length +1

        intPoint = Math.floor( point );
        weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
        c[ 0 ] = ( intPoint - 1 ) % points.length;
        c[ 1 ] = ( intPoint ) % points.length;
        c[ 2 ] = ( intPoint + 1 ) % points.length;
        c[ 3 ] = ( intPoint + 2 ) % points.length;

        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );

        return v;

    }

);
/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = (function() {

	var playing = [];
	var library = {};
	var that    = {};


	//--- update ---

	that.update = function( deltaTimeMS ) {

		for( var i = 0; i < playing.length; i ++ )
			playing[ i ].update( deltaTimeMS );

	};


	//--- add ---

	that.addToUpdate = function( animation ) {

		if ( playing.indexOf( animation ) === -1 )
			playing.push( animation );

	};


	//--- remove ---

	that.removeFromUpdate = function( animation ) {

		var index = playing.indexOf( animation );

		if( index !== -1 )
			playing.splice( index, 1 );

	};


	//--- add ---

	that.add = function( data ) {

		if ( library[ data.name ] !== undefined )
			THREE.onwarning( "THREE.AnimationHandler.add: Warning! " + data.name + " already exists in library. Overwriting." );

		library[ data.name ] = data;
		initData( data );

	};


	//--- get ---

	that.get = function( name ) {

		if ( typeof name === "string" ) {

			if ( library[ name ] ) {

				return library[ name ];

			} else {

				THREE.onwarning( "THREE.AnimationHandler.get: Couldn't find animation " + name );
				return null;

			}

		} else {

			// todo: add simple tween library

		}

	};

	//--- parse ---

	that.parse = function( root ) {

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for( var b = 0; b < root.bones.length; b++ ) {

				hierarchy.push( root.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	};

	var parseRecurseHierarchy = function( root, hierarchy ) {

		hierarchy.push( root );

		for( var c = 0; c < root.children.length; c++ )
			parseRecurseHierarchy( root.children[ c ], hierarchy );

	}


	//--- init data ---

	var initData = function( data ) {

		if( data.initialized === true )
			return;


		// loop through all keys

		for( var h = 0; h < data.hierarchy.length; h ++ ) {

			for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if( data.hierarchy[ h ].keys[ k ].time < 0 )
					data.hierarchy[ h ].keys[ k ].time = 0;


				// create quaternions

				if( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				 !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );

				}

			}


			// prepare morph target keys

			if( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = -1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for ( var morphTargetName in usedMorphTargets ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}

		// done

		data.initialized = true;

	};


	// interpolation types

	that.LINEAR = 0;
	that.CATMULLROM = 1;
	that.CATMULLROM_FORWARD = 2;

	return that;

}());

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, name ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( name );
	this.hierarchy = THREE.AnimationHandler.parse( root );

	this.currentTime = 0;
	this.timeScale = 1;

	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	this.interpolationType = THREE.AnimationHandler.LINEAR;

};

THREE.Animation.prototype.play = function ( startTime ) {

	this.currentTime = startTime !== undefined ? startTime : 0;

	if ( this.isPlaying === false ) {

		this.isPlaying = true;

		this.reset();
		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};


THREE.Animation.prototype.pause = function() {

	if ( this.isPaused === true ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;
	THREE.AnimationHandler.removeFromUpdate( this );

};

THREE.Animation.prototype.reset = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		object.matrixAutoUpdate = true;

		if ( object.animationCache === undefined ) {

			object.animationCache = {};
			object.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

		}

		var prevKey = object.animationCache.prevKey;
		var nextKey = object.animationCache.nextKey;

		prevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];
		prevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];
		prevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];

		nextKey.pos = this.getNextKeyWith( "pos", h, 1 );
		nextKey.rot = this.getNextKeyWith( "rot", h, 1 );
		nextKey.scl = this.getNextKeyWith( "scl", h, 1 );

	}

};


THREE.Animation.prototype.update = (function(){

	var points = [];
	var target = new THREE.Vector3();
	
	// Catmull-Rom spline

	var interpolateCatmullRom = function ( points, scale ) {

		var c = [], v3 = [],
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		point = ( points.length - 1 ) * scale;
		intPoint = Math.floor( point );
		weight = point - intPoint;
	
		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
	
		pa = points[ c[ 0 ] ];
		pb = points[ c[ 1 ] ];
		pc = points[ c[ 2 ] ];
		pd = points[ c[ 3 ] ];
	
		w2 = weight * weight;
		w3 = weight * w2;
	
		v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
		v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
		v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );
	
		return v3;

	};

	var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {
	
		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;
	
		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
	};
	
	return function ( delta ) {
		if ( this.isPlaying === false ) return;
	
		this.currentTime += delta * this.timeScale;
	
		//
	
		var vector;
		var types = [ "pos", "rot", "scl" ];
	
		var duration = this.data.length;
	
		if ( this.loop === true && this.currentTime > duration ) {
	
			this.currentTime %= duration;
			this.reset();
	
		} else if ( this.loop === false && this.currentTime > duration ) {
	
			this.stop();
			return;
	
		}
	
		this.currentTime = Math.min( this.currentTime, duration );
	
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {
	
			var object = this.hierarchy[ h ];
			var animationCache = object.animationCache;
	
			// loop through pos/rot/scl
	
			for ( var t = 0; t < 3; t ++ ) {
	
				// get keys
	
				var type    = types[ t ];
				var prevKey = animationCache.prevKey[ type ];
				var nextKey = animationCache.nextKey[ type ];
	
				if ( nextKey.time <= this.currentTime ) {
	
					prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					nextKey = this.getNextKeyWith( type, h, 1 );
	
					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {
	
						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );
	
					}
	
					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;
	
				}
	
				object.matrixAutoUpdate = true;
				object.matrixWorldNeedsUpdate = true;
	
				var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );
	
				var prevXYZ = prevKey[ type ];
				var nextXYZ = nextKey[ type ];
	
				if ( scale < 0 ) scale = 0;
				if ( scale > 1 ) scale = 1;
	
				// interpolate
	
				if ( type === "pos" ) {
	
					vector = object.position;
	
					if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {
	
						vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
						this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
						points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
						points[ 1 ] = prevXYZ;
						points[ 2 ] = nextXYZ;
						points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];
	
						scale = scale * 0.33 + 0.33;
	
						var currentPoint = interpolateCatmullRom( points, scale );
	
						vector.x = currentPoint[ 0 ];
						vector.y = currentPoint[ 1 ];
						vector.z = currentPoint[ 2 ];
	
						if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
							var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );
	
							target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
							target.sub( vector );
							target.y = 0;
							target.normalize();
	
							var angle = Math.atan2( target.x, target.z );
							object.rotation.set( 0, angle, 0 );
	
						}
	
					}
	
				} else if ( type === "rot" ) {
	
					THREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );
	
				} else if ( type === "scl" ) {
	
					vector = object.scale;
	
					vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
				}
	
			}
	
		}

	};

})();





// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key < keys.length - 1 ? key : keys.length - 1;

	} else {

		key = key % keys.length;

	}

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key > 0 ? key : 0;

	} else {

		key = key >= 0 ? key : key + keys.length;

	}


	for ( ; key >= 0; key -- ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( root, data ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );
	this.currentTime = 0;
	this.timeScale = 0.001;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	// initialize to first keyframes

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var keys = this.data.hierarchy[h].keys,
			sids = this.data.hierarchy[h].sids,
			obj = this.hierarchy[h];

		if ( keys.length && sids ) {

			for ( var s = 0; s < sids.length; s++ ) {

				var sid = sids[ s ],
					next = this.getNextKeyWith( sid, h, 0 );

				if ( next ) {

					next.apply( sid );

				}

			}

			obj.matrixAutoUpdate = false;
			this.data.hierarchy[h].node.updateMatrix();
			obj.matrixWorldNeedsUpdate = true;

		}

	}

};

// Play

THREE.KeyFrameAnimation.prototype.play = function ( startTime ) {

	this.currentTime = startTime !== undefined ? startTime : 0;

	if ( this.isPlaying === false ) {

		this.isPlaying = true;

		// reset key cache

		var h, hl = this.hierarchy.length,
			object,
			node;

		for ( h = 0; h < hl; h++ ) {

			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];

			if ( node.animationCache === undefined ) {

				node.animationCache = {};
				node.animationCache.prevKey = null;
				node.animationCache.nextKey = null;
				node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

			}

			var keys = this.data.hierarchy[h].keys;

			if (keys.length) {

				node.animationCache.prevKey = keys[ 0 ];
				node.animationCache.nextKey = keys[ 1 ];

				this.startTime = Math.min( keys[0].time, this.startTime );
				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

			}

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};



// Pause

THREE.KeyFrameAnimation.prototype.pause = function() {

	if( this.isPaused ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


// Stop

THREE.KeyFrameAnimation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;

	THREE.AnimationHandler.removeFromUpdate( this );

	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.data.hierarchy.length; h++ ) {
        
		var obj = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		if ( node.animationCache !== undefined ) {

			var original = node.animationCache.originalMatrix;

			if( obj instanceof THREE.Bone ) {

				original.copy( obj.skinMatrix );
				obj.skinMatrix = original;

			} else {

				original.copy( obj.matrix );
				obj.matrix = original;

			}

			delete node.animationCache;

		}

	}

};


// Update

THREE.KeyFrameAnimation.prototype.update = function ( delta ) {

	if ( this.isPlaying === false ) return;

	this.currentTime += delta * this.timeScale;

	//

	var duration = this.data.length;

	if ( this.loop === true && this.currentTime > duration ) {

		this.currentTime %= duration;

	}

	this.currentTime = Math.min( this.currentTime, duration );

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

		var object = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		var keys = node.keys,
			animationCache = node.animationCache;


		if ( keys.length ) {

			var prevKey = animationCache.prevKey;
			var nextKey = animationCache.nextKey;

			if ( nextKey.time <= this.currentTime ) {

				while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

					prevKey = nextKey;
					nextKey = keys[ prevKey.index + 1 ];

				}

				animationCache.prevKey = prevKey;
				animationCache.nextKey = nextKey;

			}

			if ( nextKey.time >= this.currentTime ) {

				prevKey.interpolate( nextKey, this.currentTime );

			} else {

				prevKey.interpolate( nextKey, nextKey.time );

			}

			this.data.hierarchy[ h ].node.updateMatrix();
			object.matrixWorldNeedsUpdate = true;

		}

	}

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key % keys.length;

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key >= 0 ? key : key + keys.length;

	for ( ; key >= 0; key-- ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ keys.length - 1 ];

};

/**
 * @author mrdoob / http://mrdoob.com
 */

THREE.MorphAnimation = function ( mesh ) {

	this.mesh = mesh;
	this.frames = mesh.morphTargetInfluences.length;
	this.currentTime = 0;
	this.duration = 1000;
	this.loop = true;

	this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

	play: function () {

		this.isPlaying = true;

	},

	pause: function () {

		this.isPlaying = false;
	},

	update: ( function () {

		var lastFrame = 0;
		var currentFrame = 0;

		return function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta;

			if ( this.loop === true && this.currentTime > this.duration ) {

				this.currentTime %= this.duration;

			}

			this.currentTime = Math.min( this.currentTime, this.duration );

			var interpolation = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / interpolation );

			if ( frame != currentFrame ) {

				this.mesh.morphTargetInfluences[ lastFrame ] = 0;
				this.mesh.morphTargetInfluences[ currentFrame ] = 1;
				this.mesh.morphTargetInfluences[ frame ] = 0;

				lastFrame = currentFrame;
				currentFrame = frame;

			}

			this.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
			this.mesh.morphTargetInfluences[ lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];

		}

	} )()

};

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );
	this.className = "CubeCamera";

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, -1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, -1, 0 );
	cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, -1 );
	cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, -1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, -1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.generateMipmaps;

		renderTarget.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );

/**
 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
 *
 *	A general perpose camera, for setting FOV, Lens Focal Length,
 *		and switching between perspective and orthographic views easily.
 *		Use this only if you do not wish to manage
 *		both a Orthographic and Perspective Camera
 *
 */


THREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {

	THREE.Camera.call( this );
	this.className = "CombinedCamera";

	this.fov = fov;

	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

	// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects

	this.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 	orthoNear, orthoFar );
	this.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );

	this.zoom = 1;

	this.toPerspective();

	var aspect = width/height;

};

THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.CombinedCamera.prototype.toPerspective = function () {

	// Switches to the Perspective Camera

	this.near = this.cameraP.near;
	this.far = this.cameraP.far;

	this.cameraP.fov =  this.fov / this.zoom ;

	this.cameraP.updateProjectionMatrix();

	this.projectionMatrix = this.cameraP.projectionMatrix;

	this.inPerspectiveMode = true;
	this.inOrthographicMode = false;

};

THREE.CombinedCamera.prototype.toOrthographic = function () {

	// Switches to the Orthographic camera estimating viewport from Perspective

	var fov = this.fov;
	var aspect = this.cameraP.aspect;
	var near = this.cameraP.near;
	var far = this.cameraP.far;

	// The size that we set is the mid plane of the viewing frustum

	var hyperfocus = ( near + far ) / 2;

	var halfHeight = Math.tan( fov / 2 ) * hyperfocus;
	var planeHeight = 2 * halfHeight;
	var planeWidth = planeHeight * aspect;
	var halfWidth = planeWidth / 2;

	halfHeight /= this.zoom;
	halfWidth /= this.zoom;

	this.cameraO.left = -halfWidth;
	this.cameraO.right = halfWidth;
	this.cameraO.top = halfHeight;
	this.cameraO.bottom = -halfHeight;

	// this.cameraO.left = -farHalfWidth;
	// this.cameraO.right = farHalfWidth;
	// this.cameraO.top = farHalfHeight;
	// this.cameraO.bottom = -farHalfHeight;

	// this.cameraO.left = this.left / this.zoom;
	// this.cameraO.right = this.right / this.zoom;
	// this.cameraO.top = this.top / this.zoom;
	// this.cameraO.bottom = this.bottom / this.zoom;

	this.cameraO.updateProjectionMatrix();

	this.near = this.cameraO.near;
	this.far = this.cameraO.far;
	this.projectionMatrix = this.cameraO.projectionMatrix;

	this.inPerspectiveMode = false;
	this.inOrthographicMode = true;

};


THREE.CombinedCamera.prototype.setSize = function( width, height ) {

	this.cameraP.aspect = width / height;
	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

};


THREE.CombinedCamera.prototype.setFov = function( fov ) {

	this.fov = fov;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

// For mantaining similar API with PerspectiveCamera

THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toPerspective();
		this.toOrthographic();

	}

};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
THREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );

	this.setFov( fov );

	return fov;
};


THREE.CombinedCamera.prototype.setZoom = function( zoom ) {

	this.zoom = zoom;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

THREE.CombinedCamera.prototype.toFrontView = function() {

	this.rotation.x = 0;
	this.rotation.y = 0;
	this.rotation.z = 0;

	// should we be modifing the matrix instead?

	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBackView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toLeftView = function() {

	this.rotation.x = 0;
	this.rotation.y = - Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toRightView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toTopView = function() {

	this.rotation.x = - Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBottomView = function() {

	this.rotation.x = Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );
	this.className = "BoxGeometry";

	var scope = this;

	this.width = width;
	this.height = height;
	this.depth = depth;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var width_half = this.width / 2;
	var height_half = this.height / 2;
	var depth_half = this.depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy++ ) {

			for ( ix = 0; ix < gridX; ix++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.computeCentroids();
	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );
	this.className = "CircleGeometry";

	this.radius = radius = radius || 50;
	this.segments = segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
	this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var i, uvs = [],
	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

	this.vertices.push(center);
	uvs.push( centerUV );

	for ( i = 0; i <= segments; i ++ ) {

		var vertex = new THREE.Vector3();
		var segment = thetaStart + i / segments * thetaLength;

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		this.vertices.push( vertex );
		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 1; i <= segments; i ++ ) {

		var v1 = i;
		var v2 = i + 1 ;
		var v3 = 0;

		this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );

// DEPRECATED

THREE.CubeGeometry = THREE.BoxGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

	THREE.Geometry.call( this );
	this.className = "CylinderGeometry";

	this.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;
	this.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	this.height = height = height !== undefined ? height : 100;

	this.radialSegments = radialSegments = radialSegments || 8;
	this.heightSegments = heightSegments = heightSegments || 1;

	this.openEnded = openEnded = openEnded !== undefined ? openEnded : false;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * Math.PI * 2 );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * Math.PI * 2 );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

}

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {
		shapes = [];
		return;
	}

	THREE.Geometry.call( this );
	this.className = "ExtrudeGeometry";

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var shapebb = this.shapebb;
	//shapebb = shape.getBoundingBox();



	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( !vec ) return THREE.onerror( "die, vec not specified" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	// Find directions for point movement

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( inPt, inPrev, inNext ) {

		var EPSILON = 0.0000000001;
		var sign = THREE.Math.sign;
		
		// computes for inPt the corresponding point inPt' on a new contour
		//   shiftet by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.
		
		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
		
		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
		
		// check for colinear edges
		var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
		if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
			
			// length of vectors for normalizing
	
			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
			
			// shift adjacent points by unit vectors to the left
	
			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
			
			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
			// scaling factor for v_prev to intersection point
	
			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			// vector from inPt to intersection point
	
			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
			if ( v_trans_lensq <= 2 ) {
				return	new THREE.Vector2( v_trans_x, v_trans_y );
			} else {
				shrink_by = Math.sqrt( v_trans_lensq / 2 );
			}
			
		} else {		// handle special case of colinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > EPSILON ) {
				if ( v_next_x > EPSILON ) { direction_eq = true; }
			} else {
				if ( v_prev_x < -EPSILON ) {
					if ( v_next_x < -EPSILON ) { direction_eq = true; }
				} else {
					if ( sign(v_prev_y) == sign(v_next_y) ) { direction_eq = true; }
				}
			}

			if ( direction_eq ) {
				// console.log("Warning: lines are a straight sequence");
				v_trans_x = -v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );
			} else {
				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );
			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			//vert = scalePt( contour[ i ], contourCentroid, bs, false );
			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
				//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );

				v( vert.x, vert.y,  -z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( !extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

			position2.copy( extrudePts[0] ).add(normal).add(binormal);

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( !extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[s] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( !extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0 ; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ], true );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );

			}
		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( --i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}
		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c, isBottom ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		// normal, color, material
		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

		var uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );

 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

 		var uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,
 		                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );

 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {
		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y;

		return [
			new THREE.Vector2( ax, ay ),
			new THREE.Vector2( bx, by ),
			new THREE.Vector2( cx, cy )
		];

	},

	generateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {

		return this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );

	},

	generateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,
	                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,
	                              contourIndex1, contourIndex2 ) {

		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,
			az = geometry.vertices[ indexA ].z,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,
			bz = geometry.vertices[ indexB ].z,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y,
			cz = geometry.vertices[ indexC ].z,

			dx = geometry.vertices[ indexD ].x,
			dy = geometry.vertices[ indexD ].y,
			dz = geometry.vertices[ indexD ].z;

		if ( Math.abs( ay - by ) < 0.01 ) {
			return [
				new THREE.Vector2( ax, 1 - az ),
				new THREE.Vector2( bx, 1 - bz ),
				new THREE.Vector2( cx, 1 - cz ),
				new THREE.Vector2( dx, 1 - dz )
			];
		} else {
			return [
				new THREE.Vector2( ay, 1 - az ),
				new THREE.Vector2( by, 1 - bz ),
				new THREE.Vector2( cy, 1 - cz ),
				new THREE.Vector2( dy, 1 - dz )
			];
		}
	}
};

THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );
	this.className = "ShapeGeometry";

	if ( shapes instanceof Array === false ) shapes = [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	var shapebb = this.shapebb;

	//

	var i, l, hole, s;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i++ ) {

			hole = holes[ i ];

			if ( THREE.Shape.Utils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

	// Vertices

	var contour = vertices;

	for ( i = 0, l = holes.length; i < l; i++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	var cont, clen = contour.length;

	for ( i = 0; i < vlen; i++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );

	}

};

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.
THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );
	this.className = "LatheGeometry";

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.Geometry.call( this );
	this.className = "PlaneGeometry";

	this.width = width;
	this.height = height;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;

	var ix, iz;
	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = this.widthSegments;
	var gridZ = this.heightSegments;

	var gridX1 = gridX + 1;
	var gridZ1 = gridZ + 1;

	var segment_width = this.width / gridX;
	var segment_height = this.height / gridZ;

	var normal = new THREE.Vector3( 0, 0, 1 );

	for ( iz = 0; iz < gridZ1; iz ++ ) {

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;
			var y = iz * segment_height - height_half;

			this.vertices.push( new THREE.Vector3( x, - y, 0 ) );

		}

	}

	for ( iz = 0; iz < gridZ; iz ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iz;
			var b = ix + gridX1 * ( iz + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iz + 1 );
			var d = ( ix + 1 ) + gridX1 * iz;

			var uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );
			var uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );
			var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );
			var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );

			var face = new THREE.Face3( a, b, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			face = new THREE.Face3( b, c, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeCentroids();

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );
	this.className = "RingGeometry";

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 3, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i <= phiSegments; i ++ ) { // concentric circles inside ring

		for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

		var thetaSegment = i * thetaSegments;

		for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment + i;
			var v2 = segment + thetaSegments + i;
			var v3 = segment + thetaSegments + 1 + i;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			v1 = segment + i;
			v2 = segment + thetaSegments + 1 + i;
			v3 = segment + 1 + i;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );
	this.className = "SphereGeometry";

	this.radius = radius = radius || 50;

	this.widthSegments = widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	this.heightSegments = heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	this.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;
	this.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
	this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;
			var v = y / heightSegments;

			var vertex = new THREE.Vector3();
			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < this.heightSegments; y ++ ) {

		for ( x = 0; x < this.widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].clone().normalize();
			var n2 = this.vertices[ v2 ].clone().normalize();
			var n3 = this.vertices[ v3 ].clone().normalize();
			var n4 = this.vertices[ v4 ].clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {

				uv1.x = ( uv1.x + uv2.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {

				uv3.x = ( uv3.x + uv4.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {
	this.className = "TextGeometry";

	parameters = parameters || {};

	var textShapes = THREE.FontUtils.generateShapes( text, parameters );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );
	this.className = "TorusGeometry";
	
	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 8;
	this.tubularSegments = tubularSegments || 6;
	this.arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= this.radialSegments; j ++ ) {

		for ( var i = 0; i <= this.tubularSegments; i ++ ) {

			var u = i / this.tubularSegments * this.arc;
			var v = j / this.radialSegments * Math.PI * 2;

			center.x = this.radius * Math.cos( u );
			center.y = this.radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = this.tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}


	for ( var j = 1; j <= this.radialSegments; j ++ ) {

		for ( var i = 1; i <= this.tubularSegments; i ++ ) {

			var a = ( this.tubularSegments + 1 ) * j + i - 1;
			var b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( this.tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );
	this.className = "TorusKnotGeometry";

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 64;
	this.tubularSegments = tubularSegments || 8;
	this.p = p || 2;
	this.q = q || 3;
	this.heightScale = heightScale || 1;
	this.grid = new Array( this.radialSegments );

	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		this.grid[ i ] = new Array( this.tubularSegments );
		var u = i / this.radialSegments * 2 * this.p * Math.PI;
		var p1 = getPos( u, this.q, this.p, this.radius, this.heightScale );
		var p2 = getPos( u + 0.01, this.q, this.p, this.radius, this.heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var v = j / this.tubularSegments * 2 * Math.PI;
			var cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = this.tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			this.grid[ i ][ j ] = scope.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % this.radialSegments;
			var jp = ( j + 1 ) % this.tubularSegments;

			var a = this.grid[ i ][ j ];
			var b = this.grid[ ip ][ j ];
			var c = this.grid[ ip ][ jp ];
			var d = this.grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );
			var uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function( path, segments, radius, radialSegments, closed ) {

	THREE.Geometry.call( this );
	this.className = "TubeGeometry";

	this.path = path;
	this.segments = segments || 64;
	this.radius = radius || 1;
	this.radialSegments = radialSegments || 8;
	this.closed = closed || false;

	this.grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = this.segments + 1,

		x, y, z,
		tx, ty, tz,
		u, v,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}


	// consruct the grid

	for ( i = 0; i < numpoints; i++ ) {

		this.grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		for ( j = 0; j < this.radialSegments; j++ ) {

			v = j / this.radialSegments * 2 * Math.PI;

			cx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = this.radius * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			this.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}
	}


	// construct the mesh

	for ( i = 0; i < this.segments; i++ ) {

		for ( j = 0; j < this.radialSegments; j++ ) {

			ip = ( this.closed ) ? (i + 1) % this.segments : i + 1;
			jp = (j + 1) % this.radialSegments;

			a = this.grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = this.grid[ ip ][ j ];
			c = this.grid[ ip ][ jp ];
			d = this.grid[ i ][ jp ];

			uva = new THREE.Vector2( i / this.segments, j / this.radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radialSegments );
			uvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {

	var	tangent = new THREE.Vector3(),
		normal = new THREE.Vector3(),
		binormal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		epsilon = 0.0001,
		smallest,

		tx, ty, tz,
		i, u, v;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}

	function initialNormal3() {
		// select an initial normal vector perpenicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {
			smallest = tx;
			normal.set( 1, 0, 0 );
		}

		if ( ty <= smallest ) {
			smallest = ty;
			normal.set( 0, 1, 0 );
		}

		if ( tz <= smallest ) {
			normal.set( 0, 0, 1 );
		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i++ ) {

		normals[ i ] = normals[ i-1 ].clone();

		binormals[ i ] = binormals[ i-1 ].clone();

		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

		if ( vec.length() > epsilon ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), -1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

			theta = -theta;

		}

		for ( i = 1; i < numpoints; i++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}
};

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {

	THREE.Geometry.call( this );
	this.className = "PolyhedronGeometry";

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i ++ ) {

		prepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );

	}

	var midpoints = [], p = this.vertices;

	var f = [];
	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var v1 = p[ faces[ i ][ 0 ] ];
		var v2 = p[ faces[ i ][ 1 ] ];
		var v3 = p[ faces[ i ][ 2 ] ];

		f[ i ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

	}

	for ( var i = 0, l = f.length; i < l; i ++ ) {

		subdivide(f[ i ], detail);

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, Math.max( x1, x2 ) );
		var min = Math.min( x0, Math.min( x1, x2 ) );

		if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeCentroids();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3 ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
		face.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
		that.faces.push( face );

		var azi = azimuth( face.centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide(face, detail ) {

		var cols = Math.pow(2, detail);
		var cells = Math.pow(4, detail);
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++) {

				if ( j == 0 && i == cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 == 0 ) {

					make(
						v[ i ][ k + 1],
						v[ i + 1 ][ k ],
						v[ i ][ k ]
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1][ k + 1],
						v[ i + 1 ][ k ]
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, -vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	this.radius = radius;
	this.detail = detail;

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],
		[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],
		[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]
	];

	var faces = [
		[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],
		[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],
		[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],
		[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
	this.className = "IcosahedronGeometry";

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]
	];

	var faces = [
		[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
	this.className = "OctahedronGeometry";

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {
	this.className = "TetrahedronGeometry";

	var vertices = [
		[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]
	];

	var faces = [
		[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );
	this.className = "ParametricGeometry";

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, il, j, p;
	var u, v;

	var stackCount = stacks + 1;
	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}
	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = (i + 1) * sliceCount + j + 1;
			d = (i + 1) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var geometry = new THREE.Geometry();

	geometry.vertices.push(
		new THREE.Vector3(), new THREE.Vector3( size, 0, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, size, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, 0, size )
	);

	geometry.colors.push(
		new THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),
		new THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),
		new THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )
	);

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );
	this.className = "AxisHelper";

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  hex - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = function ( dir, origin, length, hex, headLength, headWidth ) {

	// dir is assumed to be normalized

	THREE.Object3D.call( this );
	this.className = "ArrowHelper";

	if ( hex === undefined ) hex = 0xffff00;
	if ( length === undefined ) length = 1;
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.position = origin;

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
	lineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );

	this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

	this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );

	this.setDirection( dir );
	this.setLength( length, headLength, headWidth );

};

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.ArrowHelper.prototype.setDirection = function () {

	var axis = new THREE.Vector3();
	var radians;

	return function ( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}();

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, length, 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( hex ) {

	this.line.material.color.setHex( hex );
	this.cone.material.color.setHex( hex );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	//   5____4
	// 1/___0/|
	// | 6__|_7
	// 2/___3/

	var vertices = [
		new THREE.Vector3(   1,   1,   1 ),
		new THREE.Vector3( - 1,   1,   1 ),
		new THREE.Vector3( - 1, - 1,   1 ),
		new THREE.Vector3(   1, - 1,   1 ),

		new THREE.Vector3(   1,   1, - 1 ),
		new THREE.Vector3( - 1,   1, - 1 ),
		new THREE.Vector3( - 1, - 1, - 1 ),
		new THREE.Vector3(   1, - 1, - 1 )
	];

	this.vertices = vertices;

	// TODO: Wouldn't be nice if Line had .segments?

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		vertices[ 0 ], vertices[ 1 ],
		vertices[ 1 ], vertices[ 2 ],
		vertices[ 2 ], vertices[ 3 ],
		vertices[ 3 ], vertices[ 0 ],

		vertices[ 4 ], vertices[ 5 ],
		vertices[ 5 ], vertices[ 6 ],
		vertices[ 6 ], vertices[ 7 ],
		vertices[ 7 ], vertices[ 4 ],

		vertices[ 0 ], vertices[ 4 ],
		vertices[ 1 ], vertices[ 5 ],
		vertices[ 2 ], vertices[ 6 ],
		vertices[ 3 ], vertices[ 7 ]
	);

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );

THREE.BoxHelper.prototype.update = function ( object ) {

	var geometry = object.geometry;

	if ( geometry.boundingBox === null ) {

		geometry.computeBoundingBox();

	}

	var min = geometry.boundingBox.min;
	var max = geometry.boundingBox.max;
	var vertices = this.vertices;

	vertices[ 0 ].set( max.x, max.y, max.z );
	vertices[ 1 ].set( min.x, max.y, max.z );
	vertices[ 2 ].set( min.x, min.y, max.z );
	vertices[ 3 ].set( max.x, min.y, max.z );
	vertices[ 4 ].set( max.x, max.y, min.z );
	vertices[ 5 ].set( min.x, max.y, min.z );
	vertices[ 6 ].set( min.x, min.y, min.z );
	vertices[ 7 ].set( max.x, min.y, min.z );

	this.geometry.computeBoundingSphere();
	this.geometry.verticesNeedUpdate = true;

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.camera = camera;
	this.matrixWorld = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

THREE.CameraHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();
	var projector = new THREE.Projector();

	return function () {

		var scope = this;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, -1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", -w, -h, -1 );
		setPoint( "n2",  w, -h, -1 );
		setPoint( "n3", -w,  h, -1 );
		setPoint( "n4",  w,  h, -1 );

		// far

		setPoint( "f1", -w, -h, 1 );
		setPoint( "f2",  w, -h, 1 );
		setPoint( "f3", -w,  h, 1 );
		setPoint( "f4",  w,  h, 1 );

		// up

		setPoint( "u1",  w * 0.7, h * 1.1, -1 );
		setPoint( "u2", -w * 0.7, h * 1.1, -1 );
		setPoint( "u3",        0, h * 2,   -1 );

		// cross

		setPoint( "cf1", -w,  0, 1 );
		setPoint( "cf2",  w,  0, 1 );
		setPoint( "cf3",  0, -h, 1 );
		setPoint( "cf4",  0,  h, 1 );

		setPoint( "cn1", -w,  0, -1 );
		setPoint( "cn2",  w,  0, -1 );
		setPoint( "cn3",  0, -h, -1 );
		setPoint( "cn4",  0,  h, -1 );

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z );
			projector.unprojectVector( vector, camera );

			var points = scope.pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					scope.geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		}

		this.geometry.verticesNeedUpdate = true;

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;
	var geometry = new THREE.PlaneGeometry( size, size );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Mesh( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push( new THREE.Vector3() );
	geometry.vertices.push( new THREE.Vector3() );

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.DirectionalLightHelper.prototype.dispose = function () {
	
	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	}

}();


/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	var geometry2 = object.geometry.clone();

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;
	var numEdges = 0;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
				numEdges ++;

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

	var coords = geometry.attributes.position.array;

	var index = 0;

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

			var vertex = vertices[ h.vert1 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

			vertex = vertices[ h.vert2 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var faces = this.object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.vertices.push( new THREE.Vector3() );

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.FaceNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function ( object ) {

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			v1.copy( face.normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

			var idx = 2 * i;

			vertices[ idx ].copy( face.centroid ).applyMatrix4( worldMatrix );

			vertices[ idx + 1 ].addVectors( vertices[ idx ], v1 );

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());


/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

}

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.HemisphereLightHelper.prototype.dispose = function () {
	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();


/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrixWorld = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.PointLightHelper.prototype.dispose = function () {
	
	this.geometry.dispose();
	this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};


/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -0.5, 0 ) );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	
	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose();
	this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var normal = face.vertexNormals[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0x0000ff;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var tangent = face.vertexTangents[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	if ( object.geometry instanceof THREE.Geometry ) {

		var vertices = object.geometry.vertices;
		var faces = object.geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

		var coords = geometry.attributes.position.array;

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

	} else if ( object.geometry instanceof THREE.BufferGeometry && object.geometry.attributes.index !== undefined ) { // indexed BufferGeometry

		var vertices = object.geometry.attributes.position.array;
		var indices = object.geometry.attributes.index.array;
		var offsets = object.geometry.offsets;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 2 * indices.length );

		for ( var o = 0, ol = offsets.length; o < ol; ++ o ) {

			var start = offsets[ o ].start;
			var count = offsets[ o ].count;
			var index = offsets[ o ].index;

			for ( var i = start, il = start + count; i < il; i += 3 ) {

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = index + indices[ i + j ];
					edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;

					}

				}

			}

		}

		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

		var coords = geometry.attributes.position.array;

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var index = 6 * i + 3 * j;
				var index2 = 3 * edges[ 2 * i + j];
				coords[ index + 0 ] = vertices[ index2 ];
				coords[ index + 1 ] = vertices[ index2 + 1 ];
				coords[ index + 2 ] = vertices[ index2 + 2 ];

			}

		}

	} else if ( object.geometry instanceof THREE.BufferGeometry	) { // non-indexed BufferGeometry

		var vertices = object.geometry.attributes.position.array;
		var numEdges = vertices.length / 3;
		var numTris = numEdges / 3;

		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

		var coords = geometry.attributes.position.array;

		for ( var i = 0, l = numTris; i < l; i ++ ) {

			for ( var j = 0; j < 3; j ++ ) {

				var index = 18 * i + 6 * j;

				var index1 = 9 * i + 3 * j;
				coords[ index + 0 ] = vertices[ index1 ];
				coords[ index + 1 ] = vertices[ index1 + 1 ];
				coords[ index + 2 ] = vertices[ index1 + 2 ];

				var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
				coords[ index + 3 ] = vertices[ index2 ];
				coords[ index + 4 ] = vertices[ index2 + 1 ];
				coords[ index + 5 ] = vertices[ index2 + 2 ];

			}

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

	THREE.Object3D.call( this );

	this.render = function ( renderCallback ) { };

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if( size === undefined ) size = -1;
	if( distance === undefined ) distance = 0;
	if( opacity === undefined ) opacity = 1;
	if( color === undefined ) color = new THREE.Color( 0xffffff );
	if( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( { texture: texture, 			// THREE.Texture
		                    size: size, 				// size in pixels (-1 = use texture.width)
		                    distance: distance, 		// distance (0-1) from light source (0=at light source)
		                    x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
		                    scale: 1, 					// scale
		                    rotation: 1, 				// rotation
		                    opacity: opacity,			// opacity
							color: color,				// color
		                    blending: blending } );		// blending

};


/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = -this.positionScreen.x * 2;
	var vecY = -this.positionScreen.y * 2;

	for( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};













/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		startFrame: start,
		endFrame: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];
			var num = chunks[ 2 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = -1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = -1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		THREE.onwarning( "animation[" + name + "] undefined" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= -1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

	}

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function () {

	var _gl, _renderer, _precision, _lensFlare = {};

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		_precision = renderer.getPrecision();

		_lensFlare.vertices = new Float32Array( 8 + 8 );
		_lensFlare.faces = new Uint16Array( 6 );

		var i = 0;
		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;	// vertex
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;	// uv... etc.

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;

		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;

		i = 0;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;

		// buffers

		_lensFlare.vertexBuffer     = _gl.createBuffer();
		_lensFlare.elementBuffer    = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );

		// textures

		_lensFlare.tempTexture      = _gl.createTexture();
		_lensFlare.occlusionTexture = _gl.createTexture();

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		if ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {

			_lensFlare.hasVertexTexture = false;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlare" ], _precision );

		} else {

			_lensFlare.hasVertexTexture = true;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlareVertexTexture" ], _precision );

		}

		_lensFlare.attributes = {};
		_lensFlare.uniforms = {};

		_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, "position" );
		_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, "uv" );

		_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, "renderType" );
		_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, "map" );
		_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, "occlusionMap" );
		_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, "opacity" );
		_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, "color" );
		_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, "scale" );
		_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, "rotation" );
		_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, "screenPosition" );

	};


	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 *         Then _lensFlare.update_lensFlares() is called to re-position and
	 *         update transparency of flares. Then they are rendered.
	 *
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var flares = scene.__webglFlares,
			nFlares = flares.length;

		if ( ! nFlares ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		var uniforms = _lensFlare.uniforms,
			attributes = _lensFlare.attributes;

		// set _lensFlare program and reset blending

		_gl.useProgram( _lensFlare.program );

		_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );
		_gl.enableVertexAttribArray( _lensFlare.attributes.uv );

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/unforms

		_gl.uniform1i( uniforms.occlusionMap, 0 );
		_gl.uniform1i( uniforms.map, 1 );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );

		_gl.disable( _gl.CULL_FACE );
		_gl.depthMask( false );

		var i, j, jl, flare, sprite;

		for ( i = 0; i < nFlares; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition )

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( _lensFlare.hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				_gl.uniform1i( uniforms.renderType, 0 );
				_gl.uniform2f( uniforms.scale, scale.x, scale.y );
				_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				_gl.disable( _gl.BLEND );
				_gl.enable( _gl.DEPTH_TEST );

				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				_gl.activeTexture( _gl.TEXTURE0 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				_gl.uniform1i( uniforms.renderType, 1 );
				_gl.disable( _gl.DEPTH_TEST );

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition )

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				_gl.uniform1i( uniforms.renderType, 2 );
				_gl.enable( _gl.BLEND );

				for ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						_gl.uniform2f( uniforms.scale, scale.x, scale.y );
						_gl.uniform1f( uniforms.rotation, sprite.rotation );

						_gl.uniform1f( uniforms.opacity, sprite.opacity );
						_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						_renderer.setTexture( sprite.texture, 1 );

						_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );
		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthMask( true );

	};

	function createProgram ( shader, precision ) {

		var program = _gl.createProgram();

		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );

		var prefix = "precision " + precision + " float;\n";

		_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		_gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		_gl.compileShader( fragmentShader );
		_gl.compileShader( vertexShader );

		_gl.attachShader( program, fragmentShader );
		_gl.attachShader( program, vertexShader );

		_gl.linkProgram( program );

		return program;

	};

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function () {

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_matrixPosition = new THREE.Vector3();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		shadowMap, shadowMatrix, shadowCamera,
		program, buffer, material,
		webglObject, object, light,
		renderList,

		lights = [],
		k = 0,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_gl.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.FRONT );

		} else {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.setDepthTest( true );

		// preprocess lights
		// 	- skip lights that are not casting shadows
		//	- create virtual lights for cascaded shadow maps

		for ( i = 0, il = scene.__lights.length; i < il; i ++ ) {

			light = scene.__lights[ i ];

			if ( ! light.castShadow ) continue;

			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

					var virtualLight;

					if ( ! light.shadowCascadeArray[ n ] ) {

						virtualLight = createVirtualLight( light, n );
						virtualLight.originalCamera = camera;

						var gyro = new THREE.Gyroscope();
						gyro.position = light.shadowCascadeOffset;

						gyro.add( virtualLight );
						gyro.add( virtualLight.target );

						camera.add( gyro );

						light.shadowCascadeArray[ n ] = virtualLight;

						//console.log( "Created virtualLight", virtualLight );

					} else {

						virtualLight = light.shadowCascadeArray[ n ];

					}

					updateVirtualLight( light, n );

					lights[ k ] = virtualLight;
					k ++;

				}

			} else {

				lights[ k ] = light;
				k ++;

			}

		}

		// render depth map

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( ! light.shadowMap ) {

				var shadowFilter = THREE.LinearFilter;

				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

					shadowFilter = THREE.NearestFilter;

				}

				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

				light.shadowMatrix = new THREE.Matrix4();

			}

			if ( ! light.shadowCamera ) {

				if ( light instanceof THREE.SpotLight ) {

					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

				} else if ( light instanceof THREE.DirectionalLight ) {

					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

				} else {

					THREE.onerror( "Unsupported light type for shadow" );
					continue;

				}

				scene.add( light.shadowCamera );

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			}

			if ( light.shadowCameraVisible && ! light.cameraHelper ) {

				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
				light.shadowCamera.add( light.cameraHelper );

			}

			if ( light.isVirtual && virtualLight.originalCamera == camera ) {

				updateShadowCamera( camera, light );

			}

			shadowMap = light.shadowMap;
			shadowMatrix = light.shadowMatrix;
			shadowCamera = light.shadowCamera;

			shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
			_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _matrixPosition );
			shadowCamera.updateMatrixWorld();

			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
			if ( light.shadowCameraVisible ) light.cameraHelper.update();

			// compute shadow matrix

			shadowMatrix.set( 0.5, 0.0, 0.0, 0.5,
							  0.0, 0.5, 0.0, 0.5,
							  0.0, 0.0, 0.5, 0.5,
							  0.0, 0.0, 0.0, 1.0 );

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			// update camera matrices and frustum

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			// render shadow map

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// set object matrices & frustum culling

			renderList = scene.__webglObjects;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				webglObject.render = false;

				if ( object.visible && object.castShadow ) {

					if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

						webglObject.render = true;

					}

				}

			}

			// render regular objects

			var objectMaterial, useMorphing, useSkinning;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];

				if ( webglObject.render ) {

					object = webglObject.object;
					buffer = webglObject.buffer;

					// culling is overriden globally for all objects
					// while rendering depth map

					// need to deal with MeshFaceMaterial somehow
					// in that case just use the first of material.materials for now
					// (proper solution would require to break objects by materials
					//  similarly to regular rendering and then set corresponding
					//  depth materials per each chunk instead of just once per object)

					objectMaterial = getObjectMaterial( object );

					useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

					if ( object.customDepthMaterial ) {

						material = object.customDepthMaterial;

					} else if ( useSkinning ) {

						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

					} else if ( useMorphing ) {

						material = _depthMaterialMorph;

					} else {

						material = _depthMaterial;

					}

					if ( buffer instanceof THREE.BufferGeometry ) {

						_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );

					} else {

						_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );

					}

				}

			}

			// set matrices and render immediate objects

			renderList = scene.__webglObjectsImmediate;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				if ( object.visible && object.castShadow ) {

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );

				}

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

	};

	function createVirtualLight( light, cascade ) {

		var virtualLight = new THREE.DirectionalLight();

		virtualLight.isVirtual = true;

		virtualLight.onlyShadow = true;
		virtualLight.castShadow = true;

		virtualLight.shadowCameraNear = light.shadowCameraNear;
		virtualLight.shadowCameraFar = light.shadowCameraFar;

		virtualLight.shadowCameraLeft = light.shadowCameraLeft;
		virtualLight.shadowCameraRight = light.shadowCameraRight;
		virtualLight.shadowCameraBottom = light.shadowCameraBottom;
		virtualLight.shadowCameraTop = light.shadowCameraTop;

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;

		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

		virtualLight.pointsWorld = [];
		virtualLight.pointsFrustum = [];

		var pointsWorld = virtualLight.pointsWorld,
			pointsFrustum = virtualLight.pointsFrustum;

		for ( var i = 0; i < 8; i ++ ) {

			pointsWorld[ i ] = new THREE.Vector3();
			pointsFrustum[ i ] = new THREE.Vector3();

		}

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		pointsFrustum[ 0 ].set( -1, -1, nearZ );
		pointsFrustum[ 1 ].set(  1, -1, nearZ );
		pointsFrustum[ 2 ].set( -1,  1, nearZ );
		pointsFrustum[ 3 ].set(  1,  1, nearZ );

		pointsFrustum[ 4 ].set( -1, -1, farZ );
		pointsFrustum[ 5 ].set(  1, -1, farZ );
		pointsFrustum[ 6 ].set( -1,  1, farZ );
		pointsFrustum[ 7 ].set(  1,  1, farZ );

		return virtualLight;

	}

	// Synchronize virtual light with the original light

	function updateVirtualLight( light, cascade ) {

		var virtualLight = light.shadowCascadeArray[ cascade ];

		virtualLight.position.copy( light.position );
		virtualLight.target.position.copy( light.target.position );
		virtualLight.lookAt( virtualLight.target );

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;
		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		var pointsFrustum = virtualLight.pointsFrustum;

		pointsFrustum[ 0 ].z = nearZ;
		pointsFrustum[ 1 ].z = nearZ;
		pointsFrustum[ 2 ].z = nearZ;
		pointsFrustum[ 3 ].z = nearZ;

		pointsFrustum[ 4 ].z = farZ;
		pointsFrustum[ 5 ].z = farZ;
		pointsFrustum[ 6 ].z = farZ;
		pointsFrustum[ 7 ].z = farZ;

	}

	// Fit shadow camera's ortho frustum to camera frustum

	function updateShadowCamera( camera, light ) {

		var shadowCamera = light.shadowCamera,
			pointsFrustum = light.pointsFrustum,
			pointsWorld = light.pointsWorld;

		_min.set( Infinity, Infinity, Infinity );
		_max.set( -Infinity, -Infinity, -Infinity );

		for ( var i = 0; i < 8; i ++ ) {

			var p = pointsWorld[ i ];

			p.copy( pointsFrustum[ i ] );
			THREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );

			p.applyMatrix4( shadowCamera.matrixWorldInverse );

			if ( p.x < _min.x ) _min.x = p.x;
			if ( p.x > _max.x ) _max.x = p.x;

			if ( p.y < _min.y ) _min.y = p.y;
			if ( p.y > _max.y ) _max.y = p.y;

			if ( p.z < _min.z ) _min.z = p.z;
			if ( p.z > _max.z ) _max.z = p.z;

		}

		shadowCamera.left = _min.x;
		shadowCamera.right = _max.x;
		shadowCamera.top = _max.y;
		shadowCamera.bottom = _min.y;

		// can't really fit near/far
		//shadowCamera.near = _min.z;
		//shadowCamera.far = _max.z;

		shadowCamera.updateProjectionMatrix();

	}

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use for shadow maps

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

THREE.ShadowMapPlugin.__projector = new THREE.Projector();

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function () {

	var _gl, _renderer, _texture;

	var vertices, faces, vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		vertices = new Float32Array( [
			- 0.5, - 0.5, 0, 0, 
			  0.5, - 0.5, 1, 0,
			  0.5,   0.5, 1, 1,
			- 0.5,   0.5, 0, 1
		] );

		faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = _gl.createBuffer();
		elementBuffer = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faces, _gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			_gl.getAttribLocation ( program, 'position' ),
			uv:					_gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			_gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			_gl.getUniformLocation( program, 'uvScale' ),

			rotation:			_gl.getUniformLocation( program, 'rotation' ),
			scale:				_gl.getUniformLocation( program, 'scale' ),

			color:				_gl.getUniformLocation( program, 'color' ),
			map:				_gl.getUniformLocation( program, 'map' ),
			opacity:			_gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	_gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	_gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			_gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			_gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			_gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				_gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			_gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			_gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = '#ffffff';
		context.fillRect( 0, 0, canvas.width, canvas.height );

		_texture = new THREE.Texture( canvas );
		_texture.needsUpdate = true;

	};

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var sprites = scene.__webglSprites,
			nSprites = sprites.length;

		if ( ! nSprites ) return;

		// setup gl

		_gl.useProgram( program );

		_gl.enableVertexAttribArray( attributes.position );
		_gl.enableVertexAttribArray( attributes.uv );

		_gl.disable( _gl.CULL_FACE );
		_gl.enable( _gl.BLEND );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
		_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		_gl.activeTexture( _gl.TEXTURE0 );
		_gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				_gl.uniform1f( uniforms.fogNear, fog.near );
				_gl.uniform1f( uniforms.fogFar, fog.far );

				_gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				_gl.uniform1f( uniforms.fogDensity, fog.density );

				_gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			_gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		var i, sprite, material, fogType, scale = [];

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];
			material = sprite.material;

			if ( sprite.visible === false ) continue;

			sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];

			if ( sprite.visible === false ) continue;

			material = sprite.material;

			_gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

			scale[ 0 ] = sprite.scale.x;
			scale[ 1 ] = sprite.scale.y;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			} else {

				fogType = 0;

			}

			if ( oldFogType !== fogType ) {

				_gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				_gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				_gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				_gl.uniform2f( uniforms.uvOffset, 0, 0 );
				_gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			_gl.uniform1f( uniforms.opacity, material.opacity );
			_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			_gl.uniform1f( uniforms.rotation, material.rotation );
			_gl.uniform2fv( uniforms.scale, scale );

			_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			_renderer.setDepthTest( material.depthTest );
			_renderer.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				_renderer.setTexture( material.map, 0 );

			} else {

				_renderer.setTexture( _texture, 0 );

			}

			_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );

	};

	function createProgram () {

		var program = _gl.createProgram();

		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );
		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );

		_gl.shaderSource( vertexShader, [

			'precision ' + _renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		_gl.shaderSource( fragmentShader, [

			'precision ' + _renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		_gl.compileShader( vertexShader );
		_gl.compileShader( fragmentShader );

		_gl.attachShader( program, vertexShader );
		_gl.attachShader( program, fragmentShader );

		_gl.linkProgram( program );

		return program;

	};

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DepthPassPlugin = function () {

	this.enabled = false;
	this.renderTarget = null;

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! this.enabled ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		program, buffer, material,
		webglObject, object, light,
		renderList,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_renderer.setDepthTest( true );

		// update scene

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// render depth map

		_renderer.setRenderTarget( this.renderTarget );
		_renderer.clear();

		// set object matrices & frustum culling

		renderList = scene.__webglObjects;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

					webglObject.render = true;

				}

			}

		}

		// render regular objects

		var objectMaterial, useMorphing, useSkinning;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				// todo: create proper depth material for particles

				if ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;

				objectMaterial = getObjectMaterial( object );

				if ( objectMaterial ) _renderer.setMaterialFaces( object.material );

				useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

				if ( object.customDepthMaterial ) {

					material = object.customDepthMaterial;

				} else if ( useSkinning ) {

					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

				} else if ( useMorphing ) {

					material = _depthMaterialMorph;

				} else {

					material = _depthMaterial;

				}

				if ( buffer instanceof THREE.BufferGeometry ) {

					_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );

				} else {

					_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );

				}

			}

		}

		// set matrices and render immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			if ( object.visible ) {

				object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

				_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

	};

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};


/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.ShaderFlares = {

	'lensFlareVertexTexture': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"uniform sampler2D occlusionMap;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				"vUV = uv;",

				"vec2 pos = position;",

				"if( renderType == 2 ) {",

					"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

					"vVisibility =        visibility.r / 9.0;",
					"vVisibility *= 1.0 - visibility.g / 9.0;",
					"vVisibility *=       visibility.b / 9.0;",
					"vVisibility *= 1.0 - visibility.a / 9.0;",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * vVisibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"
		].join( "\n" )

	},


	'lensFlare': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",

			"void main() {",

				"vUV = uv;",

				"vec2 pos = position;",

				"if( renderType == 2 ) {",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"precision mediump float;",

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform sampler2D occlusionMap;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
					"visibility = ( 1.0 - visibility / 4.0 );",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * visibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"

		].join( "\n" )

	}

};


// Export the THREE object for **Node.js**, with
// backwards-compatibility for the old `require()` API. If we're in
// the browser, add `_` as a global object via a string identifier,
// for Closure Compiler "advanced" mode.
if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/three/three.js","/../node_modules/three")
},{"1YiZ5S":5,"buffer":2}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the 
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherâYates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from an array.
  // If **n** is not specified, returns a single random element from the array.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (arguments.length < 2 || guard) {
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = new Date();
      var later = function() {
        var last = (new Date()) - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/underscore/underscore.js","/../node_modules/underscore")
},{"1YiZ5S":5,"buffer":2}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THR = require('three');
var Utils = require("./utils");
var _     = require('underscore');
ROTATE  = 10;
ROTATEC = 11;
MOVE = 12;
SHOOT = 13;
HIT = 15;
RELOAD_WEAPONS = 16;
UI_SETTINGS = 1000;




/*
ÐÐºÑÐ¾Ñ Ð¿ÑÐ¸Ð²ÑÐ·Ð°Ð½ Ðº Ð¼ÐµÑÑ, Ð¼ÐµÑ Ðº ÑÑÐµÐ½Ðµ.

ÐÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾:
1 ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ Ð°ÐºÑÐ¸Ð¸ Ð¸Ð· Ð½Ð°Ð¶Ð°ÑÐ¸Ð¹ ÐºÐ½Ð¾Ð¿Ð¾Ðº
2 ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ Ð°ÐºÑÐ¸Ð¸ Ð¸Ð· Ð½Ð°Ð¶Ð°ÑÐ¸Ð¹ Ð½Ð° ÐºÐ¾Ð½ÑÑÐ¾Ð»Ñ
3 ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ Ð°ÐºÑÐ¸Ð¸ Ð¸Ð· Ð´ÑÑÐ³Ð¸Ñ Ð°ÐºÑÐ¸Ð¹ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ - Ð³ÐµÐ½ÐµÑÐ°ÑÐ¾Ñ Ð°ÐºÑÐ¸Ð¹ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð±ÑÑÑ Ð´Ð¾ÑÑÑÐ¿ÐµÐ½ Ð²Ð½ÑÑÑÐ¸ ÐºÐ»Ð°ÑÑÐ¾Ð² ÑÐµÐ°Ð³Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ.

Ð¡Ð¾Ð·Ð´Ð°Ð½Ð½ÑÐµ Ð°ÐºÑÐ¸Ð¸ Ð¸Ð¼ÐµÑÑ Ð²ÑÐµ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ Ð´Ð»Ñ Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ¸ Ð²Ð½ÑÑÑÐ¸ ÐºÐ»Ð°ÑÑÐ¾Ð²

ÐÐ¾ÑÐ»Ðµ Ð³ÐµÐ½ÐµÑÐ°ÑÐ¸Ð¸ Ð°ÐºÑÐ¸Ð¸ Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑÑÑÑ Ð½Ð° ÑÐµÑÐ²ÐµÑ.
Ð ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐµ ÑÐµÐ°Ð³Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ Ð°ÐºÑÐ¸Ð¸ Ð¼Ð¾Ð³ÑÑ Ð¿Ð¾ÑÐ²Ð¸ÑÑÑÑ Ð½Ð° ÑÐµÑÐ²ÐµÑÐµ - ÑÐ°ÐºÐ¸Ðµ Ð°ÐºÑÐ¸Ð¸ Ð½Ðµ Ð¿ÐµÑÐµÑÑÐ»Ð°ÑÑÑÑ Ð½Ð° ÑÐµÑÐ²ÐµÑ Ñ ÐºÐ»Ð¸ÐµÐ½ÑÐ°, Ð° ÑÐ¾Ð»ÑÐºÐ¾ Ð½Ð°Ð¾Ð±Ð¾ÑÐ¾Ñ




Ð¢Ð°ÐºÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼, Ð½ÐµÐ¾Ð±Ð¾ÑÐ¾Ð´Ð¸Ð¼Ð¾ Ð² Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ ÐºÐ¾Ð½ÑÑÐ¾Ð»Ð»ÐµÑÐ° Ð²ÐºÐ»ÑÑÐ°ÑÑ Ð¸Ð½ÑÑÐ°Ð½Ñ Ð³ÐµÐ½ÐµÑÐ°ÑÐ¾ÑÐ° Ð°ÐºÑÐ¸Ð¹.
*/

/*
var newAction = function(type, wp, device, mesh_id, scene_id, actor_id, ts, tdiff){
	return {type:type,
			wp:wp,
			device:device,
			
			mesh_id:mesh_id,
			scene_id:scene_id,
			actor_id:actor_id,
			ts: ts,
			tdiff: tdiff}
}
function curry(fn) {
     var slice = Array.prototype.slice,
        stored_args = slice.call(arguments, 1);
     return function () {
        var new_args = slice.call(arguments),
              args = stored_args.concat(new_args);
        return fn.apply(null, args);
     };
}


var workpointsActionList = {
	pilot: []
}

*/


var Controller = {description:'controller'}

if(typeof window ==='undefined'){
	
	var L = {setValue:function(){}};
	is_browser = false;
}else{
	var L = SL;
	is_browser = true;
}


	
Controller.NetworkActor =   function(onAct, W){
		
		var map = Controller.ControllersActionMap()
		var self = this;
		
		this.run = function(){
			// no need to bother - event style
		}
		this.act=function(S, action, is_on, actor){
			if (W !== undefined){
				action.timestamp -= W._time_diff
			}
			var _a = map[action.controller].act(S, action, is_on, actor, onAct);
		}
		return this;
	};
Controller.LocalInputActor = function(W, socket){
		var self = this;
		self.World = W;
		var map = Controller.ControllersActionMap()
		var actor = W.login;
		self.actions_by_scene = {}
		///// ACTION TYPES 
		ROTATE  = 10
		ROTATEC = 11
		MOVE = 12
		SHOOT = 13
		
		
		

		self._default_actions={
		
			87: {type:ROTATE, controller:"pilot",  p:{ a:0,d:-1}},
			83: {type:ROTATE, controller:"pilot",  p:{ a:0,d:1}},
			
			65: {type:ROTATE, controller:"pilot",  p:{ a:1,d:1}},
			68: {type:ROTATE, controller:"pilot",  p:{ a:1,d:-1}},
			
			90: {type:ROTATE, controller:"pilot",  p:{ a:2,d:1}},
			67: {type:ROTATE, controller:"pilot",  p:{ a:2,d:-1}},
		
		
			79: {type:ROTATEC, controller:"pilot", p:{ a:'x',d:'+'}},
			80: {type:ROTATEC, controller:"pilot", p:{ a:'x',d:'-'}},
		
			73: {type:ROTATEC, controller:"pilot", p:{ a:'y',d:'+'}},
			75: {type:ROTATEC, controller:"pilot", p:{ a:'y',d:'-'}},
		
			38: {type:MOVE, controller:"pilot", p:{ a:2,d:-1}},
			40: {type:MOVE, controller:"pilot", p:{ a:2,d:1}},
			
			82: {type:RELOAD_WEAPONS, controller:"turret"},
		
			'lmouse':{type: SHOOT, MA:true, controller:"turret", p:{ '_turret_direction': function(t,k){
				// delete t[k]
				// console.log("w")
				// console.log(W.controllable());
				//var T = Controller.T();
				
				//var C = W.controllable();
				//var Cc = W.get_main_viewport().camera
				//var camera_position_vector = new T.Vector3()
				//console.log(C.json);
				//var camera =  C.json.cameras[Cc]
				//console.log(camera);
				//camera_position_vector.fromArray(camera.position);
				//camera_position_vector.applyEuler( C.rotation.clone() )
				//camera_position_vector.add(C.position.clone());
				//console.log("camera pos in W", camera_position_vector);
				// console.log("REPLACING",W.mouse_projection_vec.clone())
				
				t[k.substr(1)] = W.mouse_projection_vec.clone() //.sub(camera_position_vector)
			}}},
		}
	
		self.actions = self._default_actions;
		self._keycodes_in_action = {}
		this.input = function(keycode, up_or_down, modifiers){
			var ts = new Date().getTime()
			
			// Updating values in event:
			
            // console.log("SSSS");
			
			if(up_or_down) {// down == true
				self._keycodes_in_action[keycode] = {in_action:true, ts:ts}
			}else{
				if(self._keycodes_in_action[keycode]){
					// ÐÐ¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ Ð¼Ð¾Ð³ Ð½Ð°Ð¶Ð°ÑÑ ÐºÐ½Ð¾Ð¿ÐºÑ Ð¼ÑÑÐ¸ Ð² Ð¾Ð´Ð½Ð¾Ð¼ Ð¼ÐµÑÑÐµ - Ð° Ð¾ÑÐ¿ÑÑÑÐ¸ÑÑ Ð½Ð°Ð´ Ð´ÑÑÐ³Ð¸Ð¼.
					var t = self._keycodes_in_action[keycode].ts
					self._keycodes_in_action[keycode].in_action = false
					self._keycodes_in_action[keycode].ts = ts
					self._keycodes_in_action[keycode].delta = ts - t
					
				}
				
			}
		}
		this.getLatestActions = function(scene, now){

            
            var actions = [];
			_.each(self._keycodes_in_action, function(k_action, keycode){
				if(k_action.in_action){
					var delta = now - k_action.ts
					var ts = now
					k_action.ts = now
					
				}else{
					var delta = k_action.delta
					var ts = k_action.ts
					delete self._keycodes_in_action[keycode]
				}
				var action = _.clone(self.actions[keycode]);

				if(keycode in W._input_keymap){
					var act_desc  = W._input_keymap[keycode];
					var new_action = {
						mesh : act_desc.mesh,
						dev : act_desc.device,
						name: act_desc.name,
						ts :ts,
						ident: ts + W._time_diff + W.avg_latencity,
						delta:delta/1000,
						wmouse:W.mouse_projection_vec.clone().toArray()
					}
					actions.push(new_action);
				}
			});
			return actions;


		}
	};
Controller.CSettingController = function(){
	this.type="settings"
	this.process = function(raw_action, mesh){
		
		// console.log("SETTING coNT READY", raw_action)
		if(raw_action.switch){
			
			mesh.alterWorkpointValue(raw_action.wp, raw_action.name, function(v){
				console.log("Altering amount ", v);
				return (! v)
			});
		}else{
			mesh.saveWorkpointValue(raw_action.wp, raw_action.name, raw_action.value);
		}
	}
}
// TODO ÐÐ¾Ð½ÑÑÐ¾Ð»Ð»ÐµÑ Ð´Ð»Ñ ÑÐ¸Ð»Ð´Ð°



Controller.CPilotController = function(){
	
		// ÐÐ±ÑÐ°Ð±Ð¾ÑÐºÐ° ÑÐ¾Ð±ÑÑÐ¸Ñ Ð¾ÑÑÑÐµÑÑÐ²Ð»ÑÐµÑÑÑ Ð² Ð´Ð²Ð° ÑÑÐ°Ð¿Ð°:
		// ÐÐµÑÐ²ÑÐ¹ ÑÑÐ°Ð¿ - Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ Ð¸ÑÑÐ¾Ð´Ñ Ð¸Ð· Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² ÑÐ¾Ð±ÑÑÐ¸Ñ ÑÐµÑ ÑÐ°ÑÐ°ÐºÑÐµÑÐ¸ÑÑÐ¸Ðº, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ñ Ð½Ð° Ð½ÑÐ¶Ð½ÑÐ¹ ÐºÐ¾ÑÐ°Ð±Ð»Ñ (ÐÐµÐºÑÐ¾ÑÐ°)
		// ÐÑÐ¾ÑÐ¾Ð¹ ÑÑÐ°Ð¿ - Ð¿ÐµÑÐµÑÑÐµÑ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ (ÑÐ°Ð±Ð¾ÑÐ° Ð´Ð²Ð¸Ð³Ð°ÑÐµÐ»ÐµÐ¹)
		 
		this.type='pilot';
		this.action_types=[ROTATE, MOVE];
		this.getUI = function(W, actor){
			var ui = function(){
				this.actor = actor;
				this.construct = function(){
					this.indicators_length = 110;
					this.total_width = 170;
					this.cont = $('<div>').css({
						'position':'fixed',
						// 'border': '1px solid red',
						'width': this.total_width + "px",
						'height': '60px',
						'top':40,
						'left':50+300,
						'background-color':'white'
					}).appendTo('body');
						
					this.shield_cont = $('<div>').css({
						position:'fixed',
						left:0,
						height:50,
						bottom:50,
						'background-color':'#f3f',
						width:400
						
					}).appendTo('body');
				var mesh = W.scenes[actor.scene].meshes[actor.control.object_guid];
				var scene = W.scenes[actor.scene];
				var self = this;
				
				self.shield_update_closures = []
				_.each(mesh.type.shields, function(shields, type){
					_.each(shields, function(shield_id){
						var shield_dev = mesh.type.devices[shield_id];
						
						var d  = $('<div>').css({width:50, height:"100%", float:'left', 'margin-right':"10px"}).appendTo(self.shield_cont);
						var sic = $('<div>').css({width:"100%", height:10 }).appendTo(d) // strenth indicator container
						var l = shield_dev.shield_type.toLocaleUpperCase();
						var b = $('<div>').css({width:"100%", height:30,
												"text-align":'center',
												'vertical-align': 'middle',
												'line-height':'30px',
												'background-color':'#333','color':"#F0F"})
											.text(l).appendTo(d).click(function(){
												
												mesh.startDeviceAction(shield_id, "toggle",0);
												
											}) 
						var cic = $('<div>').css({width:"100%", height:10}).appendTo(d) // capacitor indicator container
						
						var si = $('<div>').css({width:"100%", height:"100%", 'background-color':"blue" }).appendTo(sic);
						var ci = $("<div>").css({width:"100%", height:"100%",'background-color':"yellow" }).appendTo(cic);
						var closure = function(){
							var reserve_cap_amount = mesh.getDeviceSetting(shield_id, "reserve_capacity");
							var tot_cap_amount = shield_dev.capacitor;
							var w = reserve_cap_amount/tot_cap_amount * 100;
							ci.width( w + '%' );
							
							var is_on = mesh.getDeviceSetting(shield_id, 'state') ;
							if (is_on){
								b.css({color:'red', 'background-color':'white'});
							}else{
								b.css({'background-color':'#333','color':"#F0F"});
							}
							
							var current_capacity = mesh.getDeviceSetting(shield_id, 'capacity');
							var max_capacity = shield_dev.capacity;
							var ww =( current_capacity / max_capacity * 100) + "%";
							si.width(ww);
							
							// console.log("updating shield", shield, num);
						}
						self.shield_update_closures.push(closure);
						
					});
				})
					
						
									
				this.indicators = $('<div>').css({
					"width": this.indicators_length,
					"height":"100%",
					"float": "left",
					'background-color':'white'
				}).appendTo(this.cont);

				this.switches = $('<div>').css({
					"width": this.total_width - this.indicators_length ,
					"height":"100%",
					"float": "left",
					'background-color':'white'
				}).appendTo(this.cont);
				
				this.fuel_indicator = $('<div>') .css({
					"width": this.indicators_length ,
					"height":"25%",
					// "float": "left",
					'background-color':'green'
				}).appendTo(this.indicators);
			
				this.power_indicator = $('<div>') .css({
					"width": this.indicators_length ,
					"height":"25%",
					// "float": "left",
					'background-color':'red'
				}).appendTo(this.indicators);
				
				this.capacitor_indicator = $('<div>') .css({
					"width": this.indicators_length ,
					"height":"50%",
					// "float": "left",
					'background-color':'yellow'
				}).appendTo(this.indicators);
			
				
				
				var self = this;
				this.engines_key = $("<div>").css({
					width:"100%",
					height:"20px",
					
				}).text("E").appendTo(this.switches).click(function(){
					self._engines_dialog();
				});
				
				this.shield_key = $("<div>").css({
					width:"100%",
					height:"20px",
					
				}).text("S").appendTo(this.switches).click(function(){
					self._shields_dialog();
				});;
				
				this.turret_keys = $("<div>").css({
					width:"100%",
					height:"20px",
					
				}).text("T").appendTo(this.switches);
	
				}
				this._update_shield_indicator = function(){
					_.each(this.shield_update_closures, function(cl){
						cl();
					})
				}
				this._update_fuel_indicator = function(){}
				this._update_power_indicator = function(){}
				this._update_capacitor_indicator = function(){
					var mesh = W.scenes[actor.scene].meshes[actor.control.object_guid];
					var psd = mesh.type.devices[mesh.type.power_source];
					var total_cap = psd.capacitor;
					var current_cap = mesh.getDeviceSetting(mesh.type.power_source, "capacitor");
					L.setValue("CUR CONS", current_cap);
			
					if(current_cap > total_cap){
						percentage = 1;
					}else{
						percentage = current_cap / total_cap;
					}
					this.capacitor_indicator.width(percentage * this.indicators_length);
					
					
				}
				this._shields_dialog = function(){
					var mesh = W.scenes[actor.scene].meshes[actor.control.object_guid];
					var scene = W.scenes[actor.scene];
					
					cont = $('<div>').css({
						'position':'absolute',
						// 'border': '1px solid red',
						'width': 400 + "px",
						'height': '600px',
						'top':40 + 100,
						'left':50+300,
						'padding': "10px",
						'border-radius':'3px',
						'border-width':'1px',
						'border-style':'solid',
						'border-color':'#aaa',
						'background-color':'#222'}).appendTo('body');
					var  cc = $('<div>').appendTo(cont).css({'width':"100%",height:20, 'padding-bottom': '30px'});
					var  closer = $('<div>').appendTo(cont).css({'width':"20", height:20, 'background-color':'red', float:'right' }).click(function(){
						cont.remove();
					}).appendTo(cc);
					
					_.each(mesh.type.shields, function(s, i){
						if (i === 'thermal'){return}
						_.each(s, function(shield_id){
							var e1 = $("<div>").css({
								width:300,
								height:40
							}).appendTo(cont);
								
							$('<div>').css({'float':'left', 'color':'#bbb'}).width(40).text(i).appendTo(e1) 
							var slc =  $('<div>').css({'float':'left', width:120,'margin-left':10}).appendTo(e1);
						
							var pc = new PowerControlWidget({container:slc[0], starting_percent:0, end_percent:1.5,progress_value:0,
								change: function( val ) {
									mesh.startDeviceAction(shield_id, "set_power", val);

								},
								slide:function(val){ 
								}
								
							});
							// var sett =  "s_" + i + num + "_power"
							var cur_val = mesh.getDeviceSetting(shield_id, "power");
							pc.set_value( cur_val );
							
						})
					})
					
				};
				
				this._engines_dialog = function(){

					var mesh = W.scenes[actor.scene].meshes[actor.control.object_guid];
					var scene = W.scenes[actor.scene];

					cont = $('<div>').css({
						'position':'absolute',
						// 'border': '1px solid red',
						'width': 400 + "px",
						'height': '600px',
						'top':40 + 100,
						'left':50+300,
						'padding': "10px",
						'border-radius':'3px',
						'border-width':'1px',
						'border-style':'solid',
						'border-color':'#aaa',
						'background-color':'#222'}).appendTo('body');
						var  cc = $('<div>').appendTo(cont).css({'width':"100%",height:20, 'padding-bottom': '30px'});
						var  closer = $('<div>').appendTo(cont).css({'width':"20", height:20, 'background-color':'red', float:'right' }).click(function(){
							cont.remove();
						}).appendTo(cc);;
					
					
					_.each(mesh.type.engines, function(engines, engine_type){
						
						_.each(engines, function(engine_id){
							
							// var et = engine_type;
							// var ea = en;
							var en_dev = mesh.type.devices[engine_id];
							
							var e1 = $("<div>").css({
								width:300,
								height:40
								}).appendTo(cont);
						
							$('<div>').css({'float':'left', 'color':'#bbb'}).width(40).text(en_dev.name).appendTo(e1) 
							var slc =  $('<div>').css({'float':'left', width:120,'margin-left':10}).appendTo(e1);
							
							var pc = new PowerControlWidget({container:slc[0], starting_percent:0, end_percent:1.5,progress_value:0,
								change: function( val ) {
									mesh.startDeviceAction(engine_id, "set_power", val);

								},
								slide:function(val){ 
									// mesh.startDeviceAction(engine_id, "set_power", val);
								}
									
							});
							// var sett =  "eng_" + engine_name + "_power"
							var cur_val = mesh.getDeviceSetting(engine_id, "power" );
							pc.set_value( cur_val );
								
						})
					})
				}
				
				this.refresh = function(){
					this._update_fuel_indicator();
					this._update_power_indicator();
					this._update_capacitor_indicator();
					this._update_shield_indicator();
				};
				
			}
		
			var UI = new ui();
			return UI;
		}
		
		var T = Controller.T();
		
		function get_axis(a){
			if(a == 'x'){
				axis = new Controller.T().Vector3(1,0,0)
			}
			if(a == 'y'){
				axis = new Controller.T().Vector3(0,1,0)
			}
			if(a == 'z'){
				axis = new Controller.T().Vector3(0,0,1)
			}
			return axis
		
		
		}
		this.process = function(action, mesh){
			
			if(action.name == 'set_power'){
				console.log( "setting power of", action.dev, " to ", action.value)
				mesh.setDeviceSetting(action.dev, 'power', action.value);
				
			}else{
			
				var T = Controller.T();
			
				var unit = new T.Vector3();
				unit.fromArray(mesh.type.devices[action.dev].unit);
				var engine_name = mesh.type.devices[action.dev].engine_type + "_" + mesh.type.devices[action.dev].name;
				var percent_of_power = mesh.getDeviceSetting(action.dev, "power");
				var engine_type = mesh.type.devices[action.dev].engine_type;
			
				var performance = mesh.type.devices[action.dev].performance;
				var consumption = mesh.type.devices[action.dev].consumption;
				var capacitor_left = mesh.getDeviceSetting(mesh.type.power_source, "capacitor");
				var energy_consumption = percent_of_power* consumption * action.delta;
			
				if (capacitor_left < energy_consumption){
					energy_consumption = capacitor_left;
				}
				//console.log("took energy", energy_consumption);
				//L.setValue("NEW CONS", energy_consumption);
			
				var impulse = energy_consumption * performance;
				console.log("we go with", impulse, percent_of_power);
				unit.multiplyScalar(impulse);
			
				mesh.update_static_physical_data(action.ts)
			
				mesh.alterDeviceSetting(mesh.type.power_source, 'capacitor' ,function(value){
					L.setValue("NEW CONSump1", energy_consumption);
					var nv = value - energy_consumption;
					if (nv < 0) {return 0}
					else{ return nv }
					
				})
			
			
				if (engine_type == 'rotation'){
					mesh.angular_impulse.add(unit)
				}else if(engine_type == 'propulsion'){
				
					var tug = unit.clone().applyQuaternion(mesh.quaternion);
					mesh.impulse.add(tug);
				
				

			
				}	
			}
			
		}
		
		/*
		this.process_ = function(raw_action, mesh){
			// console.log("On the server", action);
			
			var process = function(object_guid, action){
				mesh.update_static_physical_data(action.ts)
				
				
				mesh.alterWorkpointValue("Piloting", 'capacitor' ,function(value){
					L.setValue("NEW CONSump1", raw_action.energy_consumption);
					var nv = value - raw_action.energy_consumption;
					if (nv < 0) {return 0}
					else{ return nv }
						
				})
				
				if (action.type === ROTATE){
					mesh.angular_impulse.add(action.vector)
				}else if(action.type === MOVE){
					if(action.vector instanceof T.Vector3){
						var v = action.vector
					}else{
						var v = new T.Vector3(action.vector.x, action.vector.y, action.vector.z)
					
					}
					var tug = v.clone().applyQuaternion(mesh.quaternion);
					mesh.impulse.add(tug);
					
					

				
				}
				
			}
			// console.log('call process',  _.has(raw_action,'vector') );
			
			if (_.has(raw_action, 'vector'))  { // ÐÑÐ»Ð¸ Ð°ÐºÑÐ¸Ñ ÑÐ¶Ðµ Ð²ÑÑÐ¸ÑÐ»Ð¸Ð»Ð¸ - Ð±ÑÐ´ÐµÐ¼ Ð¿ÑÐ¸Ð¼ÐµÐ½ÑÑÑ Ð²ÑÐµ Ð²ÐµÐºÑÐ¾ÑÐ° Ð½Ð° Ð½ÐµÐµ
				process('-', raw_action)
			}else{
				this.act_for_mesh(mesh, raw_action, process); // ÐÑÐ»Ð¸ Ð½ÐµÑ - ÑÐ¾ ÑÐ½Ð°ÑÐ°Ð»Ð° Ð²ÑÑÐ¸ÑÐ»Ð¸Ð¼ Ð¸Ñ
			}
		};
		this.act_for_mesh=function(mesh, action, onAct){
			var C = mesh;
			var T = Controller.T();
			
			var ets ={};
			ets[ROTATE]='rotation';
			ets[MOVE] = 'propulsion';
			
			var et = ets[action.type]
			if(typeof action.p === 'string'){
				action.p = JSON.parse(action.p);
			}
			var ea = action.p.a ==0 ? 'x' : action.p.a ==1 ? 'y': 'z'
			if(action.p.d <0){ea +='-'}else{ea += '+' }
			var engine_name = et + "_" + ea
			
			var AX= action.p.a;
			var ar = [0,0,0];
			ar[AX] = action.p.d
			
			var vec = new T.Vector3();
			vec.fromArray(ar);         // AX == 'x'?new T.Vector3(a,0,0):(AX =='y'?new T.Vector3(0, a, 0): new T.Vector3(0,0,a))
			// Ð¢ÐµÐ¿ÐµÑÑ ÐµÐ³Ð¾ Ð½Ð°Ð´Ð¾ ÑÐ¼Ð½Ð¾Ð¶Ð¸ÑÑ Ð½Ð° Ð¼Ð¾ÑÐ½Ð¾ÑÑÑ Ð´Ð²Ð¸Ð³Ð°ÑÐµÐ»Ñ Ð¸ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ ÑÐ¸Ð»Ñ
			// Ð¢ÐµÐºÑÑÐ°Ñ Ð¼Ð¾ÑÐ½Ð¾ÑÑÑ Ð´Ð²Ð¸Ð³Ð°ÑÐµÐ»Ñ - ÑÑÐ¾ Ð¿ÑÐ¾ÑÐµÐ½Ñ ÐµÐ³Ð¾ Ð¼Ð¾ÑÐ½Ð¾ÑÑÐ¸, ÑÐ¼Ð½Ð¾Ð¶ÐµÐ½Ð½ÑÐ¹ Ð½Ð° ÐµÐ³Ð¾ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½ÑÑ Ð¼Ð¾ÑÐ½Ð¾ÑÑÑ, ÑÐ¼Ð½Ð¾Ð¶ÐµÐ½Ð½ÑÐ¹ Ð½Ð° ÐµÐ³Ð¾ ÐÐÐ Ð² Ð´Ð¶Ð¾ÑÐ»ÑÑ
			// console.log(action.wp);
			var percent_of_power = mesh.getWorkpointValue(action.wp, "eng_" + engine_name + "_power");
			//console.log ("MM", mesh.workpoint_states,action.p, action.wp, "eng_" + engine_name + "_power");
			var max_power = mesh.type.engines[et][ea].consumption;
			var performance = mesh.type.engines[et][ea].performance;
			var energy_consumption = percent_of_power* max_power * action.delta;
			action.energy_consumption = energy_consumption;
			
			var capacitor_left = mesh.getWorkpointValue("Piloting", "capacitor");
			if (capacitor_left < energy_consumption){
				energy_consumption = capacitor_left;
			}
			//console.log("took energy", energy_consumption);
			//L.setValue("NEW CONS", energy_consumption);
			
			var impulse = energy_consumption * performance;
			//L.setValue("NEW IMPULSE", impulse);
			
			// var power = C.engines[et][ea];
			// console.log(percent_of_power, max_power, energy_consumption, impulse);
			
			vec.multiplyScalar(impulse);
			//console.log("action delta", action.ts, action.delta);
			// vec.multiplyScalar(action.delta)
			action.vector = vec
			
			// ÐÐ°ÑÐ»Ð¸ Ð²ÑÐµ ÑÐ¸Ð»Ñ Ð¸ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ Ð¾Ð±ÑÐ°ÑÐ½Ð¾ ÑÐ¾Ð±ÑÑÐ¸Ðµ
			// console.log("MESH", "GUID", C);
			onAct(C.json.GUID, action)
			
		},
		this.act = function(S, action,  actor_guid, onAct_ ){
			// Ð­ÑÐ° ÑÑÐ½ÐºÑÐ¸Ñ ÑÐ¾Ð·Ð´Ð°ÑÐµÑ Ð°ÐºÑÐ¸Ñ Ð¸ÑÑÐ¾Ð´Ñ Ð¸Ð· ÑÑÐ»Ð¾Ð²Ð¸Ð¹ Ð¾ÐºÑÑÐ¶ÐµÐ½Ð¸Ñ
			// Ð Ð´Ð°Ð½Ð½Ð¾Ð¼ ÑÐ»ÑÑÐ°Ðµ Ð½Ð°Ð¼ Ð½Ð°Ð´Ð¾ ÑÐ¾Ð·Ð´Ð°ÑÑ Ð¿Ð¾Ð´ÑÐ¾Ð±Ð½Ð¾ Ð¾Ð¿Ð¸ÑÑÐ²Ð°ÑÑÐµÐµ ÑÐ¾Ð±ÑÑÐ¸Ðµ Ð¾ ÑÐ¾Ð¼, ÑÑÐ¾ Ð¼Ð¾Ð¶ÐµÑ Ð¸ Ð´Ð¾Ð¶Ð½Ð¾ Ð¿ÑÐ¾Ð¸ÑÑÐ¾Ð´Ð¸ÑÑ Ñ ÐºÐ¾ÑÐ°Ð±Ð»ÐµÐ¼
			if(S === undefined ) return;
			var C = S.mesh_for(actor_guid);
			var actor = S.actors[actor_guid];
			var onAct = function(guid, action){
				onAct_(guid, action);
			}
			action.wp = actor.control.workpoint;
			this.act_for_mesh(C, action, onAct );

			
		}
		*/
		// return this;
	
	};


Controller.basicAutoPilotActor=function (S, id, oid){
		this.targets = ["orbit_object", "close_to_object"];
		this.default_distance = 200
		this.get_foes = function(){
			this.foes = []
			for (var i =0; i < W.meshes.length; i++){
				if(i != id) foes.push({id:id, obj:W.meshes[i]})
			}
		}
	};

	
Controller.CTurretController = function(){
	this.type = 'turret';
	
	this.getUI = function(W, actor){
		var ui = function(){
			this.rules_height = 140
			this.actor = actor;
			this.construct = function(){
				this.cont = $('<div>').css({'position':'fixed',
								// 'border': '1px solid red',
								'width':"66px",
								'height': '170px',
								'top':40,
								'left':50,
								'background-color':'white'}).appendTo('body');
				
				var rul_cont = $('<div>').css({
					"width":  "100%",
					"height": this.rules_height + 'px',
					'background-color':'blue'
		
				}).appendTo(this.cont);
	
				var bul_cont = $('<div>').css({
					"width":  "100%",
					"height": (170 - this.rules_height) + "px",
					'background-color':'green'
				}).appendTo(this.cont);
	
				var auto_track_switch = $('<div>').css({'width':'22px',
														'height':'22px',
														'border-radius':'11px',
														'float':'left',
														'background-color':'white'}).appendTo(rul_cont);
				this.magazine_indicator = $('<div>').css(
					{'width':'22px',
					'height':  this.rules_height +  'px',
					'float':'left',
					'background-color':'red'}).appendTo(rul_cont);
				this.time_indicator = $('<div>').css(
					{'width':'22px',
					'height':  this.rules_height+  'px',
					'float':'left',
					'background-color':'red'}
				) .appendTo(rul_cont);
	
			}
			this._set_magazine_capacity = function(){
				var O = W.scenes[actor.scene].meshes[actor.control.object_guid];
				var wp = O.json.workpoints[actor.control.workpoint];
				var mag_cap = O.json.turrets[wp.turret].magazine_capacity;
				var _mag    = O.getWorkpointValue(actor.control.workpoint, "magazine");
				if (! _mag) _mag = 0;
				
				var percentage = _mag/ mag_cap;
				if(_mag  == 0){
					this.magazine_indicator.height("1px");
					this.magazine_indicator.css('background-color','red')
					
				}else{
					this.magazine_indicator.height(percentage * this.rules_height);
					this.magazine_indicator.css('background-color','green')
				}
				
				
				
				
			}
			this._set_readiness_timer = function(){
				var O = W.scenes[actor.scene].meshes[actor.control.object_guid];
				var wp = O.json.workpoints[actor.control.workpoint];
				var rate = O.json.turrets[wp.turret].turret_shoot_rate;
				var reload_rate = O.json.turrets[wp.turret].turret_reload_rate;
				
				var _ts  = O.getWorkpointValue(actor.control.workpoint, "last_shot_time");
				var ir_ts = O.getWorkpointValue(actor.control.workpoint, "is_reloading");
				var now  = new Date().getTime();

				var ir_diff = now - ir_ts;
				if(ir_diff > reload_rate){
					var _mag    = O.getWorkpointValue(actor.control.workpoint, "magazine");
				
					var diff = now - _ts;
					if(_mag === 0 ){
						percentage = 0;
					}else{
						if(diff > rate){
							var percentage = 1;
						} else{
							var percentage =  (diff / rate);
						}
					
					}
					
				}else{
					percentage = ir_diff/reload_rate;
				}
				
				
				this.time_indicator.height(percentage * this.rules_height);
				
				
			}
			this.refresh = function(){
				this._set_readiness_timer();
				this._set_magazine_capacity();
			}
		}
		
		var UI = new ui();
		return UI;
	}
		
	
	
	this.process = function(raw_action, mesh){
		// console.log("On the server", action);
		
		var process = function(object_guid, action){
			console.log("CHO", action.type === SHOOT, action.type == SHOOT, action.type)
			if(action.type == RELOAD_WEAPONS){
				
				console.log("process > REALODING:", action);
				mesh.saveWorkpointValue( action.wp, "is_reloading" , action.ts ); 
				mesh.saveWorkpointValue( action.wp, 'magazine', action.new_capacity);
			}
			if(action.type === HIT){
				console.log("process > HITED", action);
			}
			
			if (action.type == SHOOT){
				
				
				mesh.saveWorkpointValue(action.wp, "last_shot_time", action.ts);
				var am = mesh.getWorkpointValue(action.wp, 'magazine');
				if (am ){
					if (am !== 0){
						mesh.saveWorkpointValue(action.wp,"magazine", am - 1);
					}
				}
				
			}
			
		}
		// console.log('call process',  _.has(raw_action,'vector') );
		
		//if (_.has(raw_action, 'vector'))  { // ÐÑÐ»Ð¸ Ð°ÐºÑÐ¸Ñ ÑÐ¶Ðµ Ð²ÑÑÐ¸ÑÐ»Ð¸Ð»Ð¸ - Ð±ÑÐ´ÐµÐ¼ Ð¿ÑÐ¸Ð¼ÐµÐ½ÑÑÑ Ð²ÑÐµ Ð²ÐµÐºÑÐ¾ÑÐ° Ð½Ð° Ð½ÐµÐµ
		process('-', raw_action)
			//}else{
		//	this.act_for_mesh(mesh, raw_action, process); // ÐÑÐ»Ð¸ Ð½ÐµÑ - ÑÐ¾ ÑÐ½Ð°ÑÐ°Ð»Ð° Ð²ÑÑÐ¸ÑÐ»Ð¸Ð¼ Ð¸Ñ
			// }
	};
	
		this.act = function(S, action,  actor_guid, onAct ){
			if (S === undefined){return;}
			
			var C = S.mesh_for(actor_guid);
			
			if (action.type === HIT){
				console.log("we already processed  hit", action);
				
				return;
			}
			if(action.type === RELOAD_WEAPONS){
				// Here we could check if we can reload - isn't bullet bunker empty?
				var actor = S.get_actor(actor_guid);
				var O = S.meshes[actor.control.object_guid];
				var wp = O.json.workpoints[actor.control.workpoint];
				var mag_cap = O.json.turrets[wp.turret].magazine_capacity;
				
				actor = S.get_actor(actor_guid);
				action.wp = actor.control.workpoint;
				action.new_capacity = mag_cap;
				onAct(C.json.GUID, action);
			}
			if (action.type === SHOOT ){
				// if(! is_down) return;
				// console.log('>>>');
				// var weapon = C.weapons[0];
				//console.log("shot by", actor)
				
				var T = Controller.T();
				//console.log("Woah");
				
				// TODO ÐÐ°Ð´Ð¾ ÑÐ´ÐµÐ»Ð°ÑÑ Ð¿ÑÐ¾ÑÑÐ¾Ð¹ ÑÐ¿Ð¾ÑÐ¾Ð± Ð¿ÑÐ¾Ð²ÐµÑÐ¸ÑÑ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ðµ Ð² ÑÐµÐºÑÑÑÑÑ ÑÐµÐ»Ñ Ð¸ÑÑÐ¾Ð´Ñ Ð¸Ð· Ð´Ð°Ð½Ð½ÑÑ Ð² ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ð¸
				// TODO ÐÐµ Ð±ÑÐ´ÐµÐ¼ Ð³Ð½Ð°ÑÑÑÑ Ð·Ð° Ð´Ð¾ÑÑÐ¾Ð²ÐµÑÐ½Ð¾ÑÑÑÑ - Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼ Ð´Ð¾ÑÑÐ¾Ð²ÐµÑÐ½Ð¾ÑÑÐ¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ + Ð²Ð²Ð¾Ð´Ð¸Ð¼ Ð²ÐµÐ»Ð¸ÑÐ¸Ð½Ñ Ð²ÐµÐ·ÐµÐ½Ð¸Ñ.
				// TODO ÐÑÐ°ÑÑÐ°Ð¹ÑÐµÐµ ÑÐ°ÑÑÑÐ¾ÑÐ½Ð¸Ðµ Ð¼ÐµÐ¶Ð´Ñ ÑÐºÑÐµÑÐ¸Ð²Ð°ÑÑÐ¸Ð¼Ð¸ÑÑ ÐºÑÐ¸Ð²ÑÐ¼Ð¸ Ð¸ ÑÑÐ°Ð²Ð½ÐµÐ½Ð¸Ðµ Ñ ÑÐ¸Ð·Ð¸ÑÐµÑÐºÐ¸Ð¼Ð¸ ÑÐ°Ð·Ð¼ÐµÑÐ°Ð¼Ð¸
				// TODO Ð£Ð¼Ð½Ð¾Ð¶ÐµÐ½Ð½Ð¾Ðµ Ð½Ð° ÐºÐ¾ÑÑÑÐ¸ÑÐ¸ÐµÐ½ÑÑ ÑÐ°Ð·Ð±ÑÐ¾ÑÐ°
				// ÐÐ»Ñ Ð¼ÐµÐ´Ð»ÐµÐ½Ð½Ð¾ Ð´Ð²Ð¸Ð¶ÑÑÑÐ¸ÑÑÑ Ð·Ð°ÑÐ°Ð´Ð¾Ð² Ð²ÑÑÐ¸ÑÐ»ÑÑÑ Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ÑÑÑ Ð¸Ñ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ - Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÑ Ð¸Ð·Ð¼ÐµÐ½Ð¸ÑÑ ÑÐºÐ¾ÑÐ¾ÑÑÑ ÑÐµÐ»Ð¸ ÑÐ°Ðº, ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð¿Ð°ÑÑÑ Ð¿Ð¾Ð´ Ð¾Ð±ÑÑÑÐµÐ» Ð¸Ð»Ð¸ ÑÐ¹ÑÐ¸ Ð¾Ñ Ð½ÐµÐ³Ð¾
				// ÐÐ»Ñ ÑÐ°ÐºÐµÑ - ÑÑÐ¾ Ð±ÑÐ´ÑÑ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð·Ð°ÑÐ²Ð°ÑÐ° ÑÐµÐ»Ð¸ Ð¸ Ð²ÑÑÑÑÐµÐ»Ð° - Ð²Ð»Ð¸ÑÐ½Ð¸Ñ Ð½Ð° ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ðµ ÑÑÑÐµÐ»Ð¸.
				
				
				var seed = Math.random() // Ð­ÑÐ¾ Ð·ÐµÑÐ½Ð¾ Ð±ÑÐ´ÐµÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑÑÑ Ð´Ð»Ñ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ÑÑÐµÐ¹ Ð¸ Ð¾Ð½Ð¾ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð·Ð°Ð¿Ð¸ÑÐ°Ð½Ð¾ Ð² ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ - ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð·Ð²Ð¾Ð»Ð¸ÑÑ ÑÐµÑÐ²ÐµÑÑ Ð²ÑÑÐ¸ÑÐ»Ð¸ÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ð´ÐµÑÐµÑÐ¼Ð¸Ð½Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾
				// console.log(action)
				// Ð¢ÐµÐ¿ÐµÑÑ Ð²ÑÑÐ»ÑÐµÐ¼ Ð²ÐµÐºÑÐ¾Ñ Ð²ÑÑÑÑÐµÐ»Ð° Ð² Ð¼Ð¸ÑÐ¾Ð²ÑÑ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ñ
				var shoot_vec = new T.Vector3(action.p.turret_direction.x,
											  action.p.turret_direction.y,
											  action.p.turret_direction.z);

				//dist
				// For all targets:
				// calculate closest distance and time to that 
				// console.log("ACTOR", actor);
				
				var C = S.mesh_for(actor_guid);
				var object = C.json
				var actor = S.actors[actor_guid];
				
				
				var wp = object.workpoints[actor.control.workpoint];
				
				var last_shot_time = C.getWorkpointValue(actor.control.workpoint, "last_shot_time")
				var is_reloading = C.getWorkpointValue(actor.control.workpoint, "is_reloading"  ); 
				var _mag = C.getWorkpointValue(actor.control.workpoint, "magazine")
				
				console.log("SERV act before", action);
				// console.log("LOG TIMES", is_reloading, last_shot_time,  action.ts - is_reloading, action.ts - last_shot_time);
				
				if( (action.ts -  is_reloading) < C.json.turrets[wp.turret].turret_reload_rate){
					return ;
				}
				console.log("SERV act - reloaded", action);
				
				if(_mag == 0){
					return ;
				}
				console.log("SERV act full mag", action);
				
				if (last_shot_time){
					// console.log("last shot time", last_shot_time,(action.ts - last_shot_time ) < C.json.turrets[wp.turret].turret_shoot_rate );
					if((action.ts - last_shot_time ) < C.json.turrets[wp.turret].turret_shoot_rate){
						// console.log('no shoot');
						return; // this turret cannot shoot now
					}
				}
				console.log("SERV act shoot freely", action);
				
				// console.log("BOOOSH!");
				
				
				var turret = object.turrets[ wp.turret ] 
				
				var turret_position_vector = new T.Vector3();
				turret_position_vector.fromArray(turret.position );
				
				var bullet_pos = C.position.clone()
				bullet_pos.add(  turret_position_vector.clone() )
				
				shoot_vec.sub(bullet_pos.clone())
				// ÐÐ°Ð´Ð¾ ÑÐ¾ÑÑÐ°Ð²Ð¸ÑÑ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¼ÐµÑÐµÐ¹, ÑÐµÑÐµÐ· ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¿ÑÐ¾ÑÐ¾Ð´Ð¸Ñ Ð»ÑÑ ÑÑÐ°ÐµÐºÑÐ¾ÑÐ¸Ð¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ ÑÐ½Ð°ÑÑÐ´Ð° Ñ ÑÑÐµÑÐ¾Ð¼ Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ÑÑÐ¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ
				var collidables = [];
				_.each(S.meshes, function(mesh, i){
					if(i ==  actor.control.object_guid) return;
					
					var target_pos = mesh.position.clone();
					var target_impulse = mesh.impulse.clone();
					var target_velocity = target_impulse.multiplyScalar(1/mesh.mass);
					
					// Ð£Ð²ÐµÐ»Ð¸ÑÐ¸Ð¼ ÑÐºÐ¾ÑÐ¾ÑÑÑ Ð²Ð¾ Ð¼Ð½Ð¾Ð³Ð¾-Ð¼Ð½Ð¾Ð³Ð¾ ÑÐ°Ð·
					// shoot_vec.multiplyScalar( 100 );
					target_pos.sub( bullet_pos );
					target_velocity.sub( shoot_vec );
					
					var dot = target_pos.dot(target_velocity);
					
					
					var cosp = dot/( target_pos.length() * target_velocity.length() )
					var sinp = Math.sqrt(1 - cosp*cosp);
					
					var v = Math.abs(cosp) * target_velocity.length();
					// console.log(v, target_pos.length());
					var time = target_pos.length() / v 
					var distance = sinp * target_pos.length(); // ÐÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð°Ñ Ð´Ð¸ÑÑÐ°Ð½ÑÐ¸Ñ, Ð² ÐºÐ¾ÑÐ¾ÑÐ¾Ð¹ Ð¿ÑÐ¾Ð¹Ð´ÐµÑ ÑÐ½Ð°ÑÑÐ´ Ð¾Ñ ÐºÐ¾ÑÐ°Ð±Ð»Ñ
					
					//console.log("distance and time", distance, time);
					
					// Ð ÐµÑÐµÐ½Ð¸Ðµ Ð¾ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ð¸ Ð½Ð°Ð´Ð¾ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÑÑ Ð·Ð´ÐµÑÑ
					//  distance ÐÐ¾Ð¶ÐµÑ ÑÐ¼ÐµÐ½ÑÑÐ¸ÑÑÑÑ Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑÐ¸ Ð¾Ñ ÑÐºÐ¸Ð»Ð»Ð¾Ð² Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸ ÑÐ°ÑÐ°ÐºÑÐµÑÐ¸ÑÑÐ¸Ðº Ð¾ÑÑÐ¶Ð¸Ñ
					
					// Ð¡ÑÐ°Ð²Ð½ÐµÐ½Ð¸Ðµ Ñ Ð³ÐµÐ¾Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ¸Ð¼Ð¸ ÑÐ°Ð·Ð¼ÐµÑÐ°Ð¼Ð¸ ÑÐµÐ»Ð°:
					var boundRadius = mesh.geometry.boundingSphere;
					// console.log("SPHERE", boundRadius.radius, distance);
					if(distance < boundRadius.radius){
						// hit 
						collidables.push({time: time, mesh:i, distance:distance})
						
					}
					
					// Ð¡Ð¸Ð½ÑÑ - ÑÑÐ¾ Ð¼ÐµÑÐ° Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ. ÐÑÐ¸ ÑÐ¼Ð½Ð¾Ð¶ÐµÐ½Ð¸Ð¸ ÐµÑ Ð½Ð° Ð²ÐµÐºÑÐ¾Ñ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¸ Ð¼Ñ ÑÐ·Ð½Ð°ÐµÐ¼ Ð½Ð° ÐºÐ°ÐºÐ¾Ð¹ Ð´Ð¸ÑÑÐ°Ð½ÑÐ¸Ð¸ Ð¿ÑÐ¾Ð¹Ð´ÐµÑ ÑÐ½Ð°ÑÑÐ´ Ð¾Ñ ÑÐµÐ»Ð¸
					// ÐÐ¾ÑÐ¸Ð½ÑÑ Ð´Ð°ÐµÑ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¾ Ð²ÑÐµÐ¼ÐµÐ½Ð¸  Ð´Ð¾ ÐºÐ¾Ð½ÑÐ°ÐºÑÐ°. ÐÑÐ»Ð¸ ÐºÐ¾ÑÐ¸Ð½ÑÑ Ð¾ÑÑÐ¸ÑÐ°ÑÐµÐ»ÑÐ½ÑÐ¹ - Ð·Ð½Ð°ÑÐ¸Ñ  
					// console.log("sin and cos", target_pos.toArray(), mesh.position.toArray(), sinp, cosp);
					
				});
				// Ð¢ÐµÐ¿ÐµÑÑ, Ð½Ð°Ð´Ð¾ Ð·Ð°Ð¿Ð¸ÑÐ½ÑÑÑ ÑÑÐ¾ ÑÐ¾Ð±ÑÑÐ¸Ðµ Ð² Ð¾ÑÐµÑÐµÐ´Ñ Ð¿ÑÐ¾ÑÐµÑÑÐ¸Ð½Ð³Ð°:
				// 1. Ð¡Ð¾Ð±ÑÑÐ¸Ðµ - Ð¸Ð¼Ð¿ÑÐ»ÑÑ Ð½Ð° Ð½Ð°Ñ, ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ Ð¼Ð¾Ð¶ÐµÑ Ð²ÐºÐ»ÑÑÐ°ÑÑ ÑÐ°ÐºÐ¶Ðµ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ðµ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¹ Ð²Ð½ÑÑÑÐµÐ½Ð½Ð¸Ñ Ð¿ÑÐ¸Ð±Ð¾ÑÐ¾Ð² - Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¿Ð°ÑÑÐ¾Ð½Ð¾Ð²
				// 2. Ð ÑÐ»ÑÑÐ°Ðµ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ - Ð¾ÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð² Ð±ÑÐ´ÑÑÐµÐµ ÑÐ¾Ð±ÑÑÐ¸Ðµ Ð¾Ð± Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¸ Ð¸Ð¼Ð¿ÑÐ»ÑÑÐ° Ð¸ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ ÑÐµÐ»Ð¸.
				
				action.wp = actor.control.workpoint;
				console.log("checkout if we got it");
				if (collidables.length > 0){
					var col = _.sortBy(collidables, function(i){ return i.time})[0]
					var  mesh_id = col.mesh
					action.hit = true;
					action.time = col.time;
					action.mesh = mesh_id;
					action.distance = col.distance;
					action.seed = seed;
					
					var hit_action = {};
					hit_action.ts = action.ts + action.time;
					hit_action.slave = true;
					hit_action.parent = action.ident;
					hit_action.diff = action.diff;
					hit_action.power = 100500;
					hit_action.distance = col.distance;
					hit_action.mesh = mesh_id;
					hit_action.controller = "turret";
					hit_action.type = HIT;
					hit_action.actor = action.actor;
					// console.log("HIT", action, hit_action);
					console.log("HIHIHIT", action.time);
					onAct(mesh_id, hit_action);
					
					
				}else{
					action.hit = false;
				}
				onAct(C.json.GUID, action);
				 
				
			
			}
		}
		// return this;
	
	};
Controller.ControllersActionMap= function(){
		if (this._ControllersActionMap){
			return this._ControllersActionMap
		}else{
			// ÐÐ¾Ð¾Ð±ÑÐµ Ð½Ð°Ð¼ Ð±Ñ Ð½Ðµ Ð¿Ð¾Ð¼ÐµÑÐ°Ð»Ð¸ Ð¸Ð½ÑÑÐ°Ð½ÑÑ ÐºÐ¾Ð½ÑÑÐ¾Ð»Ð¾Ð² Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐµ Ð´Ð»Ñ ÑÐ²Ð¾ÐµÐ¹ wp ÑÑÐ¾Ð±Ñ Ð½Ðµ ÐºÐ¾Ð½Ð¾Ð¿Ð°ÑÐ¸ÑÑ Ð¼Ð¾Ð·Ð³.
			var PilotController = new Controller.CPilotController();
			var TurretController = new Controller.CTurretController();
			var SettingsController = new Controller.CSettingController();
			this._ControllersActionMap = {}
			//this._ControllersActionMap[MOVE]= PilotController;
			//this._ControllersActionMap[ROTATE]=PilotController;
			this._ControllersActionMap['pilot']= PilotController;
			this._ControllersActionMap['engine']= PilotController;
			
			this._ControllersActionMap['turret']= TurretController;
			this._ControllersActionMap['settings'] = SettingsController;
			
			return this._ControllersActionMap;
			
		}
	}

if(typeof window === 'undefined'){
	Controller.T = function(){
		return THR
	};
	Controller.createShotParticle=function(){
		var T = this.T();
		console.log('P');
		var cubeGeometry = new T.CubeGeometry(1,1,1,1,1,1);
		var map	= T.ImageUtils.loadTexture( "/textures/lensflare/lensflare0.png" );
		var SpriteMaterial = new T.SpriteMaterial( { map: map, color: 0xffffff, fog: true } );
		return new T.Object3D();
	};

}else{
	Controller.T = function(){
		return THREE
	};
	Controller.createShotParticle=function(){
		var T = this.T();
		// console.log("particle")
		// var cubeGeometry = new T.CubeGeometry(1,1,1,1,1,1);
		var map	= T.ImageUtils.loadTexture( "/textures/lensflare/lensflare0.png" );
		var material = new T.SpriteMaterial( { map: map, color: 0xffffff, fog: true } );
		material.transparent = true;
		material.blending = THREE.AdditiveBlending;
		
		// var a = new T.Sprite(material);
		var a = new T.Mesh(new T.SphereGeometry(2));
		a.static = false;
		a.has_engines = false;
		return a
	};
	
}

Controller.BasicBulletActor=function(S, id, coid){ 
		// id = is object in the world controllable by this actor
		// coid  MUST BE an object, who shoot this bullet
		//var S = W.scene
		this.name = "Basic_actor_" + (new Date().getTime())
		// this.W;
		this.oid = id
		this.coid = coid
		// console.log(id);
		this.my_mesh = S.meshes[id]
		//console.log("MY MESH", this.my_mesh, id)
		var self = this;
		// console.log(W.meshes, id, W.meshes.length)
		var total_time_in_space = 0;
		var _possible_targets = {};
		var T = Controller.T();
	
		this.run = function(time_left){
			total_time_in_space += time_left
			//console.log('running');
			if (total_time_in_space > 10){
				//S.meshes.splice(id, 1)
				//console.log("removing")
				S._delete_object(id)
				delete S.automatic_actors[this.name];
			}
			var vel = this.my_mesh.vel.clone();
			var mpos = this.my_mesh.position.clone();
		
			var thres = 4 * this.my_mesh.vel.length();
			var in_thres = [];
			//console.log("THRes", thres);
		
			_.each( S.meshes, function(m,i) {
				if(i === id || i === coid) return;
				if(m.is_not_collidable) return;
				// var m = W.meshes[i];
				var mp =  m.position.clone();
				var pd = mp.sub( mpos )
				// console.log( vel, pd )
				var ag = Math.acos(pd.dot(vel)/ vel.length() / pd.length()) // ÑÐ³Ð¾Ð» Ð¼ÐµÐ¶Ð´Ñ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸ÐµÐ¼ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ Ð¸ ÑÐµÐ½ÑÑÐ¾Ð¼ Ð¾Ð±ÑÐµÐºÑÐ°
				if (ag < Math.PI/16)
				{
					//console.log('ag');
					// console.log("HH", i, ag, Math.PI/8);
				
					// console.log("id vefore", 	id, );
					var sub = self.my_mesh.position.clone().sub( mp );
					
					var dist = sub.length()
					if( dist < thres){
						//console.log("OKE");
						if( in_thres.indexOf( i ) === -1 ){
							//console.log('possible');
						
							in_thres.push(i) // Add mesh index
							target = {last_point :mpos.clone(),
									  last_angle : ag,
									  last_distance : dist,
									  angle_raise : 0,
									  distance_raise :0,
									  distance_shortens : 0,
									  angle_lowers : 0,
								  	  id : i}
							_possible_targets[i] = target
						}//else{}
					}
					
				}else{
					if(i in _possible_targets){
						//console.log('POS', i)
						// Ð£Ð³Ð¾Ð» Ð±ÑÐ» Ð¾ÑÑÑÑÐ¹ - ÑÑÐ°Ð» ÑÑÐ¿Ð¾Ð¹
						// console.log("here!",i);
						// ÐÐ°Ð´Ð¾ Ð¿ÑÐ¾Ð²ÐµÑÐ¸ÑÑ, Ð½Ðµ Ð¿ÐµÑÐµÑÐµÐºÐ°ÐµÑ Ð»Ð¸ Ð¾ÑÑÐµÐ·Ð¾Ðº - Ð¿ÑÐ¾ÑÐ»ÑÐµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ - ÑÐµÐºÑÑÐ¸Ðµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð½Ð°Ñ Ð¼ÐµÑ
						var direction = mpos.clone().sub( _possible_targets[i].last_point)
						var ray = new T.Raycaster(_possible_targets[i].last_point, direction.clone().normalize() )
						if(S.need_update_matrix){
							m.updateMatrixWorld();
						}
						var isr = ray.intersectObjects([m])
						//if (m.type == 'ship'){
							
							// console.log("matrix autoupd", m.matrixWorld.elements)
							// console.log(mpos);
							// console.log(ray,isr)
							
							//}
						
						//console.log( m.type )
						if (isr.length > 0 && isr[0].distance < direction.length() ){
							//for( var index =0; index<isr.length; index++){
							//	console.log("HERE", isr[index].distance, direction.length())
							///}
					
							// console.log('HIT')
							// console.log("END", isr[0].point);
							m.worldToLocal(isr[0].point) // Ð¢ÐµÐ¿ÐµÑÑ ÑÑÐ¾ Ð¿Ð»ÐµÑÐ¾ ÑÐ´Ð°ÑÐ°
							var impulse = self.my_mesh.impulse;  //vel.clone().multiplyScalar(self.my_mesh.mass)
							var axis = new T.Vector3().crossVectors(isr[0].point, impulse)
					
							var ag = Math.acos(isr[0].point.clone().dot(impulse) / impulse.length() / isr[0].point.length() )
							// Ð¢ÐµÐ¿ÐµÑÑ ÑÑÐ¾ Ð²ÑÐ°ÑÐµÐ½Ð¸Ðµ Ð½Ð°Ð´Ð¾ ÑÐ°Ð·Ð±Ð¸ÑÑ Ð¿Ð¾ Ð¾ÑÑÐ¼
							var mat = new T.Matrix4().makeRotationAxis(axis.normalize(), ag)
							var eul = new T.Euler()
							eul.setFromRotationMatrix(mat, "XYZ")
							// console.log(i, eul)
							var avel = new T.Vector3();
							avel.x = eul.x;
							avel.y = eul.y;
							avel.z = eul.z;
							var ck = isr[0].point.length() * Math.sin(ag - Math.PI/2)
					
							// console.log(this.my_mesh.mass / m.mass * (ck * ck ));
							avel.multiplyScalar(self.my_mesh.mass/m.mass * Math.abs(ck))
					
							// ÐÐµ ÑÑÐ¸ÑÑÐ²Ð°Ñ Ð¼Ð°ÑÑÑ Ð¸ Ð¿Ð»ÐµÑÐ¾... 
							var mavel = S.meshes[i].avel
							if (! mavel ){mavel = new T.Vector3(0,0,0)}
							mavel.x += avel.x
							mavel.y += avel.y
							mavel.z += avel.z;
							// console.log(mavel.x, mavel.y, mavel.z)
							S.meshes[i].avel = mavel;
					
					
					
							// add_vel = impulse.multiplyScalar( 1/ m.mass);
							// console.log(add_vel)
							// Ð£Ð±ÑÐ°ÑÑ Ð¿Ð¾ÐºÐ° ÑÐºÐ¾ÑÐ¾ÑÑÑ
							//if (S.meshes[i].vel){
								// console.log(S.meshes[i].impulse)
							S.meshes[i].impulse.add( impulse );
							// console.log(S.meshes[i].impulse)
								// }
					
					
							//console.log("END LOCAL", isr[0].point);
							//console.log('oke, we shoot it:', i)
							// Now we will just remove object from scene with the bullet
							//W.scene.remove(W.meshes[i])
							S._delete_object(id)
							
							//if(S.three_scene){
							//	S.three_scene.remove(S.meshes[id]) // ÑÐ´ÑÐ»ÑÐµÐ¼ ÑÐ´ÑÐ¾ Ð¸Ð· ÑÑÐµÐ½Ñ
							//}
							//delete S.meshes[ id ]; // ... Ð¸Ð· Ð¼ÐµÑÐµÐ¹
							delete S.actors[self.name]; // ... Ð£Ð´Ð°Ð»ÑÐµÐ¼ ÑÑÐ¾Ð³Ð¾ Ð°ÐºÑÐ¾ÑÐ° - Ð±Ð¾Ð»ÑÑÐµ Ð½Ðµ Ð·Ð°Ð³ÑÑÐ·Ð¸ÑÑÑ ÑÑÐ° ÑÑÐ½ÐºÑÐ¸Ñ
					
							//W.meshes.splice(i, 1);
							delete _possible_targets[i] // ... Ð¸Ð· Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑÑ ÑÐµÐ»ÐµÐ¹ ÑÐ´Ð°Ð»ÑÐµÐ¼ ÑÑÐ¾Ñ Ð¼ÐµÑ
							// bla.bla = 1
						}else{
							delete _possible_targets[i];
						
						}
					}
					// console.log( ag, Math.PI/8);
				
				}
			
			})
			//bla.bal +=1
			//console.log(bla)
		
		
			// console.log(total_time_in_space ,W.meshes.length, W.actors)
		}
	
	
	};
	
var Controllers = function (){

	var dev_con_proto = {
		process : function(action){
			mesh.setDeviceSetting(device.id, action.name, action.value);
	
		}
	};
	this.EngineController = function(mesh, device_id){
		
		this.getUI = function(W){
			
		}
		
		this.process = function(action){
			var T = Controller.T();
	
			var unit = new T.Vector3();
			unit.fromArray(mesh.type.devices[action.dev].unit);
			var engine_name = mesh.type.devices[action.dev].engine_type + "_" + mesh.type.devices[action.dev].name;
			var percent_of_power = mesh.getDeviceSetting(action.dev, "power");
			var engine_type = mesh.type.devices[action.dev].engine_type;
	
			var performance = mesh.type.devices[action.dev].performance;
			var consumption = mesh.type.devices[action.dev].consumption;
			var capacitor_left = mesh.getDeviceSetting(mesh.type.power_source, "capacitor");
			var energy_consumption = percent_of_power* consumption * action.delta;
	
			if (capacitor_left < energy_consumption){
				energy_consumption = capacitor_left;
			}
			var impulse = energy_consumption * performance;
			unit.multiplyScalar(impulse);
			mesh.update_static_physical_data(action.ts)
	
			mesh.alterDeviceSetting(mesh.type.power_source, 'capacitor' ,function(value){
				var nv = value - energy_consumption;
				if (nv < 0) {return 0}
				else{ return nv }
			
			})
	
	
			if (engine_type == 'rotation'){
				mesh.angular_impulse.add(unit)
			}else if(engine_type == 'propulsion'){
				var tug = unit.clone().applyQuaternion(mesh.quaternion);
				mesh.impulse.add(tug);
			}	
		}
	}
	this.EngineController.device_types = "engine";
	
	this.ShieldController = function(mesh, device_id){
		
		this.process = function(action){
			mesh.alterDeviceSetting(device_id, 'state', function(v){ return !v});
		}
		this.getUI = function(W){
			var ui = function(){
				this.construct = function(){
					var shield_dev = mesh.type.devices[device_id];
					
					var my_ind = $("#shield_indicator_"+device_id);
					console.log(my_ind.size());
					if(my_ind.size() != 0){
						my_ind.remove();
					}
			
					var shc = $("#shields_holder_container")
					if(shc.size() == 0){
						shc = $('<div id="shields_holder_container">').css({
							position:'fixed',
							left:0,
							height:50,
							bottom:50,
							'background-color':'#f3f',
							width:400
					
						}).appendTo('body');
					}
					var d  = $('<div >').attr('id',"shield_indicator_"+device_id) .css({width:50, height:"100%", float:'left', 'margin-right':"10px"}).appendTo(shc);
					var sic = $('<div>').css({width:"100%", height:10 }).appendTo(d) // strenth indicator container
					var l = shield_dev.shield_type.toLocaleUpperCase();
					var b = $('<div>').css({width:"100%", height:30,
											"text-align":'center',
											'vertical-align': 'middle',
											'line-height':'30px',
											'background-color':'#333','color':"#F0F"})
										.text(l).appendTo(d).click(function(){
									
											mesh.startDeviceAction(device_id, "toggle",0);
									
										}) 
					var cic = $('<div>').css({width:"100%", height:10}).appendTo(d) // capacitor indicator container
			
					var si = $('<div>').css({width:"100%", height:"100%", 'background-color':"blue" }).appendTo(sic);
					var ci = $("<div>").css({width:"100%", height:"100%",'background-color':"yellow" }).appendTo(cic);
					this._redraw_closure = function(){
						var reserve_cap_amount = mesh.getDeviceSetting(device_id, "reserve_capacity");
						var tot_cap_amount = shield_dev.capacitor;
						var w = reserve_cap_amount/tot_cap_amount * 100;
						ci.width( w + '%' );
				
						var is_on = mesh.getDeviceSetting(device_id, 'state') ;
						if (is_on){
							b.css({color:'red', 'background-color':'white'});
						}else{
							b.css({'background-color':'#333','color':"#F0F"});
						}
				
						var current_capacity = mesh.getDeviceSetting(device_id, 'capacity');
						var max_capacity = shield_dev.capacity;
						var ww =( current_capacity / max_capacity * 100) + "%";
						si.width(ww);
				
						// console.log("updating shield", shield, num);
					}
				}
				this.refresh = function(){
					this._redraw_closure();
				}
			}
			return new ui();
			
			
		}
	}
	this.ShieldController.device_types = "shield";
	
	this.EnergyCoreController = function(mesh, device_id){
		
		this.process = function(action){
			mesh.setDeviceSetting(action.dev_id, action.name, action.value);
		}
		this.getUI = function(W){
			var ui = function(){
				this.indicators_length = 110;
				this.total_width = 170;
				
				this.construct = function(){
					this.cont = $('<div>').css({
						'position':'fixed',
						// 'border': '1px solid red',
						'width': this.total_width + "px",
						'height': '60px',
						'top':40,
						'left':50+300,
						'background-color':'white'
					}).appendTo('body');
					
					this.indicators = $('<div>').css({
						"width": this.indicators_length,
						"height":"100%",
						"float": "left",
						'background-color':'white'
					}).appendTo(this.cont);

					this.switches = $('<div>').css({
						"width": this.total_width - this.indicators_length ,
						"height":"100%",
						"float": "left",
						'background-color':'white'
					}).appendTo(this.cont);
				
					this.fuel_indicator = $('<div>') .css({
						"width": this.indicators_length ,
						"height":"25%",
						// "float": "left",
						'background-color':'green'
					}).appendTo(this.indicators);
			
					this.power_indicator = $('<div>') .css({
						"width": this.indicators_length ,
						"height":"25%",
						// "float": "left",
						'background-color':'red'
					}).appendTo(this.indicators);
				
					this.capacitor_indicator = $('<div>') .css({
						"width": this.indicators_length ,
						"height":"50%",
						// "float": "left",
						'background-color':'yellow'
					}).appendTo(this.indicators);
					var self = this;
					this.engines_key = $("<div>").css({
						width:"100%",
						height:"20px",
					
					}).text("E").appendTo(this.switches).click(function(){
						self._engines_dialog();
					});
				
					this.shield_key = $("<div>").css({
						width:"100%",
						height:"20px",
					
					}).text("S").appendTo(this.switches).click(function(){
						self._shields_dialog();
					});;
				
					this.turret_keys = $("<div>").css({
						width:"100%",
						height:"20px",
					
					}).text("T").appendTo(this.switches);
			
			
				}
				this._shields_dialog = function(){
					//var mesh = W.scenes[actor.scene].meshes[actor.control.object_guid];
					//var scene = W.scenes[actor.scene];
					
					cont = $('<div>').css({
						'position':'absolute',
						// 'border': '1px solid red',
						'width': 400 + "px",
						'height': '600px',
						'top':40 + 100,
						'left':50+300,
						'padding': "10px",
						'border-radius':'3px',
						'border-width':'1px',
						'border-style':'solid',
						'border-color':'#aaa',
						'background-color':'#222'}).appendTo('body');
					var  cc = $('<div>').appendTo(cont).css({'width':"100%",height:20, 'padding-bottom': '30px'});
					var  closer = $('<div>').appendTo(cont).css({'width':"20", height:20, 'background-color':'red', float:'right' }).click(function(){
						cont.remove();
					}).appendTo(cc);
					
					_.each(mesh.type.shields, function(s, i){
						if (i === 'thermal'){return}
						_.each(s, function(shield_id){
							var e1 = $("<div>").css({
								width:300,
								height:40
							}).appendTo(cont);
								
							$('<div>').css({'float':'left', 'color':'#bbb'}).width(40).text(i).appendTo(e1) 
							var slc =  $('<div>').css({'float':'left', width:120,'margin-left':10}).appendTo(e1);
						
							var pc = new PowerControlWidget({container:slc[0], starting_percent:0, end_percent:1.5,progress_value:0,
								change: function( val ) {
									mesh.startDeviceAction(mesh.type.power_source, "power", val, {"dev_id": shield_id});

								},
								slide:function(val){ 
								}
								
							});
							// var sett =  "s_" + i + num + "_power"
							var cur_val = mesh.getDeviceSetting(shield_id, "power");
							pc.set_value( cur_val );
							
						})
					})
					
				};
				
				this._engines_dialog = function(){

					//var mesh = W.scenes[actor.scene].meshes[actor.control.object_guid];
					//var scene = W.scenes[actor.scene];

					cont = $('<div>').css({
						'position':'absolute',
						// 'border': '1px solid red',
						'width': 400 + "px",
						'height': '600px',
						'top':40 + 100,
						'left':50+300,
						'padding': "10px",
						'border-radius':'3px',
						'border-width':'1px',
						'border-style':'solid',
						'border-color':'#aaa',
						'background-color':'#222'}).appendTo('body');
						var  cc = $('<div>').appendTo(cont).css({'width':"100%",height:20, 'padding-bottom': '30px'});
						var  closer = $('<div>').appendTo(cont).css({'width':"20", height:20, 'background-color':'red', float:'right' }).click(function(){
							cont.remove();
						}).appendTo(cc);;
					
					
					_.each(mesh.type.engines, function(engines, engine_type){
						
						_.each(engines, function(engine_id){
							
							// var et = engine_type;
							// var ea = en;
							var en_dev = mesh.type.devices[engine_id];
							
							var e1 = $("<div>").css({
								width:300,
								height:40
								}).appendTo(cont);
						
							$('<div>').css({'float':'left', 'color':'#bbb'}).width(40).text(en_dev.name).appendTo(e1) 
							var slc =  $('<div>').css({'float':'left', width:120,'margin-left':10}).appendTo(e1);
							
							var pc = new PowerControlWidget({container:slc[0], starting_percent:0, end_percent:1.5,progress_value:0,
								change: function( val ) {
									mesh.startDeviceAction(mesh.type.power_source, "power", val, {"dev_id": engine_id});

								},
								slide:function(val){ 
									// mesh.startDeviceAction(engine_id, "set_power", val);
								}
									
							});
							// var sett =  "eng_" + engine_name + "_power"
							var cur_val = mesh.getDeviceSetting(engine_id, "power" );
							pc.set_value( cur_val );
								
						})
					})
				}
				this._update_fuel_indicator = function(){}
				this._update_power_indicator = function(){}
				this._update_capacitor_indicator = function(){
					// var mesh = W.scenes[actor.scene].meshes[actor.control.object_guid];
					var psd = mesh.type.devices[mesh.type.power_source];
					var total_cap = psd.capacitor;
					var current_cap = mesh.getDeviceSetting(mesh.type.power_source, "capacitor");
					
					L.setValue("CUR CONS", current_cap);
			
					if(current_cap > total_cap){
						percentage = 1;
					}else{
						percentage = current_cap / total_cap;
					}
					this.capacitor_indicator.width(percentage * this.indicators_length);
					
					
				}
				
				this.refresh = function(){
					this._update_fuel_indicator();
					this._update_power_indicator();
					this._update_capacitor_indicator();
					
				}
			}
			return new ui();
			
		}
	}
	this.EnergyCoreController.device_types = "power";
	this.TurretController  = function(mesh, device_id){
		this.process = function(action){
			//console.log("CHO", action.type === SHOOT, action.type == SHOOT, action.type)
			var turret = mesh.type.devices[device_id];
			if(action.name == 'reload'){
				
				// console.log("process > REALODING:", action);
				mesh.setDeviceSetting( device_id, "is_reloading" , action.ts ); 
				mesh.setDeviceSetting( device_id, 'magazine', turret.magazine_capacity);
			}
			
			if (action.name == 'fire'){
				
				
				//console.log("FIRED");
				
				
				var T = Controller.T();
				
				
				var seed = Math.random() // Ð­ÑÐ¾ Ð·ÐµÑÐ½Ð¾ Ð±ÑÐ´ÐµÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑÑÑ Ð´Ð»Ñ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ÑÑÐµÐ¹ Ð¸ Ð¾Ð½Ð¾ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð·Ð°Ð¿Ð¸ÑÐ°Ð½Ð¾ Ð² ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ - ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð·Ð²Ð¾Ð»Ð¸ÑÑ ÑÐµÑÐ²ÐµÑÑ Ð²ÑÑÐ¸ÑÐ»Ð¸ÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ð´ÐµÑÐµÑÐ¼Ð¸Ð½Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾
				// console.log(action)
				// Ð¢ÐµÐ¿ÐµÑÑ Ð²ÑÑÐ»ÑÐµÐ¼ Ð²ÐµÐºÑÐ¾Ñ Ð²ÑÑÑÑÐµÐ»Ð° Ð² Ð¼Ð¸ÑÐ¾Ð²ÑÑ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ñ
				var shoot_vec = new T.Vector3();
				shoot_vec.fromArray(action.wmouse);

				//dist
				// For all targets:
				// calculate closest distance and time to that 
				// console.log("ACTOR", actor);
				
				//var C = S.mesh_for(actor_guid);
				//var object = C.json
				//var actor = S.actors[actor_guid];
				
				
				//var wp = object.workpoints[actor.control.workpoint];
				
				var last_shot_time = mesh.getDeviceSetting(device_id, "last_shot_time")
				var is_reloading = mesh.getDeviceSetting(device_id, "is_reloading"  ); 
				var _mag = mesh.getDeviceSetting(device_id, "magazine")
				
				// console.log("SERV act before", action);
				// console.log("LOG TIMES", is_reloading, last_shot_time,  action.ts - is_reloading, action.ts - last_shot_time);
				
				if( (action.ts -  is_reloading) < mesh.type.devices[device_id].turret_reload_rate){
					return ;
				}
				//console.log("SERV act - reloaded", action);
				
				if(_mag == 0){
					return ;
				}
				//console.log("SERV act full mag", action);
				
				if (last_shot_time){
					// console.log("last shot time", last_shot_time,(action.ts - last_shot_time ) < C.json.turrets[wp.turret].turret_shoot_rate );
					if((action.ts - last_shot_time ) < mesh.type.devices[device_id].turret_shoot_rate){
						// console.log('no shoot');
						return; // this turret cannot shoot now
					}
				}
				//console.log("SERV act shoot freely", action);
				
				//console.log("BOOOSH!");
				var shoot_impulse = mesh.type.devices[device_id].shoot_impulse;
				// TODO ÐÑÐ¸Ð¼ÐµÐ½Ð¸ÑÑ Ð²ÑÑÑÑÐµÐ» Ðº ÑÐ¾Ð±ÑÑÐ²ÐµÐ½Ð½Ð¾Ð¼Ñ Ð¸Ð¼Ð¿ÑÐ»ÑÑÑ - 
				
				
				mesh.setDeviceSetting(device_id, "last_shot_time", action.ts);
				mesh.alterDeviceSetting(device_id, 'magazine', function(v){
                    console.log("mag");
					return v - 1;
				})
				//console.log("Now let's see, did we get somebody");
				
				var turret = mesh.type.devices[ device_id ] ;
				
				var turret_position_vector = new T.Vector3();
				turret_position_vector.fromArray( turret.position );
				
				var bullet_pos = mesh.position.clone()
				bullet_pos.add(  turret_position_vector.clone() )

				var BULLET_MASS = 1;
				
				shoot_vec.sub(bullet_pos.clone()) // ÐÐ°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð²ÑÑÑÐµÑÐ»Ð°
				shoot_vec.multiplyScalar( shoot_impulse / BULLET_MASS ); // ÑÐºÐ¾ÑÐ¾ÑÑÑ Ð²ÑÑÑÑÐµÐ»Ð°
				
				// ÐÐ°Ð´Ð¾ ÑÐ¾ÑÑÐ°Ð²Ð¸ÑÑ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¼ÐµÑÐµÐ¹, ÑÐµÑÐµÐ· ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¿ÑÐ¾ÑÐ¾Ð´Ð¸Ñ Ð»ÑÑ ÑÑÐ°ÐµÐºÑÐ¾ÑÐ¸Ð¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ ÑÐ½Ð°ÑÑÐ´Ð° Ñ ÑÑÐµÑÐ¾Ð¼ Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ÑÑÐ¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ
				var collidables = [];
				_.each(mesh._scene.meshes, function(tmesh, i){
					if(i ==  mesh.GUID) return;
					
					var target_pos = tmesh.position.clone();
					var target_impulse = tmesh.impulse.clone();
					var target_velocity = target_impulse.multiplyScalar(1/tmesh.mass);
					
					// Ð£Ð²ÐµÐ»Ð¸ÑÐ¸Ð¼ ÑÐºÐ¾ÑÐ¾ÑÑÑ Ð²Ð¾ Ð¼Ð½Ð¾Ð³Ð¾-Ð¼Ð½Ð¾Ð³Ð¾ ÑÐ°Ð·
					target_pos.sub( bullet_pos );
					target_velocity.sub( shoot_vec );
					
					var dot = target_pos.dot(target_velocity);
					
					
					var cosp = dot/( target_pos.length() * target_velocity.length() )
					var sinp = Math.sqrt(1 - cosp*cosp);
					
					var v = Math.abs(cosp) * target_velocity.length();
					// console.log(v, target_pos.length());
					var time = target_pos.length() / v 
					var distance = sinp * target_pos.length(); // ÐÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð°Ñ Ð´Ð¸ÑÑÐ°Ð½ÑÐ¸Ñ, Ð² ÐºÐ¾ÑÐ¾ÑÐ¾Ð¹ Ð¿ÑÐ¾Ð¹Ð´ÐµÑ ÑÐ½Ð°ÑÑÐ´ Ð¾Ñ ÐºÐ¾ÑÐ°Ð±Ð»Ñ
					
					//console.log("distance and time", distance, time);
					
					// Ð ÐµÑÐµÐ½Ð¸Ðµ Ð¾ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ð¸ Ð½Ð°Ð´Ð¾ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÑÑ Ð·Ð´ÐµÑÑ
					//  distance ÐÐ¾Ð¶ÐµÑ ÑÐ¼ÐµÐ½ÑÑÐ¸ÑÑÑÑ Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑÐ¸ Ð¾Ñ ÑÐºÐ¸Ð»Ð»Ð¾Ð² Ð¸Ð³ÑÐ¾ÐºÐ° Ð¸ ÑÐ°ÑÐ°ÐºÑÐµÑÐ¸ÑÑÐ¸Ðº Ð¾ÑÑÐ¶Ð¸Ñ
					
					// Ð¡ÑÐ°Ð²Ð½ÐµÐ½Ð¸Ðµ Ñ Ð³ÐµÐ¾Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ¸Ð¼Ð¸ ÑÐ°Ð·Ð¼ÐµÑÐ°Ð¼Ð¸ ÑÐµÐ»Ð°:
					var boundRadius = tmesh.geometry.boundingSphere;
					// console.log("SPHERE", boundRadius.radius, distance);
					//console.log(target_velocity.toArray(), shoot_vec.toArray());
					if(distance < boundRadius.radius){
						// hit 
						collidables.push({time: time, mesh:tmesh, distance:distance})
						
					}
					
					
					// Ð¡Ð¸Ð½ÑÑ - ÑÑÐ¾ Ð¼ÐµÑÐ° Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ. ÐÑÐ¸ ÑÐ¼Ð½Ð¾Ð¶ÐµÐ½Ð¸Ð¸ ÐµÑ Ð½Ð° Ð²ÐµÐºÑÐ¾Ñ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¸ Ð¼Ñ ÑÐ·Ð½Ð°ÐµÐ¼ Ð½Ð° ÐºÐ°ÐºÐ¾Ð¹ Ð´Ð¸ÑÑÐ°Ð½ÑÐ¸Ð¸ Ð¿ÑÐ¾Ð¹Ð´ÐµÑ ÑÐ½Ð°ÑÑÐ´ Ð¾Ñ ÑÐµÐ»Ð¸
					// ÐÐ¾ÑÐ¸Ð½ÑÑ Ð´Ð°ÐµÑ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¾ Ð²ÑÐµÐ¼ÐµÐ½Ð¸  Ð´Ð¾ ÐºÐ¾Ð½ÑÐ°ÐºÑÐ°. ÐÑÐ»Ð¸ ÐºÐ¾ÑÐ¸Ð½ÑÑ Ð¾ÑÑÐ¸ÑÐ°ÑÐµÐ»ÑÐ½ÑÐ¹ - Ð·Ð½Ð°ÑÐ¸Ñ  
					// console.log("sin and cos", target_pos.toArray(), mesh.position.toArray(), sinp, cosp);
					
				});
				// Ð¢ÐµÐ¿ÐµÑÑ, Ð½Ð°Ð´Ð¾ Ð·Ð°Ð¿Ð¸ÑÐ½ÑÑÑ ÑÑÐ¾ ÑÐ¾Ð±ÑÑÐ¸Ðµ Ð² Ð¾ÑÐµÑÐµÐ´Ñ Ð¿ÑÐ¾ÑÐµÑÑÐ¸Ð½Ð³Ð°:
				// 1. Ð¡Ð¾Ð±ÑÑÐ¸Ðµ - Ð¸Ð¼Ð¿ÑÐ»ÑÑ Ð½Ð° Ð½Ð°Ñ, ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ Ð¼Ð¾Ð¶ÐµÑ Ð²ÐºÐ»ÑÑÐ°ÑÑ ÑÐ°ÐºÐ¶Ðµ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ðµ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¹ Ð²Ð½ÑÑÑÐµÐ½Ð½Ð¸Ñ Ð¿ÑÐ¸Ð±Ð¾ÑÐ¾Ð² - Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¿Ð°ÑÑÐ¾Ð½Ð¾Ð²
				// 2. Ð ÑÐ»ÑÑÐ°Ðµ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ - Ð¾ÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð² Ð±ÑÐ´ÑÑÐµÐµ ÑÐ¾Ð±ÑÑÐ¸Ðµ Ð¾Ð± Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¸ Ð¸Ð¼Ð¿ÑÐ»ÑÑÐ° Ð¸ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ ÑÐµÐ»Ð¸.
				
				if (collidables.length > 0){
					var  col = _.sortBy(collidables, function(i){ return i.time})[0]
					var  tmesh = col.mesh // ÐÐ¾Ð¿Ð°Ð»Ð¸!
					//console.log("We got your ASS");
					
					var action_processor = function(){
						// console.log("here we will process the hit");
						var shield_hp = shoot_impulse * 0.7;
						var armor_hp  = shoot_impulse * 0.8;
						var hull_hp = shoot_impulse * 1.05;
						var sh_seq = tmesh.shields.concat(tmesh.armors)
						sh_seq.push(tmesh.type.hull_device)
						
						var rec = function(seq){
							if (seq.length == 0){return};
							var f = seq[0];
							var dev = mesh.type.devices[f]
							
							var tail = seq.slice(1);
							var hp;
							if (dev.shield_type == 'armor'){hp = shoot_impulse * 0.7}
							if (dev.shield_type == 'shield'){hp = shoot_impulse * 0.8}
							if (dev.shield_type == 'hull'){hp = shoot_impulse * 1.05}
							
							
							tmesh.alterDeviceSetting(f, "capacity", function(v){
								if (v <= 0){ rec(tail); return 0;}
								var nv = v - hp;
								if(nv <= 0){ return 0 }else{return nv};
							})
						}
						//console.log('launch req');
						rec(sh_seq);
						//console.log("HERE's OUR RESULTS")
						// DEBUG"
						_.each(sh_seq, function(d){
							var sh = tmesh.getDeviceSetting(d, "capacity")
							var dev = tmesh.type.devices[d];
							//console.log("DEBUGGING SHOTS", d, dev.name, sh);
						})
						//ENDOF DEBUG
						
						
						
						
					}
					tmesh.startVirtualDeviceAction(action_processor, action.ts + col.time, action.ident + col.time);
					
					
					
				}
				
			}
			
		}
		this.getUI = function(W){
    		var ui = function(){
    			this.rules_height = 140
                this.onAction = function(W, scene_guid, action){
                    var three_scene = W.three_scenes[scene_guid];
                    
                    var expl = SpriteUtils.createExposionObject(
                                    "#" + action.mesh + "_"+action.ident, 
                                    action.ts, 
                                    action.wmouse, 
                                    10,
                                    three_scene, 
                                    W);
                },
                this.construct = function(){
    				this.cont = $('<div>').css({'position':'fixed',
    								// 'border': '1px solid red',
    								'width':"66px",
    								'height': '170px',
    								'top':40,
    								'left':50,
    								'background-color':'white'}).appendTo('body');
		
    				var rul_cont = $('<div>').css({
    					"width":  "100%",
    					"height": this.rules_height + 'px',
    					'background-color':'blue'

    				}).appendTo(this.cont);

    				var bul_cont = $('<div>').css({
    					"width":  "100%",
    					"height": (170 - this.rules_height) + "px",
    					'background-color':'green'
    				}).appendTo(this.cont);

    				var auto_track_switch = $('<div>').css({'width':'22px',
    														'height':'22px',
    														'border-radius':'11px',
    														'float':'left',
    														'background-color':'white'}).appendTo(rul_cont);
    				this.magazine_indicator = $('<div>').css(
    					{'width':'22px',
    					'height':  this.rules_height +  'px',
    					'float':'left',
    					'background-color':'red'}).appendTo(rul_cont);
    				this.time_indicator = $('<div>').css(
    					{'width':'22px',
    					'height':  this.rules_height+  'px',
    					'float':'left',
    					'background-color':'red'}
    				) .appendTo(rul_cont);

    			}
    			this._set_magazine_capacity = function(){
    				// var O = W.scenes[actor.scene].meshes[actor.control.object_guid];
    				//var wp = O.json.workpoints[actor.control.workpoint];
    				var mag_cap = mesh.type.devices[device_id].magazine_capacity;
    				var _mag    = mesh.getDeviceSetting(device_id, "magazine");
    				if (! _mag) _mag = 0;
		
    				var percentage = _mag/ mag_cap;
                    // console.log(this.magazine_indicator);
    				if(_mag  == 0){
    					this.magazine_indicator.height("1px");
    					this.magazine_indicator.css('background-color','red')
			
    				}else{
                        // console.log("hh", device_id, percentage * this.rules_height)
    					this.magazine_indicator.height(percentage * this.rules_height);
    					this.magazine_indicator.css('background-color','green')
    				}
		
		
		
		
    			}
    			this._set_readiness_timer = function(){
    				var rate = mesh.type.devices[device_id].turret_shoot_rate;
    				var reload_rate = mesh.type.devices[device_id].turret_reload_rate;
		
    				var _ts  = mesh.getDeviceSetting(device_id, "last_shot_time");
    				var ir_ts = mesh.getDeviceSetting(device_id, "is_reloading");
    				var now  = new Date().getTime();
                    // console.log(_ts, ir_ts, now);
    				var ir_diff = now - ir_ts;
    				if(ir_diff > reload_rate){
    					var _mag    = mesh.getDeviceSetting(device_id, "magazine");
		
    					var diff = now - _ts;
    					if(_mag === 0 ){
    						percentage = 0;
    					}else{
    						if(diff > rate){
    							var percentage = 1;
    						} else{
    							var percentage =  (diff / rate);
    						}
			
    					}
			
    				}else{
    					percentage = ir_diff/reload_rate;
    				}
		
		
    				this.time_indicator.height(percentage * this.rules_height);
		
		
    			}
    			this.refresh = function(){
    				this._set_readiness_timer();
    				this._set_magazine_capacity();
    			}
    		}

    		var UI = new ui();
    		return UI;
		}
	}
	this.TurretController.device_types = "turret";
	this.VirtualDeviceController = function(mesh, device_id){
		this.getUI = function(){}
		this.process = function(action){
			// Call it;
			// console.log("okey - we could do thing here",action);
			
			mesh._foreign_procs[action.ts]();
		}
	}
	this.VirtualDeviceController.device_types = "virtual";
	
	var controllersMap = {}
	for(i in this){
		controllersMap[this[i].device_types] = this[i];
	}
	this.controllersMap = controllersMap;
	// console.log(">>", this.controllersMap);

}
var cc = new Controllers();
Controller.deviceControllers = cc;
module.exports = Controller
//var TurretController = new CTurretController()
//CPilotController.prototype = {constructor:CPilotController}
//var PilotController = new CPilotController();

//console.log(TurretController.act, PilotController.act)

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/controller.js","/")
},{"./utils":15,"1YiZ5S":5,"buffer":2,"three":6,"underscore":7}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var _     = require('underscore');



if(typeof window ==='undefined'){
	
	var L = {setValue:function(){}};
	is_browser = false;
}else{
	var L = SL;
	is_browser = true;
}
var EventQueue = function(mesh_id){
	this._mesh_guid = mesh_id;
	this._mesh_id = mesh_id.substring(0,5);
	
	this._events = {};
	this._stamps = []; // sorted;
	this._remove_before = 0;
	this._last_processed = 0;
	this._rem_comm =0
	this._disp_counter1 = 0;
	this._disp_counter2 = 0;
	
	// this._stamps_ix
}
EventQueue.prototype.add = function( e, ts ){
	if(this._events[ts]){
		this._events[ts].push(e);	
	}else{
		this._events[ts] = [e];
	}
	
	this._stamps.push(ts);
	this._stamps.sort();
}
EventQueue.prototype.set_last_processed = function(ts){
	this._last_processed = ts;
	this._include_last_once = true;
}
EventQueue.prototype.remove = function(remove_before_ts){
	this._rem_comm += 1;
	this._remove_before = remove_before_ts; // Lazy removing
	
}
EventQueue.prototype.process = function(now, processor){
	var removed_ixes = [];
	var self = this;
	// console.log("S");
	var processed_events = 0;
	_.each(this._stamps, function(ts, ix){
		
		if (ts <= self._remove_before){
			removed_ixes.push(ix);
			delete self._events[ts];
			return;
		}
		var is_from = self._include_last_once? self._last_processed <= ts : self._last_processed < ts;
		//console.log("FFF", [is_from,ts <= now], self._last_processed, ts, now, ts-now );
		
		if(is_from && ts <= now){
			self._include_last_once = false;
			_.each(self._events[ts], function(e){
				if(!is_browser){
				}

				processor(  e, ts )
				processed_events += 1;
			})

			self._last_processed = ts;

			
		}
	})

	_.each(removed_ixes, function(ix){
		self._stamps.splice(ix, 1);
	})
	//L.setValue("ST" + this._mesh_id, this._stamps.length)
	
}

module.exports = EventQueue;
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/event_queue.js","/")
},{"1YiZ5S":5,"buffer":2,"underscore":7}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
Scene = require('./scene.js')
Mission = require('./missions.js')
Utils = require('./utils.js')
SpriteUtils = require('./sprite_utils.js')
Controller = require('./controller.js')
AObject = require('./object.js')



}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_cd55ca70.js","/")
},{"./controller.js":8,"./missions.js":11,"./object.js":12,"./scene.js":13,"./sprite_utils.js":14,"./utils.js":15,"1YiZ5S":5,"buffer":2}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Scene = require('./scene')
var u = require('./utils')
var _     = require('underscore');


var getMissionType =function (type){
	return create_mission_json()
}

var create_mission_json = function(  ){
	var p1 = [-110, 100, 40];
	var p2 = [500, 200, -50];
	var c = 0.2
	var p1 = _.map(p1,function(v){return v*c});
	var p2 = _.map(p2,function(v){return v*c});;
	var psource = {
		fuel_cell_capacity: 500, // ÐÐ±ÑÐµÐ¼ ÑÐ¾Ð¿Ð»Ð¸Ð²Ð°
		fuel_consumption_performance: 1, // Ð£Ð´ÐµÐ»ÑÐ½Ð°Ñ ÑÐ½ÐµÑÐ³Ð¸Ñ ÑÐ¾Ð¿Ð»Ð¸Ð²Ð° - 
		max_power: 6000, // ÐÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð°Ñ Ð¼Ð¾ÑÐ½Ð¾ÑÑÑ Ð¸ÑÑÐ¾ÑÐ½Ð¸ÐºÐ° ÑÐ½ÐµÑÐ³Ð¸Ð¸ - ÐÐ¶ (ÐÑ.Ñ)
		min_power:0, // ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð°Ñ Ð¼Ð¾ÑÐ½Ð¾ÑÑÑ Ð¸ÑÑÐ¾ÑÐ½Ð¸ÐºÐ° ÑÐ½ÐµÑÐ³Ð¸Ð¸
		powerup_speed:2, // Ð¡ÐºÐ¾ÑÐ¾ÑÑÑ ÑÐ²ÐµÐ»Ð¸ÑÐµÐ½Ð¸Ñ Ð¼Ð¾ÑÐ½Ð¾ÑÑÐ¸ Ð¸ÑÑÐ¾ÑÐ½Ð¸ÐºÐ° - Ð´Ð¶Ð¾ÑÐ»Ð¸ Ð² ÑÐµÐºÑÐ½Ð´Ñ
		powerdown_speed:2, // Ð¡ÐºÐ¾ÑÐ¾ÑÑÑ ÑÐ¼ÐµÐ½ÑÑÐµÐ½Ð¸Ñ Ð¼Ð¾ÑÐ½Ð¾ÑÑÐ¸ Ð¸ÑÑÐ¾ÑÐ½Ð¸ÐºÐ°
		capacitor:360000 // ÐÐ¼ÐºÐ¾ÑÑÑ ÐºÐ¾Ð½Ð´ÐµÐ½ÑÐ°ÑÐ¾ÑÐ°

	};

    devices = [
    // Engines first
    //0
    {type:'engine', name:'x-', engine_type:'rotation', consumption:1000, performance:0.8, unit:[-1, 0, 0], actions:{impulse:{default_key:87}, power:{} } },
    //1
    {type:'engine', name:'x+', engine_type:'rotation', consumption:1000, performance:0.8, unit:[1, 0, 0], actions:{impulse:{default_key:83}, power:{} }},
    
    //2
    {type:'engine', name:'y+', engine_type:'rotation', consumption:1000, performance:0.8, unit:[0, 1, 0], actions:{impulse:{default_key:65}, power:{} }},
    //3
    {type:'engine', name:'y-', engine_type:'rotation', consumption:1000, performance:0.8, unit:[0, -1, 0], actions:{impulse:{default_key:68}, power:{} }},
    //4
    
    {type:'engine', name:'z+', engine_type:'rotation', consumption:1000, performance:0.8, unit:[0, 0, 1], actions:{impulse:{default_key:90}, power:{} }},
    //5
    {type:'engine', name:'z-', engine_type:'rotation', consumption:1000, performance:0.8, unit:[0, 0, -1], actions:{impulse:{default_key:67}, power:{} }},
    
    //6
    {type:'engine', name:'z+', engine_type:'propulsion', consumption:5000, performance:0.8, unit:[0, 0, -1], actions:{impulse:{default_key:38}, power:{} }},
    //7
    {type:'engine', name:'z-', engine_type:'propulsion', consumption:5000, performance:0.8, unit:[0, 0, 1], actions:{impulse:{default_key:40}, power:{} }},
    
    // Shields & engine
    //8
    {type:'power',  name:'Power Source', powerup_speed:2, powerdown_speed:2, capacitor:360000, max_power:6000, min_power:0, actions:{power:{}} },
    //9
    {type:'shield', name:'Armor',shield_type:'armor', effective_impulse:300, capacity:4000, capacitor:4000, charge_rate:500, repair_rate:300, performance:0.5, actions:{power:{}, toggle:{is_switch:true} }},
    //10
    {type:'shield', name:'Shield',shield_type:'shield', capacity:5000, capacitor:10000, charge_rate:1000, setup_energy:3000, actions:{power:{}, toggle:{is_switch:true} }},
    //11
    {type:'shield', name:'Thermal',shield_type:'thermal', effective_impulse:300, actions:{power:{}, toggle:{is_switch:true} }},
    
    // turrets, bays, drones, launchers
    //12
    {type:'turret', name:"Front turret", position: [0,0.5,0], magazine_capacity: 100, turret_shoot_rate:2000, turret_reload_rate:10000, shoot_impulse:320, actions:{fire:{ default_key:'lmouse'}, reload:{default_key:82} } },
    //13
    {type:'turret', name:"back turret", position: [0,0,2], magazine_capacity: 100, turret_shoot_rate:2000, turret_reload_rate:10000, shoot_impulse:320, actions:{fire:{ default_key:'lmouse'}, reload:{default_key:82} } },
    //14
    {type:"virtual", name:"Foreign action virtual device", actions:{"process":{}}},
    //15
    {type:"hull", name:"Hull hp", shield_type:'hull', capacity:1000, actions:{}}
    

    ]
	var shields = {
		"armor":[9],
		"shield":[10],
		thermal:[]
	};
	engines = {
		'rotation':[0,1,2,3,4,5],
		'propulsion':[6,7],
	}
	var def_ship1 = {type:'ship',
					 "ship_type":"Default",
						 model_3d:'/models/StarCruiser.js',
						 physical:{
							 pos:p1,
							 rot:{to:p2},
						 },
					 
						 "cameras":{
								"front":{
									"label":"main",
									"position": [0,0.5,0],
									"direction":[0,0,-1]
									},
								"back":{
										"label":"main",
										"position": [0,0.5,2],
										"direction":[0,0,1]
										}
									},

                        devices:devices,
                        power_source:8,
                        foreign_processor:14,
                        hull_device:15,
						"workpoints":{
							"Piloting":{
									"views": ["front","back"],
									"type":"pilot",
                                    devices:[0,1,2,3,4,5,6,7,8,9,10,11]
									},
							"Front turret":
									{
									"views":["front"],
                                    
									"type":"turret",
									"turret":"front",
                                    
                                    devices:[12]
									},
						
							"Back turret":{
									"views":["back"],
									"type":"turret",
									"turret":"back",
                                    devices:[13]
                                    
						
									},
						
			
								},
								//"power_source":psource,
								shields:shields,
								
						 'engines': engines ,
						'mass': 10000,
						'GUID':u.make_guid()
					}
	var def_ship2 = {type:'ship',
 					 "ship_type":"Default",
	
						 model_3d:'/models/StarCruiser.js',
						 physical:{
							 pos:p2,
							 rot:{to:p1},
						 
						 },
			 			"cameras":{
			 					"front":{
			 						"label":"main",
			 						"position": [0,0.5,0],
			 						"direction":[0,0,-1]
			 						},
			 					"back":{
			 							"label":"main",
			 							"position": [0,0.5,2],
			 							"direction":[0,0,1]
			 							}
									},
									
                                    devices:devices,
                                    power_source:8,
                                    foreign_processor:14,
                                    hull_device:15,
                                    
            						"workpoints":{
            							"Piloting":{
            									"views": ["front","back"],
            									"type":"pilot",
                                                devices:[0,1,2,3,4,5,6,7,8,9,10,11]
            									},
            							"Front turret":
            									{
            									"views":["front"],
                                    
            									"type":"turret",
            									"turret":"front",
                                    
                                                devices:[12]
            									},
						
            							"Back turret":{
            									"views":["back"],
            									"type":"turret",
            									"turret":"back",
                                                devices:[13]
                                    
						
            									},
						
			
            								},

											// "power_source":psource,
            								shields:shields,
											 'engines': engines ,
						
			 			'mass': 10000,
						'GUID':u.make_guid()
					}
	// ÐÐµÑÑÐºÐ¾ Ð·Ð°Ð´Ð°Ð½Ð½ÑÐµ ÐºÐ¾ÑÐ°Ð±Ð»Ð¸ÐºÐ¸ - Ð±ÐµÐ· Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¹ Ð¸ ÑÐºÐ¾ÑÐ¾ÑÑÐµÐ¹	
	var pivot= 	function(x,y,z){
		return {type:'static',
		
						 model_3d:'/models/sp.js',
						 physical:{
							 pos:[x, y, z]
							 //rot:{to: [-110, 100, 40]},
						 
						 },
			 			'mass': 1000000,
						'GUID':u.make_guid()
					}
	}
	this._dh2 = def_ship2; // Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÐ¼ ÐºÐ¾ÑÐ°Ð±Ð»Ð¸Ðº - Ð¿Ð¾ÑÐ¾Ð¼Ñ ÑÑÐ¾ Ð¿Ð¾ÐºÐ° Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ Ð½Ðµ Ð²ÑÐ±Ð¸ÑÐ°ÐµÑ ÐºÐ¾ÑÐ°Ð±Ð»Ñ - Ð¾Ð½ ÐµÐ¼Ñ Ð½Ð°Ð·Ð½Ð°ÑÐ°ÐµÑÑÑ		
	var so = {}
	_.each([def_ship1,def_ship2], function(s){
		so[s.GUID] = s
	})
	// ÐÐ´ÐµÑÑ Ð¼Ñ Ð¿ÑÐ¾ÑÑÐ¾ Ð½Ð°Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ ÑÑÐµÐ½Ñ ÑÐ°ÑÐ¸ÐºÐ°Ð¼Ð¸ - Ð¿Ð¾ ÑÐ¼Ñ, ÑÑÐ¸ ÑÐ°ÑÐ¸ÐºÐ¸ Ð½Ð°Ð´Ð¾ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ Ð½Ðµ Ð·Ð´ÐµÑÑ - Ð° Ð¸Ð½Ð¶ÐµÐºÑÐ¸ÑÑ Ð¸Ð· Ð¼Ð¸ÑÐ°
	/*
	var inc = 0
	var step = 200;
	for (var x=-200; x<= 200; x+=step){
		for (var y=-200; y<= 200; y+=step){
			for (var z=-200; z<= 200; z+=step){
				//console.log(inc,"x,y,z",x,y,z)
				inc +=1;
				var p =pivot(x,y,z)
				so[p.GUID] = p
			}
		}
	}*/
	// --- ÐÐ°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ ÑÑÐµÐ½Ñ
	var mission = {
		actors : {},
		commands:['red', 'blue'],
		_commands_amount:[1,0],
		max_per_command:1,
		min_per_command:1,
		coords : [100, 500, 300], // Global coords of mission origin
		shared_objects: so,
		objects_for_command:{"red":[def_ship1.GUID],"blue":[def_ship2.GUID]}
		
	}
	return mission
}
var Mission = function(type){
	this.descr = "Mission"
	this.mission = getMissionType(type);
	//console.log(this.mission);
	
}

Mission.prototype = {
	constructor: Mission,
	


	create :function(creator_id, callback){
	
		// No params - only one mission available
		var self = this ;
		this.GUID = u.make_guid();
		this.creator = creator_id;
		this.ready_to_start = false
		this.is_started = false
		this._users = {};
		this._position_binds = {};
		this._total_actors = 0;
		this._total_logins = 0;
		

	

		self._mission_logins = [];
		self._mission_objects = {}
		
		self._mission_ready = function(){
			callback(self);
		
		
		}
		// self.prepare_scene();
		self._mission_ready();
		return this
	},
	getScene: function(){
		return this._scene;
	},
	prepare_scene : function(bcaster){
	
		// console.log(Scene);
		if(! this._scene_loaded){
			// console.log("DO PREP SCENE")
            // console.log("TTT",bcaster);
			this._scene = new Scene(bcaster);
            this._scene.gx = this.mission.coords[0];
            this._scene.gy = this.mission.coords[1];
            this._scene.gz = this.mission.coords[2];
			//create_from_world(this.mission.coords[0],
			//										this.mission.coords[1],
			//										this.mission.coords[2] );
			var self = this;
			_.each(this.mission.shared_objects, function(obj){
				self._scene.join_object(obj)
	
			})		
			var actors = this.prepare_actors()								
			_.each(actors, function(as){ // ÐÐ¸ÑÑÐ¸Ñ Ð´Ð¾ ÑÑÐ¾Ð³Ð¾ Ð²ÑÐµÐ¼ÐµÐ½Ð¸ Ð½Ðµ Ð¸Ð¼ÐµÐ»Ð° ÑÑÐµÐ½Ñ - Ð½Ð°Ð´Ð¾ Ð´Ð°ÑÑ ÐµÑ ÐºÐ°Ð¶Ð´Ð¾Ð¼Ñ Ð°ÐºÑÐ¾ÑÑ Ð·Ð´ÐµÑÑ
				//console.log(a)
				as.scene = self._scene.GUID
				self._scene.join_actor(as);
			})
			this._scene_loaded= true;
			// console.log("Prepd")
		}
		
							
	},
	prepare_actors: function(){
		var self = this;
		var actors = []
		_.each(this._users, function(positions_of_user, user_id){
			_.each(positions_of_user, function(position){
				
				actors.push(self._make_actor(position, user_id));
				
			})
		})
		return actors;
	},
	_make_actor: function(pos_id, user_id){
		var pos = this._positions[pos_id]
		var new_actor_guid = u.make_short_guid()
		var controllable = {object_guid:pos.object_guid, workpoint:pos.workpoint, type: pos.control_type} // viewport:'front', controls:['Pilot', 'Turret']} 
		console.log("make actor",  pos);
		return {command:pos.command, user_id: user_id, control: controllable, GUID:  new_actor_guid}
		
	},
	
	join_player :function(user_id, position_id ){// login, command, object_guid, place){
		if (this._positions[position_id].busy){return;};
		
		if(this._users[user_id] === undefined){ // ÐÐ´Ð¸Ð½ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ Ð¼Ð¾Ð¶ÐµÑ Ð¸Ð¼ÐµÑÑ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¹
			this._users[user_id] = [position_id];
			
		}else{
			this._users[user_id].push(position_id);
			
		}
		this._position_binds[position_id] = user_id // ÐÐ¾Ð·Ð¸ÑÐ¸ÐµÐ¹ Ð¼Ð¾Ð¶ÐµÑ ÑÐ¿ÑÐ°Ð²Ð»ÑÑÑ - Ð½Ð° Ð½ÐµÐ¹ ÑÐ¸Ð´ÐµÑÑ - ÑÐ¾Ð»ÑÐºÐ¾ Ð¾Ð´Ð¸Ð½ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ
		this._positions[position_id].busy = true;
		this._positions[position_id].user_id = user_id;
		
		if(this.is_started){
			var actor = this._make_actor(position_id, user_id);
			actor.scene = this._scene.GUID;
			this._scene.join_actor(actor)
		}
		
		/*
		var self = this;
		var M = self.mission;
		var command;
		// Get first available command
		// console.log("LOGIN", login)
		if (self._mission_objects[object_guid] === undefined){
			self._mission_objects[object_guid] = {}
		}
		//_.each(places, function(p){ // Ð­ÑÐ¾Ñ ÐºÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ Ð¿ÑÐ¸ Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ð¸ Ð¼ÐµÑÑ Ð½Ð° ÐºÐ¾ÑÐ°Ð±Ð»Ð¸
			self._mission_objects[object_guid][place] = login;
			
			//})
		// TODO ÐÐ´ÐµÑÑ Ð½Ð°Ð´Ð¾ Ð²ÑÑÐ°Ð²Ð»ÑÑÑ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð² - Ð½ÐµÐ·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ Ð¾Ñ ÑÐ¾Ð³Ð¾, ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð»Ð¾Ð³Ð¸Ð½Ð¾Ð²
		// TODO ÐÐ°Ð´Ð¾ Ð¿ÑÐ¾Ð²ÐµÑÑÑÑ Ð½Ð°Ð»Ð¸ÑÐ¸Ðµ Ð»Ð¾Ð³Ð¸Ð½Ð¾Ð² Ð¸ ÐµÑÐ»Ð¸ ÐµÑÑÑ - Ð½Ðµ ÑÑÐ¿Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑÑ, Ð° Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑÑ ÐµÐ¼Ñ Ð²Ð¾ÑÐºÐ¿Ð¾Ð¸Ð½Ñ
		// ÐÐ¾ Ð·Ð°Ð½ÑÑÑÐ¼ Ð²Ð¾ÑÐºÐ¿Ð¾Ð¸Ð½ÑÐ°Ð¼ ÑÐ¸ÑÑÐ°ÑÑ Ð³Ð¾ÑÐ¾Ð²Ð½Ð¾ÑÑÑ
		var controllable = {object_guid:object_guid, workpoint:place} // viewport:'front', controls:['Pilot', 'Turret']} 
		var new_actor_guid = u.make_guid()
		var actor = {command:command, login:login, control: controllable, GUID:  new_actor_guid}
		// ÐÐ¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð°ÐºÑÐ¾ÑÐ° - Ð¸Ð½Ð´ÐµÐºÑÐ¸ÑÑÑ Ð¿Ð¾ Ð»Ð¾Ð³Ð¸Ð½Ñ
		if (self.mission.actors[new_actor_guid] === undefined){
			self.mission.actors[new_actor_guid] = [actor]
		}else{
			self.mission.actors[new_actor_guid].push(actor)
		}
		
		self._total_actors += 1
		if(self._total_actors >= 2){
			console.log("LOGINS", self._mission_logins);
			self.ready_to_start = true;
		}else{
			console.log("TOTAL_ACTORS", self._total_actors);
		}
		
		console.log("TA",self._total_actors);
		// console.log("ACTORS", self.mission.actors);
		if (self._scene){
			actor.scene = self._scene.GUID
			self._scene.join_actor(actor)
		}
		return new_actor_guid
		*/
	},
	to_json:function(){
		var ret = {};
		_.extend(ret, this.mission);
		ret.positions = this.positions()
		ret.GUID = this.GUID;
		return ret;
	},
	positions: function(cb){
		var self = this;
		//console.log(this);
		var places = [];
		if(self._positions){
			if(cb)cb(self._positions);
			return self._positions;
			
		}else{
			self._positions = []
			var counter = 0;
			_.each(self.mission.commands, function(command){
				_.each(self.mission.objects_for_command[command], function(object_guid){
					// console.log(command, self.mission.shared_objects);
					var object = self.mission.shared_objects[object_guid]
					_.each(object.workpoints, function(workpoint, wp_label){
					
					
						var place = {'command':command,
						 			 'object_type': object.type,
									 'object_subtype':object.ship_type,
									 'object_guid': object.GUID,
								 	 'workpoint':wp_label,
									 'control_type': workpoint.type,
									 'MGUID' : self.GUID
								 
								 }
								 place.id = counter;
								 counter += 1;
	 					
								 
						self._positions.push(place)
					
					})
				
				
				})
			
			})
			if(cb)cb(places);
			return self._positions;
			
		}
	}
	
}
//console.log(Mission);
module.exports = Mission
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/missions.js","/")
},{"./scene":13,"./utils":15,"1YiZ5S":5,"buffer":2,"underscore":7}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var THR = require('three');
var EQ = require("./event_queue");
var _     = require('underscore');
var Controller = require("./controller");



// // CL(THR, THREE);
if(typeof window === 'undefined'){
	// var AObject = {}; THR.Mesh;
	
	// AObject.prototype.THREE = THR // Saveing THREE.js as part of scene - this step could be done on a certain platform
	var L = {setValue:function(){}};
	var get_three = function(){
		return THR;
	}
	//var THREE = THR;
	// AObject.prototype.do_prepare_rendering = false;
	 
	
}else{
	var get_three = function(){
		return THREE;
	}
	var L = SL;
	
	// // CL('loaded', THREE )
	//var AObject =  THREE.Mesh;
	// AObject.prototype.THREE = THREE
	//AObject.prototype.do_prepare_rendering = true;
	
}

// // CL("Holy crap", AObject)


function createObject(scene, mat, geom){
	
	var THREE = get_three();
	var m = THREE.Mesh;
	m.prototype._scene = scene;
	m.prototype.some_counter = 0;
	m.prototype._foreign_procs = {};
    
	
	m.prototype.reload_saved_state= function(){
		// ÐÐ´ÐµÑÑ Ð¼Ñ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð½Ð¾Ðµ ÑÐ°Ð½ÐµÐµ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ðµ - ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ðµ, ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ Ð±ÑÐ»Ð¾ Ñ ÑÑÐ¸Ð¼ Ð¾Ð±ÑÐµÐºÑÐ¾Ð¼ ÐºÐ¾Ð³Ð´Ð°-ÑÐ¾ Ð´Ð°Ð²Ð½Ð¾
        /*
		prev_state___ = {workpoints:{
			"Front turret": {
				"magazine": 30,
				"last_shot_time":0,
			},
			"Back turret": {
				"magazine": 50,
				"last_shot_time":0,
			}
			"Piloting":{
				"capacitor":0,
				"eng_rotation_x+_power": 1,
				"eng_rotation_y+_power": 1,
				"eng_rotation_z+_power": 1,
				"eng_rotation_x-_power": 1,
				"eng_rotation_y-_power": 1,
				"eng_rotation_z-_power": 1,

				"eng_propulsion_x-_power": 1,
				"eng_propulsion_y-_power": 1,
				"eng_propulsion_z-_power": 1,
				"eng_propulsion_x+_power": 1,
				"eng_propulsion_y+_power": 1,
				"eng_propulsion_z+_power": 1,
				
				's_armor0_power':0.1,
				's_shield0_power':0.3,
				
				's_armor0_state':false,
				's_armor0_cap': 400,
				's_armor0_rcap':0,
				's_shield0_state':false,
				's_shield0_cap':500,
				's_shield0_rcap':0,
				

				
			}
			
		}};
		
		prev_state = {
			world:{	
				position: this.position.toArray(),
				rotation: this.rotation.toArray(),
				impulse:  this.impulse.toArray(),
				angular_impulse: this.angular_impulse.toArray()
            },
            
			devices:[
				{power:1},
				{power:1},
				{power:1},
				{power:1},
				{power:1},
				{power:1},
			
			
				{power:1},
				{power:1},
			
				{capacitor:0, power:1},
			
				{power:0.1, capacity:100, state:false, reserve_capacity:0},
				{power:0.1, capacity:100, state:false, reserve_capacity:0},
				{power:0.0, capacity:0},
			
				{magazine:30, last_shot_time:0, is_reloading:0},
				{magazine:30, last_shot_time:0, is_reloading:0},
				{},
				{capacity:200}
			]	
		};
        */
        
        // // CL("TTTTTTTTTTTTTT",this.type)
		this.restoreState(this.json.last_state);
		
	}
	/*
	m.prototype.getState = function(){
		if(this.some_counter < 100){
			// // CL("Last Process while state" + this.eventManager._mesh_id, this.eventManager._last_processed);
			this.some_counter +=1;
		}
		var current_state = {	
			server_ts: this.eventManager._last_processed , 
			world:{	
				position: this.position.toArray(),
				rotation: this.rotation.toArray(),
				impulse:  this.impulse.toArray(),
				angular_impulse: this.angular_impulse.toArray()},};
							
		if (this.workpoint_states){
			current_state.workpoints = {}
			for (workpoint in this.workpoint_states){
				current_state.workpoints[workpoint] = {};
				for (param in this.workpoint_states[workpoint]){
					current_state.workpoints[workpoint][param] = this.workpoint_states[workpoint][param];
				}
			}
		}
		return current_state;
		
	}
	*/
	m.prototype.getState = function(){
		var current_state = {	
			server_ts: this.eventManager._last_processed , 
			world:{	
				position: this.position.toArray(),
				rotation: this.rotation.toArray(),
				impulse:  this.impulse.toArray(),
				angular_impulse: this.angular_impulse.toArray()}};
							
		if (this.devices){
			current_state.devices = {}
			for (dev in this.devices){
				current_state.devices[dev] = {};
				for (param in this.devices[dev]){
					current_state.devices[dev][param] = this.devices[dev][param];
				}
			}
		}
		return current_state;
	}
	m.prototype.restoreState = function(state){
		var self = this;
		for(v in state.world){
            if(this[v] === undefined){
               this[v] = new THREE.Vector3(); 
            }
			this[v].fromArray(state.world[v]);
		}
		if(state.devices){
            
			_.each(state.devices, function(dev_st, ix){
                if(self.devices[ix] === undefined){
                    self.devices[ix] = {};
                }
				_.each(dev_st, function(val, name){
					self.devices[ix][name]=val;
				
				})
			})
			
		}
	}
	/*
	m.prototype.restoreState = function(state ){
		for(v in state.world){
			this[v].fromArray(state.world[v]);
		}
		if(state.workpoints){
			if(typeof this.workpoint_states === 'undefined'){
				this.workpoint_states = {};
			}
			for (var wp in state.workpoints){
				if (typeof this.workpoint_states[wp] ==='undefined'){
					this.workpoint_states[wp] = {};
				}
				for(var p in state.workpoints[wp]){
					this.workpoint_states[wp][p] = state.workpoints[wp][p];
				}
			}
		}
		
	}
	*/
	
	m.prototype.setDeviceSetting = function(dev, name, value){
		this.devices[dev][name] = value;
	}
	m.prototype.getDeviceSetting = function(dev, name){
        // CL(this.devices, dev, name);
		return this.devices[dev][name] ;
	}
	m.prototype.alterDeviceSetting = function(dev, name, callback){
		if (this.devices[dev]){
			var value = this.devices[dev][name];
			var new_value = callback(value);
			if (new_value !== undefined){
				// L.setValue(" set " + param, new_value );
				
				this.devices[dev][name] = new_value;
			}
		}
		
	}
	m.prototype.saveWorkpointValue = function(wp, param, value){
		if(typeof this.workpoint_states[wp] === 'undefined'){
			this.workpoint_states[wp] = {};
			this.workpoint_states[wp][param] = value
		}else{
			this.workpoint_states[wp][param] = value
			
		}
	}
	m.prototype.getWorkpointValue = function(wp, param){
		if (this.workpoint_states[wp]){
			return this.workpoint_states[wp][param];
		}
		return undefined;
	}
	m.prototype.alterWorkpointValue = function(wp, param, modifier){
		if (this.workpoint_states[wp]){
			value = this.workpoint_states[wp][param];
			new_value = modifier(value);
			if (new_value !== undefined){
				// L.setValue(" set " + param, new_value );
				
				this.workpoint_states[wp][param] = new_value;
			}
		}
		// return undefined;
		
	}
	m.prototype.recalculate_till_server_report = function(server_report, time_diff){
		var state = server_report;
		var last_ts = state.server_ts;
		this.restoreState(state);
		
		current_ts = last_ts // - time_diff;
		if (last_ts !== 0){
			this.eventManager.set_last_processed(current_ts);
			this.eventManager.remove(current_ts);
		}
	};
	
	m.prototype.update_static_physical_data = function(till_time){
		var time_left = (till_time - this.last_processed_timestamp) / 1000 // to seconds;
		// // CL(time_left);
		var um = 1 / this.mass;
		var umt = time_left * um

		var rots = this.angular_impulse.clone().multiplyScalar(umt)
		var poses = this.impulse.clone().multiplyScalar(umt)

		// mesh.vel = mesh.impulse.clone().multiplyScalar(um);

		// // CL("statics ",rots.toArray(), poses.toArray());
		this.rotateX(rots.x)
		this.rotateY(rots.y)
		this.rotateZ(rots.z);

		this.position.add(poses);
		
		var power_plant_current_power = this.getDeviceSetting(this.type.power_source, 'power');
		var psource_dev = this.type.devices[this.type.power_source]
		var max_power = psource_dev.max_power;
		var power_produced = (max_power * power_plant_current_power)  * time_left ;
		var max_capacitor = psource_dev.capacitor
		// L.setValue("POWER PRODUCED", power_produced);
		// L.setValue("TIME ", time_left);
		
		this.alterDeviceSetting(this.type.power_source, "capacitor", function(value){
			if (value < max_capacitor){
				
				return value + power_produced;
			}else{
				return value;
			}
		})
		
		var self = this;
		_.each(this.type.shields, function(shields, type){
			_.each(shields, function(shield_id){
				// Ð¡ÐÐÐ§ÐÐÐ ÐÐÐ Ð¯ÐÐÐÐ ÐÐ¥ ÐÐÐÐÐ¡ÐÐ¢ÐÐ Ð«
				var shield_dev = self.type.devices[shield_id]
				var performance = 1;
				var charge_power = self.getDeviceSetting(shield_id, 'power');
				var reserve_cap_amount = self.getDeviceSetting(shield_id, 'reserve_capacity');
				var max_rcap_amount = shield_dev.capacitor;
				var charge_nominal = shield_dev.charge_rate * charge_power * time_left;
				var cap = self.getDeviceSetting(self.type.power_source, "capacitor");
				if( reserve_cap_amount < max_rcap_amount  ){
					var consumed = charge_nominal;
					if(cap >= consumed){
						var added = consumed * performance;
						self.alterDeviceSetting(shield_id, "reserve_capacity", function(val){
							return val + added;
							
						});
						self.alterDeviceSetting(self.type.power_source, "capacitor", function(val){
							return val - consumed;
						});
						
					}
				}
				// Ð¢ÐÐÐÐ Ð¬ ÐÐ ÐÐÐÐ Ð¯Ð Ð¡ÐÐ¡Ð¢ÐÐ¯ÐÐ Ð ÐÐÐÐ¢Ð«
				if(type === 'armor'){
					
					if(self.getDeviceSetting(shield_id, 'state') ){
						var cur_am = self.getDeviceSetting(shield_id, "capacity");
						var max_am = shield_dev.capacity;
						if(cur_am < max_am){
							var rr = shield_dev.repair_rate * time_left;
							var perf = shield_dev.performance;
							var rcap = self.getDeviceSetting(shield_id, 'reserve_capacity');
							
							consumed = rr / perf;
							if(consumed > rcap){ 
								consumed = rcap 
								rr = consumed * perf ;
							};
							self.alterDeviceSetting(shield_id, "capacity", function(val){
								return val + rr;
							})
							self.alterDeviceSetting(shield_id, "reserve_capacity", function(val){
								return val - consumed;
							})
							
						}
					}
				}
				if(type ==='shield'){
					var state = self.getDeviceSetting(shield_id, "state");
					var is_on = state;
					L.setValue("is_on", is_on);
					L.setValue("state", state);
					if( is_on ){
						var rcap = self.getDeviceSetting(shield_id, "reserve_capacity");
						var need = shield_dev.setup_energy;
						
						if(need <=rcap){
							
							var cap = shield_dev.capacity;
							self.alterDeviceSetting(shield_id, "capacity", function(val){
								return cap;
							})
							self.alterDeviceSetting(shield_id, "reserve_capacity", function(val){
								return val - need;
							})
							
							// Ð¢ÐµÐ¿ÐµÑÑ Ð½Ð°Ð´Ð¾ Ð²ÑÐºÐ»ÑÑÐ¸ÑÑ, Ð¿ÑÐ¾Ð²ÐµÐ´Ñ Ð¿Ð¾ ÑÐ¸ÑÑÐµÐ¼Ðµ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ð¹
							// // CL("MESH ACTORS", self.actors)
							self.autoMessage(shield_id, "toggle", 0) ;// This one should go through networking
							// self._scene.addSettingToScene(actor, sett, undefined, true);

							
						}
					}
					
				}
			})
		})
		
		
		var curr_hull = this.getDeviceSetting(this.type.hull_device, "capacity");
		if(curr_hull <=0){
            
			// // CL("DESTROYED");
            scene.removeObject(self);
            
		}
		this.last_processed_timestamp = till_time
		
		
		
	}
	m.prototype.createDeviceAction = function(dev,name, val, add_params){
		var action = this.type.devices[dev].actions[name];
		console.log("GUID", this.GUID, this.type.GUID )
		if(action.is_switch){
			var act = {
				mesh : this.GUID,
				dev : dev,
				name: name,
				ts :new Date().getTime(),
			};
			
		}else{
			var act = {
				mesh : this.GUID,
				dev : dev,
				name: name,
				ts :new Date().getTime(),
				delta: 0,
				value: val
			};
			
		}
		if(add_params){
			for(i in add_params){
				act[i] = add_params[i];
			}
			
		}
		
		if (this._scene.W){
			act.ident = act.ts + this._scene.W._time_diff;
		}else{
			act.ident = act.ts;
		}
		return act
	}
	m.prototype.startDeviceAction = function(dev, name, val, add_params){
		var act = this.createDeviceAction(dev, name, val, add_params);
		// // CL("this is a createde action", act)
		this.eventManager.add(act, act.ts)
		this._scene._addToServerQueue(act)
		
	};
	m.prototype.startVirtualDeviceAction = function(proc, ts, ident){
		this._foreign_procs[ts] = proc;
		var act = {
			dev : this.type.foreign_processor,
			name: 'process',
			ts :ts,
			ident:ident,
		};
		this.eventManager.add(act);
		
	}
	m.prototype.autoMessage = function(dev, name, val){
		var act = this.createDeviceAction(dev, name, val)
		this.eventManager.add(act, act.ts);
		// this._scene.makeSceneBroadcast(act);
	}
	
	m.prototype.downStreamMessage = function(dev, name, val){
		var act = this.createDeviceAction(dev, name, val)
		this.eventManager.add(act, act.ts);
		this._scene.makeSceneBroadcast(act);
	}
	
	m.prototype.enqueue_auto_setting_action = function(wp, setting, value, is_switch){
		act = {
			type: 1000,
			name:setting,
			value:value,
			wp : wp,
			actor: this.actors[wp].GUID,
			object_guid: this.GUID,
			scene: this._scene.GUID,
			ts: new Date().getTime(),
			controller: "settings"
		}
		if (is_switch){
			act.switch = true;
			delete act.value;
		}
		if (this._scene.W){
			act.ident = act.ts + this._scene.W._time_diff;
		}else{
			act.ident = act.ts;
		}
		
		// Ð­ÑÐ° Ð°ÐºÑÐ¸Ñ Ð´Ð¾Ð»Ð¶Ð½Ð° Ð±ÑÑÑ ÑÐ¾Ð·Ð´Ð°Ð½Ð° Ð½ÐµÐ·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ Ð¸ Ð½Ð° ÐºÐ»Ð¸ÐµÐ½ÑÐµ Ð¸ Ð½Ð° ÑÐµÑÐ²ÐµÑÐµ, ÑÐ°Ð· ÑÐ¶ Ð¾Ð½Ð° Ð´Ð¾Ð»ÐµÑÐµÐ»Ð° Ð´Ð¾ ÑÐµÑÐ²ÐµÑÐ°
		// Ð¢Ð¾Ð³Ð´Ð° 
		// this._scene._addToServerQueue.call(this._scene, act); 
		this.eventManager.add(act, act.ts)
	}
	
	
	m.prototype.load_json = function(){
		var self = this;
	
		var object = self.json
        self.GUID = self.json.GUID;
	
		// // CL("Loading", )
	
		self.eventManager = new EQ( object.GUID );
		self.pending_actions = [];
		self.workpoint_states = {};
		self._processed_actions = [];
		self._actions_index = {};
		self._previous_states = []
		self._previous_states_index = {}
		self.total_angular_impulses = [];
				// // CL(i, mesh.total_torques, mesh.total_powers)
		self.type=object.sub_type
		//var object_rotated = false
		// Setting defaults 
		//self.avel = new THREE.Vector3(0,0,0)
		//self.aacc = new THREE.Vector3(0,0,0)
		//self.vel = new THREE.Vector3(0,0,0)
		//self.acc = new THREE.Vector3(0,0,0)
	
      
	    /*
		if ( object.physical ){
			for(i in object.physical){
				
				var _is = 'to' in object.physical[i]
				if (!_is){
					if(i !='rotation'){
						var v = new THREE.Vector3()
						
					}else{
						var v = new THREE.Euler()
					}
					v.set.apply(v, object.physical[i])
					self[i] = v
				
				}else{
					var p = new THREE.Vector3(object.physical[i].to[0], object.physical[i].to[1], object.physical[i].to[2])
					// Try to rotate p on 180 
					//p.rotateX(2* Math.PI);
					self.lookAt(p.negate())
					// mesh.rotateX(2*Math.PI)
					self.rot = new THREE.Vector3(self.rotation.x, self.rotation.y, self.rotation.z);
					object_rotated = true;
				}
			}
		}else{
			var pi2 = Math.PI * 2;
			self.pos = new THREE.Vector3(Math.random() * 200, Math.random() * 200, Math.random() * 200);
			self.rot = new THREE.Vector3(Math.random() * pi2, Math.random() * pi2, Math.random() * pi2);
			
		}
        */
		/*
		self.position = self.pos;
		if (! object_rotated &&  'rot' in self){
			
			var uel = new self.THREE.Euler(self.rot.x, self.rot.y, self.rot.z);
			self.rotation = uel;
		}
        */
		// // CL(mesh.position)
        console.log("Creating object", self.type);
		self.cameras = self.type.cameras;
		self.mass = self.type.mass;
		// self.angular_impulse = self.avel.clone().multiplyScalar(object.mass)
		// self.impulse = self.vel.clone().multiplyScalar(object.mass)
		

		
		self.last_processed_timestamp = new Date().getTime();
		
		// ÐÐ¾-Ð»ÑÐ±Ð¾Ð¼Ñ Ð·Ð´ÐµÑÑ Ð¿ÑÐ¸Ð´ÐµÑÑÑ ÐºÐµÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð°ÐºÑÐ¾ÑÐ¾Ð² Ð² ÑÑÐ¾Ð¼ Ð¼ÐµÑÐµ
		// ÐÐÐ¯ÐÐ¬!
		self.actors = {}
		_.each(self._scene.actors, function(actor, aid){
			if(actor.control.object_guid == self.json.GUID){
				self.actors[actor.control.workpoint] = actor;
			}
		})
		
		// Ð¡Ð¾Ð·Ð´Ð°Ð´Ð¸Ð¼ ÐºÐ°ÑÑÑ ÑÐµÑÑÐ¸Ð½Ð³Ð¾Ð² Ð´Ð»Ñ ÑÑÑÑÐ¾Ð¹ÑÑÐ²
		// ÑÐ°ÐºÐ¶Ðµ ÑÐ¾Ð·Ð´Ð°ÐµÐ¼ ÐºÐ°ÑÑÑ ÐºÐ¾Ð½ÑÑÐ¾Ð»Ð»ÐµÑÐ¾Ð² Ð´ÐµÐ²Ð°Ð¹ÑÐ¾Ð²
		
		self.devices = [];
		self.controllers=[];
		self.armors = [];
		self.shields = [];
		self.uis = [];
        // CL("loading devices", self.type.devices);
		_.each(self.type.devices, function(dev,ix){
			self.devices.push({});
			if (dev.type == 'shield'){
				if(dev.shield_type == 'shield'){ self.shields.push(ix)}
				if(dev.shield_type == 'armor'){ self.armors.push(ix)}
				if(dev.shield_type == 'thermal'){ /* no use yet */}
				
			}
			var C = Controller.deviceControllers.controllersMap[dev.type]
			if (C){
				var contr = new C(self, ix);
				self.controllers.push(contr)
				if(self._scene.W){
					self.uis.push(contr.getUI(self._scene.W));
				}
			}
		});
        
		self.reload_saved_state();

		
		
	
	}
	m.prototype.getUIForWP=function(wp){
		var self =this;
		var ui_list=[];
        var _wp = this.type.workpoints[wp];
		_.each(_wp.devices, function(d_id){
			var  ui = self.uis[d_id]
			if (ui){
				ui_list.push(ui)
			}
		})
        return ui_list;
		
	};
	m.prototype.getActionList = function(){
		// ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ
		// 
		// 
		//  {wp: [actions] }
		var self = this;
		var obj = {}
		_.each(this.type.workpoints, function(wp, wp_name){
			av_act_list = []
			_.each(wp.devices, function(dev_ix){
				var dev  = self.type.devices[dev_ix];
				_.each(dev.actions, function(act, act_name){
					var a = {mesh:self.GUID, device: dev_ix, name:act_name};
					if (act.default_key){
						a.default_key = act.default_key;
					}
					av_act_list.push(a);
					
				})
				// // CL("AA",wp_name, dev.type,  dev.actions)
			})
			obj[ wp_name ] = av_act_list;
			
		})
		return obj;

	};
    m.prototype.clear = function(){
        this._scene = null;
        this.geometry = null;

    }
	return (new m(mat, geom));
}


module.exports = createObject;

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/object.js","/")
},{"./controller":8,"./event_queue":9,"1YiZ5S":5,"buffer":2,"three":6,"underscore":7}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var fs    = require('fs');
var u = require('./utils');
var THR = require('three');
var Controller = require('./controller');
var AObject = require('./object');
var EQ = require("./event_queue");

var _     = require('underscore');

var SceneObject = function(threeScene, W){
	this.description= "Scene routines";
	this.GUID =  u.make_guid();
	// this.broadcaster = broadcaster;


    this.use_client_rendering = false;
    if(threeScene !== undefined && W !== undefined){
        this.inputService = InputServiceGetter();
    	this.W = W;
    	this.three_scene = threeScene;
        this.use_client_rendering = true;
    }
    
	this._create();
	
};
Scene = {constructor: SceneObject}
if(typeof window === 'undefined'){
	Scene.THREE = THR; // Saveing THREE.js as part of scene - this step could be done on a certain platform
	Scene.do_prepare_rendering = false
	Scene.ajax_load_models = false
	Scene.need_update_matrix = true
	Scene.localActions = false
	var is_browser = false;
	
	
}else{
	var is_browser = true;
	Scene.THREE = THREE;
	Scene.do_prepare_rendering = true;
	Scene.ajax_load_models = true;
	Scene.need_update_matrix = false;
	Scene.localActions = true;
	Scene.INPUT_TIMESTEP = 0.0700; // seconds
	Scene.time_since_last_actions_acquired = 0;
	
	// Scene.save_meshes_past = true
	
	
}

Scene.get_actor = function(actor_guid){
	return this.get_actors()[actor_guid];
}


Scene.mesh_for = function(actor_guid){
	var actor = this.actors[actor_guid];
	return this.meshes[actor.control.object_guid]
}

Scene.create = function(){
	this._create();
	
	return this;
}

Scene._create = function(){
	this.clock = new (this.THREE.Clock)();
	this.time_inc  = 0;
	this.tick_counter = 0;
	this._scene_object_cache = {};
	this._scene_obj_actors={};
	this._network_messages = [];
    this._last_user_activity = new Date().getTime();
	this._last_server_report = {};
	this.loaded_objects_count = 0;
	this._model_cache = {};
    
    
	this._server_sync_queue = [];
	this._server_last_sended = 0;
	this.meshes = {};
    this.actors = {};
	this.loader =  new this.THREE.JSONLoader();
	this.total_objects_count = 0;
	
	this.mesh_last_states = {}
	this.mesh_actions = {};
	this._target_aq = 0.01; // seconds to get to sync target
	this.is_loaded = false
	this._d = false
    
	
}
/*
Scene.update_from_world = function(){
	// globalx-y-z - galaxy coords with 1 meter accuracy
	var closest_scene_with_distance = this.get_closest_scene(this.gx, this.gy, this.gz);
	// if closest_scene is not null - we must inject object with actors to that scene - it's already_loaded
	// else - We finding objects for that scene
				
	var objects_within_coords = this.get_objects_in(this.gx, this.gy, this.gz); // ÐÐ°Ð³ÑÑÐ·ÐºÐ° Ð¾Ð±ÑÐµÐºÑÐ¾Ð² Ð² ÑÑÐµÐ½Ñ Ð¸Ð· Ð³Ð»Ð¾Ð±Ð°Ð»ÑÐ½Ð¾Ð³Ð¾ Ð¼Ð¸ÑÐ°
	
	var objects = {}
	for ( var i = 0; i < objects_within_coords.length ; i++ ){
		objects[ objects_within_coords[i].GUID ] =   objects_within_coords[i];
	}
	_.extend(this._scene.objects, objects)
	
	this._scene.sunDirection = [0,1,0]
	this._scene.sunLightColor = [Math.random(), 0.8, 0.9] // HSL
	this._scene.coords =[ this.gx, this.gy, this.gz ]
	
    
	
	return this
	
}
*/

Scene.get_actors = function(){
	return this.actors
}

Scene.get_object = function(guid){
	return this.meshes[guid].type;
}

Scene.get_json = function(){
	return this._scene
}
Scene.get_closest_scene = function(){
	return undefined
}
Scene.get_objects_in = function(){
	return [];
}
Scene.join_object = function( object ){
    
	this.load_object(object, object.GUID);
	

}
Scene.join_actor = function( actor ){



	this.actors[actor.GUID] = actor;
	if(this.actor_wp_ix === undefined){
		this.actor_wp_ix = {}
		
	}else{
		if (this.actor_wp_ix[actor.control.object_guid] === undefined){
			this.actor_wp_ix[actor.control.object_guid] = {}
		}else{
			this.actor_wp_ix[actor.control.object_guid][actor.wp] = actor;
		}
	}
	return this
	
    
}


Scene.addActions = function(mesh_guid, actions){
	this.mesh_actions[mesh_guid] = actions
}
Scene.getActions = function(){
	return this.mesh_actions;
}

Scene.load_object = function(object, ix){
    
    var self = this;
	self.total_objects_count +=1;
    
	
	if (! self.ajax_load_models){
		var m = object.sub_type.model_3d.split('/')[2];
		var model_path= "./public/models/" + m
	}

	
	var rf = function(){
		var with_geom_and_mat = function(geom, mat){
			var m = new self.THREE.Matrix4()
			m.identity()
		
			
			var mesh = AObject(self, geom, mat) ;//self.THREE.Mesh( geom, mat );
			mesh.json = object;
			mesh.load_json();
			var actions = mesh.getActionList();


			self.addActions(object.GUID, actions);
			
			if (self.do_prepare_rendering){
				if (object.type !=='static'){

					var label = SpriteUtils.makeTextSprite("mesh: " + ix);
					label.position = new self.THREE.Vector3(0,0,0);
					mesh.add(label);

				}
				self.three_scene.add( mesh );
		
			}
			
			self.meshes[ object.GUID ] = mesh;
			self.loaded_objects_count +=1;
			self._model_loaded( ix )
		}
		
		
		if(self.ajax_load_models){
			self._get_model(object.sub_type.model_3d,self._ajax_getter, with_geom_and_mat)
		}else{
			self._get_model(model_path, self._fs_getter, with_geom_and_mat)

		}
	}
	setTimeout(rf,1);
}
Scene.load = function(onload, three_scene, W){
	// three scene - is a param for adding meshes to
	var self = this;

	// DEBUG THINGS
	//self.total = new self.THREE.Vector3();
	//self.total_t=0;
	//self.controller_map= Controller.ControllersActionMap()
	self._call_back = onload;
	
    this._server_sync_queue = [];
	this._server_last_sended = 0;
	self.meshes = {}
	self.loader =  new self.THREE.JSONLoader();
	self.total_objects_count = 0;
	
	if(typeof window !== 'undefined'){
		self.three_scene = three_scene
		self.W = W;
	}
	
	
	
},
Scene._ajax_getter=function(name, cb) {

	var self = this;
	self.loader.load( name, function(geom, mat){
		
		var material = new THREE.MeshFaceMaterial( mat );
		//var a = {geom:geom, material:material}
		cb(geom, material);
		
	})
}
Scene._fs_getter=function(name, cb){
	var self = this;
	fs.readFile(name, function(err,data){

		if(err) throw err;
		var json = JSON.parse(data)
        var result = self.loader.parse( json, '' );

		var ld = (function(){
			var material = new self.THREE.MeshFaceMaterial( result.materials );
			cb(result.geometry, material);
		
		})
		setTimeout(ld,1);
	});
}

Scene._get_model = function(name, getter, with_geom_and_mat){
	var self = this;
	var mat_geom_cb = function(geom, mat){
		self._model_cache[name] = {geom:geom, material:mat}
		with_geom_and_mat(geom, mat)
	}
	if (name in self._model_cache){
		var a= self._model_cache[name]
		with_geom_and_mat(a.geom, a.material)
	}else{
		getter.apply(self,[name, mat_geom_cb])
	}
				
}
Scene._delete_object = function(guid){
	var self = this;
	if(self.three_scene){
		self.three_scene.remove(self.meshes[guid]) // ÑÐ´ÑÐ»ÑÐµÐ¼ ÑÐ´ÑÐ¾ Ð¸Ð· ÑÑÐµÐ½Ñ
	}
	delete self.meshes[ guid ]; // ... Ð¸Ð· Ð¼ÐµÑÐµÐ¹
	delete self._scene_object_cache[ guid ]
	
	
}
Scene._model_loaded = function(ix){

	if (this.loaded_objects_count == this.total_objects_count){
		// scene loaded
		this.is_loaded = true;
		if  (this.onLoadCallback){
			this.onLoadCallback(this)
		}
	}else{


	}
}
Scene.sync = function(sync){
	var self = this;

	self._last_server_report = sync


}
Scene.get = function(){
	return this._scene
}
Scene.get_almanach = function(){

	return this.mesh_last_states
	
}
Scene.createSettingAction =function(actor, setting_name, setting_value, is_switch){

	var action = {
		type: 1000,
		name:setting_name,
		value:setting_value,
		actor:actor.GUID,
		wp : actor.control.workpoint,
		object_guid: actor.control.object_guid,
		scene: actor.scene,
		ts: new Date().getTime(),
		
		controller: "settings"
	}
	if (is_switch){
		action.switch = true;
		delete action.value;
	}
	action.ident = action.ts + this.W._time_diff;
	return action;
	
}

Scene.makeActorSetting = function(actor, setting_name, setting_value, is_switch){
	this._addToServerQueue(this.createSettingAction(actor,setting_name,setting_value,is_switch));
}
Scene.addSettingToScene = function(actor, setting_name, setting_value, is_switch){
	var action = this.createSettingAction(actor, setting_name, setting_value, is_switch);
	var mesh = this.meshes[actor.control.object_guid];
	mesh.eventManager.add(action)
}
Scene.sendAction= function(actor, name, val, is_switch){
	var action = this.createSettingAction(actor, name, val, is_switch);
	var mesh = this.meshes[actor.control.object_guid];
	this._addToServerQueue(action);
	mesh.eventManager.add(action);
	
	
}

Scene.unload = function(callback){
    console.log("We must now save all object states and report with callback");
    callback();
}

Scene.tick = function(){
	var self = this;
	if(self.tick_num){
		self.tick_num+=1;
	}else{
		self.tick_num = 0;
	}
	var now = new Date().getTime();
    

	var time_left = self.clock.getDelta();
	self.time_inc += time_left;
	
	
	if(self.last_ts === undefined){
		self.last_ts = new Date().getTime();
	}
	if(self.localActions){ // ÐÑÐ»Ð¸ ÑÑÐ¾ ÐºÐ»Ð¸ÐµÐ½Ñ Ð¸ Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ ÑÐ¿ÑÐ°Ð²Ð»ÑÑÑ ÑÐºÐ»Ð°Ð²Ð¸Ð°ÑÑÑÑ
		
		if(self.time_since_last_actions_acquired > self.INPUT_TIMESTEP){
			self.time_since_last_actions_acquired = 0
			var new_actions = self.getLocalActions(now);
			
			if(new_actions.length > 0){
				
				_.each(new_actions, function(a){

					self._addToServerQueue(a);

					self.meshes[a.mesh].eventManager.add(a, a.ident  );
                    

                    
					
				})
			}
			
		}else{
			self.time_since_last_actions_acquired += time_left;
			
		}
	}
	var nm = self.getNetworkActions();
	_.each(nm,function(action){
        // ÐÑÐ»Ð¸ Ñ Ð½Ð°Ñ ÐµÑÑÑ Ð¾Ð±ÑÐµÐºÑ W - ÑÐ¾ Ð¼Ñ Ð´Ð¾Ð»Ð¶Ð½Ñ Ð¸ÑÐ¿Ð¾Ð»Ð½ÑÑÑ Ð°ÐºÑÐ¸Ð¸ Ð¿Ð¾ Ð²ÑÐµÐ¼ÐµÐ½Ð¸ Ð½Ðµ ÑÑÐ¸ÑÑÐ²Ð°Ñ Ð²ÑÐµÐ¼Ñ Ð·Ð°Ð´ÐµÑÐ¶ÐºÐ¸
		var mesh = self.meshes[action.mesh];
        
        //if(self.W !== undefined){
    		//mesh.eventManager.add(action, action.ident - W._time_diff);
            
            //}else{ // ÐÑÐ»Ð¸ Ð½ÐµÑÑ - Ð·Ð½Ð°ÑÐ¸Ñ Ð½Ð° ÑÐµÑÐ²ÐµÑÐµ - Ð¸ Ð·Ð½Ð°ÑÐ¸Ñ ÑÑÑÐ¾Ð³Ð¾
    	mesh.eventManager.add(action, action.ident);
            
            //}
	})

	
	// lastActions = getLastActions
	_.each(self.meshes, function(mesh, i){
		
		if (mesh.type == 'static') return;
		if(self.localActions && (i in self._last_server_report) ){

			
			mesh.recalculate_till_server_report(self._last_server_report[i] , self.W._time_diff);

			
			delete self._last_server_report[i]; 
			
			
		}

		if(self.W){
			var q_now =  now + self.W._time_diff;
		}else{
			var q_now = now;
		}

		mesh.eventManager.process(q_now, function(event){

			mesh.controllers[event.dev].process(event);
            if(self.W){
                if(mesh.uis[event.dev] && mesh.uis[event.dev].onAction){
                    mesh.uis[event.dev].onAction(self.W, self.GUID, event );
                }
            }
			
		})

		if(! is_browser){

		}
		

		
		if(! (self.localActions )){
			
			self.mesh_last_states[i] = mesh.getState();
			
		}
		self.process_physical(mesh, now);
		
		
		
		
	})
	self.last_ts = now
    
    
	
}
Scene.getNetworkActions = function(){
	var ret = _.clone(this._network_messages)
	this._network_messages = [];
	return ret;
}
Scene.getLocalActions = function(now){
    return this.inputService.getLatestActions(this.GUID, now);
}
Scene.makeSceneBroadcast = function(action){
	if(this.broadcaster){
		this.broadcaster("mesh-action", this.actors, action);
		
	}
}
Scene.removeObject = function (mesh) {

    if (this.do_prepare_rendering) {
        this.createBlast( mesh );
        this.three_scene.remove(mesh);
        
    }
    delete this.meshes[mesh.json.GUID];
    
    
}

Scene.createBlast = function (mesh) {
    var ts = new Date().getTime();

    SpriteUtils.createExposionObject(
        "#" + mesh.json.GUID + "_" + ts , 
        ts, 
        mesh.position.toArray(), 
        mesh.geometry.boundingSphere.radius * 20,
        this.three_scene, 
        this.W);
}
Scene.process_physical = function(mesh, now){
	mesh.update_static_physical_data(now);
	
}
Scene._addToServerQueue = function(action){
	this.W.sendAction(this.GUID, action);
}
Scene._flushServerQueue = function(){
	var size = this._server_sync_queue.length ;
	var ret = this._server_sync_queue.slice(this._server_last_sended);

	this._server_last_sended = size;
	return {scene:this.GUID, actions:ret};
}
Scene.addNetworkMessage = function(mes){
    this._last_user_activity = new Date().getTime();

	this._network_messages.push(mes) // = this._network_messages.concat(mes)
};
Scene.clear = function(){
    for (var i in this.meshes){

        this.meshes[i].clear();
        this.meshes[i] = null;

    };
    this.three_scene = null;
    this.actors = null;
    this.W = null;
    this.onLoadCallback = null;
    this._scene_object_cache = null;
    for (var mc in this._model_cache){
        delete this._model_cache[mc];

    }
};

SceneObject.prototype = Scene;
module.exports = SceneObject;

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/scene.js","/")
},{"./controller":8,"./event_queue":9,"./object":12,"./utils":15,"1YiZ5S":5,"buffer":2,"fs":1,"three":6,"underscore":7}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){




var Mod = {
    
    createExposionObject : function(id, ts, position, size, scene){
        var geom  = new THREE.PlaneGeometry( 1, 1 );
        var TIME_ = 1403660000000;
        var explosion_time = 5000.;
        
        var vshader = [
         'varying vec2 vUv;',
         'uniform vec3 scale;',
         'void main(){',
         '    vUv = uv;',
         '    float rotation = 0.0;',

         '    vec3 alignedPosition = vec3(position.x * scale.x, position.y * scale.y, position.z*scale.z);',
         '    vec2 pos = alignedPosition.xy;',

         '    vec2 rotatedPosition;',
         '    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
         '    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

         '    vec4 finalPosition;',

         '    finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
         '    finalPosition.xy += rotatedPosition;',
         '    finalPosition = projectionMatrix * finalPosition;',

         '    gl_Position =  finalPosition;',
         '}'
        ].join('\n');
        
        var fshader = [
         'uniform float cur_time;',
         'uniform float beg_time;',
         'uniform float explosion_time;',
         'varying vec2 vUv;',

         'void main(){',

         '    float time_left = cur_time - beg_time;',
         '    float expl_step0 = 0.;',
         '    float expl_step1 = 0.3;',
         '    float expl_max   = 1.;',

         '    float as0 = 0.;',
         '    float as1 = 1.;',
         '    float as2 = 0.;',

         '    float time_perc = clamp( (time_left / explosion_time), 0., 1. ) ;',

         '    float alphap; ',
         '    alphap = mix(as0,as1, smoothstep(expl_step0, expl_step1, time_perc));',
         '    alphap = mix(alphap,as2, smoothstep(expl_step1, expl_max, time_perc));',

         '    vec2 p = vUv;',
         '    vec2 c = vec2(0.5, 0.5);',
         '    float max_g = 1.;',
         '    float dist = length(p - c) * 2. ;',

         '    float step1 = 0.;',
         '    float step2 = 0.2;',
         '    float step3 = 0.3;',
         
         '    float a0 = 1.;',
         '    float a1 = 1.;',
         '    float a2 = 0.7;',
         '    float a3 = 0.0;',
        
         '    vec4 c0 = vec4(1., 1., 1., a0 * alphap);',
         '    vec4 c1 = vec4(0.9, 0.9, 1., a1 * alphap);',
         '    vec4 c2 = vec4(0.7, 0.7, 1., a2 * alphap);',
         '    vec4 c3 = vec4(0., 0., 0., 0.);',
         
         '    vec4 color;',
         '    color = mix(c0, c1, smoothstep(step1, step2, dist));',
         '    color = mix(color, c2, smoothstep(step2, step3, dist));',
         '    color = mix(color, c3, smoothstep(step3, max_g, dist));',

         '    gl_FragColor = color; ',
         '}'
         
         ].join('\n');

        var uniforms = {
					beg_time:   { type: "f", value: ts - TIME_ },
                    cur_time: { type: "f",  value: ts - TIME_ },
                    scale :   {type:"v3", value: new THREE.Vector3(0, 0, 0)},
                    explosion_time:{ type:'f', value: explosion_time }
					//resolution:   { type: "v2", value: new THREE.Vector2() }
				};
        var upd_uniforms = function(){
            var ct = new Date().getTime() - TIME_;
            // console.log("UU", ct)
            uniforms.cur_time.value = ct;
        }
        
        var mat = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vshader,
					fragmentShader: fshader,
                    transparent: true,
                    blending:THREE.AdditiveBlending

				} );
        
        var mesh = new THREE.Mesh(geom, mat)
        mesh.scale.set(size, size, size);
        uniforms.scale.value = mesh.scale;
        mesh.position.fromArray(position);
        
        var uniformUpdaterName = "exp_" + id + "_" + ts
        var uniformUpdaters = CustomUpdaterGetter();
        
        uniformUpdaters.add( uniformUpdaterName, upd_uniforms);
        var deleter = function(){
            
            uniformUpdaters(uniformUpdaterName);
            scene.remove(mesh)
            
        }
        setTimeout(deleter, explosion_time + 500);
        scene.add(mesh);
        
        return mesh;
        
    },
	makeTextSprite:function( message, parameters ){
		if ( parameters === undefined ) parameters = {};
	
		var fontface = parameters.hasOwnProperty("fontface") ? 
			parameters["fontface"] : "Arial";
	
		var fontsize = parameters.hasOwnProperty("fontsize") ? 
			parameters["fontsize"] : 18;
	
		var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
			parameters["borderThickness"] : 4;
	
		var borderColor = parameters.hasOwnProperty("borderColor") ?
			parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
	
		var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
			parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

		//var spriteAlignment = THREE.SpriteAlignment.topLeft;
		
		var canvas = document.createElement('canvas');
		var context = canvas.getContext('2d');
		context.font = "Bold " + fontsize + "px " + fontface;
    
		// get size data (height depends only on font size)
		var metrics = context.measureText( message );
		var textWidth = metrics.width;
	
		// background color
		context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
									  + backgroundColor.b + "," + backgroundColor.a + ")";
		// border color
		context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
									  + borderColor.b + "," + borderColor.a + ")";

		context.lineWidth = borderThickness;
		this.roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
		// 1.4 is extra height factor for text below baseline: g,j,p,q.
	
		// text color
		context.fillStyle = "rgba(0, 0, 0, 1.0)";

		context.fillText( message, borderThickness, fontsize + borderThickness);
	
		// canvas contents will be used for a texture
		var texture = new THREE.Texture(canvas) 
		texture.needsUpdate = true;

		var spriteMaterial = new THREE.SpriteMaterial( 
			{ map: texture, useScreenCoordinates: false } );
		var sprite = new THREE.Sprite( spriteMaterial );
		sprite.scale.set(20,20,1.0);
		return sprite;	
	},
	roundRect:function(ctx, x, y, w, h, r) 
	{
	    ctx.beginPath();
	    ctx.moveTo(x+r, y);
	    ctx.lineTo(x+w-r, y);
	    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
	    ctx.lineTo(x+w, y+h-r);
	    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
	    ctx.lineTo(x+r, y+h);
	    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
	    ctx.lineTo(x, y+r);
	    ctx.quadraticCurveTo(x, y, x+r, y);
	    ctx.closePath();
	    ctx.fill();
		ctx.stroke();   
	}
}
module.exports=Mod

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/sprite_utils.js","/")
},{"1YiZ5S":5,"buffer":2}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

var PredefinedOrbitalPlanes = [[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[0,1,0],[-0.3090169943749474,0.9510565162951535,0],[-0.24999999999999994,0.9510565162951535,0.1816356320013402],[-0.09549150281252627,0.9510565162951535,0.2938926261462365],[0.09549150281252627,0.9510565162951535,0.2938926261462365],[0.24999999999999992,0.9510565162951535,0.18163563200134025],[0.3090169943749474,0.9510565162951535,3.784366729417715e-17],[0.24999999999999994,0.9510565162951535,-0.18163563200134017],[0.09549150281252632,0.9510565162951535,-0.2938926261462365],[-0.09549150281252623,0.9510565162951535,-0.2938926261462365],[-0.24999999999999992,0.9510565162951535,-0.18163563200134025],[-0.3090169943749474,0.9510565162951535,-7.56873345883543e-17],[-0.5877852522924731,0.8090169943749473,0],[-0.47552825814757677,0.8090169943749473,0.3454915028125263],[-0.1816356320013402,0.8090169943749473,0.5590169943749475],[0.1816356320013402,0.8090169943749473,0.5590169943749475],[0.47552825814757665,0.8090169943749473,0.3454915028125264],[0.5877852522924731,0.8090169943749473,7.198293276126593e-17],[0.47552825814757677,0.8090169943749473,-0.3454915028125262],[0.1816356320013403,0.8090169943749473,-0.5590169943749473],[-0.18163563200134014,0.8090169943749473,-0.5590169943749475],[-0.47552825814757665,0.8090169943749473,-0.3454915028125264],[-0.5877852522924731,0.8090169943749473,-1.4396586552253185e-16],[-0.8090169943749473,0.5877852522924731,0],[-0.6545084971874736,0.5877852522924731,0.47552825814757677],[-0.24999999999999994,0.5877852522924731,0.7694208842938133],[0.24999999999999994,0.5877852522924731,0.7694208842938133],[0.6545084971874735,0.5877852522924731,0.4755282581475768],[0.8090169943749473,0.5877852522924731,9.907600723509855e-17],[0.6545084971874736,0.5877852522924731,-0.47552825814757665],[0.2500000000000001,0.5877852522924731,-0.7694208842938132],[-0.24999999999999986,0.5877852522924731,-0.7694208842938133],[-0.6545084971874735,0.5877852522924731,-0.4755282581475768],[-0.8090169943749473,0.5877852522924731,-1.981520144701971e-16],[-0.9510565162951535,0.3090169943749474,0],[-0.7694208842938133,0.3090169943749474,0.5590169943749475],[-0.2938926261462365,0.3090169943749474,0.9045084971874736],[0.2938926261462365,0.3090169943749474,0.9045084971874736],[0.7694208842938132,0.3090169943749474,0.5590169943749476],[0.9510565162951535,0.3090169943749474,1.1647083181762659e-16],[0.7694208842938133,0.3090169943749474,-0.5590169943749473],[0.2938926261462367,0.3090169943749474,-0.9045084971874735],[-0.2938926261462364,0.3090169943749474,-0.9045084971874736],[-0.7694208842938132,0.3090169943749474,-0.5590169943749476],[-0.9510565162951535,0.3090169943749474,-2.3294166363525317e-16],[-1,0,0],[-0.8090169943749473,0,0.5877852522924731],[-0.3090169943749474,0,0.9510565162951535],[0.3090169943749474,0,0.9510565162951535],[0.8090169943749472,0,0.5877852522924732],[1,0,1.224646798818428e-16],[0.8090169943749473,0,-0.587785252292473],[0.30901699437494756,0,-0.9510565162951534],[-0.3090169943749473,0,-0.9510565162951535],[-0.8090169943749472,0,-0.5877852522924732],[-1,0,-2.449293597636856e-16]]

var Utils = {
	make_short_guid :function(){
		var guid = '4xxxxx'.replace(/[xy]/g, function(c) {
		    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
		    return v.toString(16);
		});
		return guid;
	},
	
	make_guid :function(){
		var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
		    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
		    return v.toString(16);
		});
		return guid;
	},
    orbital_normal : function(id){
        if(id < PredefinedOrbitalPlanes.length){
            return PredefinedOrbitalPlanes[id];
        }
    },
    orbital_height:function(id){
        // orbits start from 200 km and spred up to 2 * celestial_radius with step 300km
        var base = 200000; //meters
        var step = 300000;
        return id*step + base;
        
    },
    ix_array: function(arr, ix, val){
        if(arr[ix] === undefined){
            arr[ix] = [val]
        }else{
            arr[ix].push( val );
        }
    }

    
}
module.exports = Utils;
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/utils.js","/")
},{"1YiZ5S":5,"buffer":2}]},{},[10])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hemwvRG9jdW1lbnRzL3dvcmtzcGFjZS9hei1hei5ydS9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvYXpsL0RvY3VtZW50cy93b3Jrc3BhY2UvYXotYXoucnUvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiL1VzZXJzL2F6bC9Eb2N1bWVudHMvd29ya3NwYWNlL2F6LWF6LnJ1L25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9hemwvRG9jdW1lbnRzL3dvcmtzcGFjZS9hei1hei5ydS9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL2F6bC9Eb2N1bWVudHMvd29ya3NwYWNlL2F6LWF6LnJ1L25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi9Vc2Vycy9hemwvRG9jdW1lbnRzL3dvcmtzcGFjZS9hei1hei5ydS9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvYXpsL0RvY3VtZW50cy93b3Jrc3BhY2UvYXotYXoucnUvbm9kZV9tb2R1bGVzL3RocmVlL3RocmVlLmpzIiwiL1VzZXJzL2F6bC9Eb2N1bWVudHMvd29ya3NwYWNlL2F6LWF6LnJ1L25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCIvVXNlcnMvYXpsL0RvY3VtZW50cy93b3Jrc3BhY2UvYXotYXoucnUvc2VydmVyL2NvbnRyb2xsZXIuanMiLCIvVXNlcnMvYXpsL0RvY3VtZW50cy93b3Jrc3BhY2UvYXotYXoucnUvc2VydmVyL2V2ZW50X3F1ZXVlLmpzIiwiL1VzZXJzL2F6bC9Eb2N1bWVudHMvd29ya3NwYWNlL2F6LWF6LnJ1L3NlcnZlci9mYWtlX2NkNTVjYTcwLmpzIiwiL1VzZXJzL2F6bC9Eb2N1bWVudHMvd29ya3NwYWNlL2F6LWF6LnJ1L3NlcnZlci9taXNzaW9ucy5qcyIsIi9Vc2Vycy9hemwvRG9jdW1lbnRzL3dvcmtzcGFjZS9hei1hei5ydS9zZXJ2ZXIvb2JqZWN0LmpzIiwiL1VzZXJzL2F6bC9Eb2N1bWVudHMvd29ya3NwYWNlL2F6LWF6LnJ1L3NlcnZlci9zY2VuZS5qcyIsIi9Vc2Vycy9hemwvRG9jdW1lbnRzL3dvcmtzcGFjZS9hei1hei5ydS9zZXJ2ZXIvc3ByaXRlX3V0aWxzLmpzIiwiL1VzZXJzL2F6bC9Eb2N1bWVudHMvd29ya3NwYWNlL2F6LWF6LnJ1L3NlcnZlci91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbi90Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOTdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNscUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG4vKipcbiAqIElmIGBCdWZmZXIuX3VzZVR5cGVkQXJyYXlzYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKGNvbXBhdGlibGUgZG93biB0byBJRTYpXG4gKi9cbkJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLFxuICAvLyBDaHJvbWUgNyssIFNhZmFyaSA1LjErLCBPcGVyYSAxMS42KywgaU9TIDQuMisuIElmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcywgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnRcbiAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gYWRkIGFsbCB0aGUgbm9kZSBCdWZmZXIgQVBJIG1ldGhvZHMuIFRoaXMgaXMgYW4gaXNzdWVcbiAgLy8gaW4gRmlyZWZveCA0LTI5LiBOb3cgZml4ZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBhc3N1bWUgdGhhdCBvYmplY3QgaXMgYXJyYXktbGlrZVxuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3RbaV1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4nICtcbiAgICAgICdsaXN0IHNob3VsZCBiZSBhbiBBcnJheS4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMlxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBfdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2FzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgID8gTnVtYmVyKGVuZClcbiAgICA6IGVuZCA9IHNlbGYubGVuZ3RoXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gX2JpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIF9hc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gX2hleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSsxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSBjbGFtcChzdGFydCwgbGVuLCAwKVxuICBlbmQgPSBjbGFtcChlbmQsIGxlbiwgbGVuKVxuXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpXG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTRcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHNlbGYgPSBzZWxmIHx8IHt9Oy8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIExhcnJ5IEJhdHRsZSAvIGh0dHA6Ly9iYXRlcnUuY29tL25ld3NcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxudmFyIFRIUkVFID0geyBSRVZJU0lPTjogJzY2JyB9O1xyXG5cclxuc2VsZi5jb25zb2xlID0gc2VsZi5jb25zb2xlIHx8IHtcclxuXHJcblx0aW5mbzogZnVuY3Rpb24gKCkge30sXHJcblx0bG9nOiBmdW5jdGlvbiAoKSB7fSxcclxuXHRkZWJ1ZzogZnVuY3Rpb24gKCkge30sXHJcblx0d2FybjogZnVuY3Rpb24gKCkge30sXHJcblx0ZXJyb3I6IGZ1bmN0aW9uICgpIHt9XHJcblxyXG59O1xyXG5cclxuLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuLy8gaHR0cDovL215Lm9wZXJhLmNvbS9lbW9sbGVyL2Jsb2cvMjAxMS8xMi8yMC9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWVyLWFuaW1hdGluZ1xyXG5cclxuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJ5IEVyaWsgTcO2bGxlclxyXG4vLyBmaXhlcyBmcm9tIFBhdWwgSXJpc2ggYW5kIFRpbm8gWmlqZGVsXHJcbi8vIHVzaW5nICdzZWxmJyBpbnN0ZWFkIG9mICd3aW5kb3cnIGZvciBjb21wYXRpYmlsaXR5IHdpdGggYm90aCBOb2RlSlMgYW5kIElFMTAuXHJcbiggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbGFzdFRpbWUgPSAwO1xyXG5cdHZhciB2ZW5kb3JzID0gWyAnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJyBdO1xyXG5cclxuXHRmb3IgKCB2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsrIHggKSB7XHJcblxyXG5cdFx0c2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xyXG5cdFx0c2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHNlbGZbIHZlbmRvcnNbIHggXSArICdDYW5jZWxBbmltYXRpb25GcmFtZScgXSB8fCBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCAmJiBzZWxmWydzZXRUaW1lb3V0J10gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHR2YXIgY3VyclRpbWUgPSBEYXRlLm5vdygpLCB0aW1lVG9DYWxsID0gTWF0aC5tYXgoIDAsIDE2IC0gKCBjdXJyVGltZSAtIGxhc3RUaW1lICkgKTtcclxuXHRcdFx0dmFyIGlkID0gc2VsZi5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgY2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApOyB9LCB0aW1lVG9DYWxsICk7XHJcblx0XHRcdGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdFx0XHRyZXR1cm4gaWQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiggc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGZbJ2NsZWFyVGltZW91dCddICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0c2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICggaWQgKSB7IHNlbGYuY2xlYXJUaW1lb3V0KCBpZCApIH07XHJcblxyXG5cdH1cclxuXHJcbn0oKSApO1xyXG5cclxuVEhSRUUuRXhjZXB0aW9uRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oIG1lc3NhZ2UsIG9wdGlvbmFsRGF0YSApIHtcclxuXHRjb25zb2xlLmVycm9yKCBtZXNzYWdlICk7XHJcblx0Y29uc29sZS5lcnJvciggb3B0aW9uYWxEYXRhICk7XHJcblx0dmFyIGVycm9yID0gbmV3IEVycm9yKCBtZXNzYWdlICk7XHJcblx0ZXJyb3Iub3B0aW9uYWxEYXRhID0gb3B0aW9uYWxEYXRhO1xyXG5cdHRocm93IGVycm9yO1xyXG59O1xyXG5cclxuVEhSRUUuQ29uc29sZUVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKCBtZXNzYWdlLCBvcHRpb25hbERhdGEgKSB7XHJcblx0Y29uc29sZS5lcnJvciggbWVzc2FnZSApO1xyXG5cdGNvbnNvbGUuZXJyb3IoIG9wdGlvbmFsRGF0YSApO1xyXG59O1xyXG5cclxuVEhSRUUuQ29uc29sZVdhcm5pbmdIYW5kbGVyID0gZnVuY3Rpb24oIG1lc3NhZ2UsIG9wdGlvbmFsRGF0YSApIHtcclxuXHRjb25zb2xlLndhcm4oIG1lc3NhZ2UgKTtcclxuXHRjb25zb2xlLndhcm4oIG9wdGlvbmFsRGF0YSApO1xyXG59O1xyXG5cclxuVEhSRUUuTnVsbEhhbmRsZXIgPSBmdW5jdGlvbiggbWVzc2FnZSwgb3B0aW9uYWxEYXRhICkge1xyXG59O1xyXG5cclxuLy8gdGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBpcyBleGNlcHRpb25cclxuVEhSRUUub25lcnJvciA9IFRIUkVFLkV4Y2VwdGlvbkVycm9ySGFuZGxlcjtcclxuXHJcblRIUkVFLm9ud2FybmluZyA9IFRIUkVFLkNvbnNvbGVXYXJuaW5nSGFuZGxlcjtcclxuXHJcbi8vIEdMIFNUQVRFIENPTlNUQU5UU1xyXG5cclxuVEhSRUUuQ3VsbEZhY2VOb25lID0gMDtcclxuVEhSRUUuQ3VsbEZhY2VCYWNrID0gMTtcclxuVEhSRUUuQ3VsbEZhY2VGcm9udCA9IDI7XHJcblRIUkVFLkN1bGxGYWNlRnJvbnRCYWNrID0gMztcclxuXHJcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcclxuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gMTtcclxuXHJcbi8vIFNIQURPV0lORyBUWVBFU1xyXG5cclxuVEhSRUUuQmFzaWNTaGFkb3dNYXAgPSAwO1xyXG5USFJFRS5QQ0ZTaGFkb3dNYXAgPSAxO1xyXG5USFJFRS5QQ0ZTb2Z0U2hhZG93TWFwID0gMjtcclxuXHJcbi8vIE1BVEVSSUFMIENPTlNUQU5UU1xyXG5cclxuLy8gc2lkZVxyXG5cclxuVEhSRUUuRnJvbnRTaWRlID0gMDtcclxuVEhSRUUuQmFja1NpZGUgPSAxO1xyXG5USFJFRS5Eb3VibGVTaWRlID0gMjtcclxuXHJcbi8vIHNoYWRpbmdcclxuXHJcblRIUkVFLk5vU2hhZGluZyA9IDA7XHJcblRIUkVFLkZsYXRTaGFkaW5nID0gMTtcclxuVEhSRUUuU21vb3RoU2hhZGluZyA9IDI7XHJcblxyXG4vLyBjb2xvcnNcclxuXHJcblRIUkVFLk5vQ29sb3JzID0gMDtcclxuVEhSRUUuRmFjZUNvbG9ycyA9IDE7XHJcblRIUkVFLlZlcnRleENvbG9ycyA9IDI7XHJcblxyXG4vLyBibGVuZGluZyBtb2Rlc1xyXG5cclxuVEhSRUUuTm9CbGVuZGluZyA9IDA7XHJcblRIUkVFLk5vcm1hbEJsZW5kaW5nID0gMTtcclxuVEhSRUUuQWRkaXRpdmVCbGVuZGluZyA9IDI7XHJcblRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xyXG5USFJFRS5NdWx0aXBseUJsZW5kaW5nID0gNDtcclxuVEhSRUUuQ3VzdG9tQmxlbmRpbmcgPSA1O1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIGVxdWF0aW9uc1xyXG4vLyAobnVtYmVycyBzdGFydCBmcm9tIDEwMCBub3QgdG8gY2xhc2ggd2l0aCBvdGhlclxyXG4vLyAgbWFwcGluZ3MgdG8gT3BlbkdMIGNvbnN0YW50cyBkZWZpbmVkIGluIFRleHR1cmUuanMpXHJcblxyXG5USFJFRS5BZGRFcXVhdGlvbiA9IDEwMDtcclxuVEhSRUUuU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcclxuVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XHJcblxyXG4vLyBjdXN0b20gYmxlbmRpbmcgZGVzdGluYXRpb24gZmFjdG9yc1xyXG5cclxuVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcclxuVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG5USFJFRS5TcmNDb2xvckZhY3RvciA9IDIwMjtcclxuVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcclxuVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XHJcblRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcblRIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xyXG5USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIHNvdXJjZSBmYWN0b3JzXHJcblxyXG4vL1RIUkVFLlplcm9GYWN0b3IgPSAyMDA7XHJcbi8vVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG4vL1RIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xyXG4vL1RIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcbi8vVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XHJcbi8vVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcclxuVEhSRUUuRHN0Q29sb3JGYWN0b3IgPSAyMDg7XHJcblRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XHJcblRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XHJcblxyXG5cclxuLy8gVEVYVFVSRSBDT05TVEFOVFNcclxuXHJcblRIUkVFLk11bHRpcGx5T3BlcmF0aW9uID0gMDtcclxuVEhSRUUuTWl4T3BlcmF0aW9uID0gMTtcclxuVEhSRUUuQWRkT3BlcmF0aW9uID0gMjtcclxuXHJcbi8vIE1hcHBpbmcgbW9kZXNcclxuXHJcblRIUkVFLlVWTWFwcGluZyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XHJcblRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcclxuVEhSRUUuU3BoZXJpY2FsUmVmcmFjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbi8vIFdyYXBwaW5nIG1vZGVzXHJcblxyXG5USFJFRS5SZXBlYXRXcmFwcGluZyA9IDEwMDA7XHJcblRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xyXG5USFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcclxuXHJcbi8vIEZpbHRlcnNcclxuXHJcblRIUkVFLk5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xyXG5USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XHJcblRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xyXG5USFJFRS5MaW5lYXJGaWx0ZXIgPSAxMDA2O1xyXG5USFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcclxuVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcclxuXHJcbi8vIERhdGEgdHlwZXNcclxuXHJcblRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xyXG5USFJFRS5CeXRlVHlwZSA9IDEwMTA7XHJcblRIUkVFLlNob3J0VHlwZSA9IDEwMTE7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcclxuVEhSRUUuSW50VHlwZSA9IDEwMTM7XHJcblRIUkVFLlVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XHJcblRIUkVFLkZsb2F0VHlwZSA9IDEwMTU7XHJcblxyXG4vLyBQaXhlbCB0eXBlc1xyXG5cclxuLy9USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcclxuVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNjtcclxuVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxNztcclxuVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE4O1xyXG5cclxuLy8gUGl4ZWwgZm9ybWF0c1xyXG5cclxuVEhSRUUuQWxwaGFGb3JtYXQgPSAxMDE5O1xyXG5USFJFRS5SR0JGb3JtYXQgPSAxMDIwO1xyXG5USFJFRS5SR0JBRm9ybWF0ID0gMTAyMTtcclxuVEhSRUUuTHVtaW5hbmNlRm9ybWF0ID0gMTAyMjtcclxuVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDIzO1xyXG5cclxuLy8gQ29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcclxuXHJcblRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMTtcclxuVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMjtcclxuVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gMjAwMztcclxuVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMjAwNDtcclxuXHJcbi8qXHJcbi8vIFBvdGVudGlhbCBmdXR1cmUgUFZSVEMgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcclxuVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAwO1xyXG5USFJFRS5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDE7XHJcblRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDI7XHJcblRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDM7XHJcbiovXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Db2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRSR0IoIGFyZ3VtZW50c1sgMCBdLCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcy5zZXQoIGNvbG9yIClcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db2xvci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Db2xvcixcclxuXHJcblx0cjogMSwgZzogMSwgYjogMSxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcclxuXHJcblx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRIZXg6IGZ1bmN0aW9uICggaGV4ICkge1xyXG5cclxuXHRcdGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xyXG5cclxuXHRcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XHJcblx0XHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XHJcblx0XHR0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSR0I6IGZ1bmN0aW9uICggciwgZywgYiApIHtcclxuXHJcblx0XHR0aGlzLnIgPSByO1xyXG5cdFx0dGhpcy5nID0gZztcclxuXHRcdHRoaXMuYiA9IGI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEhTTDogZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuXHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXHJcblxyXG5cdFx0aWYgKCBzID09PSAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gbDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIGh1ZTJyZ2IgPSBmdW5jdGlvbiAoIHAsIHEsIHQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdCA8IDAgKSB0ICs9IDE7XHJcblx0XHRcdFx0aWYgKCB0ID4gMSApIHQgLT0gMTtcclxuXHRcdFx0XHRpZiAoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqIHQ7XHJcblx0XHRcdFx0aWYgKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcclxuXHRcdFx0XHRpZiAoIHQgPCAyIC8gMyApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqICggMiAvIDMgLSB0ICk7XHJcblx0XHRcdFx0cmV0dXJuIHA7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcclxuXHRcdFx0dmFyIHEgPSAoIDIgKiBsICkgLSBwO1xyXG5cclxuXHRcdFx0dGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XHJcblx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcclxuXHRcdFx0dGhpcy5iID0gaHVlMnJnYiggcSwgcCwgaCAtIDEgLyAzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcclxuXHJcblx0XHQvLyByZ2IoMjU1LDAsMClcclxuXHJcblx0XHRpZiAoIC9ecmdiXFwoKFxcZCspLCA/KFxcZCspLCA/KFxcZCspXFwpJC9pLnRlc3QoIHN0eWxlICkgKSB7XHJcblxyXG5cdFx0XHR2YXIgY29sb3IgPSAvXnJnYlxcKChcXGQrKSwgPyhcXGQrKSwgPyhcXGQrKVxcKSQvaS5leGVjKCBzdHlsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZ2IoMTAwJSwwJSwwJSlcclxuXHJcblx0XHRpZiAoIC9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLnRlc3QoIHN0eWxlICkgKSB7XHJcblxyXG5cdFx0XHR2YXIgY29sb3IgPSAvXnJnYlxcKChcXGQrKVxcJSwgPyhcXGQrKVxcJSwgPyhcXGQrKVxcJVxcKSQvaS5leGVjKCBzdHlsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMDtcclxuXHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMDtcclxuXHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyAjZmYwMDAwXHJcblxyXG5cdFx0aWYgKCAvXlxcIyhbMC05YS1mXXs2fSkkL2kudGVzdCggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdHZhciBjb2xvciA9IC9eXFwjKFswLTlhLWZdezZ9KSQvaS5leGVjKCBzdHlsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRIZXgoIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxNiApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gI2YwMFxyXG5cclxuXHRcdGlmICggL15cXCMoWzAtOWEtZl0pKFswLTlhLWZdKShbMC05YS1mXSkkL2kudGVzdCggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdHZhciBjb2xvciA9IC9eXFwjKFswLTlhLWZdKShbMC05YS1mXSkoWzAtOWEtZl0pJC9pLmV4ZWMoIHN0eWxlICk7XHJcblxyXG5cdFx0XHR0aGlzLnNldEhleCggcGFyc2VJbnQoIGNvbG9yWyAxIF0gKyBjb2xvclsgMSBdICsgY29sb3JbIDIgXSArIGNvbG9yWyAyIF0gKyBjb2xvclsgMyBdICsgY29sb3JbIDMgXSwgMTYgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlZFxyXG5cclxuXHRcdGlmICggL14oXFx3KykkL2kudGVzdCggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0SGV4KCBUSFJFRS5Db2xvcktleXdvcmRzWyBzdHlsZSBdICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iID0gY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gY29sb3IuciAqIGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgPSBjb2xvci5nICogY29sb3IuZztcclxuXHRcdHRoaXMuYiA9IGNvbG9yLmIgKiBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIGNvbG9yLnIgKTtcclxuXHRcdHRoaXMuZyA9IE1hdGguc3FydCggY29sb3IuZyApO1xyXG5cdFx0dGhpcy5iID0gTWF0aC5zcXJ0KCBjb2xvci5iICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XHJcblxyXG5cdFx0dGhpcy5yID0gciAqIHI7XHJcblx0XHR0aGlzLmcgPSBnICogZztcclxuXHRcdHRoaXMuYiA9IGIgKiBiO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuciA9IE1hdGguc3FydCggdGhpcy5yICk7XHJcblx0XHR0aGlzLmcgPSBNYXRoLnNxcnQoIHRoaXMuZyApO1xyXG5cdFx0dGhpcy5iID0gTWF0aC5zcXJ0KCB0aGlzLmIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SGV4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5yICogMjU1ICkgPDwgMTYgXiAoIHRoaXMuZyAqIDI1NSApIDw8IDggXiAoIHRoaXMuYiAqIDI1NSApIDw8IDA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhleFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SFNMOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXHJcblxyXG5cdFx0dmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xyXG5cclxuXHRcdHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xyXG5cclxuXHRcdHZhciBtYXggPSBNYXRoLm1heCggciwgZywgYiApO1xyXG5cdFx0dmFyIG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XHJcblxyXG5cdFx0dmFyIGh1ZSwgc2F0dXJhdGlvbjtcclxuXHRcdHZhciBsaWdodG5lc3MgPSAoIG1pbiArIG1heCApIC8gMi4wO1xyXG5cclxuXHRcdGlmICggbWluID09PSBtYXggKSB7XHJcblxyXG5cdFx0XHRodWUgPSAwO1xyXG5cdFx0XHRzYXR1cmF0aW9uID0gMDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIGRlbHRhID0gbWF4IC0gbWluO1xyXG5cclxuXHRcdFx0c2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvICggbWF4ICsgbWluICkgOiBkZWx0YSAvICggMiAtIG1heCAtIG1pbiApO1xyXG5cclxuXHRcdFx0c3dpdGNoICggbWF4ICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIHI6IGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgZzogaHVlID0gKCBiIC0gciApIC8gZGVsdGEgKyAyOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIGI6IGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDsgYnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRodWUgLz0gNjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aHNsLmggPSBodWU7XHJcblx0XHRoc2wucyA9IHNhdHVyYXRpb247XHJcblx0XHRoc2wubCA9IGxpZ2h0bmVzcztcclxuXHJcblx0XHRyZXR1cm4gaHNsO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9mZnNldEhTTDogZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuXHRcdHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xyXG5cclxuXHRcdGhzbC5oICs9IGg7IGhzbC5zICs9IHM7IGhzbC5sICs9IGw7XHJcblxyXG5cdFx0dGhpcy5zZXRIU0woIGhzbC5oLCBoc2wucywgaHNsLmwgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciArPSBjb2xvci5yO1xyXG5cdFx0dGhpcy5nICs9IGNvbG9yLmc7XHJcblx0XHR0aGlzLmIgKz0gY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGNvbG9yMS5yICsgY29sb3IyLnI7XHJcblx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xyXG5cdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy5yICs9IHM7XHJcblx0XHR0aGlzLmcgKz0gcztcclxuXHRcdHRoaXMuYiArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgKj0gY29sb3IucjtcclxuXHRcdHRoaXMuZyAqPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iICo9IGNvbG9yLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy5yICo9IHM7XHJcblx0XHR0aGlzLmcgKj0gcztcclxuXHRcdHRoaXMuYiAqPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcclxuXHRcdHRoaXMuZyArPSAoIGNvbG9yLmcgLSB0aGlzLmcgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy5iICs9ICggY29sb3IuYiAtIHRoaXMuYiApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBjICkge1xyXG5cclxuXHRcdHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGFycmF5WyAwIF07XHJcblx0XHR0aGlzLmcgPSBhcnJheVsgMSBdO1xyXG5cdFx0dGhpcy5iID0gYXJyYXlbIDIgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBbIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgXTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkNvbG9yKCkuc2V0UkdCKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Db2xvcktleXdvcmRzID0geyBcImFsaWNlYmx1ZVwiOiAweEYwRjhGRiwgXCJhbnRpcXVld2hpdGVcIjogMHhGQUVCRDcsIFwiYXF1YVwiOiAweDAwRkZGRiwgXCJhcXVhbWFyaW5lXCI6IDB4N0ZGRkQ0LCBcImF6dXJlXCI6IDB4RjBGRkZGLFxyXG5cImJlaWdlXCI6IDB4RjVGNURDLCBcImJpc3F1ZVwiOiAweEZGRTRDNCwgXCJibGFja1wiOiAweDAwMDAwMCwgXCJibGFuY2hlZGFsbW9uZFwiOiAweEZGRUJDRCwgXCJibHVlXCI6IDB4MDAwMEZGLCBcImJsdWV2aW9sZXRcIjogMHg4QTJCRTIsXHJcblwiYnJvd25cIjogMHhBNTJBMkEsIFwiYnVybHl3b29kXCI6IDB4REVCODg3LCBcImNhZGV0Ymx1ZVwiOiAweDVGOUVBMCwgXCJjaGFydHJldXNlXCI6IDB4N0ZGRjAwLCBcImNob2NvbGF0ZVwiOiAweEQyNjkxRSwgXCJjb3JhbFwiOiAweEZGN0Y1MCxcclxuXCJjb3JuZmxvd2VyYmx1ZVwiOiAweDY0OTVFRCwgXCJjb3Juc2lsa1wiOiAweEZGRjhEQywgXCJjcmltc29uXCI6IDB4REMxNDNDLCBcImN5YW5cIjogMHgwMEZGRkYsIFwiZGFya2JsdWVcIjogMHgwMDAwOEIsIFwiZGFya2N5YW5cIjogMHgwMDhCOEIsXHJcblwiZGFya2dvbGRlbnJvZFwiOiAweEI4ODYwQiwgXCJkYXJrZ3JheVwiOiAweEE5QTlBOSwgXCJkYXJrZ3JlZW5cIjogMHgwMDY0MDAsIFwiZGFya2dyZXlcIjogMHhBOUE5QTksIFwiZGFya2toYWtpXCI6IDB4QkRCNzZCLCBcImRhcmttYWdlbnRhXCI6IDB4OEIwMDhCLFxyXG5cImRhcmtvbGl2ZWdyZWVuXCI6IDB4NTU2QjJGLCBcImRhcmtvcmFuZ2VcIjogMHhGRjhDMDAsIFwiZGFya29yY2hpZFwiOiAweDk5MzJDQywgXCJkYXJrcmVkXCI6IDB4OEIwMDAwLCBcImRhcmtzYWxtb25cIjogMHhFOTk2N0EsIFwiZGFya3NlYWdyZWVuXCI6IDB4OEZCQzhGLFxyXG5cImRhcmtzbGF0ZWJsdWVcIjogMHg0ODNEOEIsIFwiZGFya3NsYXRlZ3JheVwiOiAweDJGNEY0RiwgXCJkYXJrc2xhdGVncmV5XCI6IDB4MkY0RjRGLCBcImRhcmt0dXJxdW9pc2VcIjogMHgwMENFRDEsIFwiZGFya3Zpb2xldFwiOiAweDk0MDBEMyxcclxuXCJkZWVwcGlua1wiOiAweEZGMTQ5MywgXCJkZWVwc2t5Ymx1ZVwiOiAweDAwQkZGRiwgXCJkaW1ncmF5XCI6IDB4Njk2OTY5LCBcImRpbWdyZXlcIjogMHg2OTY5NjksIFwiZG9kZ2VyYmx1ZVwiOiAweDFFOTBGRiwgXCJmaXJlYnJpY2tcIjogMHhCMjIyMjIsXHJcblwiZmxvcmFsd2hpdGVcIjogMHhGRkZBRjAsIFwiZm9yZXN0Z3JlZW5cIjogMHgyMjhCMjIsIFwiZnVjaHNpYVwiOiAweEZGMDBGRiwgXCJnYWluc2Jvcm9cIjogMHhEQ0RDREMsIFwiZ2hvc3R3aGl0ZVwiOiAweEY4RjhGRiwgXCJnb2xkXCI6IDB4RkZENzAwLFxyXG5cImdvbGRlbnJvZFwiOiAweERBQTUyMCwgXCJncmF5XCI6IDB4ODA4MDgwLCBcImdyZWVuXCI6IDB4MDA4MDAwLCBcImdyZWVueWVsbG93XCI6IDB4QURGRjJGLCBcImdyZXlcIjogMHg4MDgwODAsIFwiaG9uZXlkZXdcIjogMHhGMEZGRjAsIFwiaG90cGlua1wiOiAweEZGNjlCNCxcclxuXCJpbmRpYW5yZWRcIjogMHhDRDVDNUMsIFwiaW5kaWdvXCI6IDB4NEIwMDgyLCBcIml2b3J5XCI6IDB4RkZGRkYwLCBcImtoYWtpXCI6IDB4RjBFNjhDLCBcImxhdmVuZGVyXCI6IDB4RTZFNkZBLCBcImxhdmVuZGVyYmx1c2hcIjogMHhGRkYwRjUsIFwibGF3bmdyZWVuXCI6IDB4N0NGQzAwLFxyXG5cImxlbW9uY2hpZmZvblwiOiAweEZGRkFDRCwgXCJsaWdodGJsdWVcIjogMHhBREQ4RTYsIFwibGlnaHRjb3JhbFwiOiAweEYwODA4MCwgXCJsaWdodGN5YW5cIjogMHhFMEZGRkYsIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogMHhGQUZBRDIsIFwibGlnaHRncmF5XCI6IDB4RDNEM0QzLFxyXG5cImxpZ2h0Z3JlZW5cIjogMHg5MEVFOTAsIFwibGlnaHRncmV5XCI6IDB4RDNEM0QzLCBcImxpZ2h0cGlua1wiOiAweEZGQjZDMSwgXCJsaWdodHNhbG1vblwiOiAweEZGQTA3QSwgXCJsaWdodHNlYWdyZWVuXCI6IDB4MjBCMkFBLCBcImxpZ2h0c2t5Ymx1ZVwiOiAweDg3Q0VGQSxcclxuXCJsaWdodHNsYXRlZ3JheVwiOiAweDc3ODg5OSwgXCJsaWdodHNsYXRlZ3JleVwiOiAweDc3ODg5OSwgXCJsaWdodHN0ZWVsYmx1ZVwiOiAweEIwQzRERSwgXCJsaWdodHllbGxvd1wiOiAweEZGRkZFMCwgXCJsaW1lXCI6IDB4MDBGRjAwLCBcImxpbWVncmVlblwiOiAweDMyQ0QzMixcclxuXCJsaW5lblwiOiAweEZBRjBFNiwgXCJtYWdlbnRhXCI6IDB4RkYwMEZGLCBcIm1hcm9vblwiOiAweDgwMDAwMCwgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IDB4NjZDREFBLCBcIm1lZGl1bWJsdWVcIjogMHgwMDAwQ0QsIFwibWVkaXVtb3JjaGlkXCI6IDB4QkE1NUQzLFxyXG5cIm1lZGl1bXB1cnBsZVwiOiAweDkzNzBEQiwgXCJtZWRpdW1zZWFncmVlblwiOiAweDNDQjM3MSwgXCJtZWRpdW1zbGF0ZWJsdWVcIjogMHg3QjY4RUUsIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogMHgwMEZBOUEsIFwibWVkaXVtdHVycXVvaXNlXCI6IDB4NDhEMUNDLFxyXG5cIm1lZGl1bXZpb2xldHJlZFwiOiAweEM3MTU4NSwgXCJtaWRuaWdodGJsdWVcIjogMHgxOTE5NzAsIFwibWludGNyZWFtXCI6IDB4RjVGRkZBLCBcIm1pc3R5cm9zZVwiOiAweEZGRTRFMSwgXCJtb2NjYXNpblwiOiAweEZGRTRCNSwgXCJuYXZham93aGl0ZVwiOiAweEZGREVBRCxcclxuXCJuYXZ5XCI6IDB4MDAwMDgwLCBcIm9sZGxhY2VcIjogMHhGREY1RTYsIFwib2xpdmVcIjogMHg4MDgwMDAsIFwib2xpdmVkcmFiXCI6IDB4NkI4RTIzLCBcIm9yYW5nZVwiOiAweEZGQTUwMCwgXCJvcmFuZ2VyZWRcIjogMHhGRjQ1MDAsIFwib3JjaGlkXCI6IDB4REE3MEQ2LFxyXG5cInBhbGVnb2xkZW5yb2RcIjogMHhFRUU4QUEsIFwicGFsZWdyZWVuXCI6IDB4OThGQjk4LCBcInBhbGV0dXJxdW9pc2VcIjogMHhBRkVFRUUsIFwicGFsZXZpb2xldHJlZFwiOiAweERCNzA5MywgXCJwYXBheWF3aGlwXCI6IDB4RkZFRkQ1LCBcInBlYWNocHVmZlwiOiAweEZGREFCOSxcclxuXCJwZXJ1XCI6IDB4Q0Q4NTNGLCBcInBpbmtcIjogMHhGRkMwQ0IsIFwicGx1bVwiOiAweEREQTBERCwgXCJwb3dkZXJibHVlXCI6IDB4QjBFMEU2LCBcInB1cnBsZVwiOiAweDgwMDA4MCwgXCJyZWRcIjogMHhGRjAwMDAsIFwicm9zeWJyb3duXCI6IDB4QkM4RjhGLFxyXG5cInJveWFsYmx1ZVwiOiAweDQxNjlFMSwgXCJzYWRkbGVicm93blwiOiAweDhCNDUxMywgXCJzYWxtb25cIjogMHhGQTgwNzIsIFwic2FuZHlicm93blwiOiAweEY0QTQ2MCwgXCJzZWFncmVlblwiOiAweDJFOEI1NywgXCJzZWFzaGVsbFwiOiAweEZGRjVFRSxcclxuXCJzaWVubmFcIjogMHhBMDUyMkQsIFwic2lsdmVyXCI6IDB4QzBDMEMwLCBcInNreWJsdWVcIjogMHg4N0NFRUIsIFwic2xhdGVibHVlXCI6IDB4NkE1QUNELCBcInNsYXRlZ3JheVwiOiAweDcwODA5MCwgXCJzbGF0ZWdyZXlcIjogMHg3MDgwOTAsIFwic25vd1wiOiAweEZGRkFGQSxcclxuXCJzcHJpbmdncmVlblwiOiAweDAwRkY3RiwgXCJzdGVlbGJsdWVcIjogMHg0NjgyQjQsIFwidGFuXCI6IDB4RDJCNDhDLCBcInRlYWxcIjogMHgwMDgwODAsIFwidGhpc3RsZVwiOiAweEQ4QkZEOCwgXCJ0b21hdG9cIjogMHhGRjYzNDcsIFwidHVycXVvaXNlXCI6IDB4NDBFMEQwLFxyXG5cInZpb2xldFwiOiAweEVFODJFRSwgXCJ3aGVhdFwiOiAweEY1REVCMywgXCJ3aGl0ZVwiOiAweEZGRkZGRiwgXCJ3aGl0ZXNtb2tlXCI6IDB4RjVGNUY1LCBcInllbGxvd1wiOiAweEZGRkYwMCwgXCJ5ZWxsb3dncmVlblwiOiAweDlBQ0QzMiB9O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICovXHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHR0aGlzLl94ID0geCB8fCAwO1xyXG5cdHRoaXMuX3kgPSB5IHx8IDA7XHJcblx0dGhpcy5feiA9IHogfHwgMDtcclxuXHR0aGlzLl93ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb24ucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbixcclxuXHJcblx0X3g6IDAsX3k6IDAsIF96OiAwLCBfdzogMCxcclxuXHJcblx0X2V1bGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdF91cGRhdGVFdWxlcjogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2V1bGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9ldWxlci5zZXRGcm9tUXVhdGVybmlvbiggdGhpcywgdW5kZWZpbmVkLCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHggKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl94O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgeCAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZUV1bGVyKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB5ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHkgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVFdWxlcigpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgeiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3o7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB6ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feiA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRXVsZXIoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHcgKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl93O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgdyAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3cgPSB2YWx1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZUV1bGVyKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0dGhpcy5feSA9IHk7XHJcblx0XHR0aGlzLl96ID0gejtcclxuXHRcdHRoaXMuX3cgPSB3O1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUV1bGVyKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gcXVhdGVybmlvbi5feDtcclxuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLl95O1xyXG5cdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uX3o7XHJcblx0XHR0aGlzLl93ID0gcXVhdGVybmlvbi5fdztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVFdWxlcigpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcclxuXHJcblx0XHRpZiAoICEgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyICkgKSByZXR1cm4gVEhSRUUub25lcnJvciggJ2V4cGVjdGluZyBhIEV1bGVyJywgZXVsZXIgKTtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xyXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuXHRcdHZhciBjMSA9IE1hdGguY29zKCBldWxlci5feCAvIDIgKTtcclxuXHRcdHZhciBjMiA9IE1hdGguY29zKCBldWxlci5feSAvIDIgKTtcclxuXHRcdHZhciBjMyA9IE1hdGguY29zKCBldWxlci5feiAvIDIgKTtcclxuXHRcdHZhciBzMSA9IE1hdGguc2luKCBldWxlci5feCAvIDIgKTtcclxuXHRcdHZhciBzMiA9IE1hdGguc2luKCBldWxlci5feSAvIDIgKTtcclxuXHRcdHZhciBzMyA9IE1hdGguc2luKCBldWxlci5feiAvIDIgKTtcclxuXHJcblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLl91cGRhdGVFdWxlcigpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxyXG5cdFx0Ly8gYXhpcyBoYXZlIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xyXG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XHJcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcclxuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRXVsZXIoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0aWYgKCAhICggbSBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgKSApIHJldHVybiBUSFJFRS5vbmVycm9yKCAnZXhwZWN0aW5nIGEgTWF0cml4NCcsIG0gKTtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxyXG5cclxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHRcclxuXHJcblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbMF0sIG0xMiA9IHRlWzRdLCBtMTMgPSB0ZVs4XSxcclxuXHRcdFx0bTIxID0gdGVbMV0sIG0yMiA9IHRlWzVdLCBtMjMgPSB0ZVs5XSxcclxuXHRcdFx0bTMxID0gdGVbMl0sIG0zMiA9IHRlWzZdLCBtMzMgPSB0ZVsxMF0sXHJcblxyXG5cdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcclxuXHRcdFx0cztcclxuXHJcblx0XHRpZiAoIHRyYWNlID4gMCApIHtcclxuXHJcblx0XHRcdHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcclxuXHRcdFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9IChtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcclxuXHRcdFx0dGhpcy5feSA9IChtMTIgKyBtMjEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAobTEzICsgbTMxICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9IChtMTMgLSBtMzEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAobTEyICsgbTIxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAobTIzICsgbTMyICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRXVsZXIoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aW52ZXJzZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29uanVnYXRlKCkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblx0XHJcblx0YWRkOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0dGhpcy5feCArPSBxLl94O1xyXG5cdFx0dGhpcy5feSArPSBxLl95O1xyXG5cdFx0dGhpcy5feiArPSBxLl96O1xyXG5cdFx0dGhpcy5fdyArPSBxLl93O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWI6IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHR0aGlzLl94IC09IHEuX3g7XHJcblx0XHR0aGlzLl95IC09IHEuX3k7XHJcblx0XHR0aGlzLl96IC09IHEuX3o7XHJcblx0XHR0aGlzLl93IC09IHEuX3c7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy5feCAqPSBzO1xyXG5cdFx0dGhpcy5feSAqPSBzO1xyXG5cdFx0dGhpcy5feiAqPSBzO1xyXG5cdFx0dGhpcy5fdyAqPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl94ICo9IC0xO1xyXG5cdFx0dGhpcy5feSAqPSAtMTtcclxuXHRcdHRoaXMuX3ogKj0gLTE7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRXVsZXIoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRpZiAoIGwgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gMDtcclxuXHRcdFx0dGhpcy5feSA9IDA7XHJcblx0XHRcdHRoaXMuX3ogPSAwO1xyXG5cdFx0XHR0aGlzLl93ID0gMTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bCA9IDEgLyBsO1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xyXG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XHJcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcclxuXHRcdFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcclxuXHJcblx0XHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFRIUkVFLm9ud2FybmluZyggJ0RFUFJFQ0FURUQ6IFF1YXRlcm5pb25cXCdzIC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cclxuXHJcblx0XHR2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcclxuXHRcdHZhciBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xyXG5cclxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XHJcblx0XHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xyXG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcclxuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRXVsZXIoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoICdERVBSRUNBVEVEOiBRdWF0ZXJuaW9uXFwncyAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cclxuXHJcblx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAtcWIuX3c7XHJcblx0XHRcdHRoaXMuX3ggPSAtcWIuX3g7XHJcblx0XHRcdHRoaXMuX3kgPSAtcWIuX3k7XHJcblx0XHRcdHRoaXMuX3ogPSAtcWIuX3o7XHJcblxyXG5cdFx0XHRjb3NIYWxmVGhldGEgPSAtY29zSGFsZlRoZXRhO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSB3O1xyXG5cdFx0XHR0aGlzLl94ID0geDtcclxuXHRcdFx0dGhpcy5feSA9IHk7XHJcblx0XHRcdHRoaXMuX3ogPSB6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYWxmVGhldGEgPSBNYXRoLmFjb3MoIGNvc0hhbGZUaGV0YSApO1xyXG5cdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XHJcblxyXG5cdFx0aWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XHJcblx0XHRcdHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XHJcblx0XHRcdHRoaXMuX3kgPSAwLjUgKiAoIHkgKyB0aGlzLl95ICk7XHJcblx0XHRcdHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcclxuXHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XHJcblxyXG5cdFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcclxuXHRcdHRoaXMuX3ggPSAoIHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVFdWxlcigpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcclxuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xyXG5cdFx0dGhpcy5feiA9IGFycmF5WyAyIF07XHJcblx0XHR0aGlzLl93ID0gYXJyYXlbIDMgXTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVFdWxlcigpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIFsgdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuUXVhdGVybmlvbiggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbi5zbGVycCA9IGZ1bmN0aW9uICggcWEsIHFiLCBxbSwgdCApIHtcclxuXHJcblx0cmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjIgPSBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IyLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHJcblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIFRIUkVFLm9uZXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBUSFJFRS5vbmVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2Lng7XHJcblx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0VEhSRUUub253YXJuaW5nKCAnREVQUkVDQVRFRDogVmVjdG9yMlxcJ3MgLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5vbndhcm5pbmcoICdERVBSRUNBVEVEOiBWZWN0b3IyXFwncyAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSBzO1xyXG5cdFx0dGhpcy55ICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0aWYgKCBzY2FsYXIgIT09IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcclxuXHJcblx0XHRcdHRoaXMueCAqPSBpbnZTY2FsYXI7XHJcblx0XHRcdHRoaXMueSAqPSBpbnZTY2FsYXI7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IDA7XHJcblx0XHRcdHRoaXMueSA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA+IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPiB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxyXG5cclxuXHRcdGlmICggdGhpcy54IDwgbWluLnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBtaW4ueDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IG1heC54O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueSA8IG1pbi55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gbWluLnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSBtYXgueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Y2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcclxuXHJcblx0XHR9O1xyXG5cdFx0XHJcblx0fSApKCksXHJcblxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIC0gMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xyXG5cclxuXHRcdHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcclxuXHJcblx0XHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgMCBdO1xyXG5cdFx0dGhpcy55ID0gYXJyYXlbIDEgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0aGlzLngsIHRoaXMueSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjMgPSBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0dGhpcy56ID0geiB8fCAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yMyxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIFRIUkVFLm9uZXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIFRIUkVFLm9uZXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHRcdHRoaXMueiA9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5vbndhcm5pbmcoICdERVBSRUNBVEVEOiBWZWN0b3IzXFwncyAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHR0aGlzLnkgKz0gdi55O1xyXG5cdFx0dGhpcy56ICs9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHRcdHRoaXMueiArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xyXG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xyXG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFRIUkVFLm9ud2FybmluZ24oICdERVBSRUNBVEVEOiBWZWN0b3IzXFwncyAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cdFx0dGhpcy56IC09IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFRIUkVFLm9ud2FybmluZyggJ0RFUFJFQ0FURUQ6IFZlY3RvcjNcXCdzIC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ICo9IHYueDtcclxuXHRcdHRoaXMueSAqPSB2Lnk7XHJcblx0XHR0aGlzLnogKj0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMueSAqPSBzY2FsYXI7XHJcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKiBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogKiBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5RXVsZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcXVhdGVybmlvbjtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHRcdGlmICggISAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgKSApIHJldHVybiBUSFJFRS5vbmVycm9yKCAnZXhwZWN0aW5nIGFuIEV1bGVyJywgZXVsZXIgKTtcclxuXHJcblx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcXVhdGVybmlvbjtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdGlmICggISAoIG0gaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXgzICkgKSByZXR1cm4gVEhSRUUub25lcnJvciggJ2V4cGVjdGluZyBhbiBNYXRyaXgzJywgbSApO1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnk7XHJcblx0XHR2YXIgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzNdICogeSArIGVbNl0gKiB6O1xyXG5cdFx0dGhpcy55ID0gZVsxXSAqIHggKyBlWzRdICogeSArIGVbN10gKiB6O1xyXG5cdFx0dGhpcy56ID0gZVsyXSAqIHggKyBlWzVdICogeSArIGVbOF0gKiB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XHJcblx0XHRpZiAoICEgKCBtIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCApICkgcmV0dXJuIFRIUkVFLm9uZXJyb3IoICdleHBlY3RpbmcgYW4gTWF0cml4NCcsIG0gKTtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gICogeiArIGVbMTJdO1xyXG5cdFx0dGhpcy55ID0gZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gICogeiArIGVbMTNdO1xyXG5cdFx0dGhpcy56ID0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogeiArIGVbMTRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseVByb2plY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBwcm9qZWN0aW9uIG1hdHJpeFxyXG5cdFx0aWYgKCAhICggbSBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgKSApIHJldHVybiBUSFJFRS5vbmVycm9yKCAnZXhwZWN0aW5nIGFuIE1hdHJpeDQnLCBtICk7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGQgPSAxIC8gKCBlWzNdICogeCArIGVbN10gKiB5ICsgZVsxMV0gKiB6ICsgZVsxNV0gKTsgLy8gcGVyc3BlY3RpdmUgZGl2aWRlXHJcblxyXG5cdFx0dGhpcy54ID0gKCBlWzBdICogeCArIGVbNF0gKiB5ICsgZVs4XSAgKiB6ICsgZVsxMl0gKSAqIGQ7XHJcblx0XHR0aGlzLnkgPSAoIGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICAqIHogKyBlWzEzXSApICogZDtcclxuXHRcdHRoaXMueiA9ICggZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogeiArIGVbMTRdICkgKiBkO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueDtcclxuXHRcdHZhciB5ID0gdGhpcy55O1xyXG5cdFx0dmFyIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIHF4ID0gcS54O1xyXG5cdFx0dmFyIHF5ID0gcS55O1xyXG5cdFx0dmFyIHF6ID0gcS56O1xyXG5cdFx0dmFyIHF3ID0gcS53O1xyXG5cclxuXHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXHJcblxyXG5cdFx0dmFyIGl4ID0gIHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcclxuXHRcdHZhciBpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XHJcblx0XHR2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xyXG5cdFx0dmFyIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcclxuXHJcblx0XHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XHJcblxyXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcclxuXHRcdHRoaXMueSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XHJcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XHJcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gICogejtcclxuXHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICAqIHo7XHJcblx0XHR0aGlzLnogPSBlWzJdICogeCArIGVbNl0gKiB5ICsgZVsxMF0gKiB6O1xyXG5cclxuXHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cdFx0dGhpcy56IC89IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRpZiAoIHNjYWxhciAhPT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xyXG5cclxuXHRcdFx0dGhpcy54ICo9IGludlNjYWxhcjtcclxuXHRcdFx0dGhpcy55ICo9IGludlNjYWxhcjtcclxuXHRcdFx0dGhpcy56ICo9IGludlNjYWxhcjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0dGhpcy56ID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy54ID4gdi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gdi54O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueSA+IHYueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IHYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnogPiB2LnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSB2Lno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56IDwgdi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gbWluLng7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IG1pbi55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gbWF4Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56IDwgbWluLnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSBtaW4uejtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IG1heC56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcclxuXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAtIDEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xyXG5cclxuXHRcdHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0VEhSRUUub253YXJuaW5nKCAnREVQUkVDQVRFRDogVmVjdG9yM1xcJ3MgLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcclxuXHRcdHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xyXG5cdFx0dGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xyXG5cdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XHJcblxyXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XHJcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcclxuXHRcdHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEsIGRvdDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGRvdCA9IHRoaXMuZG90KCB2MSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY29weSggdjEgKS5tdWx0aXBseVNjYWxhciggZG90ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwbGFuZU5vcm1hbCApIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWIoIHYxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9KCksXHJcblxyXG5cdHJlZmxlY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcclxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbm9ybWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9KCksXHJcblxyXG5cdGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCB0aGlzLmxlbmd0aCgpICogdi5sZW5ndGgoKSApO1xyXG5cclxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGhldGEsIC0xLCAxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueDtcclxuXHRcdHZhciBkeSA9IHRoaXMueSAtIHYueTtcclxuXHRcdHZhciBkeiA9IHRoaXMueiAtIHYuejtcclxuXHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciApIHtcclxuXHJcblx0XHRUSFJFRS5vbmVycm9yKCBcIlJFTU9WRUQ6IFZlY3RvcjNcXCdzIHNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4IGhhcyBiZWVuIHJlbW92ZWQgaW4gZmF2b3Igb2YgRXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCksIHBsZWFzZSB1cGRhdGUgeW91ciBjb2RlLlwiKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxLCBvcmRlciApIHtcclxuXHJcblx0XHRUSFJFRS5vbmVycm9yKCBcIlJFTU9WRUQ6IFZlY3RvcjNcXCdzIHNldEV1bGVyRnJvbVF1YXRlcm5pb246IGhhcyBiZWVuIHJlbW92ZWQgaW4gZmF2b3Igb2YgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSwgcGxlYXNlIHVwZGF0ZSB5b3VyIGNvZGUuXCIpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRQb3NpdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoIFwiREVQUkVDQVRFRDogVmVjdG9yM1xcJ3MgLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZS5cIiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRTY2FsZUZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoIFwiREVQUkVDQVRFRDogVmVjdG9yM1xcJ3MgLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZS5cIiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZSggbSApO1xyXG5cdH0sXHJcblxyXG5cdGdldENvbHVtbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoIFwiREVQUkVDQVRFRDogVmVjdG9yM1xcJ3MgLmdldENvbHVtbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4Q29sdW1uKCkuIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlLlwiICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggaW5kZXgsIG1hdHJpeCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR0aGlzLnggPSBtLmVsZW1lbnRzWyAxMiBdO1xyXG5cdFx0dGhpcy55ID0gbS5lbGVtZW50c1sgMTMgXTtcclxuXHRcdHRoaXMueiA9IG0uZWxlbWVudHNbIDE0IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyAwIF0sIG0uZWxlbWVudHNbIDEgXSwgbS5lbGVtZW50c1sgIDIgXSApLmxlbmd0aCgpO1xyXG5cdFx0dmFyIHN5ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDQgXSwgbS5lbGVtZW50c1sgNSBdLCBtLmVsZW1lbnRzWyAgNiBdICkubGVuZ3RoKCk7XHJcblx0XHR2YXIgc3ogPSB0aGlzLnNldCggbS5lbGVtZW50c1sgOCBdLCBtLmVsZW1lbnRzWyA5IF0sIG0uZWxlbWVudHNbIDEwIF0gKS5sZW5ndGgoKTtcclxuXHJcblx0XHR0aGlzLnggPSBzeDtcclxuXHRcdHRoaXMueSA9IHN5O1xyXG5cdFx0dGhpcy56ID0gc3o7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU1hdHJpeENvbHVtbjogZnVuY3Rpb24gKCBpbmRleCwgbWF0cml4ICkge1xyXG5cclxuXHRcdHZhciBvZmZzZXQgPSBpbmRleCAqIDQ7XHJcblxyXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IG1lWyBvZmZzZXQgXTtcclxuXHRcdHRoaXMueSA9IG1lWyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLnogPSBtZVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYXJyYXlbIDAgXTtcclxuXHRcdHRoaXMueSA9IGFycmF5WyAxIF07XHJcblx0XHR0aGlzLnogPSBhcnJheVsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMueiBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yNCA9IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0dGhpcy54ID0geCB8fCAwO1xyXG5cdHRoaXMueSA9IHkgfHwgMDtcclxuXHR0aGlzLnogPSB6IHx8IDA7XHJcblx0dGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcjQucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yNCxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblx0XHR0aGlzLnogPSB6O1xyXG5cdFx0dGhpcy53ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XHJcblxyXG5cdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0VzogZnVuY3Rpb24gKCB3ICkge1xyXG5cclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIFRIUkVFLm9uZXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gdGhpcy53O1xyXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gVEhSRUUub25lcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cdFx0dGhpcy56ID0gdi56O1xyXG5cdFx0dGhpcy53ID0gKCB2LncgIT09IHVuZGVmaW5lZCApID8gdi53IDogMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5vbndhcm5pbmcoICdERVBSRUNBVEVEOiBWZWN0b3I0XFwncyAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHR0aGlzLnkgKz0gdi55O1xyXG5cdFx0dGhpcy56ICs9IHYuejtcclxuXHRcdHRoaXMudyArPSB2Lnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblx0XHR0aGlzLnogKz0gcztcclxuXHRcdHRoaXMudyArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xyXG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xyXG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xyXG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFRIUkVFLm9ud2FybmluZyggJ0RFUFJFQ0FURUQ6IFZlY3RvcjRcXCdzIC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54IC09IHYueDtcclxuXHRcdHRoaXMueSAtPSB2Lnk7XHJcblx0XHR0aGlzLnogLT0gdi56O1xyXG5cdFx0dGhpcy53IC09IHYudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcclxuXHRcdHRoaXMudyA9IGEudyAtIGIudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XHJcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xyXG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMudyAqPSBzY2FsYXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdGlmICggISAoIG0gaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0ICkgKSByZXR1cm4gVEhSRUUub25lcnJvciggJ2V4cGVjdGluZyBhIE1hdHJpeDQnLCBtICk7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLng7XHJcblx0XHR2YXIgeSA9IHRoaXMueTtcclxuXHRcdHZhciB6ID0gdGhpcy56O1xyXG5cdFx0dmFyIHcgPSB0aGlzLnc7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbMF0gKiB4ICsgZVs0XSAqIHkgKyBlWzhdICogeiArIGVbMTJdICogdztcclxuXHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICogeiArIGVbMTNdICogdztcclxuXHRcdHRoaXMueiA9IGVbMl0gKiB4ICsgZVs2XSAqIHkgKyBlWzEwXSAqIHogKyBlWzE0XSAqIHc7XHJcblx0XHR0aGlzLncgPSBlWzNdICogeCArIGVbN10gKiB5ICsgZVsxMV0gKiB6ICsgZVsxNV0gKiB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdGlmICggc2NhbGFyICE9PSAwICkge1xyXG5cclxuXHRcdFx0dmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XHJcblxyXG5cdFx0XHR0aGlzLnggKj0gaW52U2NhbGFyO1xyXG5cdFx0XHR0aGlzLnkgKj0gaW52U2NhbGFyO1xyXG5cdFx0XHR0aGlzLnogKj0gaW52U2NhbGFyO1xyXG5cdFx0XHR0aGlzLncgKj0gaW52U2NhbGFyO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHR0aGlzLnogPSAwO1xyXG5cdFx0XHR0aGlzLncgPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcclxuXHJcblx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xyXG5cclxuXHRcdGlmICggcyA8IDAuMDAwMSApIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSAxO1xyXG5cdFx0XHQgdGhpcy55ID0gMDtcclxuXHRcdFx0IHRoaXMueiA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSBxLnggLyBzO1xyXG5cdFx0XHQgdGhpcy55ID0gcS55IC8gcztcclxuXHRcdFx0IHRoaXMueiA9IHEueiAvIHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciBhbmdsZSwgeCwgeSwgeixcdFx0Ly8gdmFyaWFibGVzIGZvciByZXN1bHRcclxuXHRcdFx0ZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXHJcblx0XHRcdGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xyXG5cclxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbMF0sIG0xMiA9IHRlWzRdLCBtMTMgPSB0ZVs4XSxcclxuXHRcdFx0bTIxID0gdGVbMV0sIG0yMiA9IHRlWzVdLCBtMjMgPSB0ZVs5XSxcclxuXHRcdFx0bTMxID0gdGVbMl0sIG0zMiA9IHRlWzZdLCBtMzMgPSB0ZVsxMF07XHJcblxyXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKVxyXG5cdFx0ICAmJiAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKVxyXG5cdFx0ICAmJiAoIE1hdGguYWJzKCBtMjMgLSBtMzIgKSA8IGVwc2lsb24gKSApIHtcclxuXHJcblx0XHRcdC8vIHNpbmd1bGFyaXR5IGZvdW5kXHJcblx0XHRcdC8vIGZpcnN0IGNoZWNrIGZvciBpZGVudGl0eSBtYXRyaXggd2hpY2ggbXVzdCBoYXZlICsxIGZvciBhbGwgdGVybXNcclxuXHRcdFx0Ly8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xyXG5cclxuXHRcdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yIClcclxuXHRcdFx0ICAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yIClcclxuXHRcdFx0ICAmJiAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yIClcclxuXHRcdFx0ICAmJiAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xyXG5cclxuXHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcclxuXHJcblx0XHRcdFx0dGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxyXG5cclxuXHRcdFx0YW5nbGUgPSBNYXRoLlBJO1xyXG5cclxuXHRcdFx0dmFyIHh4ID0gKCBtMTEgKyAxICkgLyAyO1xyXG5cdFx0XHR2YXIgeXkgPSAoIG0yMiArIDEgKSAvIDI7XHJcblx0XHRcdHZhciB6eiA9ICggbTMzICsgMSApIC8gMjtcclxuXHRcdFx0dmFyIHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XHJcblx0XHRcdHZhciB4eiA9ICggbTEzICsgbTMxICkgLyA0O1xyXG5cdFx0XHR2YXIgeXogPSAoIG0yMyArIG0zMiApIC8gNDtcclxuXHJcblx0XHRcdGlmICggKCB4eCA+IHl5ICkgJiYgKCB4eCA+IHp6ICkgKSB7IC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXHJcblxyXG5cdFx0XHRcdGlmICggeHggPCBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0XHRcdHggPSAwO1xyXG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHggPSBNYXRoLnNxcnQoIHh4ICk7XHJcblx0XHRcdFx0XHR5ID0geHkgLyB4O1xyXG5cdFx0XHRcdFx0eiA9IHh6IC8geDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggeXkgPiB6eiApIHsgLy8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcblx0XHRcdFx0aWYgKCB5eSA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eSA9IDA7XHJcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eSA9IE1hdGguc3FydCggeXkgKTtcclxuXHRcdFx0XHRcdHggPSB4eSAvIHk7XHJcblx0XHRcdFx0XHR6ID0geXogLyB5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgeyAvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXHJcblxyXG5cdFx0XHRcdGlmICggenogPCBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHogPSAwO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHogPSBNYXRoLnNxcnQoIHp6ICk7XHJcblx0XHRcdFx0XHR4ID0geHogLyB6O1xyXG5cdFx0XHRcdFx0eSA9IHl6IC8gejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpczsgLy8gcmV0dXJuIDE4MCBkZWcgcm90YXRpb25cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxyXG5cclxuXHRcdHZhciBzID0gTWF0aC5zcXJ0KCAoIG0zMiAtIG0yMyApICogKCBtMzIgLSBtMjMgKVxyXG5cdFx0XHRcdFx0XHQgKyAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKVxyXG5cdFx0XHRcdFx0XHQgKyAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBkaXZpZGUgYnkgemVybywgc2hvdWxkIG5vdCBoYXBwZW4gaWYgbWF0cml4IGlzIG9ydGhvZ29uYWwgYW5kIHNob3VsZCBiZVxyXG5cdFx0Ly8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXHJcblxyXG5cdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcclxuXHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnggPiB2LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSB2Lng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy55ID4gdi55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueiA+IHYueiApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IHYuejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLncgPiB2LncgKSB7XHJcblxyXG5cdFx0XHR0aGlzLncgPSB2Lnc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56IDwgdi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMudyA8IHYudyApIHtcclxuXHJcblx0XHRcdHRoaXMudyA9IHYudztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XHJcblxyXG5cdFx0aWYgKCB0aGlzLnggPCBtaW4ueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IG1pbi54O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gbWF4Lng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy55IDwgbWluLnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSBtaW4ueTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IG1heC55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueiA8IG1pbi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gbWluLno7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy56ID4gbWF4LnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSBtYXguejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLncgPCBtaW4udyApIHtcclxuXHJcblx0XHRcdHRoaXMudyA9IG1pbi53O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMudyA+IG1heC53ICkge1xyXG5cclxuXHRcdFx0dGhpcy53ID0gbWF4Lnc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcFNjYWxhcjogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuXHRcdFx0aWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bWluID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHRcdFx0XHRtYXggPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XHJcblx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG4gICAgZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcbiAgICAgICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XHJcbiAgICAgICAgdGhpcy53ID0gTWF0aC5mbG9vciggdGhpcy53ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XHJcbiAgICAgICAgdGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuICAgICAgICB0aGlzLncgPSBNYXRoLmNlaWwoIHRoaXMudyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG4gICAgICAgIHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xyXG4gICAgICAgIHRoaXMudyA9IE1hdGgucm91bmQoIHRoaXMudyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG4gICAgICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG4gICAgICAgIHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG4gICAgICAgIHRoaXMudyA9ICggdGhpcy53IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLncgKSA6IE1hdGguZmxvb3IoIHRoaXMudyApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggLTEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYueiArIHRoaXMudyAqIHYudztcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKSArIE1hdGguYWJzKCB0aGlzLncgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xyXG5cclxuXHRcdHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcclxuXHJcblx0XHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cdFx0dGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgMCBdO1xyXG5cdFx0dGhpcy55ID0gYXJyYXlbIDEgXTtcclxuXHRcdHRoaXMueiA9IGFycmF5WyAyIF07XHJcblx0XHR0aGlzLncgPSBhcnJheVsgMyBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53IF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3I0KCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuRXVsZXIgPSBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xyXG5cclxuXHR0aGlzLl94ID0geCB8fCAwO1xyXG5cdHRoaXMuX3kgPSB5IHx8IDA7XHJcblx0dGhpcy5feiA9IHogfHwgMDtcclxuXHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IFRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5FdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xyXG5cclxuVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XHJcblxyXG5USFJFRS5FdWxlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5FdWxlcixcclxuXHJcblx0X3g6IDAsIF95OiAwLCBfejogMCwgX29yZGVyOiBUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXIsXHJcblxyXG5cdF9xdWF0ZXJuaW9uOiB1bmRlZmluZWQsXHJcblxyXG5cdF91cGRhdGVRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9xdWF0ZXJuaW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggdGhpcywgZmFsc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB4ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHggKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB5ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHkgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB6ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fejtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHogKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl96ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCBvcmRlciAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgb3JkZXIgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlUXVhdGVybmlvbigpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHg7XHJcblx0XHR0aGlzLl95ID0geTtcclxuXHRcdHRoaXMuX3ogPSB6O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21WZWN0b3I6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHYueDtcclxuXHRcdHRoaXMuX3kgPSB2Lnk7XHJcblx0XHR0aGlzLl96ID0gdi56O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IGV1bGVyLl94O1xyXG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xyXG5cdFx0dGhpcy5feiA9IGV1bGVyLl96O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIsIHVwZGF0ZSApIHtcclxuXHJcblx0XHRpZiAoICEgKCBtIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCApICkgcmV0dXJuIFRIUkVFLm9uZXJyb3IoICdleHBlY3RpbmcgYSBNYXRyaXg0JywgbSApO1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcclxuXHJcblx0XHRmdW5jdGlvbiBjbGFtcCggeCApIHtcclxuXHJcblx0XHRcdHJldHVybiBNYXRoLm1pbiggTWF0aC5tYXgoIHgsIC0xICksIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRlID0gbS5lbGVtZW50cztcclxuXHRcdHZhciBtMTEgPSB0ZVswXSwgbTEyID0gdGVbNF0sIG0xMyA9IHRlWzhdO1xyXG5cdFx0dmFyIG0yMSA9IHRlWzFdLCBtMjIgPSB0ZVs1XSwgbTIzID0gdGVbOV07XHJcblx0XHR2YXIgbTMxID0gdGVbMl0sIG0zMiA9IHRlWzZdLCBtMzMgPSB0ZVsxMF07XHJcblxyXG5cdFx0b3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xyXG5cclxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRUSFJFRS5vbndhcm5pbmcoICdXQVJOSU5HOiBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogJyArIG9yZGVyIClcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcclxuXHJcblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbigpIHtcclxuXHJcblx0ICAgdmFyIG1JbnRlcm1lZGlhdGUgPSBudWxsO1xyXG5cdCAgIFxyXG5cdCAgIHJldHVybiBmdW5jdGlvbiggcSwgb3JkZXIsIHVwZGF0ZSApIHtcclxuXHQgICBcclxuXHQgICBcdCAgbUludGVybWVkaWF0ZSA9IG1JbnRlcm1lZGlhdGUgfHwgbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHQgICAgICBtSW50ZXJtZWRpYXRlLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XHJcblx0ICAgICAgdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1JbnRlcm1lZGlhdGUsIG9yZGVyLCB1cGRhdGUgKTtcclxuXHQgICBcclxuXHQgICAgICByZXR1cm4gdGhpcztcclxuXHQgICB9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJlb3JkZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXHJcblxyXG5cdFx0dmFyIHEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG5ld09yZGVyICkge1xyXG5cclxuXHRcdFx0cS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcclxuXHRcdFx0dGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHJcblx0fSgpLFxyXG5cclxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IGFycmF5WyAwIF07XHJcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcclxuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xyXG5cdFx0aWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIFsgdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgXTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcclxuXHJcblx0fSxcclxuXHJcblxyXG5cdHRvVmVjdG9yMzogZnVuY3Rpb24gKCBvcHRpb25hbFJlc3VsdCApIHtcclxuXHJcblx0XHRpZiggb3B0aW9uYWxSZXN1bHQgKSB7XHJcblx0XHRcdHJldHVybiBvcHRpb25hbFJlc3VsdC5zZXQoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkV1bGVyKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkxpbmUzID0gZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xyXG5cclxuXHR0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5lbmQgPSAoIGVuZCAhPT0gdW5kZWZpbmVkICkgPyBlbmQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmUzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkxpbmUzLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcclxuXHJcblx0XHR0aGlzLnN0YXJ0LmNvcHkoIHN0YXJ0ICk7XHJcblx0XHR0aGlzLmVuZC5jb3B5KCBlbmQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBsaW5lICkge1xyXG5cclxuXHRcdHRoaXMuc3RhcnQuY29weSggbGluZS5zdGFydCApO1xyXG5cdFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGVsdGE6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKCB0aGlzLmVuZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcjogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHN0YXJ0UCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgc3RhcnRFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSApIHtcclxuXHJcblx0XHRcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xyXG5cdFx0XHRzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xyXG5cclxuXHRcdFx0dmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcclxuXHRcdFx0dmFyIHN0YXJ0RW5kX3N0YXJ0UCA9IHN0YXJ0RW5kLmRvdCggc3RhcnRQICk7XHJcblxyXG5cdFx0XHR2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcclxuXHJcblx0XHRcdGlmICggY2xhbXBUb0xpbmUgKSB7XHJcblxyXG5cdFx0XHRcdHQgPSBUSFJFRS5NYXRoLmNsYW1wKCB0LCAwLCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIGNsYW1wVG9MaW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmUuc3RhcnQuZXF1YWxzKCB0aGlzLnN0YXJ0ICkgJiYgbGluZS5lbmQuZXF1YWxzKCB0aGlzLmVuZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuTGluZTMoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuQm94MiA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjIoIEluZmluaXR5LCBJbmZpbml0eSApO1xyXG5cdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjIoIC1JbmZpbml0eSwgLUluZmluaXR5ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm94Mi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gyLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgMCBdO1xyXG5cclxuXHRcdFx0dGhpcy5taW4uY29weSggcG9pbnQgKTtcclxuXHRcdFx0dGhpcy5tYXguY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMSwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50ID0gcG9pbnRzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggcG9pbnQueCA8IHRoaXMubWluLnggKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5taW4ueCA9IHBvaW50Lng7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBvaW50LnggPiB0aGlzLm1heC54ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWF4LnggPSBwb2ludC54O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcG9pbnQueSA8IHRoaXMubWluLnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5taW4ueSA9IHBvaW50Lnk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWF4LnkgPSBwb2ludC55O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xyXG5cclxuXHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xyXG5cdFx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSBJbmZpbml0eTtcclxuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLUluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC1zY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XHJcblx0XHQgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxyXG5cdFx0ICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxyXG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LnNldChcclxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxyXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcclxuXHRcdCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cclxuXHJcblx0XHRpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0ICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblx0XHRcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Cb3gyKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5Cb3gzID0gZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMyggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xyXG5cdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjMoIC1JbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3gzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkJveDMsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy5taW4ueCA9IHBvaW50Lng7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcG9pbnQueCA+IHRoaXMubWF4LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1heC54ID0gcG9pbnQueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwb2ludC55IDwgdGhpcy5taW4ueSApIHtcclxuXHJcblx0XHRcdHRoaXMubWluLnkgPSBwb2ludC55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuXHRcdFx0dGhpcy5tYXgueSA9IHBvaW50Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcG9pbnQueiA8IHRoaXMubWluLnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1pbi56ID0gcG9pbnQuejtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdHRoaXMubWF4LnogPSBwb2ludC56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgMCBdO1xyXG5cclxuXHRcdFx0dGhpcy5taW4uY29weSggcG9pbnQgKTtcclxuXHRcdFx0dGhpcy5tYXguY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMSwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkUG9pbnQoIHBvaW50c1sgaSBdIClcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGNlbnRlciwgc2l6ZSApIHtcclxuXHJcblx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XHJcblx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2V0RnJvbU9iamVjdDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcclxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW5zJywgd29ybGQgdHJhbnNmb3Jtc1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdFx0b2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIG5vZGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbm9kZS5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuZ2VvbWV0cnkudmVydGljZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBub2RlLmdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0djEuY29weSggdmVydGljZXNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9IEluZmluaXR5O1xyXG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLUluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xyXG5cdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcclxuXHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC1zY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0ICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxyXG5cdFx0ICAgICBwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XHJcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxyXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXHJcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcclxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXHJcblx0XHQpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXHJcblxyXG5cdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdCAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XHJcblx0XHQgICAgIGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0XHRcdHJlc3VsdC5jZW50ZXIgPSB0aGlzLmNlbnRlcigpO1xyXG5cdFx0XHRyZXN1bHQucmFkaXVzID0gdGhpcy5zaXplKCB2MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IFtcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKVxyXG5cdFx0XTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xyXG5cdFx0XHRwb2ludHNbMF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAwXHJcblx0XHRcdHBvaW50c1sxXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcclxuXHRcdFx0cG9pbnRzWzJdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxyXG5cdFx0XHRwb2ludHNbM10uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDExXHJcblx0XHRcdHBvaW50c1s0XS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcclxuXHRcdFx0cG9pbnRzWzVdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxyXG5cdFx0XHRwb2ludHNbNl0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTEwXHJcblx0XHRcdHBvaW50c1s3XS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAgLy8gMTExXHJcblxyXG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cdFx0XHR0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkJveDMoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XHJcblxyXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xyXG5cclxuXHR0aGlzLnNldChcclxuXHJcblx0XHQoIG4xMSAhPT0gdW5kZWZpbmVkICkgPyBuMTEgOiAxLCBuMTIgfHwgMCwgbjEzIHx8IDAsXHJcblx0XHRuMjEgfHwgMCwgKCBuMjIgIT09IHVuZGVmaW5lZCApID8gbjIyIDogMSwgbjIzIHx8IDAsXHJcblx0XHRuMzEgfHwgMCwgbjMyIHx8IDAsICggbjMzICE9PSB1bmRlZmluZWQgKSA/IG4zMyA6IDFcclxuXHJcblx0KTtcclxufTtcclxuXHJcblRIUkVFLk1hdHJpeDMucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0cml4MyxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVswXSA9IG4xMTsgdGVbM10gPSBuMTI7IHRlWzZdID0gbjEzO1xyXG5cdFx0dGVbMV0gPSBuMjE7IHRlWzRdID0gbjIyOyB0ZVs3XSA9IG4yMztcclxuXHRcdHRlWzJdID0gbjMxOyB0ZVs1XSA9IG4zMjsgdGVbOF0gPSBuMzM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRtZVswXSwgbWVbM10sIG1lWzZdLFxyXG5cdFx0XHRtZVsxXSwgbWVbNF0sIG1lWzddLFxyXG5cdFx0XHRtZVsyXSwgbWVbNV0sIG1lWzhdXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoICdERVBSRUNBVEVEOiBNYXRyaXgzXFwncyAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDMoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHYxLnggPSBhWyBpIF07XHJcblx0XHRcdFx0djEueSA9IGFbIGkgKyAxIF07XHJcblx0XHRcdFx0djEueiA9IGFbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdHYxLmFwcGx5TWF0cml4Myh0aGlzKTtcclxuXHJcblx0XHRcdFx0YVsgaSBdICAgICA9IHYxLng7XHJcblx0XHRcdFx0YVsgaSArIDEgXSA9IHYxLnk7XHJcblx0XHRcdFx0YVsgaSArIDIgXSA9IHYxLno7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVswXSAqPSBzOyB0ZVszXSAqPSBzOyB0ZVs2XSAqPSBzO1xyXG5cdFx0dGVbMV0gKj0gczsgdGVbNF0gKj0gczsgdGVbN10gKj0gcztcclxuXHRcdHRlWzJdICo9IHM7IHRlWzVdICo9IHM7IHRlWzhdICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgYSA9IHRlWzBdLCBiID0gdGVbMV0sIGMgPSB0ZVsyXSxcclxuXHRcdFx0ZCA9IHRlWzNdLCBlID0gdGVbNF0sIGYgPSB0ZVs1XSxcclxuXHRcdFx0ZyA9IHRlWzZdLCBoID0gdGVbN10sIGkgPSB0ZVs4XTtcclxuXHJcblx0XHRyZXR1cm4gYSplKmkgLSBhKmYqaCAtIGIqZCppICsgYipmKmcgKyBjKmQqaCAtIGMqZSpnO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgZXJyb3JPbkludmVydGlibGUgKSB7XHJcblxyXG5cdFx0aWYgKCAhICggbWF0cml4IGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCApICkgcmV0dXJuIFRIUkVFLm9uZXJyb3IoICdleHBlY3RpbmcgYSBNYXRyaXg0JywgbWF0cml4ICk7XHJcblx0XHQvLyAoIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1tanMvIClcclxuXHJcblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSAgIG1lWzEwXSAqIG1lWzVdIC0gbWVbNl0gKiBtZVs5XTtcclxuXHRcdHRlWyAxIF0gPSAtIG1lWzEwXSAqIG1lWzFdICsgbWVbMl0gKiBtZVs5XTtcclxuXHRcdHRlWyAyIF0gPSAgIG1lWzZdICogbWVbMV0gLSBtZVsyXSAqIG1lWzVdO1xyXG5cdFx0dGVbIDMgXSA9IC0gbWVbMTBdICogbWVbNF0gKyBtZVs2XSAqIG1lWzhdO1xyXG5cdFx0dGVbIDQgXSA9ICAgbWVbMTBdICogbWVbMF0gLSBtZVsyXSAqIG1lWzhdO1xyXG5cdFx0dGVbIDUgXSA9IC0gbWVbNl0gKiBtZVswXSArIG1lWzJdICogbWVbNF07XHJcblx0XHR0ZVsgNiBdID0gICBtZVs5XSAqIG1lWzRdIC0gbWVbNV0gKiBtZVs4XTtcclxuXHRcdHRlWyA3IF0gPSAtIG1lWzldICogbWVbMF0gKyBtZVsxXSAqIG1lWzhdO1xyXG5cdFx0dGVbIDggXSA9ICAgbWVbNV0gKiBtZVswXSAtIG1lWzFdICogbWVbNF07XHJcblxyXG5cdFx0dmFyIGRldCA9IG1lWyAwIF0gKiB0ZVsgMCBdICsgbWVbIDEgXSAqIHRlWyAzIF0gKyBtZVsgMiBdICogdGVbIDYgXTtcclxuXHJcblx0XHQvLyBubyBpbnZlcnNlXHJcblxyXG5cdFx0aWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGVycm9yT25JbnZlcnRpYmxlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gVEhSRUUub25lcnJvciggXCJNYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiLCB0aGlzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmlkZW50aXR5KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMS4wIC8gZGV0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRtcCA9IG1bMV07IG1bMV0gPSBtWzNdOyBtWzNdID0gdG1wO1xyXG5cdFx0dG1wID0gbVsyXTsgbVsyXSA9IG1bNl07IG1bNl0gPSB0bXA7XHJcblx0XHR0bXAgPSBtWzVdOyBtWzVdID0gbVs3XTsgbVs3XSA9IHRtcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0aWYgKCAhICggbSBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgKSApIHJldHVybiBUSFJFRS5vbmVycm9yKCAnZXhwZWN0aW5nIGEgTWF0cml4NCcsIG0gKTtcclxuXHJcblx0XHR0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XHJcblxyXG5cdFx0dmFyIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJbIDAgXSA9IG1bIDAgXTtcclxuXHRcdHJbIDEgXSA9IG1bIDMgXTtcclxuXHRcdHJbIDIgXSA9IG1bIDYgXTtcclxuXHRcdHJbIDMgXSA9IG1bIDEgXTtcclxuXHRcdHJbIDQgXSA9IG1bIDQgXTtcclxuXHRcdHJbIDUgXSA9IG1bIDcgXTtcclxuXHRcdHJbIDYgXSA9IG1bIDIgXTtcclxuXHRcdHJbIDcgXSA9IG1bIDUgXTtcclxuXHRcdHJbIDggXSA9IG1bIDggXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHR0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdLFxyXG5cdFx0XHR0ZVsgMyBdLCB0ZVsgNCBdLCB0ZVsgNSBdLFxyXG5cdFx0XHR0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXHJcblx0XHRdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5NYXRyaXgzKFxyXG5cclxuXHRcdFx0dGVbMF0sIHRlWzNdLCB0ZVs2XSxcclxuXHRcdFx0dGVbMV0sIHRlWzRdLCB0ZVs3XSxcclxuXHRcdFx0dGVbMl0sIHRlWzVdLCB0ZVs4XVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxyXG4gKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblxyXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XHJcblxyXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiApO1xyXG5cclxuXHQvLyBUT0RPOiBpZiBuMTEgaXMgdW5kZWZpbmVkLCB0aGVuIGp1c3Qgc2V0IHRvIGlkZW50aXR5LCBvdGhlcndpc2UgY29weSBhbGwgb3RoZXIgdmFsdWVzIGludG8gbWF0cml4XHJcblx0Ly8gICB3ZSBzaG91bGQgbm90IHN1cHBvcnQgc2VtaSBzcGVjaWZpY2F0aW9uIG9mIE1hdHJpeDQsIGl0IGlzIGp1c3Qgd2VpcmQuXHJcblxyXG5cdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdHRlWzBdID0gKCBuMTEgIT09IHVuZGVmaW5lZCApID8gbjExIDogMTsgdGVbNF0gPSBuMTIgfHwgMDsgdGVbOF0gPSBuMTMgfHwgMDsgdGVbMTJdID0gbjE0IHx8IDA7XHJcblx0dGVbMV0gPSBuMjEgfHwgMDsgdGVbNV0gPSAoIG4yMiAhPT0gdW5kZWZpbmVkICkgPyBuMjIgOiAxOyB0ZVs5XSA9IG4yMyB8fCAwOyB0ZVsxM10gPSBuMjQgfHwgMDtcclxuXHR0ZVsyXSA9IG4zMSB8fCAwOyB0ZVs2XSA9IG4zMiB8fCAwOyB0ZVsxMF0gPSAoIG4zMyAhPT0gdW5kZWZpbmVkICkgPyBuMzMgOiAxOyB0ZVsxNF0gPSBuMzQgfHwgMDtcclxuXHR0ZVszXSA9IG40MSB8fCAwOyB0ZVs3XSA9IG40MiB8fCAwOyB0ZVsxMV0gPSBuNDMgfHwgMDsgdGVbMTVdID0gKCBuNDQgIT09IHVuZGVmaW5lZCApID8gbjQ0IDogMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRyaXg0LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDQsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVswXSA9IG4xMTsgdGVbNF0gPSBuMTI7IHRlWzhdID0gbjEzOyB0ZVsxMl0gPSBuMTQ7XHJcblx0XHR0ZVsxXSA9IG4yMTsgdGVbNV0gPSBuMjI7IHRlWzldID0gbjIzOyB0ZVsxM10gPSBuMjQ7XHJcblx0XHR0ZVsyXSA9IG4zMTsgdGVbNl0gPSBuMzI7IHRlWzEwXSA9IG4zMzsgdGVbMTRdID0gbjM0O1xyXG5cdFx0dGVbM10gPSBuNDE7IHRlWzddID0gbjQyOyB0ZVsxMV0gPSBuNDM7IHRlWzE1XSA9IG40NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDEsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDEsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dGhpcy5lbGVtZW50cy5zZXQoIG0uZWxlbWVudHMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0VEhSRUUub253YXJuaW5nKCAnREVQUkVDQVRFRDogTWF0cml4NFxcJ3MgLmV4dHJhY3RQb3NpdGlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvcHlQb3NpdGlvbigpLicgKTtcclxuXHRcdHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsxMl0gPSBtZVsxMl07XHJcblx0XHR0ZVsxM10gPSBtZVsxM107XHJcblx0XHR0ZVsxNF0gPSBtZVsxNF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4dHJhY3RCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0eEF4aXMuc2V0KCB0ZVswXSwgdGVbMV0sIHRlWzJdICk7XHJcblx0XHR5QXhpcy5zZXQoIHRlWzRdLCB0ZVs1XSwgdGVbNl0gKTtcclxuXHRcdHpBeGlzLnNldCggdGVbOF0sIHRlWzldLCB0ZVsxMF0gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFxyXG5cdH0sXHJcblxyXG5cdG1ha2VCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xyXG5cclxuXHRcdHRoaXMuaWRlbnRpdHkoKTtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdCAgICB0ZS5lbGVtZW50c1swXSA9IHhBeGlzLng7IHRlLmVsZW1lbnRzWzFdID0geEF4aXMueTsgdGUuZWxlbWVudHNbMl0gPSB4QXhpcy56O1xyXG5cdCAgICB0ZS5lbGVtZW50c1s0XSA9IHlBeGlzLng7IHRlLmVsZW1lbnRzWzVdID0geUF4aXMueTsgdGUuZWxlbWVudHNbNl0gPSB5QXhpcy56O1xyXG5cdCAgICB0ZS5lbGVtZW50c1s4XSA9IHpBeGlzLng7IHRlLmVsZW1lbnRzWzldID0gekF4aXMueTsgdGUuZWxlbWVudHNbMTBdID0gekF4aXMuejtcclxuXHJcblx0ICAgIHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWzBdLCBtZVsxXSwgbWVbMl0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWSA9IDEgLyB2MS5zZXQoIG1lWzRdLCBtZVs1XSwgbWVbNl0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWzhdLCBtZVs5XSwgbWVbMTBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHR0ZVswXSA9IG1lWzBdICogc2NhbGVYO1xyXG5cdFx0XHR0ZVsxXSA9IG1lWzFdICogc2NhbGVYO1xyXG5cdFx0XHR0ZVsyXSA9IG1lWzJdICogc2NhbGVYO1xyXG5cclxuXHRcdFx0dGVbNF0gPSBtZVs0XSAqIHNjYWxlWTtcclxuXHRcdFx0dGVbNV0gPSBtZVs1XSAqIHNjYWxlWTtcclxuXHRcdFx0dGVbNl0gPSBtZVs2XSAqIHNjYWxlWTtcclxuXHJcblx0XHRcdHRlWzhdID0gbWVbOF0gKiBzY2FsZVo7XHJcblx0XHRcdHRlWzldID0gbWVbOV0gKiBzY2FsZVo7XHJcblx0XHRcdHRlWzEwXSA9IG1lWzEwXSAqIHNjYWxlWjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdGlmICggISAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgKSApIHJldHVybiBUSFJFRS5vbmVycm9yKCAnZXhwZWN0aW5nIGEgRXVsZXInLCBldWxlciApO1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XHJcblx0XHR2YXIgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcclxuXHRcdHZhciBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XHJcblxyXG5cdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcclxuXHJcblx0XHRcdHRlWzBdID0gYyAqIGU7XHJcblx0XHRcdHRlWzRdID0gLSBjICogZjtcclxuXHRcdFx0dGVbOF0gPSBkO1xyXG5cclxuXHRcdFx0dGVbMV0gPSBhZiArIGJlICogZDtcclxuXHRcdFx0dGVbNV0gPSBhZSAtIGJmICogZDtcclxuXHRcdFx0dGVbOV0gPSAtIGIgKiBjO1xyXG5cclxuXHRcdFx0dGVbMl0gPSBiZiAtIGFlICogZDtcclxuXHRcdFx0dGVbNl0gPSBiZSArIGFmICogZDtcclxuXHRcdFx0dGVbMTBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0dmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XHJcblxyXG5cdFx0XHR0ZVswXSA9IGNlICsgZGYgKiBiO1xyXG5cdFx0XHR0ZVs0XSA9IGRlICogYiAtIGNmO1xyXG5cdFx0XHR0ZVs4XSA9IGEgKiBkO1xyXG5cclxuXHRcdFx0dGVbMV0gPSBhICogZjtcclxuXHRcdFx0dGVbNV0gPSBhICogZTtcclxuXHRcdFx0dGVbOV0gPSAtIGI7XHJcblxyXG5cdFx0XHR0ZVsyXSA9IGNmICogYiAtIGRlO1xyXG5cdFx0XHR0ZVs2XSA9IGRmICsgY2UgKiBiO1xyXG5cdFx0XHR0ZVsxMF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcclxuXHJcblx0XHRcdHRlWzBdID0gY2UgLSBkZiAqIGI7XHJcblx0XHRcdHRlWzRdID0gLSBhICogZjtcclxuXHRcdFx0dGVbOF0gPSBkZSArIGNmICogYjtcclxuXHJcblx0XHRcdHRlWzFdID0gY2YgKyBkZSAqIGI7XHJcblx0XHRcdHRlWzVdID0gYSAqIGU7XHJcblx0XHRcdHRlWzldID0gZGYgLSBjZSAqIGI7XHJcblxyXG5cdFx0XHR0ZVsyXSA9IC0gYSAqIGQ7XHJcblx0XHRcdHRlWzZdID0gYjtcclxuXHRcdFx0dGVbMTBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XHJcblxyXG5cdFx0XHR0ZVswXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVs0XSA9IGJlICogZCAtIGFmO1xyXG5cdFx0XHR0ZVs4XSA9IGFlICogZCArIGJmO1xyXG5cclxuXHRcdFx0dGVbMV0gPSBjICogZjtcclxuXHRcdFx0dGVbNV0gPSBiZiAqIGQgKyBhZTtcclxuXHRcdFx0dGVbOV0gPSBhZiAqIGQgLSBiZTtcclxuXHJcblx0XHRcdHRlWzJdID0gLSBkO1xyXG5cdFx0XHR0ZVs2XSA9IGIgKiBjO1xyXG5cdFx0XHR0ZVsxMF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcclxuXHJcblx0XHRcdHRlWzBdID0gYyAqIGU7XHJcblx0XHRcdHRlWzRdID0gYmQgLSBhYyAqIGY7XHJcblx0XHRcdHRlWzhdID0gYmMgKiBmICsgYWQ7XHJcblxyXG5cdFx0XHR0ZVsxXSA9IGY7XHJcblx0XHRcdHRlWzVdID0gYSAqIGU7XHJcblx0XHRcdHRlWzldID0gLSBiICogZTtcclxuXHJcblx0XHRcdHRlWzJdID0gLSBkICogZTtcclxuXHRcdFx0dGVbNl0gPSBhZCAqIGYgKyBiYztcclxuXHRcdFx0dGVbMTBdID0gYWMgLSBiZCAqIGY7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xyXG5cclxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XHJcblxyXG5cdFx0XHR0ZVswXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVs0XSA9IC0gZjtcclxuXHRcdFx0dGVbOF0gPSBkICogZTtcclxuXHJcblx0XHRcdHRlWzFdID0gYWMgKiBmICsgYmQ7XHJcblx0XHRcdHRlWzVdID0gYSAqIGU7XHJcblx0XHRcdHRlWzldID0gYWQgKiBmIC0gYmM7XHJcblxyXG5cdFx0XHR0ZVsyXSA9IGJjICogZiAtIGFkO1xyXG5cdFx0XHR0ZVs2XSA9IGIgKiBlO1xyXG5cdFx0XHR0ZVsxMF0gPSBiZCAqIGYgKyBhYztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbGFzdCBjb2x1bW5cclxuXHRcdHRlWzNdID0gMDtcclxuXHRcdHRlWzddID0gMDtcclxuXHRcdHRlWzExXSA9IDA7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHJvd1xyXG5cdFx0dGVbMTJdID0gMDtcclxuXHRcdHRlWzEzXSA9IDA7XHJcblx0XHR0ZVsxNF0gPSAwO1xyXG5cdFx0dGVbMTVdID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdFRIUkVFLm9ud2FybmluZyggJ0RFUFJFQ0FURUQ6IE1hdHJpeDRcXCdzIC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbi4gIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLnc7XHJcblx0XHR2YXIgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgejtcclxuXHRcdHZhciB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xyXG5cdFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XHJcblx0XHR2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcclxuXHJcblx0XHR0ZVswXSA9IDEgLSAoIHl5ICsgenogKTtcclxuXHRcdHRlWzRdID0geHkgLSB3ejtcclxuXHRcdHRlWzhdID0geHogKyB3eTtcclxuXHJcblx0XHR0ZVsxXSA9IHh5ICsgd3o7XHJcblx0XHR0ZVs1XSA9IDEgLSAoIHh4ICsgenogKTtcclxuXHRcdHRlWzldID0geXogLSB3eDtcclxuXHJcblx0XHR0ZVsyXSA9IHh6IC0gd3k7XHJcblx0XHR0ZVs2XSA9IHl6ICsgd3g7XHJcblx0XHR0ZVsxMF0gPSAxIC0gKCB4eCArIHl5ICk7XHJcblxyXG5cdFx0Ly8gbGFzdCBjb2x1bW5cclxuXHRcdHRlWzNdID0gMDtcclxuXHRcdHRlWzddID0gMDtcclxuXHRcdHRlWzExXSA9IDA7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHJvd1xyXG5cdFx0dGVbMTJdID0gMDtcclxuXHRcdHRlWzEzXSA9IDA7XHJcblx0XHR0ZVsxNF0gPSAwO1xyXG5cdFx0dGVbMTVdID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bG9va0F0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgeiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZXllLCB0YXJnZXQsIHVwICkge1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRcdHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGlmICggei5sZW5ndGgoKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0ei56ID0gMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0aWYgKCB4Lmxlbmd0aCgpID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR6LnggKz0gMC4wMDAxO1xyXG5cdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcclxuXHJcblxyXG5cdFx0XHR0ZVswXSA9IHgueDsgdGVbNF0gPSB5Lng7IHRlWzhdID0gei54O1xyXG5cdFx0XHR0ZVsxXSA9IHgueTsgdGVbNV0gPSB5Lnk7IHRlWzldID0gei55O1xyXG5cdFx0XHR0ZVsyXSA9IHguejsgdGVbNl0gPSB5Lno7IHRlWzEwXSA9IHouejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcclxuXHJcblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFRIUkVFLm9ud2FybmluZyggJ0RFUFJFQ0FURUQ6IE1hdHJpeDRcXCdzIC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5TGlzdDogZnVuY3Rpb24gKCBsaXN0T2ZNYXRyaWNlcyApIHtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgaWwgPSBsaXN0T2ZNYXRyaWNlcy5sZW5ndGg7IGkgPCBpbCA7IGkrKykge1xyXG5cdFx0ICB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIGxpc3RPZk1hdHJpY2VzWyBpIF0gKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlNYXRyaWNlc0xpc3Q6IGZ1bmN0aW9uICggbGlzdE9mTWF0cmljZXMgKSB7XHJcblxyXG5cdFx0aWYoIGxpc3RPZk1hdHJpY2VzLmxlbmd0aCA+IDAgKSB7XHJcblx0XHRcclxuXHRcdFx0dGhpcy5jb3B5KCBsaXN0T2ZNYXRyaWNlc1swXSApO1xyXG5cclxuXHRcdFx0dGhpcy5tdWx0aXBseUxpc3QoIGxpc3RPZk1hdHJpY2VzLnNsaWNlKCAxICkgKTtcclxuXHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcclxuXHRcdFx0XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHRpZiAoICEgKCBhIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCApICkgcmV0dXJuIFRIUkVFLm9uZXJyb3IoICdleHBlY3RpbmcgYSBNYXRyaXg0JywgYSApO1xyXG5cdFx0aWYgKCAhICggYiBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgKSApIHJldHVybiBUSFJFRS5vbmVycm9yKCAnZXhwZWN0aW5nIGEgTWF0cml4NCcsIGIgKTtcclxuXHJcblx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGExMSA9IGFlWzBdLCBhMTIgPSBhZVs0XSwgYTEzID0gYWVbOF0sIGExNCA9IGFlWzEyXTtcclxuXHRcdHZhciBhMjEgPSBhZVsxXSwgYTIyID0gYWVbNV0sIGEyMyA9IGFlWzldLCBhMjQgPSBhZVsxM107XHJcblx0XHR2YXIgYTMxID0gYWVbMl0sIGEzMiA9IGFlWzZdLCBhMzMgPSBhZVsxMF0sIGEzNCA9IGFlWzE0XTtcclxuXHRcdHZhciBhNDEgPSBhZVszXSwgYTQyID0gYWVbN10sIGE0MyA9IGFlWzExXSwgYTQ0ID0gYWVbMTVdO1xyXG5cclxuXHRcdHZhciBiMTEgPSBiZVswXSwgYjEyID0gYmVbNF0sIGIxMyA9IGJlWzhdLCBiMTQgPSBiZVsxMl07XHJcblx0XHR2YXIgYjIxID0gYmVbMV0sIGIyMiA9IGJlWzVdLCBiMjMgPSBiZVs5XSwgYjI0ID0gYmVbMTNdO1xyXG5cdFx0dmFyIGIzMSA9IGJlWzJdLCBiMzIgPSBiZVs2XSwgYjMzID0gYmVbMTBdLCBiMzQgPSBiZVsxNF07XHJcblx0XHR2YXIgYjQxID0gYmVbM10sIGI0MiA9IGJlWzddLCBiNDMgPSBiZVsxMV0sIGI0NCA9IGJlWzE1XTtcclxuXHJcblx0XHR0ZVswXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcclxuXHRcdHRlWzRdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xyXG5cdFx0dGVbOF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XHJcblx0XHR0ZVsxMl0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbMV0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XHJcblx0XHR0ZVs1XSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0MjtcclxuXHRcdHRlWzldID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG5cdFx0dGVbMTNdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xyXG5cclxuXHRcdHRlWzJdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xyXG5cdFx0dGVbNl0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcblx0XHR0ZVsxMF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XHJcblx0XHR0ZVsxNF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbM10gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcblx0XHR0ZVs3XSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcclxuXHRcdHRlWzExXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0MztcclxuXHRcdHRlWzE1XSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKTtcclxuXHJcblx0XHRyWyAwIF0gPSB0ZVswXTsgclsgMSBdID0gdGVbMV07IHJbIDIgXSA9IHRlWzJdOyByWyAzIF0gPSB0ZVszXTtcclxuXHRcdHJbIDQgXSA9IHRlWzRdOyByWyA1IF0gPSB0ZVs1XTsgclsgNiBdID0gdGVbNl07IHJbIDcgXSA9IHRlWzddO1xyXG5cdFx0clsgOCBdICA9IHRlWzhdOyByWyA5IF0gID0gdGVbOV07IHJbIDEwIF0gPSB0ZVsxMF07IHJbIDExIF0gPSB0ZVsxMV07XHJcblx0XHRyWyAxMiBdID0gdGVbMTJdOyByWyAxMyBdID0gdGVbMTNdOyByWyAxNCBdID0gdGVbMTRdOyByWyAxNSBdID0gdGVbMTVdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbMF0gKj0gczsgdGVbNF0gKj0gczsgdGVbOF0gKj0gczsgdGVbMTJdICo9IHM7XHJcblx0XHR0ZVsxXSAqPSBzOyB0ZVs1XSAqPSBzOyB0ZVs5XSAqPSBzOyB0ZVsxM10gKj0gcztcclxuXHRcdHRlWzJdICo9IHM7IHRlWzZdICo9IHM7IHRlWzEwXSAqPSBzOyB0ZVsxNF0gKj0gcztcclxuXHRcdHRlWzNdICo9IHM7IHRlWzddICo9IHM7IHRlWzExXSAqPSBzOyB0ZVsxNV0gKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoICdERVBSRUNBVEVEOiBNYXRyaXg0XFwncyAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIG9yIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3I0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoICdERVBSRUNBVEVEOiBNYXRyaXg0XFwncyAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHYxLnggPSBhWyBpIF07XHJcblx0XHRcdFx0djEueSA9IGFbIGkgKyAxIF07XHJcblx0XHRcdFx0djEueiA9IGFbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdHYxLmFwcGx5UHJvamVjdGlvbiggdGhpcyApO1xyXG5cclxuXHRcdFx0XHRhWyBpIF0gICAgID0gdjEueDtcclxuXHRcdFx0XHRhWyBpICsgMSBdID0gdjEueTtcclxuXHRcdFx0XHRhWyBpICsgMiBdID0gdjEuejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFRIUkVFLm9ud2FybmluZyggJ0RFUFJFQ0FURUQ6IE1hdHJpeDRcXCdzIC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHR2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0VEhSRUUub253YXJuaW5nKCAnREVQUkVDQVRFRDogTWF0cml4NFxcJ3MgLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBuMTEgPSB0ZVswXSwgbjEyID0gdGVbNF0sIG4xMyA9IHRlWzhdLCBuMTQgPSB0ZVsxMl07XHJcblx0XHR2YXIgbjIxID0gdGVbMV0sIG4yMiA9IHRlWzVdLCBuMjMgPSB0ZVs5XSwgbjI0ID0gdGVbMTNdO1xyXG5cdFx0dmFyIG4zMSA9IHRlWzJdLCBuMzIgPSB0ZVs2XSwgbjMzID0gdGVbMTBdLCBuMzQgPSB0ZVsxNF07XHJcblx0XHR2YXIgbjQxID0gdGVbM10sIG40MiA9IHRlWzddLCBuNDMgPSB0ZVsxMV0sIG40NCA9IHRlWzE1XTtcclxuXHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxyXG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXHJcblxyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0bjQxICogKFxyXG5cdFx0XHRcdCtuMTQgKiBuMjMgKiBuMzJcclxuXHRcdFx0XHQtbjEzICogbjI0ICogbjMyXHJcblx0XHRcdFx0LW4xNCAqIG4yMiAqIG4zM1xyXG5cdFx0XHRcdCtuMTIgKiBuMjQgKiBuMzNcclxuXHRcdFx0XHQrbjEzICogbjIyICogbjM0XHJcblx0XHRcdFx0LW4xMiAqIG4yMyAqIG4zNFxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQyICogKFxyXG5cdFx0XHRcdCtuMTEgKiBuMjMgKiBuMzRcclxuXHRcdFx0XHQtbjExICogbjI0ICogbjMzXHJcblx0XHRcdFx0K24xNCAqIG4yMSAqIG4zM1xyXG5cdFx0XHRcdC1uMTMgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHQrbjEzICogbjI0ICogbjMxXHJcblx0XHRcdFx0LW4xNCAqIG4yMyAqIG4zMVxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQzICogKFxyXG5cdFx0XHRcdCtuMTEgKiBuMjQgKiBuMzJcclxuXHRcdFx0XHQtbjExICogbjIyICogbjM0XHJcblx0XHRcdFx0LW4xNCAqIG4yMSAqIG4zMlxyXG5cdFx0XHRcdCtuMTIgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHQrbjE0ICogbjIyICogbjMxXHJcblx0XHRcdFx0LW4xMiAqIG4yNCAqIG4zMVxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQ0ICogKFxyXG5cdFx0XHRcdC1uMTMgKiBuMjIgKiBuMzFcclxuXHRcdFx0XHQtbjExICogbjIzICogbjMyXHJcblx0XHRcdFx0K24xMSAqIG4yMiAqIG4zM1xyXG5cdFx0XHRcdCtuMTMgKiBuMjEgKiBuMzJcclxuXHRcdFx0XHQtbjEyICogbjIxICogbjMzXHJcblx0XHRcdFx0K24xMiAqIG4yMyAqIG4zMVxyXG5cdFx0XHQpXHJcblxyXG5cdFx0KTtcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB0bXA7XHJcblxyXG5cdFx0dG1wID0gdGVbMV07IHRlWzFdID0gdGVbNF07IHRlWzRdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbMl07IHRlWzJdID0gdGVbOF07IHRlWzhdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbNl07IHRlWzZdID0gdGVbOV07IHRlWzldID0gdG1wO1xyXG5cclxuXHRcdHRtcCA9IHRlWzNdOyB0ZVszXSA9IHRlWzEyXTsgdGVbMTJdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbN107IHRlWzddID0gdGVbMTNdOyB0ZVsxM10gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsxMV07IHRlWzExXSA9IHRlWzE0XTsgdGVbMTRdID0gdG1wO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbGF0dGVuVG9BcnJheTogZnVuY3Rpb24gKCBmbGF0ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRmbGF0WyAwIF0gPSB0ZVswXTsgZmxhdFsgMSBdID0gdGVbMV07IGZsYXRbIDIgXSA9IHRlWzJdOyBmbGF0WyAzIF0gPSB0ZVszXTtcclxuXHRcdGZsYXRbIDQgXSA9IHRlWzRdOyBmbGF0WyA1IF0gPSB0ZVs1XTsgZmxhdFsgNiBdID0gdGVbNl07IGZsYXRbIDcgXSA9IHRlWzddO1xyXG5cdFx0ZmxhdFsgOCBdID0gdGVbOF07IGZsYXRbIDkgXSA9IHRlWzldOyBmbGF0WyAxMCBdID0gdGVbMTBdOyBmbGF0WyAxMSBdID0gdGVbMTFdO1xyXG5cdFx0ZmxhdFsgMTIgXSA9IHRlWzEyXTsgZmxhdFsgMTMgXSA9IHRlWzEzXTsgZmxhdFsgMTQgXSA9IHRlWzE0XTsgZmxhdFsgMTUgXSA9IHRlWzE1XTtcclxuXHJcblx0XHRyZXR1cm4gZmxhdDtcclxuXHJcblx0fSxcclxuXHJcblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uKCBmbGF0LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdGZsYXRbIG9mZnNldCBdID0gdGVbMF07XHJcblx0XHRmbGF0WyBvZmZzZXQgKyAxIF0gPSB0ZVsxXTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDIgXSA9IHRlWzJdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMyBdID0gdGVbM107XHJcblxyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgNCBdID0gdGVbNF07XHJcblx0XHRmbGF0WyBvZmZzZXQgKyA1IF0gPSB0ZVs1XTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDYgXSA9IHRlWzZdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgNyBdID0gdGVbN107XHJcblxyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgOCBdICA9IHRlWzhdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgOSBdICA9IHRlWzldO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTAgXSA9IHRlWzEwXTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDExIF0gPSB0ZVsxMV07XHJcblxyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTIgXSA9IHRlWzEyXTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDEzIF0gPSB0ZVsxM107XHJcblx0XHRmbGF0WyBvZmZzZXQgKyAxNCBdID0gdGVbMTRdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTUgXSA9IHRlWzE1XTtcclxuXHJcblx0XHRyZXR1cm4gZmxhdDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFRIUkVFLm9ud2FybmluZyggJ0RFUFJFQ0FURUQ6IE1hdHJpeDRcXCdzIC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHRyZXR1cm4gdjEuc2V0KCB0ZVsxMl0sIHRlWzEzXSwgdGVbMTRdICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbMTJdID0gdi54O1xyXG5cdFx0dGVbMTNdID0gdi55O1xyXG5cdFx0dGVbMTRdID0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG0sIGVycm9yT25JbnZlcnRpYmxlICkge1xyXG5cclxuXHRcdGlmICggISAoIG0gaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0ICkgKSByZXR1cm4gVEhSRUUub25lcnJvciggJ2V4cGVjdGluZyBhIE1hdHJpeDQnLCBtICk7XHJcblxyXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgbjExID0gbWVbMF0sIG4xMiA9IG1lWzRdLCBuMTMgPSBtZVs4XSwgbjE0ID0gbWVbMTJdO1xyXG5cdFx0dmFyIG4yMSA9IG1lWzFdLCBuMjIgPSBtZVs1XSwgbjIzID0gbWVbOV0sIG4yNCA9IG1lWzEzXTtcclxuXHRcdHZhciBuMzEgPSBtZVsyXSwgbjMyID0gbWVbNl0sIG4zMyA9IG1lWzEwXSwgbjM0ID0gbWVbMTRdO1xyXG5cdFx0dmFyIG40MSA9IG1lWzNdLCBuNDIgPSBtZVs3XSwgbjQzID0gbWVbMTFdLCBuNDQgPSBtZVsxNV07XHJcblxyXG5cdFx0dGVbMF0gPSBuMjMqbjM0Km40MiAtIG4yNCpuMzMqbjQyICsgbjI0Km4zMipuNDMgLSBuMjIqbjM0Km40MyAtIG4yMypuMzIqbjQ0ICsgbjIyKm4zMypuNDQ7XHJcblx0XHR0ZVs0XSA9IG4xNCpuMzMqbjQyIC0gbjEzKm4zNCpuNDIgLSBuMTQqbjMyKm40MyArIG4xMipuMzQqbjQzICsgbjEzKm4zMipuNDQgLSBuMTIqbjMzKm40NDtcclxuXHRcdHRlWzhdID0gbjEzKm4yNCpuNDIgLSBuMTQqbjIzKm40MiArIG4xNCpuMjIqbjQzIC0gbjEyKm4yNCpuNDMgLSBuMTMqbjIyKm40NCArIG4xMipuMjMqbjQ0O1xyXG5cdFx0dGVbMTJdID0gbjE0Km4yMypuMzIgLSBuMTMqbjI0Km4zMiAtIG4xNCpuMjIqbjMzICsgbjEyKm4yNCpuMzMgKyBuMTMqbjIyKm4zNCAtIG4xMipuMjMqbjM0O1xyXG5cdFx0dGVbMV0gPSBuMjQqbjMzKm40MSAtIG4yMypuMzQqbjQxIC0gbjI0Km4zMSpuNDMgKyBuMjEqbjM0Km40MyArIG4yMypuMzEqbjQ0IC0gbjIxKm4zMypuNDQ7XHJcblx0XHR0ZVs1XSA9IG4xMypuMzQqbjQxIC0gbjE0Km4zMypuNDEgKyBuMTQqbjMxKm40MyAtIG4xMSpuMzQqbjQzIC0gbjEzKm4zMSpuNDQgKyBuMTEqbjMzKm40NDtcclxuXHRcdHRlWzldID0gbjE0Km4yMypuNDEgLSBuMTMqbjI0Km40MSAtIG4xNCpuMjEqbjQzICsgbjExKm4yNCpuNDMgKyBuMTMqbjIxKm40NCAtIG4xMSpuMjMqbjQ0O1xyXG5cdFx0dGVbMTNdID0gbjEzKm4yNCpuMzEgLSBuMTQqbjIzKm4zMSArIG4xNCpuMjEqbjMzIC0gbjExKm4yNCpuMzMgLSBuMTMqbjIxKm4zNCArIG4xMSpuMjMqbjM0O1xyXG5cdFx0dGVbMl0gPSBuMjIqbjM0Km40MSAtIG4yNCpuMzIqbjQxICsgbjI0Km4zMSpuNDIgLSBuMjEqbjM0Km40MiAtIG4yMipuMzEqbjQ0ICsgbjIxKm4zMipuNDQ7XHJcblx0XHR0ZVs2XSA9IG4xNCpuMzIqbjQxIC0gbjEyKm4zNCpuNDEgLSBuMTQqbjMxKm40MiArIG4xMSpuMzQqbjQyICsgbjEyKm4zMSpuNDQgLSBuMTEqbjMyKm40NDtcclxuXHRcdHRlWzEwXSA9IG4xMipuMjQqbjQxIC0gbjE0Km4yMipuNDEgKyBuMTQqbjIxKm40MiAtIG4xMSpuMjQqbjQyIC0gbjEyKm4yMSpuNDQgKyBuMTEqbjIyKm40NDtcclxuXHRcdHRlWzE0XSA9IG4xNCpuMjIqbjMxIC0gbjEyKm4yNCpuMzEgLSBuMTQqbjIxKm4zMiArIG4xMSpuMjQqbjMyICsgbjEyKm4yMSpuMzQgLSBuMTEqbjIyKm4zNDtcclxuXHRcdHRlWzNdID0gbjIzKm4zMipuNDEgLSBuMjIqbjMzKm40MSAtIG4yMypuMzEqbjQyICsgbjIxKm4zMypuNDIgKyBuMjIqbjMxKm40MyAtIG4yMSpuMzIqbjQzO1xyXG5cdFx0dGVbN10gPSBuMTIqbjMzKm40MSAtIG4xMypuMzIqbjQxICsgbjEzKm4zMSpuNDIgLSBuMTEqbjMzKm40MiAtIG4xMipuMzEqbjQzICsgbjExKm4zMipuNDM7XHJcblx0XHR0ZVsxMV0gPSBuMTMqbjIyKm40MSAtIG4xMipuMjMqbjQxIC0gbjEzKm4yMSpuNDIgKyBuMTEqbjIzKm40MiArIG4xMipuMjEqbjQzIC0gbjExKm4yMipuNDM7XHJcblx0XHR0ZVsxNV0gPSBuMTIqbjIzKm4zMSAtIG4xMypuMjIqbjMxICsgbjEzKm4yMSpuMzIgLSBuMTEqbjIzKm4zMiAtIG4xMipuMjEqbjMzICsgbjExKm4yMipuMzM7XHJcblxyXG5cdFx0dmFyIGRldCA9IG4xMSAqIHRlWyAwIF0gKyBuMjEgKiB0ZVsgNCBdICsgbjMxICogdGVbIDggXSArIG40MSAqIHRlWyAxMiBdO1xyXG5cclxuXHRcdGlmICggZGV0ID09IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGVycm9yT25JbnZlcnRpYmxlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHQgcmV0dXJuIFRIUkVFLm9uZXJyb3IoIFwiTWF0cml4NC5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIiwgdGhpcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5pZGVudGl0eSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMSAvIGRldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRUSFJFRS5vbmVycm9yKCAnREVQUkVDQVRFRDogTWF0cml4NFxcJ3MgLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG5cdFx0VEhSRUUub25lcnJvciggJ0RFUFJFQ0FURUQ6IE1hdHJpeDRcXCdzIC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcclxuXHJcblx0fSxcclxuXHJcblx0cm90YXRlWTogZnVuY3Rpb24gKCBhbmdsZSApIHtcclxuXHJcblx0XHRUSFJFRS5vbmVycm9yKCAnREVQUkVDQVRFRDogTWF0cml4NFxcJ3MgLnJvdGF0ZVkoKSBoYXMgYmVlbiByZW1vdmVkLicpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFRIUkVFLm9uZXJyb3IoICdERVBSRUNBVEVEOiBNYXRyaXg0XFwncyAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZUJ5QXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHRUSFJFRS5vbmVycm9yKCAnREVQUkVDQVRFRDogTWF0cml4NFxcJ3MgLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuJyk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xyXG5cclxuXHRcdHRlWzBdICo9IHg7IHRlWzRdICo9IHk7IHRlWzhdICo9IHo7XHJcblx0XHR0ZVsxXSAqPSB4OyB0ZVs1XSAqPSB5OyB0ZVs5XSAqPSB6O1xyXG5cdFx0dGVbMl0gKj0geDsgdGVbNl0gKj0geTsgdGVbMTBdICo9IHo7XHJcblx0XHR0ZVszXSAqPSB4OyB0ZVs3XSAqPSB5OyB0ZVsxMV0gKj0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBzY2FsZVhTcSA9IHRlWzBdICogdGVbMF0gKyB0ZVsxXSAqIHRlWzFdICsgdGVbMl0gKiB0ZVsyXTtcclxuXHRcdHZhciBzY2FsZVlTcSA9IHRlWzRdICogdGVbNF0gKyB0ZVs1XSAqIHRlWzVdICsgdGVbNl0gKiB0ZVs2XTtcclxuXHRcdHZhciBzY2FsZVpTcSA9IHRlWzhdICogdGVbOF0gKyB0ZVs5XSAqIHRlWzldICsgdGVbMTBdICogdGVbMTBdO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgTWF0aC5tYXgoIHNjYWxlWVNxLCBzY2FsZVpTcSApICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCB4LFxyXG5cdFx0XHQwLCAxLCAwLCB5LFxyXG5cdFx0XHQwLCAwLCAxLCB6LFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAgMCwgMCxcclxuXHRcdFx0MCwgYywgLXMsIDAsXHJcblx0XHRcdDAsIHMsICBjLCAwLFxyXG5cdFx0XHQwLCAwLCAgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvblk6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0IGMsIDAsIHMsIDAsXHJcblx0XHRcdCAwLCAxLCAwLCAwLFxyXG5cdFx0XHQtcywgMCwgYywgMCxcclxuXHRcdFx0IDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25aOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdGMsIC1zLCAwLCAwLFxyXG5cdFx0XHRzLCAgYywgMCwgMCxcclxuXHRcdFx0MCwgIDAsIDEsIDAsXHJcblx0XHRcdDAsICAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHRcdHZhciB0ID0gMSAtIGM7XHJcblx0XHR2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcclxuXHRcdHZhciB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxyXG5cdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXHJcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0IHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlU2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdHgsIDAsIDAsIDAsXHJcblx0XHRcdDAsIHksIDAsIDAsXHJcblx0XHRcdDAsIDAsIHosIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHJcblx0bWFrZVNoZWFyOiBmdW5jdGlvbiAoIHZlY3RvcjNTaGVhciwgcmV2ZXJzZVN0eWxlICkge1xyXG5cclxuXHRcdHZhciB4eSA9IHZlY3RvcjNTaGVhci54O1xyXG4gICAgXHR2YXIgeHogPSB2ZWN0b3IzU2hlYXIueTtcclxuICAgIFx0dmFyIHl6ID0gdmVjdG9yM1NoZWFyLno7XHJcblxyXG5cdFx0aWYgKCByZXZlcnNlU3R5bGUgKSB7XHJcblxyXG5cdFx0ICB0aGlzLnNldChcclxuXHRcdCAgICAxLCAgMCwgIDAsICAwLFxyXG5cdFx0ICAgIHh5LCAxLCAgMCwgIDAsXHJcblx0XHQgICAgeHosIHl6LCAxLCAgMCxcclxuXHRcdCAgICAwLCAgIDAsICAwLCAgMVxyXG5cdFx0ICApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHQgIC8vIE1heWEgc3R5bGVcclxuXHRcdCAgdGhpcy5zZXQoXHJcblx0XHQgICAgMSwgIHh5LCB4eiwgMCxcclxuXHRcdCAgICAwLCAgMSwgIHl6LCAwLFxyXG5cdFx0ICAgIDAsICAwLCAgMSwgIDAsXHJcblx0XHQgICAgMCwgIDAsICAwLCAgMVxyXG5cdFx0ICApO1xyXG5cdFx0fVxyXG5cclxuXHQgICAgcmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xyXG5cclxuXHRcdHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHRcdHRoaXMuc2NhbGUoIHNjYWxlICk7XHJcblx0XHR0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVswXSwgdGVbMV0sIHRlWzJdICkubGVuZ3RoKCk7XHJcblx0XHRcdHZhciBzeSA9IHZlY3Rvci5zZXQoIHRlWzRdLCB0ZVs1XSwgdGVbNl0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHN6ID0gdmVjdG9yLnNldCggdGVbOF0sIHRlWzldLCB0ZVsxMF0gKS5sZW5ndGgoKTtcclxuXHJcblx0XHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXHJcblx0XHRcdHZhciBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XHJcblx0XHRcdGlmKCBkZXQgPCAwICkge1xyXG5cdFx0XHRcdHN4ID0gLXN4O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb3NpdGlvbi54ID0gdGVbMTJdO1xyXG5cdFx0XHRwb3NpdGlvbi55ID0gdGVbMTNdO1xyXG5cdFx0XHRwb3NpdGlvbi56ID0gdGVbMTRdO1xyXG5cclxuXHRcdFx0Ly8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50cy5zZXQoIHRoaXMuZWxlbWVudHMgKTsgLy8gYXQgdGhpcyBwb2ludCBtYXRyaXggaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCB1c2UgLmNvcHkoKVxyXG5cclxuXHRcdFx0dmFyIGludlNYID0gMSAvIHN4O1xyXG5cdFx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XHJcblx0XHRcdHZhciBpbnZTWiA9IDEgLyBzejtcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1swXSAqPSBpbnZTWDtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWzFdICo9IGludlNYO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbMl0gKj0gaW52U1g7XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbNF0gKj0gaW52U1k7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1s1XSAqPSBpbnZTWTtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWzZdICo9IGludlNZO1xyXG5cclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWzhdICo9IGludlNaO1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbOV0gKj0gaW52U1o7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sxMF0gKj0gaW52U1o7XHJcblxyXG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHRzY2FsZS54ID0gc3g7XHJcblx0XHRcdHNjYWxlLnkgPSBzeTtcclxuXHRcdFx0c2NhbGUueiA9IHN6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHR2YXIgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcclxuXHJcblx0XHR2YXIgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xyXG5cdFx0dmFyIGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcclxuXHRcdHZhciBjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xyXG5cdFx0dmFyIGQgPSAtIDIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XHJcblxyXG5cdFx0dGVbMF0gPSB4O1x0dGVbNF0gPSAwO1x0dGVbOF0gPSBhO1x0dGVbMTJdID0gMDtcclxuXHRcdHRlWzFdID0gMDtcdHRlWzVdID0geTtcdHRlWzldID0gYjtcdHRlWzEzXSA9IDA7XHJcblx0XHR0ZVsyXSA9IDA7XHR0ZVs2XSA9IDA7XHR0ZVsxMF0gPSBjO1x0dGVbMTRdID0gZDtcclxuXHRcdHRlWzNdID0gMDtcdHRlWzddID0gMDtcdHRlWzExXSA9IC0gMTtcdHRlWzE1XSA9IDA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VQZXJzcGVjdGl2ZTogZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApO1xyXG5cdFx0dmFyIHltaW4gPSAtIHltYXg7XHJcblx0XHR2YXIgeG1pbiA9IHltaW4gKiBhc3BlY3Q7XHJcblx0XHR2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWFrZUZydXN0dW0oIHhtaW4sIHhtYXgsIHltaW4sIHltYXgsIG5lYXIsIGZhciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdyA9IHJpZ2h0IC0gbGVmdDtcclxuXHRcdHZhciBoID0gdG9wIC0gYm90dG9tO1xyXG5cdFx0dmFyIHAgPSBmYXIgLSBuZWFyO1xyXG5cclxuXHRcdHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAvIHc7XHJcblx0XHR2YXIgeSA9ICggdG9wICsgYm90dG9tICkgLyBoO1xyXG5cdFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAvIHA7XHJcblxyXG5cdFx0dGVbMF0gPSAyIC8gdztcdHRlWzRdID0gMDtcdHRlWzhdID0gMDtcdHRlWzEyXSA9IC14O1xyXG5cdFx0dGVbMV0gPSAwO1x0dGVbNV0gPSAyIC8gaDtcdHRlWzldID0gMDtcdHRlWzEzXSA9IC15O1xyXG5cdFx0dGVbMl0gPSAwO1x0dGVbNl0gPSAwO1x0dGVbMTBdID0gLTIvcDtcdHRlWzE0XSA9IC16O1xyXG5cdFx0dGVbM10gPSAwO1x0dGVbN10gPSAwO1x0dGVbMTFdID0gMDtcdHRlWzE1XSA9IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLmVsZW1lbnRzLnNldCggYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0dGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSwgdGVbIDMgXSxcclxuXHRcdFx0dGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSwgdGVbIDcgXSxcclxuXHRcdFx0dGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0sIHRlWyAxMSBdLFxyXG5cdFx0XHR0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdLCB0ZVsgMTUgXVxyXG5cdFx0XTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuTWF0cml4NChcclxuXHJcblx0XHRcdHRlWzBdLCB0ZVs0XSwgdGVbOF0sIHRlWzEyXSxcclxuXHRcdFx0dGVbMV0sIHRlWzVdLCB0ZVs5XSwgdGVbMTNdLFxyXG5cdFx0XHR0ZVsyXSwgdGVbNl0sIHRlWzEwXSwgdGVbMTRdLFxyXG5cdFx0XHR0ZVszXSwgdGVbN10sIHRlWzExXSwgdGVbMTVdXHJcblxyXG5cdFx0KTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICovXHJcblxyXG5USFJFRS5SYXkgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuXHR0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5kaXJlY3Rpb24gPSAoIGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkaXJlY3Rpb24gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlJheS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5SYXksXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0XHR0aGlzLm9yaWdpbi5jb3B5KCBvcmlnaW4gKTtcclxuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcclxuXHJcblx0XHR0aGlzLm9yaWdpbi5jb3B5KCByYXkub3JpZ2luICk7XHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVjYXN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgdjEgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJlc3VsdC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKTtcclxuXHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHJlc3VsdC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB2MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0XHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxyXG5cclxuXHRcdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvKCBwb2ludCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0djEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdjEuZGlzdGFuY2VUbyggcG9pbnQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uKCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcclxuXHJcblx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0Rpc3RhbmNlL1dtNURpc3RSYXkzU2VnbWVudDMuY3BwXHJcblx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxyXG5cdFx0Ly8gZGVmaW5lZCBieSB2MCBhbmQgdjFcclxuXHRcdC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XHJcblx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcclxuXHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcclxuXHJcblx0XHR2YXIgc2VnQ2VudGVyID0gdjAuY2xvbmUoKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0dmFyIHNlZ0RpciA9IHYxLmNsb25lKCkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0dmFyIHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8oIHYxICkgKiAwLjU7XHJcblx0XHR2YXIgZGlmZiA9IHRoaXMub3JpZ2luLmNsb25lKCkuc3ViKCBzZWdDZW50ZXIgKTtcclxuXHRcdHZhciBhMDEgPSAtIHRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XHJcblx0XHR2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xyXG5cdFx0dmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XHJcblx0XHR2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcclxuXHRcdHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcclxuXHJcblx0XHRpZiAoIGRldCA+PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gVGhlIHJheSBhbmQgc2VnbWVudCBhcmUgbm90IHBhcmFsbGVsLlxyXG5cclxuXHRcdFx0czAgPSBhMDEgKiBiMSAtIGIwO1xyXG5cdFx0XHRzMSA9IGEwMSAqIGIwIC0gYjE7XHJcblx0XHRcdGV4dERldCA9IHNlZ0V4dGVudCAqIGRldDtcclxuXHJcblx0XHRcdGlmICggczAgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHMxIDw9IGV4dERldCApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAwXHJcblx0XHRcdFx0XHRcdC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cclxuXHJcblx0XHRcdFx0XHRcdHZhciBpbnZEZXQgPSAxIC8gZGV0O1xyXG5cdFx0XHRcdFx0XHRzMCAqPSBpbnZEZXQ7XHJcblx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcclxuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IHMwICogKCBzMCArIGEwMSAqIHMxICsgMiAqIGIwICkgKyBzMSAqICggYTAxICogczAgKyBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDFcclxuXHJcblx0XHRcdFx0XHRcdHMxID0gc2VnRXh0ZW50O1xyXG5cdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCkgKTtcclxuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVnaW9uIDVcclxuXHJcblx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xyXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjApICk7XHJcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIHMxIDw9IC0gZXh0RGV0KSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVnaW9uIDRcclxuXHJcblx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggLSBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XHJcblx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVnaW9uIDNcclxuXHJcblx0XHRcdFx0XHRzMCA9IDA7XHJcblx0XHRcdFx0XHRzMSA9IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcblx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIHJlZ2lvbiAyXHJcblxyXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcclxuXHRcdFx0XHRcdHMxID0gKCBzMCA+IDAgKSA/IHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXHJcblxyXG5cdFx0XHRzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XHJcblx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcclxuXHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XHJcblxyXG5cdFx0XHRvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xyXG5cclxuXHRcdFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBzZWdEaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggczEgKS5hZGQoIHNlZ0NlbnRlciApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzcXJEaXN0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gc3BoZXJlLnJhZGl1cztcclxuXHJcblx0fSxcclxuXHJcblx0aXNJbnRlcnNlY3Rpb25QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHQvLyBjaGVjayBpZiB0aGUgcmF5IGxpZXMgb24gdGhlIHBsYW5lIGZpcnN0XHJcblxyXG5cdFx0dmFyIGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdGlmICggZGlzdFRvUG9pbnQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRpZiAoIGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWVcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblx0XHRpZiAoIGRlbm9taW5hdG9yID09IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXHJcblx0XHRcdGlmKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT0gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcclxuXHJcblx0XHQvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxyXG5cclxuXHRcdHJldHVybiB0ID49IDAgPyB0IDogIG51bGw7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xyXG5cclxuXHRcdGlmICggdCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmF0KCB0LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHJcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCAsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuc2NyYXRjaGFwaXhlbC5jb20vbGVzc29ucy8zZC1iYXNpYy1sZXNzb25zL2xlc3Nvbi03LWludGVyc2VjdGluZy1zaW1wbGUtc2hhcGVzL3JheS1ib3gtaW50ZXJzZWN0aW9uL1xyXG5cclxuXHRcdHZhciB0bWluLHRtYXgsdHltaW4sdHltYXgsdHptaW4sdHptYXg7XHJcblxyXG5cdFx0dmFyIGludmRpcnggPSAxL3RoaXMuZGlyZWN0aW9uLngsXHJcblx0XHRcdGludmRpcnkgPSAxL3RoaXMuZGlyZWN0aW9uLnksXHJcblx0XHRcdGludmRpcnogPSAxL3RoaXMuZGlyZWN0aW9uLno7XHJcblxyXG5cdFx0dmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xyXG5cclxuXHRcdGlmIChpbnZkaXJ4ID49IDApIHtcclxuXHRcdFx0XHRcclxuXHRcdFx0dG1pbiA9IChib3gubWluLnggLSBvcmlnaW4ueCkgKiBpbnZkaXJ4O1xyXG5cdFx0XHR0bWF4ID0gKGJveC5tYXgueCAtIG9yaWdpbi54KSAqIGludmRpcng7XHJcblxyXG5cdFx0fSBlbHNlIHsgXHJcblxyXG5cdFx0XHR0bWluID0gKGJveC5tYXgueCAtIG9yaWdpbi54KSAqIGludmRpcng7XHJcblx0XHRcdHRtYXggPSAoYm94Lm1pbi54IC0gb3JpZ2luLngpICogaW52ZGlyeDtcclxuXHRcdH1cdFx0XHRcclxuXHJcblx0XHRpZiAoaW52ZGlyeSA+PSAwKSB7XHJcblx0XHRcclxuXHRcdFx0dHltaW4gPSAoYm94Lm1pbi55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcclxuXHRcdFx0dHltYXggPSAoYm94Lm1heC55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dHltaW4gPSAoYm94Lm1heC55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcclxuXHRcdFx0dHltYXggPSAoYm94Lm1pbi55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoKHRtaW4gPiB0eW1heCkgfHwgKHR5bWluID4gdG1heCkpIHJldHVybiBudWxsO1xyXG5cclxuXHRcdC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cclxuXHRcdC8vIChyZXN1bHQgb2YgMCAqIEluZmluaXR5KS4geCAhPT0geCByZXR1cm5zIHRydWUgaWYgeCBpcyBOYU5cclxuXHRcdFxyXG5cdFx0aWYgKHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xyXG5cclxuXHRcdGlmICh0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcclxuXHJcblx0XHRpZiAoaW52ZGlyeiA+PSAwKSB7XHJcblx0XHRcclxuXHRcdFx0dHptaW4gPSAoYm94Lm1pbi56IC0gb3JpZ2luLnopICogaW52ZGlyejtcclxuXHRcdFx0dHptYXggPSAoYm94Lm1heC56IC0gb3JpZ2luLnopICogaW52ZGlyejtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dHptaW4gPSAoYm94Lm1heC56IC0gb3JpZ2luLnopICogaW52ZGlyejtcclxuXHRcdFx0dHptYXggPSAoYm94Lm1pbi56IC0gb3JpZ2luLnopICogaW52ZGlyejtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoKHRtaW4gPiB0em1heCkgfHwgKHR6bWluID4gdG1heCkpIHJldHVybiBudWxsO1xyXG5cclxuXHRcdGlmICh0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcclxuXHJcblx0XHRpZiAodHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XHJcblxyXG5cdFx0Ly9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxyXG5cclxuXHRcdGlmICggdG1heCA8IDAgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cclxuXHRcdHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBlZGdlMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vTGliTWF0aGVtYXRpY3MvSW50ZXJzZWN0aW9uL1dtNUludHJSYXkzVHJpYW5nbGUzLmNwcFxyXG5cclxuXHRcdFx0ZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0XHRlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XHJcblx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xyXG5cclxuXHRcdFx0Ly8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXHJcblx0XHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcclxuXHRcdFx0Ly8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXHJcblx0XHRcdC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxyXG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxyXG5cdFx0XHR2YXIgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBub3JtYWwgKTtcclxuXHRcdFx0dmFyIHNpZ247XHJcblxyXG5cdFx0XHRpZiAoIERkTiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0c2lnbiA9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xyXG5cclxuXHRcdFx0XHRzaWduID0gLSAxO1xyXG5cdFx0XHRcdERkTiA9IC0gRGROO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XHJcblx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcclxuXHJcblx0XHRcdC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggRGRReEUyIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xyXG5cclxuXHRcdFx0Ly8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0aWYgKCBEZEUxeFEgPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXHJcblx0XHRcdHZhciBRZE4gPSAtIHNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHQvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRcdGlmICggUWROIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHRcclxuXHRcdH1cclxuXHRcclxuXHR9KCksXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xyXG5cclxuXHRcdHRoaXMuZGlyZWN0aW9uLmFkZCggdGhpcy5vcmlnaW4gKS5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcclxuXHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24uc3ViKCB0aGlzLm9yaWdpbiApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHJheSApIHtcclxuXHJcblx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5SYXkoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BoZXJlID0gZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcblx0dGhpcy5jZW50ZXIgPSAoIGNlbnRlciAhPT0gdW5kZWZpbmVkICkgPyBjZW50ZXIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGhlcmUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuU3BoZXJlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSAge1xyXG5cclxuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xyXG5cclxuXHRcdFx0aWYgKCBvcHRpb25hbENlbnRlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjZW50ZXIuY29weSggb3B0aW9uYWxDZW50ZXIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGJveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5jZW50ZXIoIGNlbnRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMCwgY3ggPSBjZW50ZXIueCwgY3kgPSBjZW50ZXIueSwgY3ogPSBjZW50ZXIuejtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwdCA9IHBvaW50c1sgaSBdO1xyXG5cdFx0XHRcdHZhciBkeCA9IGN4IC0gcHQueDtcclxuXHRcdFx0XHR2YXIgZHkgPSBjeSAtIHB0Lnk7XHJcblx0XHRcdFx0dmFyIGR6ID0gY3ogLSBwdC56O1xyXG5cclxuXHRcdFx0XHR2YXIgZGlzdGFuY2VTcXVhcmVkID0gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xyXG5cclxuXHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgZGlzdGFuY2VTcXVhcmVkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1x0XHRcdFxyXG4gXHRcdFxyXG4gXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJlc3VsdC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xyXG5cclxuXHRcdFx0cmVzdWx0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0cmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGJveCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFx0Ym94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XHJcblx0XHRib3guZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XHJcblxyXG5cdFx0cmV0dXJuIGJveDtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlNwaGVyZSgpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICovXHJcblxyXG5USFJFRS5GcnVzdHVtID0gZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xyXG5cclxuXHR0aGlzLnBsYW5lcyA9IFtcclxuXHJcblx0XHQoIHAwICE9PSB1bmRlZmluZWQgKSA/IHAwIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHAxICE9PSB1bmRlZmluZWQgKSA/IHAxIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHAzICE9PSB1bmRlZmluZWQgKSA/IHAzIDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHA0ICE9PSB1bmRlZmluZWQgKSA/IHA0IDogbmV3IFRIUkVFLlBsYW5lKCksXHJcblx0XHQoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFRIUkVFLlBsYW5lKClcclxuXHJcblx0XTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GcnVzdHVtLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkZydXN0dW0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcblx0XHRwbGFuZXNbMF0uY29weSggcDAgKTtcclxuXHRcdHBsYW5lc1sxXS5jb3B5KCBwMSApO1xyXG5cdFx0cGxhbmVzWzJdLmNvcHkoIHAyICk7XHJcblx0XHRwbGFuZXNbM10uY29weSggcDMgKTtcclxuXHRcdHBsYW5lc1s0XS5jb3B5KCBwNCApO1xyXG5cdFx0cGxhbmVzWzVdLmNvcHkoIHA1ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggZnJ1c3R1bSApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0cGxhbmVzW2ldLmNvcHkoIGZydXN0dW0ucGxhbmVzW2ldICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHRcdHZhciBtZTAgPSBtZVswXSwgbWUxID0gbWVbMV0sIG1lMiA9IG1lWzJdLCBtZTMgPSBtZVszXTtcclxuXHRcdHZhciBtZTQgPSBtZVs0XSwgbWU1ID0gbWVbNV0sIG1lNiA9IG1lWzZdLCBtZTcgPSBtZVs3XTtcclxuXHRcdHZhciBtZTggPSBtZVs4XSwgbWU5ID0gbWVbOV0sIG1lMTAgPSBtZVsxMF0sIG1lMTEgPSBtZVsxMV07XHJcblx0XHR2YXIgbWUxMiA9IG1lWzEyXSwgbWUxMyA9IG1lWzEzXSwgbWUxNCA9IG1lWzE0XSwgbWUxNSA9IG1lWzE1XTtcclxuXHJcblx0XHRwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XHJcblx0XHRwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblx0XHR2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcclxuXHRcdHZhciBuZWdSYWRpdXMgPSAtc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNCb3ggOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgcDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBib3ggKSB7XHJcblxyXG5cdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2IDsgaSArKyApIHtcclxuXHRcdFx0XHJcblx0XHRcdFx0dmFyIHBsYW5lID0gcGxhbmVzW2ldO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHAxLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWluLnggOiBib3gubWF4Lng7XHJcblx0XHRcdFx0cDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcclxuXHRcdFx0XHRwMS55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1pbi55IDogYm94Lm1heC55O1xyXG5cdFx0XHRcdHAyLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWF4LnkgOiBib3gubWluLnk7XHJcblx0XHRcdFx0cDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcclxuXHRcdFx0XHRwMi56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xyXG5cclxuXHRcdFx0XHR2YXIgZDEgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAxICk7XHJcblx0XHRcdFx0dmFyIGQyID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMiApO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIGlmIGJvdGggb3V0c2lkZSBwbGFuZSwgbm8gaW50ZXJzZWN0aW9uXHJcblxyXG5cdFx0XHRcdGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5GcnVzdHVtKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLlBsYW5lID0gZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xyXG5cclxuXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XHJcblx0dGhpcy5jb25zdGFudCA9ICggY29uc3RhbnQgIT09IHVuZGVmaW5lZCApID8gY29uc3RhbnQgOiAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBsYW5lLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlBsYW5lLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xyXG5cdFx0dGhpcy5jb25zdGFudCA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XHQvLyBtdXN0IGJlIHRoaXMubm9ybWFsLCBub3Qgbm9ybWFsLCBhcyB0aGlzLm5vcm1hbCBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdHZhciBub3JtYWwgPSB2MS5zdWJWZWN0b3JzKCBjLCBiICkuY3Jvc3MoIHYyLnN1YlZlY3RvcnMoIGEsIGIgKSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Ly8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cclxuXHJcblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBwbGFuZS5ub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXHJcblxyXG5cdFx0dmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcclxuXHRcdHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKCBpbnZlcnNlTm9ybWFsTGVuZ3RoICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29uc3RhbnQgKj0gLTE7XHJcblx0XHR0aGlzLm5vcm1hbC5uZWdhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHByb2plY3RQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub3J0aG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkuc3ViKCBwb2ludCApLm5lZ2F0ZSgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvcnRob1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcGVycGVuZGljdWxhck1hZ25pdHVkZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCBwZXJwZW5kaWN1bGFyTWFnbml0dWRlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlzSW50ZXJzZWN0aW9uTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xyXG5cclxuXHRcdC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxyXG5cclxuXHRcdHZhciBzdGFydFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApO1xyXG5cdFx0dmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcclxuXHJcblx0XHRyZXR1cm4gKCBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwICkgfHwgKCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xyXG5cclxuXHRcdFx0dmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRcdGlmICggZGVub21pbmF0b3IgPT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxyXG5cdFx0XHRcdGlmKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXHJcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0XHRpZiggdCA8IDAgfHwgdCA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHJcblx0Y29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XHJcblxyXG5cdFx0XHRpZiAoICEgKCBtYXRyaXggaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0ICkgKSByZXR1cm4gVEhSRUUub25lcnJvciggJ2V4cGVjdGluZyBhIE1hdHJpeDQnLCBtYXRyaXggKTtcclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgbmV3IG5vcm1hbCBiYXNlZCBvbiB0aGVvcnkgaGVyZTpcclxuXHRcdFx0Ly8gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX25vcm1hbHRyYW5zZm9ybS5odG1sXHJcblx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBtMS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cdFx0XHR2YXIgbmV3Tm9ybWFsID0gdjEuY29weSggdGhpcy5ub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIG5ld0NvcGxhbmFyUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoIHYyICk7XHJcblx0XHRcdG5ld0NvcGxhbmFyUG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5ld05vcm1hbCwgbmV3Q29wbGFuYXJQb2ludCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50IC0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT0gdGhpcy5jb25zdGFudCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuUGxhbmUoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRoID0ge1xyXG5cclxuXHRQSTI6IE1hdGguUEkgKiAyLFxyXG5cdERlZ3JlZVRvUmFkaWFuc0ZhY3RvcjogTWF0aC5QSSAvIDE4MCxcclxuXHRSYWRpYW5Ub0RlZ3JlZXNGYWN0b3I6IDE4MCAvIE1hdGguUEksXHJcblxyXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuYnJvb2ZhLmNvbS9Ub29scy9NYXRoLnV1aWQuaHRtXHJcblx0XHRcclxuXHRcdHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoJycpO1xyXG5cdFx0dmFyIHV1aWQgPSBuZXcgQXJyYXkoMzYpO1xyXG5cdFx0dmFyIHJuZCA9IDAsIHI7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGkgPT0gOCB8fCBpID09IDEzIHx8IGkgPT0gMTggfHwgaSA9PSAyMyApIHtcclxuXHRcdFx0XHJcblx0XHRcdFx0XHR1dWlkWyBpIF0gPSAnLSc7XHJcblx0XHRcdFxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGkgPT0gMTQgKSB7XHJcblx0XHRcdFxyXG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gJzQnO1xyXG5cdFx0XHRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcclxuXHRcdFx0XHRcdGlmIChybmQgPD0gMHgwMikgcm5kID0gMHgyMDAwMDAwICsgKE1hdGgucmFuZG9tKCkqMHgxMDAwMDAwKXwwO1xyXG5cdFx0XHRcdFx0ciA9IHJuZCAmIDB4ZjtcclxuXHRcdFx0XHRcdHJuZCA9IHJuZCA+PiA0O1xyXG5cdFx0XHRcdFx0dXVpZFtpXSA9IGNoYXJzWyhpID09IDE5KSA/IChyICYgMHgzKSB8IDB4OCA6IHJdO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiB1dWlkLmpvaW4oJycpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Ly8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGI+XHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIHgsIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggeCA8IGEgKSA/IGEgOiAoICggeCA+IGIgKSA/IGIgOiB4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIENsYW1wIHZhbHVlIHRvIHJhbmdlIDxhLCBpbmYpXHJcblxyXG5cdGNsYW1wQm90dG9tOiBmdW5jdGlvbiAoIHgsIGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHggPCBhID8gYSA6IHg7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cclxuXHJcblx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xyXG5cclxuXHRcdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcclxuXHJcblx0c21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdFx0eCA9ICggeCAtIG1pbiApLyggbWF4IC0gbWluICk7XHJcblxyXG5cdFx0cmV0dXJuIHgqeCooMyAtIDIqeCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNtb290aGVyc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdFx0eCA9ICggeCAtIG1pbiApLyggbWF4IC0gbWluICk7XHJcblxyXG5cdFx0cmV0dXJuIHgqeCp4Kih4Kih4KjYgLSAxNSkgKyAxMCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwwLCAxPiB3aXRoIDE2IGJpdHMgb2YgcmFuZG9tbmVzc1xyXG5cdC8vIChzdGFuZGFyZCBNYXRoLnJhbmRvbSgpIGNyZWF0ZXMgcmVwZXRpdGl2ZSBwYXR0ZXJucyB3aGVuIGFwcGxpZWQgb3ZlciBsYXJnZXIgc3BhY2UpXHJcblxyXG5cdHJhbmRvbTE2OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggNjUyODAgKiBNYXRoLnJhbmRvbSgpICsgMjU1ICogTWF0aC5yYW5kb20oKSApIC8gNjU1MzU7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcclxuXHJcblx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcclxuXHJcblx0cmFuZEZsb2F0OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcblx0XHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXHJcblxyXG5cdHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKCByYW5nZSApIHtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2lnbjogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHggPCAwICkgPyAtIDEgOiAoIHggPiAwICkgPyAxIDogMDtcclxuXHJcblx0fSxcclxuXHJcblx0ZGVnVG9SYWQ6IGZ1bmN0aW9uICggZGVncmVlcyApIHtcclxuXHJcblx0XHRyZXR1cm4gZGVncmVlcyAqIHRoaXMuRGVncmVlVG9SYWRpYW5zRmFjdG9yO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCByYWRpYW5zICkge1xyXG5cclxuXHRcdHJldHVybiByYWRpYW5zICogdGhpcy5SYWRpYW5Ub0RlZ3JlZXNGYWN0b3I7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogU3BsaW5lIGZyb20gVHdlZW4uanMsIHNsaWdodGx5IG9wdGltaXplZCAoYW5kIHRyYXNoZWQpXHJcbiAqIGh0dHA6Ly9zb2xlLmdpdGh1Yi5jb20vdHdlZW4uanMvZXhhbXBsZXMvMDVfc3BsaW5lLmh0bWxcclxuICpcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcGxpbmUgPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0dGhpcy5wb2ludHMgPSBwb2ludHM7XHJcblxyXG5cdHZhciBjID0gW10sIHYzID0geyB4OiAwLCB5OiAwLCB6OiAwIH0sXHJcblx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcclxuXHRwYSwgcGIsIHBjLCBwZDtcclxuXHJcblx0dGhpcy5pbml0RnJvbUFycmF5ID0gZnVuY3Rpb24oIGEgKSB7XHJcblxyXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5wb2ludHNbIGkgXSA9IHsgeDogYVsgaSBdWyAwIF0sIHk6IGFbIGkgXVsgMSBdLCB6OiBhWyBpIF1bIDIgXSB9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uICggayApIHtcclxuXHJcblx0XHRwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaztcclxuXHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0Y1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcclxuXHRcdGNbIDEgXSA9IGludFBvaW50O1xyXG5cdFx0Y1sgMiBdID0gaW50UG9pbnQgID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMiA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDE7XHJcblx0XHRjWyAzIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAzID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcclxuXHJcblx0XHRwYSA9IHRoaXMucG9pbnRzWyBjWyAwIF0gXTtcclxuXHRcdHBiID0gdGhpcy5wb2ludHNbIGNbIDEgXSBdO1xyXG5cdFx0cGMgPSB0aGlzLnBvaW50c1sgY1sgMiBdIF07XHJcblx0XHRwZCA9IHRoaXMucG9pbnRzWyBjWyAzIF0gXTtcclxuXHJcblx0XHR3MiA9IHdlaWdodCAqIHdlaWdodDtcclxuXHRcdHczID0gd2VpZ2h0ICogdzI7XHJcblxyXG5cdFx0djMueCA9IGludGVycG9sYXRlKCBwYS54LCBwYi54LCBwYy54LCBwZC54LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cdFx0djMueSA9IGludGVycG9sYXRlKCBwYS55LCBwYi55LCBwYy55LCBwZC55LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cdFx0djMueiA9IGludGVycG9sYXRlKCBwYS56LCBwYi56LCBwYy56LCBwZC56LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cclxuXHRcdHJldHVybiB2MztcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRDb250cm9sUG9pbnRzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGksIHAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGgsXHJcblx0XHRcdGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHAgPSB0aGlzLnBvaW50c1sgaSBdO1xyXG5cdFx0XHRjb29yZHNbIGkgXSA9IFsgcC54LCBwLnksIHAueiBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29vcmRzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBhcHByb3hpbWF0ZSBsZW5ndGggYnkgc3VtbWluZyBsaW5lYXIgc2VnbWVudHNcclxuXHJcblx0dGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoIG5TdWJEaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0dmFyIGksIGluZGV4LCBuU2FtcGxlcywgcG9zaXRpb24sXHJcblx0XHRcdHBvaW50ID0gMCwgaW50UG9pbnQgPSAwLCBvbGRJbnRQb2ludCA9IDAsXHJcblx0XHRcdG9sZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0dG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0Y2h1bmtMZW5ndGhzID0gW10sXHJcblx0XHRcdHRvdGFsTGVuZ3RoID0gMDtcclxuXHJcblx0XHQvLyBmaXJzdCBwb2ludCBoYXMgMCBsZW5ndGhcclxuXHJcblx0XHRjaHVua0xlbmd0aHNbIDAgXSA9IDA7XHJcblxyXG5cdFx0aWYgKCAhblN1YkRpdmlzaW9ucyApIG5TdWJEaXZpc2lvbnMgPSAxMDA7XHJcblxyXG5cdFx0blNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xyXG5cclxuXHRcdG9sZFBvc2l0aW9uLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKTtcclxuXHJcblx0XHRmb3IgKCBpID0gMTsgaSA8IG5TYW1wbGVzOyBpICsrICkge1xyXG5cclxuXHRcdFx0aW5kZXggPSBpIC8gblNhbXBsZXM7XHJcblxyXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XHJcblx0XHRcdHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0dG90YWxMZW5ndGggKz0gdG1wVmVjLmRpc3RhbmNlVG8oIG9sZFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRvbGRQb3NpdGlvbi5jb3B5KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0cG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGluZGV4O1xyXG5cdFx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRpZiAoIGludFBvaW50ICE9IG9sZEludFBvaW50ICkge1xyXG5cclxuXHRcdFx0XHRjaHVua0xlbmd0aHNbIGludFBvaW50IF0gPSB0b3RhbExlbmd0aDtcclxuXHRcdFx0XHRvbGRJbnRQb2ludCA9IGludFBvaW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBsYXN0IHBvaW50IGVuZHMgd2l0aCB0b3RhbCBsZW5ndGhcclxuXHJcblx0XHRjaHVua0xlbmd0aHNbIGNodW5rTGVuZ3Rocy5sZW5ndGggXSA9IHRvdGFsTGVuZ3RoO1xyXG5cclxuXHRcdHJldHVybiB7IGNodW5rczogY2h1bmtMZW5ndGhzLCB0b3RhbDogdG90YWxMZW5ndGggfTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGggPSBmdW5jdGlvbiAoIHNhbXBsaW5nQ29lZiApIHtcclxuXHJcblx0XHR2YXIgaSwgaixcclxuXHRcdFx0aW5kZXgsIGluZGV4Q3VycmVudCwgaW5kZXhOZXh0LFxyXG5cdFx0XHRsaW5lYXJEaXN0YW5jZSwgcmVhbERpc3RhbmNlLFxyXG5cdFx0XHRzYW1wbGluZywgcG9zaXRpb24sXHJcblx0XHRcdG5ld3BvaW50cyA9IFtdLFxyXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG5cdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdGZvciAoIGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0XHQvL3RtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSAtIDEgXSApO1xyXG5cdFx0XHQvL2xpbmVhckRpc3RhbmNlID0gdG1wVmVjLmRpc3RhbmNlVG8oIHRoaXMucG9pbnRzWyBpIF0gKTtcclxuXHJcblx0XHRcdHJlYWxEaXN0YW5jZSA9IHNsLmNodW5rc1sgaSBdIC0gc2wuY2h1bmtzWyBpIC0gMSBdO1xyXG5cclxuXHRcdFx0c2FtcGxpbmcgPSBNYXRoLmNlaWwoIHNhbXBsaW5nQ29lZiAqIHJlYWxEaXN0YW5jZSAvIHNsLnRvdGFsICk7XHJcblxyXG5cdFx0XHRpbmRleEN1cnJlbnQgPSAoIGkgLSAxICkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcclxuXHRcdFx0aW5kZXhOZXh0ID0gaSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDE7IGogPCBzYW1wbGluZyAtIDE7IGorKyApIHtcclxuXHJcblx0XHRcdFx0aW5kZXggPSBpbmRleEN1cnJlbnQgKyBqICogKCAxIC8gc2FtcGxpbmcgKSAqICggaW5kZXhOZXh0IC0gaW5kZXhDdXJyZW50ICk7XHJcblxyXG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcclxuXHRcdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHBvc2l0aW9uICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSBdICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQ2F0bXVsbC1Sb21cclxuXHJcblx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XHJcblxyXG5cdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXHJcblx0XHRcdHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblxyXG5cdFx0cmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlRyaWFuZ2xlID0gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xyXG5cclxuXHR0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5iID0gKCBiICE9PSB1bmRlZmluZWQgKSA/IGIgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuYyA9ICggYyAhPT0gdW5kZWZpbmVkICkgPyBjIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UcmlhbmdsZS5ub3JtYWwgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcclxuXHRcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcclxuXHRcdHJlc3VsdC5jcm9zcyggdjAgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcclxuXHRcdGlmKCByZXN1bHRMZW5ndGhTcSA+IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCByZXN1bHRMZW5ndGhTcSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG4vLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y29vcmRpbmF0ZXNcclxuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcclxuVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0djAuc3ViVmVjdG9ycyggYywgYSApO1xyXG5cdFx0djEuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0djIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcclxuXHJcblx0XHR2YXIgZG90MDAgPSB2MC5kb3QoIHYwICk7XHJcblx0XHR2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XHJcblx0XHR2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XHJcblx0XHR2YXIgZG90MTEgPSB2MS5kb3QoIHYxICk7XHJcblx0XHR2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XHJcblxyXG5cdFx0dmFyIGRlbm9tID0gKCBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSApO1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdC8vIGNvbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXHJcblx0XHRpZiggZGVub20gPT0gMCApIHtcclxuXHRcdFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XHJcblx0XHRcdC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIC0yLCAtMSwgLTEgKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW52RGVub20gPSAxIC8gZGVub207XHJcblx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xyXG5cdFx0dmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcclxuXHJcblx0XHQvLyBiYXJ5Y29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcclxuXHRcdHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XHJcblxyXG5cdFx0cmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVHJpYW5nbGUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCBhICk7XHJcblx0XHR0aGlzLmIuY29weSggYiApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIGMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uICggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCBwb2ludHNbaTBdICk7XHJcblx0XHR0aGlzLmIuY29weSggcG9pbnRzW2kxXSApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIHBvaW50c1tpMl0gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcclxuXHRcdHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFyZWE6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2MC5zdWJWZWN0b3JzKCB0aGlzLmMsIHRoaXMuYiApO1xyXG5cdFx0XHR2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHYwLmNyb3NzKCB2MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWlkcG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICkuYWRkKCB0aGlzLmMgKS5tdWx0aXBseVNjYWxhciggMSAvIDMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBsYW5lOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuUGxhbmUoKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiYXJ5Y29vcmRGcm9tUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVHJpYW5nbGUoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5WZXJ0ZXggPSBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdHJldHVybiBUSFJFRS5vbmVycm9yKCAnVEhSRUUuVmVydGV4IGhhcyBiZWVuIERFUFJFQ0FURUQuIFVzZSBUSFJFRS5WZWN0b3IzIGluc3RlYWQuJyApO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlVWID0gZnVuY3Rpb24gKCB1LCB2ICkge1xyXG5cclxuXHRUSFJFRS5vbmVycm9yKCAnVEhSRUUuVVYgaGFzIGJlZW4gREVQUkVDQVRFRC4gVXNlIFRIUkVFLlZlY3RvcjIgaW5zdGVhZC4nKVxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkNsb2NrID0gZnVuY3Rpb24gKCBhdXRvU3RhcnQgKSB7XHJcblxyXG5cdHRoaXMuYXV0b1N0YXJ0ID0gKCBhdXRvU3RhcnQgIT09IHVuZGVmaW5lZCApID8gYXV0b1N0YXJ0IDogdHJ1ZTtcclxuXHJcblx0dGhpcy5zdGFydFRpbWUgPSAwO1xyXG5cdHRoaXMub2xkVGltZSA9IDA7XHJcblx0dGhpcy5lbGFwc2VkVGltZSA9IDA7XHJcblxyXG5cdHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNsb2NrLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkNsb2NrLFxyXG5cclxuXHRzdGFydDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHNlbGYucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHRcdD8gc2VsZi5wZXJmb3JtYW5jZS5ub3coKVxyXG5cdFx0XHRcdFx0OiBEYXRlLm5vdygpO1xyXG5cclxuXHRcdHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xyXG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xyXG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5nZXREZWx0YSgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldERlbHRhOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRpZmYgPSAwO1xyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnN0YXJ0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ydW5uaW5nICkge1xyXG5cclxuXHRcdFx0dmFyIG5ld1RpbWUgPSBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZFxyXG5cdFx0XHRcdFx0PyBzZWxmLnBlcmZvcm1hbmNlLm5vdygpXHJcblx0XHRcdFx0XHQ6IERhdGUubm93KCk7XHJcblxyXG5cdFx0XHRkaWZmID0gMC4wMDEgKiAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKTtcclxuXHRcdFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcclxuXHJcblx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRpZmY7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXHJcbiAqL1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge31cclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5FdmVudERpc3BhdGNoZXIsXHJcblxyXG5cdGFwcGx5OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHRcdG9iamVjdC5oYXNFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNFdmVudExpc3RlbmVyO1xyXG5cdFx0b2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcblx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcclxuXHJcblx0fSxcclxuXHJcblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0XHRsaXN0ZW5lckFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgYXJyYXkgPSBbXTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xyXG5cclxuXHRcdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XHJcblxyXG5cdFx0XHRcdHZhciBsZW5ndGggPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5WyBpIF0gPSBsaXN0ZW5lckFycmF5WyBpIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb20vXHJcbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24gKCBUSFJFRSApIHtcclxuXHJcblx0VEhSRUUuUmF5Y2FzdGVyID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHRoaXMucmF5ID0gbmV3IFRIUkVFLlJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXHJcblxyXG5cdFx0dGhpcy5uZWFyID0gbmVhciB8fCAwO1xyXG5cdFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblx0dmFyIGxvY2FsUmF5ID0gbmV3IFRIUkVFLlJheSgpO1xyXG5cdHZhciBmYWNlUGxhbmUgPSBuZXcgVEhSRUUuUGxhbmUoKTtcclxuXHR2YXIgaW50ZXJzZWN0UG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0dmFyIGRlc2NTb3J0ID0gZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHZBID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBpbnRlcnNlY3RPYmplY3QgPSBmdW5jdGlvbiAoIG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xyXG5cclxuXHRcdFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHJcblx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkuZGlzdGFuY2VUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0aWYgKCBkaXN0YW5jZSA+IG9iamVjdC5zY2FsZS54ICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0cG9pbnQ6IG9iamVjdC5wb3NpdGlvbixcclxuXHRcdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTE9EICkge1xyXG5cclxuXHRcdFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggbWF0cml4UG9zaXRpb24gKTtcclxuXHJcblx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0LmdldE9iamVjdEZvckRpc3RhbmNlKCBkaXN0YW5jZSApLCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuXHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaXNJbnRlcnNlY3Rpb25TcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDaGVjayBib3VuZGluZ0JveCBiZWZvcmUgY29udGludWluZ1xyXG5cdFx0XHRcclxuXHRcdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBvYmplY3QubWF0cml4V29ybGQgKTsgIFxyXG5cdFx0XHRsb2NhbFJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGxvY2FsUmF5LmlzSW50ZXJzZWN0aW9uQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApICB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gXHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcblx0XHRcdFx0dmFyIGEsIGIsIGM7XHJcblx0XHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5wcmVjaXNpb247XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcclxuXHRcdFx0XHRcdHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleC5hcnJheTtcclxuXHRcdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBvaSA9IDAsIG9sID0gb2Zmc2V0cy5sZW5ndGg7IG9pIDwgb2w7ICsrb2kgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgc3RhcnQgPSBvZmZzZXRzWyBvaSBdLnN0YXJ0O1xyXG5cdFx0XHRcdFx0XHR2YXIgY291bnQgPSBvZmZzZXRzWyBvaSBdLmNvdW50O1xyXG5cdFx0XHRcdFx0XHR2YXIgaW5kZXggPSBvZmZzZXRzWyBvaSBdLmluZGV4O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0YSA9IGluZGV4ICsgaW5kaWNlc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRcdGIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07IFxyXG5cdFx0XHRcdFx0XHRcdGMgPSBpbmRleCArIGluZGljZXNbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZBLnNldChcclxuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uc1sgYSAqIDMgXSxcclxuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uc1sgYSAqIDMgKyAxIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbnNbIGEgKiAzICsgMiBdXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHR2Qi5zZXQoXHJcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbnNbIGIgKiAzIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbnNbIGIgKiAzICsgMSBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25zWyBiICogMyArIDIgXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0dkMuc2V0KFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25zWyBjICogMyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25zWyBjICogMyArIDEgXSxcclxuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uc1sgYyAqIDMgKyAyIF1cclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xyXG5cdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gbG9jYWxSYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZDLCB2QiwgdkEsIHRydWUgKTsgXHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gbG9jYWxSYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZBLCB2QiwgdkMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvblBvaW50ID09PSBudWxsICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCBwcmVjaXNpb24gfHwgZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdGlvblBvaW50LFxyXG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlczogW2EsIGIsIGNdLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcclxuXHRcdFx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdDogb2JqZWN0XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIG9mZnNldHMgPSBnZW9tZXRyeS5vZmZzZXRzO1xyXG5cdFx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGEgPSBpO1xyXG5cdFx0XHRcdFx0XHRiID0gaSArIDE7XHJcblx0XHRcdFx0XHRcdGMgPSBpICsgMjtcclxuXHJcblx0XHRcdFx0XHRcdHZBLnNldChcclxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbnNbIGEgKiAzIF0sXHJcblx0XHRcdFx0XHRcdFx0cG9zaXRpb25zWyBhICogMyArIDEgXSxcclxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbnNbIGEgKiAzICsgMiBdXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdHZCLnNldChcclxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbnNbIGIgKiAzIF0sXHJcblx0XHRcdFx0XHRcdFx0cG9zaXRpb25zWyBiICogMyArIDEgXSxcclxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbnNbIGIgKiAzICsgMiBdXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdHZDLnNldChcclxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbnNbIGMgKiAzIF0sXHJcblx0XHRcdFx0XHRcdFx0cG9zaXRpb25zWyBjICogMyArIDEgXSxcclxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbnNbIGMgKiAzICsgMiBdXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcclxuXHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBsb2NhbFJheS5pbnRlcnNlY3RUcmlhbmdsZSggdkMsIHZCLCB2QSwgdHJ1ZSApOyBcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IGxvY2FsUmF5LmludGVyc2VjdFRyaWFuZ2xlKCB2QSwgdkIsIHZDLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvblBvaW50ID09PSBudWxsICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb25Qb2ludC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCBwcmVjaXNpb24gfHwgZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdGlvblBvaW50LFxyXG5cdFx0XHRcdFx0XHRcdGluZGljZXM6IFthLCBiLCBjXSxcclxuXHRcdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcclxuXHRcdFx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdFxyXG5cclxuXHRcdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGlzRmFjZU1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtcclxuXHRcdFx0XHR2YXIgb2JqZWN0TWF0ZXJpYWxzID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzIDogbnVsbDtcclxuXHJcblx0XHRcdFx0dmFyIGEsIGIsIGMsIGQ7XHJcblx0XHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5wcmVjaXNpb247XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGZhY2UgPSBnZW9tZXRyeS5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gb2JqZWN0TWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXSA6IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRhID0gdmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0YiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdGMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xyXG5cdFx0XHRcdFx0XHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuXHJcblx0XHRcdFx0XHRcdHZBLnNldCggMCwgMCwgMCApO1xyXG5cdFx0XHRcdFx0XHR2Qi5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0XHRcdFx0dkMuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyB0IF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZBLnggKz0gKCB0YXJnZXRzWyBmYWNlLmEgXS54IC0gYS54ICkgKiBpbmZsdWVuY2U7XHJcblx0XHRcdFx0XHRcdFx0dkEueSArPSAoIHRhcmdldHNbIGZhY2UuYSBdLnkgLSBhLnkgKSAqIGluZmx1ZW5jZTtcclxuXHRcdFx0XHRcdFx0XHR2QS56ICs9ICggdGFyZ2V0c1sgZmFjZS5hIF0ueiAtIGEueiApICogaW5mbHVlbmNlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2Qi54ICs9ICggdGFyZ2V0c1sgZmFjZS5iIF0ueCAtIGIueCApICogaW5mbHVlbmNlO1xyXG5cdFx0XHRcdFx0XHRcdHZCLnkgKz0gKCB0YXJnZXRzWyBmYWNlLmIgXS55IC0gYi55ICkgKiBpbmZsdWVuY2U7XHJcblx0XHRcdFx0XHRcdFx0dkIueiArPSAoIHRhcmdldHNbIGZhY2UuYiBdLnogLSBiLnogKSAqIGluZmx1ZW5jZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0dkMueCArPSAoIHRhcmdldHNbIGZhY2UuYyBdLnggLSBjLnggKSAqIGluZmx1ZW5jZTtcclxuXHRcdFx0XHRcdFx0XHR2Qy55ICs9ICggdGFyZ2V0c1sgZmFjZS5jIF0ueSAtIGMueSApICogaW5mbHVlbmNlO1xyXG5cdFx0XHRcdFx0XHRcdHZDLnogKz0gKCB0YXJnZXRzWyBmYWNlLmMgXS56IC0gYy56ICkgKiBpbmZsdWVuY2U7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR2QS5hZGQoIGEgKTtcclxuXHRcdFx0XHRcdFx0dkIuYWRkKCBiICk7XHJcblx0XHRcdFx0XHRcdHZDLmFkZCggYyApO1xyXG5cclxuXHRcdFx0XHRcdFx0YSA9IHZBO1xyXG5cdFx0XHRcdFx0XHRiID0gdkI7XHJcblx0XHRcdFx0XHRcdGMgPSB2QztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcclxuXHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gbG9jYWxSYXkuaW50ZXJzZWN0VHJpYW5nbGUoIGMsIGIsIGEsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IGxvY2FsUmF5LmludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uUG9pbnQgPT09IG51bGwgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb25Qb2ludC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHByZWNpc2lvbiB8fCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG5cdFx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0aW9uUG9pbnQsXHJcblx0XHRcdFx0XHRcdGZhY2U6IGZhY2UsXHJcblx0XHRcdFx0XHRcdGZhY2VJbmRleDogZixcclxuXHRcdFx0XHRcdFx0b2JqZWN0OiBvYmplY3RcclxuXHJcblx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xyXG5cdFx0XHR2YXIgcHJlY2lzaW9uU3EgPSBwcmVjaXNpb24gKiBwcmVjaXNpb247XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcblx0XHRcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xyXG5cdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHJcblx0XHRcdGlmICggcmF5Y2FzdGVyLnJheS5pc0ludGVyc2VjdGlvblNwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdGxvY2FsUmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcclxuXHJcblx0XHRcdC8qIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdH0gZWxzZSAqLyBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0XHRcdHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xyXG5cdFx0XHRcdHZhciBpbnRlclNlZ21lbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRcdHZhciBpbnRlclJheSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdFx0dmFyIHN0ZXAgPSBvYmplY3QudHlwZSA9PT0gVEhSRUUuTGluZVN0cmlwID8gMSA6IDI7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5iVmVydGljZXMgLSAxOyBpID0gaSArIHN0ZXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGRpc3RTcSA9IGxvY2FsUmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IGxvY2FsUmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRcdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XHJcblx0XHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxyXG5cdFx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKSxcclxuXHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcclxuXHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxyXG5cdFx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdFxyXG5cclxuXHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGludGVyc2VjdERlc2NlbmRhbnRzID0gZnVuY3Rpb24gKCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHR2YXIgZGVzY2VuZGFudHMgPSBvYmplY3QuZ2V0RGVzY2VuZGFudHMoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBkZXNjZW5kYW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBkZXNjZW5kYW50c1sgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHJcblx0VEhSRUUuUmF5Y2FzdGVyLnByb3RvdHlwZS5wcmVjaXNpb24gPSAwLjAwMDE7XHJcblx0VEhSRUUuUmF5Y2FzdGVyLnByb3RvdHlwZS5saW5lUHJlY2lzaW9uID0gMTtcclxuXHJcblx0VEhSRUUuUmF5Y2FzdGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuXHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXHJcblxyXG5cdH07XHJcblxyXG5cdFRIUkVFLlJheWNhc3Rlci5wcm90b3R5cGUuaW50ZXJzZWN0T2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xyXG5cclxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0aW50ZXJzZWN0RGVzY2VuZGFudHMoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cyApO1xyXG5cclxuXHRcdGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcclxuXHJcblx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0fTtcclxuXHJcblx0VEhSRUUuUmF5Y2FzdGVyLnByb3RvdHlwZS5pbnRlcnNlY3RPYmplY3RzID0gZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0dmFyIGludGVyc2VjdHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cyApO1xyXG5cclxuXHRcdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdERlc2NlbmRhbnRzKCBvYmplY3RzWyBpIF0sIHRoaXMsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xyXG5cclxuXHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHR9O1xyXG5cclxufSggVEhSRUUgKSApO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLk9iamVjdDNEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmlkID0gVEhSRUUuT2JqZWN0M0RJZENvdW50ICsrO1xyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIk9iamVjdDNEXCI7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHR0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuXHR0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG5cdHRoaXMudXAgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLl9yb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigpO1xyXG5cdHRoaXMuX3F1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cdHRoaXMuc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApO1xyXG5cclxuXHQvLyBrZWVwIHJvdGF0aW9uIGFuZCBxdWF0ZXJuaW9uIGluIHN5bmNcclxuXHJcblx0dGhpcy5fcm90YXRpb24uX3F1YXRlcm5pb24gPSB0aGlzLnF1YXRlcm5pb247XHJcblx0dGhpcy5fcXVhdGVybmlvbi5fZXVsZXIgPSB0aGlzLnJvdGF0aW9uO1xyXG5cclxuXHR0aGlzLnJlbmRlckRlcHRoID0gbnVsbDtcclxuXHJcblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XHJcblx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XHJcblx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XHJcblxyXG5cdHRoaXMudXNlckRhdGEgPSB7fTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0M0QsXHJcblx0XHJcblx0Z2V0IHJvdGF0aW9uICgpIHsgXHJcblx0XHRyZXR1cm4gdGhpcy5fcm90YXRpb247IFxyXG5cdH0sXHJcblxyXG5cdHNldCByb3RhdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0XHJcblx0XHR0aGlzLl9yb3RhdGlvbiA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fcm90YXRpb24uX3F1YXRlcm5pb24gPSB0aGlzLl9xdWF0ZXJuaW9uO1xyXG5cdFx0dGhpcy5fcXVhdGVybmlvbi5fZXVsZXIgPSB0aGlzLl9yb3RhdGlvbjtcclxuXHRcdHRoaXMuX3JvdGF0aW9uLl91cGRhdGVRdWF0ZXJuaW9uKCk7XHJcblx0XHRcclxuXHR9LFxyXG5cclxuXHRnZXQgcXVhdGVybmlvbiAoKSB7IFxyXG5cdFx0cmV0dXJuIHRoaXMuX3F1YXRlcm5pb247IFxyXG5cdH0sXHJcblx0XHJcblx0c2V0IHF1YXRlcm5pb24gKCB2YWx1ZSApIHtcclxuXHRcdFxyXG5cdFx0dGhpcy5fcXVhdGVybmlvbiA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fcXVhdGVybmlvbi5fZXVsZXIgPSB0aGlzLl9yb3RhdGlvbjtcclxuXHRcdHRoaXMuX3JvdGF0aW9uLl9xdWF0ZXJuaW9uID0gdGhpcy5fcXVhdGVybmlvbjtcclxuXHRcdHRoaXMuX3F1YXRlcm5pb24uX3VwZGF0ZUV1bGVyKCk7XHJcblx0XHRcclxuXHR9LFxyXG5cclxuXHRnZXQgZXVsZXJPcmRlciAoKSB7XHJcblxyXG5cdFx0VEhSRUUub253YXJuaW5nKCAnREVQUkVDQVRFRDogT2JqZWN0M0RcXCdzIC5ldWxlck9yZGVyIGhhcyBiZWVuIG1vdmVkIHRvIE9iamVjdDNEXFwncyAucm90YXRpb24ub3JkZXIuJyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgZXVsZXJPcmRlciAoIHZhbHVlICkge1xyXG5cclxuXHRcdFRIUkVFLm9ud2FybmluZyggJ0RFUFJFQ0FURUQ6IE9iamVjdDNEXFwncyAuZXVsZXJPcmRlciBoYXMgYmVlbiBtb3ZlZCB0byBPYmplY3QzRFxcJ3MgLnJvdGF0aW9uLm9yZGVyLicgKTtcclxuXHJcblx0XHR0aGlzLnJvdGF0aW9uLm9yZGVyID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB1c2VRdWF0ZXJuaW9uICgpIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoICdERVBSRUNBVEVEOiBPYmplY3QzRFxcJ3MgLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB1c2VRdWF0ZXJuaW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0VEhSRUUub253YXJuaW5nKCAnREVQUkVDQVRFRDogT2JqZWN0M0RcXCdzIC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0cm90YXRlT25BeGlzOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXHJcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuXHRcdHZhciBxMSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBxMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2VcclxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBheGlzLCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHYxLmNvcHkoIGF4aXMgKTtcclxuXHJcblx0XHRcdHYxLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XHJcblxyXG5cdFx0XHR0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggZGlzdGFuY2UsIGF4aXMgKSB7XHJcblxyXG5cdFx0VEhSRUUub253YXJuaW5nKCAnREVQUkVDQVRFRDogT2JqZWN0M0RcXCdzIC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLiBOb3RlIGFyZ3MgaGF2ZSBiZWVuIGNoYW5nZWQuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGVZOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRsb2NhbFRvV29ybGQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIG0xLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXHJcblxyXG5cdFx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRtMS5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5vbndhcm5pbmcoICdUSFJFRS5PYmplY3QzRC5hZGQ6IEFuIG9iamVjdCBjYW5cXCd0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHQvLyBhZGQgdG8gc2NlbmVcclxuXHJcblx0XHRcdHZhciBzY2VuZSA9IHRoaXM7XHJcblxyXG5cdFx0XHR3aGlsZSAoIHNjZW5lLnBhcmVudCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY2VuZSA9IHNjZW5lLnBhcmVudDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggc2NlbmUgIT09IHVuZGVmaW5lZCAmJiBzY2VuZSBpbnN0YW5jZW9mIFRIUkVFLlNjZW5lICkgIHtcclxuXHJcblx0XHRcdFx0c2NlbmUuX19hZGRPYmplY3QoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdyZW1vdmVkJyB9ICk7XHJcblxyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSBmcm9tIHNjZW5lXHJcblxyXG5cdFx0XHR2YXIgc2NlbmUgPSB0aGlzO1xyXG5cclxuXHRcdFx0d2hpbGUgKCBzY2VuZS5wYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NlbmUgPSBzY2VuZS5wYXJlbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lICE9PSB1bmRlZmluZWQgJiYgc2NlbmUgaW5zdGFuY2VvZiBUSFJFRS5TY2VuZSApIHtcclxuXHJcblx0XHRcdFx0c2NlbmUuX19yZW1vdmVPYmplY3QoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dHJhdmVyc2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiAoIGlkLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBjaGlsZC5pZCA9PT0gaWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRjaGlsZCA9IGNoaWxkLmdldE9iamVjdEJ5SWQoIGlkLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRPYmplY3RCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcclxuXHJcblx0XHRcdGlmICggY2hpbGQubmFtZSA9PT0gbmFtZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNoaWxkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGNoaWxkID0gY2hpbGQuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDaGlsZEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0VEhSRUUub253YXJuaW5nKCAnREVQUkVDQVRFRDogT2JqZWN0M0RcXCdzIC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicgKTtcclxuXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5TmFtZSggbmFtZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldERlc2NlbmRhbnRzOiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcblxyXG5cdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIGFycmF5LCB0aGlzLmNoaWxkcmVuICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5jaGlsZHJlblsgaSBdLmdldERlc2NlbmRhbnRzKCBhcnJheSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZU1hdHJpeDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoIGZvcmNlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcclxuXHJcblx0XHRvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcblx0XHRvYmplY3QudXAuY29weSggdGhpcy51cCApO1xyXG5cclxuXHRcdG9iamVjdC5wb3NpdGlvbi5jb3B5KCB0aGlzLnBvc2l0aW9uICk7XHJcblx0XHRvYmplY3QucXVhdGVybmlvbi5jb3B5KCB0aGlzLnF1YXRlcm5pb24gKTtcclxuXHRcdG9iamVjdC5zY2FsZS5jb3B5KCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdFx0b2JqZWN0LnJlbmRlckRlcHRoID0gdGhpcy5yZW5kZXJEZXB0aDtcclxuXHJcblx0XHRvYmplY3Qucm90YXRpb25BdXRvVXBkYXRlID0gdGhpcy5yb3RhdGlvbkF1dG9VcGRhdGU7XHJcblxyXG5cdFx0b2JqZWN0Lm1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cdFx0b2JqZWN0Lm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRoaXMubWF0cml4QXV0b1VwZGF0ZTtcclxuXHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xyXG5cclxuXHRcdG9iamVjdC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG5cclxuXHRcdG9iamVjdC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xyXG5cdFx0b2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XHJcblxyXG5cdFx0b2JqZWN0LmZydXN0dW1DdWxsZWQgPSB0aGlzLmZydXN0dW1DdWxsZWQ7XHJcblxyXG5cdFx0b2JqZWN0LnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSApO1xyXG5cclxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcclxuXHRcdFx0XHRvYmplY3QuYWRkKCBjaGlsZC5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvYmplY3Q7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk9iamVjdDNESWRDb3VudCA9IDA7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBqdWxpYW53YSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWxpYW53YVxyXG4gKi9cclxuXHJcblRIUkVFLlByb2plY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIF9vYmplY3QsIF9vYmplY3RDb3VudCwgX29iamVjdFBvb2wgPSBbXSwgX29iamVjdFBvb2xMZW5ndGggPSAwLFxyXG5cdF92ZXJ0ZXgsIF92ZXJ0ZXhDb3VudCwgX3ZlcnRleFBvb2wgPSBbXSwgX3ZlcnRleFBvb2xMZW5ndGggPSAwLFxyXG5cdF9mYWNlLCBfZmFjZUNvdW50LCBfZmFjZVBvb2wgPSBbXSwgX2ZhY2VQb29sTGVuZ3RoID0gMCxcclxuXHRfbGluZSwgX2xpbmVDb3VudCwgX2xpbmVQb29sID0gW10sIF9saW5lUG9vbExlbmd0aCA9IDAsXHJcblx0X3Nwcml0ZSwgX3Nwcml0ZUNvdW50LCBfc3ByaXRlUG9vbCA9IFtdLCBfc3ByaXRlUG9vbExlbmd0aCA9IDAsXHJcblxyXG5cdF9yZW5kZXJEYXRhID0geyBvYmplY3RzOiBbXSwgbGlnaHRzOiBbXSwgZWxlbWVudHM6IFtdIH0sXHJcblxyXG5cdF92QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0X3ZCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRfdkMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHRfdmVjdG9yMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0X3ZlY3RvcjQgPSBuZXcgVEhSRUUuVmVjdG9yNCgpLFxyXG5cclxuXHRfY2xpcEJveCA9IG5ldyBUSFJFRS5Cb3gzKCBuZXcgVEhSRUUuVmVjdG9yMyggLTEsIC0xLCAtMSApLCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApICksXHJcblx0X2JvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKSxcclxuXHRfcG9pbnRzMyA9IG5ldyBBcnJheSggMyApLFxyXG5cdF9wb2ludHM0ID0gbmV3IEFycmF5KCA0ICksXHJcblxyXG5cdF92aWV3TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHRfdmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuXHRfbW9kZWxNYXRyaXgsXHJcblx0X21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuXHRfbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKSxcclxuXHJcblx0X2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxyXG5cclxuXHRfY2xpcHBlZFZlcnRleDFQb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCksXHJcblx0X2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xyXG5cclxuXHR0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuXHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0X3ZpZXdQcm9qZWN0aW9uTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIF92aWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnVucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcHJvamVjdGlvbk1hdHJpeEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuXHRcdFx0cHJvamVjdGlvbk1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHRcdFx0X3ZpZXdQcm9qZWN0aW9uTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZCwgcHJvamVjdGlvbk1hdHJpeEludmVyc2UgKTtcclxuXHJcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCk7XHJcblxyXG5cdHRoaXMucGlja2luZ1JheSA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0Ly8gc2V0IHR3byB2ZWN0b3JzIHdpdGggb3Bwb3NpbmcgeiB2YWx1ZXNcclxuXHRcdHZlY3Rvci56ID0gLTEuMDtcclxuXHRcdHZhciBlbmQgPSBuZXcgVEhSRUUuVmVjdG9yMyggdmVjdG9yLngsIHZlY3Rvci55LCAxLjAgKTtcclxuXHJcblx0XHR0aGlzLnVucHJvamVjdFZlY3RvciggdmVjdG9yLCBjYW1lcmEgKTtcclxuXHRcdHRoaXMudW5wcm9qZWN0VmVjdG9yKCBlbmQsIGNhbWVyYSApO1xyXG5cclxuXHRcdC8vIGZpbmQgZGlyZWN0aW9uIGZyb20gdmVjdG9yIHRvIGVuZFxyXG5cdFx0ZW5kLnN1YiggdmVjdG9yICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5SYXljYXN0ZXIoIHZlY3RvciwgZW5kICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBwcm9qZWN0T2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcclxuXHJcblx0XHRcdF9yZW5kZXJEYXRhLmxpZ2h0cy5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdF9vYmplY3QgPSBnZXROZXh0T2JqZWN0SW5Qb29sKCk7XHJcblx0XHRcdFx0X29iamVjdC5pZCA9IG9iamVjdC5pZDtcclxuXHRcdFx0XHRfb2JqZWN0Lm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QucmVuZGVyRGVwdGggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0X29iamVjdC56ID0gb2JqZWN0LnJlbmRlckRlcHRoO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHRfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF92aWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cdFx0XHRcdFx0X29iamVjdC56ID0gX3ZlY3RvcjMuejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfcmVuZGVyRGF0YS5vYmplY3RzLnB1c2goIF9vYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRwcm9qZWN0T2JqZWN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHByb2plY3RHcmFwaCA9IGZ1bmN0aW9uICggcm9vdCwgc29ydE9iamVjdHMgKSB7XHJcblxyXG5cdFx0X29iamVjdENvdW50ID0gMDtcclxuXHJcblx0XHRfcmVuZGVyRGF0YS5vYmplY3RzLmxlbmd0aCA9IDA7XHJcblx0XHRfcmVuZGVyRGF0YS5saWdodHMubGVuZ3RoID0gMDtcclxuXHJcblx0XHRwcm9qZWN0T2JqZWN0KCByb290ICk7XHJcblxyXG5cdFx0aWYgKCBzb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdF9yZW5kZXJEYXRhLm9iamVjdHMuc29ydCggcGFpbnRlclNvcnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBSZW5kZXJMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBub3JtYWxzID0gW107XHJcblxyXG5cdFx0dmFyIG9iamVjdCA9IG51bGw7XHJcblx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuXHJcblx0XHR2YXIgc2V0T2JqZWN0ID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdG9iamVjdCA9IHZhbHVlO1xyXG5cdFx0XHRub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdG5vcm1hbHMubGVuZ3RoID0gMDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBwcm9qZWN0VmVydGV4ID0gZnVuY3Rpb24gKCB2ZXJ0ZXggKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSB2ZXJ0ZXgucG9zaXRpb247XHJcblx0XHRcdHZhciBwb3NpdGlvbldvcmxkID0gdmVydGV4LnBvc2l0aW9uV29ybGQ7XHJcblx0XHRcdHZhciBwb3NpdGlvblNjcmVlbiA9IHZlcnRleC5wb3NpdGlvblNjcmVlbjtcclxuXHJcblx0XHRcdHBvc2l0aW9uV29ybGQuY29weSggcG9zaXRpb24gKS5hcHBseU1hdHJpeDQoIF9tb2RlbE1hdHJpeCApO1xyXG5cdFx0XHRwb3NpdGlvblNjcmVlbi5jb3B5KCBwb3NpdGlvbldvcmxkICkuYXBwbHlNYXRyaXg0KCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdHZhciBpbnZXID0gMSAvIHBvc2l0aW9uU2NyZWVuLnc7XHJcblxyXG5cdFx0XHRwb3NpdGlvblNjcmVlbi54ICo9IGludlc7XHJcblx0XHRcdHBvc2l0aW9uU2NyZWVuLnkgKj0gaW52VztcclxuXHRcdFx0cG9zaXRpb25TY3JlZW4ueiAqPSBpbnZXO1xyXG5cclxuXHRcdFx0dmVydGV4LnZpc2libGUgPSBwb3NpdGlvblNjcmVlbi54ID49IC0xICYmIHBvc2l0aW9uU2NyZWVuLnggPD0gMSAmJlxyXG5cdFx0XHRcdFx0IHBvc2l0aW9uU2NyZWVuLnkgPj0gLTEgJiYgcG9zaXRpb25TY3JlZW4ueSA8PSAxICYmXHJcblx0XHRcdFx0XHQgcG9zaXRpb25TY3JlZW4ueiA+PSAtMSAmJiBwb3NpdGlvblNjcmVlbi56IDw9IDE7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgcHVzaFZlcnRleCA9IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdF92ZXJ0ZXggPSBnZXROZXh0VmVydGV4SW5Qb29sKCk7XHJcblx0XHRcdF92ZXJ0ZXgucG9zaXRpb24uc2V0KCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRwcm9qZWN0VmVydGV4KCBfdmVydGV4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgcHVzaE5vcm1hbCA9IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdG5vcm1hbHMucHVzaCggeCwgeSwgeiApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGNoZWNrVHJpYW5nbGVWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKCB2MSwgdjIsIHYzICkge1xyXG5cclxuXHRcdFx0X3BvaW50czNbIDAgXSA9IHYxLnBvc2l0aW9uU2NyZWVuO1xyXG5cdFx0XHRfcG9pbnRzM1sgMSBdID0gdjIucG9zaXRpb25TY3JlZW47XHJcblx0XHRcdF9wb2ludHMzWyAyIF0gPSB2My5wb3NpdGlvblNjcmVlbjtcclxuXHJcblx0XHRcdGlmICggdjEudmlzaWJsZSA9PT0gdHJ1ZSB8fCB2Mi52aXNpYmxlID09PSB0cnVlIHx8IHYzLnZpc2libGUgPT09IHRydWUgfHxcclxuXHRcdFx0XHRfY2xpcEJveC5pc0ludGVyc2VjdGlvbkJveCggX2JvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIF9wb2ludHMzICkgKSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuICggKCB2My5wb3NpdGlvblNjcmVlbi54IC0gdjEucG9zaXRpb25TY3JlZW4ueCApICpcclxuXHRcdFx0XHRcdCAgICAoIHYyLnBvc2l0aW9uU2NyZWVuLnkgLSB2MS5wb3NpdGlvblNjcmVlbi55ICkgLVxyXG5cdFx0XHRcdFx0ICAgICggdjMucG9zaXRpb25TY3JlZW4ueSAtIHYxLnBvc2l0aW9uU2NyZWVuLnkgKSAqXHJcblx0XHRcdFx0XHQgICAgKCB2Mi5wb3NpdGlvblNjcmVlbi54IC0gdjEucG9zaXRpb25TY3JlZW4ueCApICkgPCAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIHB1c2hMaW5lID0gZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gX3ZlcnRleFBvb2xbIGEgXTtcclxuXHRcdFx0dmFyIHYyID0gX3ZlcnRleFBvb2xbIGIgXTtcclxuXHJcblx0XHRcdF9saW5lID0gZ2V0TmV4dExpbmVJblBvb2woKTtcclxuXHJcblx0XHRcdF9saW5lLmlkID0gb2JqZWN0LmlkO1xyXG5cdFx0XHRfbGluZS52MS5jb3B5KCB2MSApO1xyXG5cdFx0XHRfbGluZS52Mi5jb3B5KCB2MiApO1xyXG5cdFx0XHRfbGluZS56ID0gKCB2MS5wb3NpdGlvblNjcmVlbi56ICsgdjIucG9zaXRpb25TY3JlZW4ueiApIC8gMjtcclxuXHJcblx0XHRcdF9saW5lLm1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0X3JlbmRlckRhdGEuZWxlbWVudHMucHVzaCggX2xpbmUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBwdXNoVHJpYW5nbGUgPSBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0XHR2YXIgdjEgPSBfdmVydGV4UG9vbFsgYSBdO1xyXG5cdFx0XHR2YXIgdjIgPSBfdmVydGV4UG9vbFsgYiBdO1xyXG5cdFx0XHR2YXIgdjMgPSBfdmVydGV4UG9vbFsgYyBdO1xyXG5cclxuXHRcdFx0aWYgKCBjaGVja1RyaWFuZ2xlVmlzaWJpbGl0eSggdjEsIHYyLCB2MyApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRfZmFjZSA9IGdldE5leHRGYWNlSW5Qb29sKCk7XHJcblxyXG5cdFx0XHRcdF9mYWNlLmlkID0gb2JqZWN0LmlkO1xyXG5cdFx0XHRcdF9mYWNlLnYxLmNvcHkoIHYxICk7XHJcblx0XHRcdFx0X2ZhY2UudjIuY29weSggdjIgKTtcclxuXHRcdFx0XHRfZmFjZS52My5jb3B5KCB2MyApO1xyXG5cdFx0XHRcdF9mYWNlLnogPSAoIHYxLnBvc2l0aW9uU2NyZWVuLnogKyB2Mi5wb3NpdGlvblNjcmVlbi56ICsgdjMucG9zaXRpb25TY3JlZW4ueiApIC8gMztcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gYXJndW1lbnRzWyBpIF0gKiAzO1xyXG5cdFx0XHRcdFx0dmFyIG5vcm1hbCA9IF9mYWNlLnZlcnRleE5vcm1hbHNNb2RlbFsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC5zZXQoIG5vcm1hbHNbIG9mZnNldCArIDAgXSwgbm9ybWFsc1sgb2Zmc2V0ICsgMSBdLCBub3JtYWxzWyBvZmZzZXQgKyAyIF0gKTtcclxuXHRcdFx0XHRcdG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9mYWNlLnZlcnRleE5vcm1hbHNMZW5ndGggPSAzO1xyXG5cclxuXHRcdFx0XHRfZmFjZS5tYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0X3JlbmRlckRhdGEuZWxlbWVudHMucHVzaCggX2ZhY2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHNldE9iamVjdDogc2V0T2JqZWN0LFxyXG5cdFx0XHRwcm9qZWN0VmVydGV4OiBwcm9qZWN0VmVydGV4LFxyXG5cdFx0XHRjaGVja1RyaWFuZ2xlVmlzaWJpbGl0eTogY2hlY2tUcmlhbmdsZVZpc2liaWxpdHksXHJcblx0XHRcdHB1c2hWZXJ0ZXg6IHB1c2hWZXJ0ZXgsXHJcblx0XHRcdHB1c2hOb3JtYWw6IHB1c2hOb3JtYWwsXHJcblx0XHRcdHB1c2hMaW5lOiBwdXNoTGluZSxcclxuXHRcdFx0cHVzaFRyaWFuZ2xlOiBwdXNoVHJpYW5nbGVcclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHJlbmRlckxpc3QgPSBuZXcgUmVuZGVyTGlzdCgpO1xyXG5cclxuXHR0aGlzLnByb2plY3RTY2VuZSA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgc29ydE9iamVjdHMsIHNvcnRFbGVtZW50cyApIHtcclxuXHJcblx0XHR2YXIgb2JqZWN0LCBnZW9tZXRyeSwgdmVydGljZXMsIGZhY2VzLCBmYWNlLCBmYWNlVmVydGV4Tm9ybWFscywgZmFjZVZlcnRleFV2cywgdXZzLFxyXG5cdFx0aXNGYWNlTWF0ZXJpYWwsIG9iamVjdE1hdGVyaWFscztcclxuXHJcblx0XHRfZmFjZUNvdW50ID0gMDtcclxuXHRcdF9saW5lQ291bnQgPSAwO1xyXG5cdFx0X3Nwcml0ZUNvdW50ID0gMDtcclxuXHJcblx0XHRfcmVuZGVyRGF0YS5lbGVtZW50cy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdGlmICggc2NlbmUuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IHVuZGVmaW5lZCApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdF92aWV3TWF0cml4LmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcclxuXHRcdF92aWV3UHJvamVjdGlvbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgX3ZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRwcm9qZWN0R3JhcGgoIHNjZW5lLCBzb3J0T2JqZWN0cyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBvID0gMCwgb2wgPSBfcmVuZGVyRGF0YS5vYmplY3RzLmxlbmd0aDsgbyA8IG9sOyBvICsrICkge1xyXG5cclxuXHRcdFx0b2JqZWN0ID0gX3JlbmRlckRhdGEub2JqZWN0c1sgbyBdLm9iamVjdDtcclxuXHRcdFx0Z2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRyZW5kZXJMaXN0LnNldE9iamVjdCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRfbW9kZWxNYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XHJcblxyXG5cdFx0XHRfdmVydGV4Q291bnQgPSAwO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cdFx0XHRcdFx0dmFyIG9mZnNldHMgPSBnZW9tZXRyeS5vZmZzZXRzO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHJlbmRlckxpc3QucHVzaFZlcnRleCggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZW5kZXJMaXN0LnB1c2hOb3JtYWwoIG5vcm1hbHNbIGkgXSwgbm9ybWFsc1sgaSArIDEgXSwgbm9ybWFsc1sgaSArIDIgXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleC5hcnJheTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggb2Zmc2V0cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgbyA9IDA7IG8gPCBvZmZzZXRzLmxlbmd0aDsgbyArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gb2Zmc2V0c1sgbyBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gb2Zmc2V0LmluZGV4O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gb2Zmc2V0LnN0YXJ0LCBsID0gb2Zmc2V0LnN0YXJ0ICsgb2Zmc2V0LmNvdW50OyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoVHJpYW5nbGUoIGluZGljZXNbIGkgXSArIGluZGV4LCBpbmRpY2VzWyBpICsgMSBdICsgaW5kZXgsIGluZGljZXNbIGkgKyAyIF0gKyBpbmRleCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoVHJpYW5nbGUoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZW5kZXJMaXN0LnB1c2hUcmlhbmdsZSggaSwgaSArIDEsIGkgKyAyICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblx0XHRcdFx0XHRmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cdFx0XHRcdFx0ZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XHJcblxyXG5cdFx0XHRcdFx0X25vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIF9tb2RlbE1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdGlzRmFjZU1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtcclxuXHRcdFx0XHRcdG9iamVjdE1hdGVyaWFscyA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gb2JqZWN0Lm1hdGVyaWFsIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgdiA9IDAsIHZsID0gdmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIHYgXTtcclxuXHRcdFx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoVmVydGV4KCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBmID0gMCwgZmwgPSBmYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZhY2UgPSBmYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0XHQ/IG9iamVjdE1hdGVyaWFscy5tYXRlcmlhbHNbIGZhY2UubWF0ZXJpYWxJbmRleCBdXHJcblx0XHRcdFx0XHRcdFx0OiBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBzaWRlID0gbWF0ZXJpYWwuc2lkZTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciB2MSA9IF92ZXJ0ZXhQb29sWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdFx0dmFyIHYyID0gX3ZlcnRleFBvb2xbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgdjMgPSBfdmVydGV4UG9vbFsgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcclxuXHRcdFx0XHRcdFx0XHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHYxcCA9IHYxLnBvc2l0aW9uO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB2MnAgPSB2Mi5wb3NpdGlvbjtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdjNwID0gdjMucG9zaXRpb247XHJcblxyXG5cdFx0XHRcdFx0XHRcdF92QS5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0XHRcdFx0XHRfdkIuc2V0KCAwLCAwLCAwICk7XHJcblx0XHRcdFx0XHRcdFx0X3ZDLnNldCggMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIHQgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0X3ZBLnggKz0gKCB0YXJnZXRzWyBmYWNlLmEgXS54IC0gdjFwLnggKSAqIGluZmx1ZW5jZTtcclxuXHRcdFx0XHRcdFx0XHRcdF92QS55ICs9ICggdGFyZ2V0c1sgZmFjZS5hIF0ueSAtIHYxcC55ICkgKiBpbmZsdWVuY2U7XHJcblx0XHRcdFx0XHRcdFx0XHRfdkEueiArPSAoIHRhcmdldHNbIGZhY2UuYSBdLnogLSB2MXAueiApICogaW5mbHVlbmNlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdF92Qi54ICs9ICggdGFyZ2V0c1sgZmFjZS5iIF0ueCAtIHYycC54ICkgKiBpbmZsdWVuY2U7XHJcblx0XHRcdFx0XHRcdFx0XHRfdkIueSArPSAoIHRhcmdldHNbIGZhY2UuYiBdLnkgLSB2MnAueSApICogaW5mbHVlbmNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0X3ZCLnogKz0gKCB0YXJnZXRzWyBmYWNlLmIgXS56IC0gdjJwLnogKSAqIGluZmx1ZW5jZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRfdkMueCArPSAoIHRhcmdldHNbIGZhY2UuYyBdLnggLSB2M3AueCApICogaW5mbHVlbmNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0X3ZDLnkgKz0gKCB0YXJnZXRzWyBmYWNlLmMgXS55IC0gdjNwLnkgKSAqIGluZmx1ZW5jZTtcclxuXHRcdFx0XHRcdFx0XHRcdF92Qy56ICs9ICggdGFyZ2V0c1sgZmFjZS5jIF0ueiAtIHYzcC56ICkgKiBpbmZsdWVuY2U7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0djEucG9zaXRpb24uYWRkKCBfdkEgKTtcclxuXHRcdFx0XHRcdFx0XHR2Mi5wb3NpdGlvbi5hZGQoIF92QiApO1xyXG5cdFx0XHRcdFx0XHRcdHYzLnBvc2l0aW9uLmFkZCggX3ZDICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHJlbmRlckxpc3QucHJvamVjdFZlcnRleCggdjEgKTtcclxuXHRcdFx0XHRcdFx0XHRyZW5kZXJMaXN0LnByb2plY3RWZXJ0ZXgoIHYyICk7XHJcblx0XHRcdFx0XHRcdFx0cmVuZGVyTGlzdC5wcm9qZWN0VmVydGV4KCB2MyApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHZpc2libGUgPSByZW5kZXJMaXN0LmNoZWNrVHJpYW5nbGVWaXNpYmlsaXR5KCB2MSwgdjIsIHYzICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoICggdmlzaWJsZSA9PT0gZmFsc2UgJiYgc2lkZSA9PT0gVEhSRUUuRnJvbnRTaWRlICkgfHxcclxuXHRcdFx0XHRcdFx0XHQgKCB2aXNpYmxlID09PSB0cnVlICYmIHNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdF9mYWNlID0gZ2V0TmV4dEZhY2VJblBvb2woKTtcclxuXHJcblx0XHRcdFx0XHRcdF9mYWNlLmlkID0gb2JqZWN0LmlkO1xyXG5cdFx0XHRcdFx0XHRfZmFjZS52MS5jb3B5KCB2MSApO1xyXG5cdFx0XHRcdFx0XHRfZmFjZS52Mi5jb3B5KCB2MiApO1xyXG5cdFx0XHRcdFx0XHRfZmFjZS52My5jb3B5KCB2MyApO1xyXG5cclxuXHRcdFx0XHRcdFx0X2ZhY2Uubm9ybWFsTW9kZWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdmlzaWJsZSA9PT0gZmFsc2UgJiYgKCBzaWRlID09PSBUSFJFRS5CYWNrU2lkZSB8fCBzaWRlID09PSBUSFJFRS5Eb3VibGVTaWRlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9mYWNlLm5vcm1hbE1vZGVsLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0X2ZhY2Uubm9ybWFsTW9kZWwuYXBwbHlNYXRyaXgzKCBfbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRfZmFjZS5jZW50cm9pZE1vZGVsLmNvcHkoIGZhY2UuY2VudHJvaWQgKS5hcHBseU1hdHJpeDQoIF9tb2RlbE1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbiA9IDAsIG5sID0gTWF0aC5taW4oIGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aCwgMyApOyBuIDwgbmw7IG4gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBub3JtYWxNb2RlbCA9IF9mYWNlLnZlcnRleE5vcm1hbHNNb2RlbFsgbiBdO1xyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbE1vZGVsLmNvcHkoIGZhY2VWZXJ0ZXhOb3JtYWxzWyBuIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCB2aXNpYmxlID09PSBmYWxzZSAmJiAoIHNpZGUgPT09IFRIUkVFLkJhY2tTaWRlIHx8IHNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxNb2RlbC5uZWdhdGUoKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRub3JtYWxNb2RlbC5hcHBseU1hdHJpeDMoIF9ub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdF9mYWNlLnZlcnRleE5vcm1hbHNMZW5ndGggPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgYyA9IDAsIGNsID0gTWF0aC5taW4oIGZhY2VWZXJ0ZXhVdnMubGVuZ3RoLCAzICk7IGMgPCBjbDsgYyArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dXZzID0gZmFjZVZlcnRleFV2c1sgYyBdWyBmIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdXZzID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIHUgPSAwLCB1bCA9IHV2cy5sZW5ndGg7IHUgPCB1bDsgdSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRfZmFjZS51dnNbIGMgXVsgdSBdID0gdXZzWyB1IF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdF9mYWNlLmNvbG9yID0gZmFjZS5jb2xvcjtcclxuXHRcdFx0XHRcdFx0X2ZhY2UubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRcdF9mYWNlLnogPSAoIHYxLnBvc2l0aW9uU2NyZWVuLnogKyB2Mi5wb3NpdGlvblNjcmVlbi56ICsgdjMucG9zaXRpb25TY3JlZW4ueiApIC8gMztcclxuXHJcblx0XHRcdFx0XHRcdF9yZW5kZXJEYXRhLmVsZW1lbnRzLnB1c2goIF9mYWNlICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZW5kZXJMaXN0LnB1c2hWZXJ0ZXgoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleC5hcnJheTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoTGluZSggaW5kaWNlc1sgaSBdLCBpbmRpY2VzWyBpICsgMSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9ICggcG9zaXRpb25zLmxlbmd0aCAvIDMgKSAtIDE7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHJlbmRlckxpc3QucHVzaExpbmUoIGksIGkgKyAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0X21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggX3ZpZXdQcm9qZWN0aW9uTWF0cml4LCBfbW9kZWxNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0aWNlcyA9IG9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdFx0XHRpZiAoIHZlcnRpY2VzLmxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdHYxID0gZ2V0TmV4dFZlcnRleEluUG9vbCgpO1xyXG5cdFx0XHRcdFx0djEucG9zaXRpb25TY3JlZW4uY29weSggdmVydGljZXNbIDAgXSApLmFwcGx5TWF0cml4NCggX21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHQvLyBIYW5kbGUgTGluZVN0cmlwIGFuZCBMaW5lUGllY2VzXHJcblx0XHRcdFx0XHR2YXIgc3RlcCA9IG9iamVjdC50eXBlID09PSBUSFJFRS5MaW5lUGllY2VzID8gMiA6IDE7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIHYgPSAxLCB2bCA9IHZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0djEgPSBnZXROZXh0VmVydGV4SW5Qb29sKCk7XHJcblx0XHRcdFx0XHRcdHYxLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHZlcnRpY2VzWyB2IF0gKS5hcHBseU1hdHJpeDQoIF9tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoICggdiArIDEgKSAlIHN0ZXAgPiAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHR2MiA9IF92ZXJ0ZXhQb29sWyBfdmVydGV4Q291bnQgLSAyIF07XHJcblxyXG5cdFx0XHRcdFx0XHRfY2xpcHBlZFZlcnRleDFQb3NpdGlvblNjcmVlbi5jb3B5KCB2MS5wb3NpdGlvblNjcmVlbiApO1xyXG5cdFx0XHRcdFx0XHRfY2xpcHBlZFZlcnRleDJQb3NpdGlvblNjcmVlbi5jb3B5KCB2Mi5wb3NpdGlvblNjcmVlbiApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjbGlwTGluZSggX2NsaXBwZWRWZXJ0ZXgxUG9zaXRpb25TY3JlZW4sIF9jbGlwcGVkVmVydGV4MlBvc2l0aW9uU2NyZWVuICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIFBlcmZvcm0gdGhlIHBlcnNwZWN0aXZlIGRpdmlkZVxyXG5cdFx0XHRcdFx0XHRcdF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLm11bHRpcGx5U2NhbGFyKCAxIC8gX2NsaXBwZWRWZXJ0ZXgxUG9zaXRpb25TY3JlZW4udyApO1xyXG5cdFx0XHRcdFx0XHRcdF9jbGlwcGVkVmVydGV4MlBvc2l0aW9uU2NyZWVuLm11bHRpcGx5U2NhbGFyKCAxIC8gX2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4udyApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfbGluZSA9IGdldE5leHRMaW5lSW5Qb29sKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9saW5lLmlkID0gb2JqZWN0LmlkO1xyXG5cdFx0XHRcdFx0XHRcdF9saW5lLnYxLnBvc2l0aW9uU2NyZWVuLmNvcHkoIF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuICk7XHJcblx0XHRcdFx0XHRcdFx0X2xpbmUudjIucG9zaXRpb25TY3JlZW4uY29weSggX2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0X2xpbmUueiA9IE1hdGgubWF4KCBfY2xpcHBlZFZlcnRleDFQb3NpdGlvblNjcmVlbi56LCBfY2xpcHBlZFZlcnRleDJQb3NpdGlvblNjcmVlbi56ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9saW5lLm1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5tYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPT09IFRIUkVFLlZlcnRleENvbG9ycyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRfbGluZS52ZXJ0ZXhDb2xvcnNbIDAgXS5jb3B5KCBvYmplY3QuZ2VvbWV0cnkuY29sb3JzWyB2IF0gKTtcclxuXHRcdFx0XHRcdFx0XHRcdF9saW5lLnZlcnRleENvbG9yc1sgMSBdLmNvcHkoIG9iamVjdC5nZW9tZXRyeS5jb2xvcnNbIHYgLSAxIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRfcmVuZGVyRGF0YS5lbGVtZW50cy5wdXNoKCBfbGluZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xyXG5cclxuXHRcdFx0XHRfdmVjdG9yNC5zZXQoIF9tb2RlbE1hdHJpeC5lbGVtZW50c1sxMl0sIF9tb2RlbE1hdHJpeC5lbGVtZW50c1sxM10sIF9tb2RlbE1hdHJpeC5lbGVtZW50c1sxNF0sIDEgKTtcclxuXHRcdFx0XHRfdmVjdG9yNC5hcHBseU1hdHJpeDQoIF92aWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHR2YXIgaW52VyA9IDEgLyBfdmVjdG9yNC53O1xyXG5cclxuXHRcdFx0XHRfdmVjdG9yNC56ICo9IGludlc7XHJcblxyXG5cdFx0XHRcdGlmICggX3ZlY3RvcjQueiA+PSAtMSAmJiBfdmVjdG9yNC56IDw9IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3Nwcml0ZSA9IGdldE5leHRTcHJpdGVJblBvb2woKTtcclxuXHRcdFx0XHRcdF9zcHJpdGUuaWQgPSBvYmplY3QuaWQ7XHJcblx0XHRcdFx0XHRfc3ByaXRlLnggPSBfdmVjdG9yNC54ICogaW52VztcclxuXHRcdFx0XHRcdF9zcHJpdGUueSA9IF92ZWN0b3I0LnkgKiBpbnZXO1xyXG5cdFx0XHRcdFx0X3Nwcml0ZS56ID0gX3ZlY3RvcjQuejtcclxuXHRcdFx0XHRcdF9zcHJpdGUub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHRcdFx0XHRcdF9zcHJpdGUucm90YXRpb24gPSBvYmplY3Qucm90YXRpb247XHJcblxyXG5cdFx0XHRcdFx0X3Nwcml0ZS5zY2FsZS54ID0gb2JqZWN0LnNjYWxlLnggKiBNYXRoLmFicyggX3Nwcml0ZS54IC0gKCBfdmVjdG9yNC54ICsgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMF0gKSAvICggX3ZlY3RvcjQudyArIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzEyXSApICk7XHJcblx0XHRcdFx0XHRfc3ByaXRlLnNjYWxlLnkgPSBvYmplY3Quc2NhbGUueSAqIE1hdGguYWJzKCBfc3ByaXRlLnkgLSAoIF92ZWN0b3I0LnkgKyBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1s1XSApIC8gKCBfdmVjdG9yNC53ICsgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMTNdICkgKTtcclxuXHJcblx0XHRcdFx0XHRfc3ByaXRlLm1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdF9yZW5kZXJEYXRhLmVsZW1lbnRzLnB1c2goIF9zcHJpdGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHNvcnRFbGVtZW50cyA9PT0gdHJ1ZSApIF9yZW5kZXJEYXRhLmVsZW1lbnRzLnNvcnQoIHBhaW50ZXJTb3J0ICk7XHJcblxyXG5cdFx0cmV0dXJuIF9yZW5kZXJEYXRhO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBQb29sc1xyXG5cclxuXHRmdW5jdGlvbiBnZXROZXh0T2JqZWN0SW5Qb29sKCkge1xyXG5cclxuXHRcdGlmICggX29iamVjdENvdW50ID09PSBfb2JqZWN0UG9vbExlbmd0aCApIHtcclxuXHJcblx0XHRcdHZhciBvYmplY3QgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZU9iamVjdCgpO1xyXG5cdFx0XHRfb2JqZWN0UG9vbC5wdXNoKCBvYmplY3QgKTtcclxuXHRcdFx0X29iamVjdFBvb2xMZW5ndGggKys7XHJcblx0XHRcdF9vYmplY3RDb3VudCArKztcclxuXHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIF9vYmplY3RQb29sWyBfb2JqZWN0Q291bnQgKysgXTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXROZXh0VmVydGV4SW5Qb29sKCkge1xyXG5cclxuXHRcdGlmICggX3ZlcnRleENvdW50ID09PSBfdmVydGV4UG9vbExlbmd0aCApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xyXG5cdFx0XHRfdmVydGV4UG9vbC5wdXNoKCB2ZXJ0ZXggKTtcclxuXHRcdFx0X3ZlcnRleFBvb2xMZW5ndGggKys7XHJcblx0XHRcdF92ZXJ0ZXhDb3VudCArKztcclxuXHRcdFx0cmV0dXJuIHZlcnRleDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIF92ZXJ0ZXhQb29sWyBfdmVydGV4Q291bnQgKysgXTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXROZXh0RmFjZUluUG9vbCgpIHtcclxuXHJcblx0XHRpZiAoIF9mYWNlQ291bnQgPT09IF9mYWNlUG9vbExlbmd0aCApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLlJlbmRlcmFibGVGYWNlKCk7XHJcblx0XHRcdF9mYWNlUG9vbC5wdXNoKCBmYWNlICk7XHJcblx0XHRcdF9mYWNlUG9vbExlbmd0aCArKztcclxuXHRcdFx0X2ZhY2VDb3VudCArKztcclxuXHRcdFx0cmV0dXJuIGZhY2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBfZmFjZVBvb2xbIF9mYWNlQ291bnQgKysgXTtcclxuXHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TmV4dExpbmVJblBvb2woKSB7XHJcblxyXG5cdFx0aWYgKCBfbGluZUNvdW50ID09PSBfbGluZVBvb2xMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR2YXIgbGluZSA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlTGluZSgpO1xyXG5cdFx0XHRfbGluZVBvb2wucHVzaCggbGluZSApO1xyXG5cdFx0XHRfbGluZVBvb2xMZW5ndGggKys7XHJcblx0XHRcdF9saW5lQ291bnQgKytcclxuXHRcdFx0cmV0dXJuIGxpbmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBfbGluZVBvb2xbIF9saW5lQ291bnQgKysgXTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXROZXh0U3ByaXRlSW5Qb29sKCkge1xyXG5cclxuXHRcdGlmICggX3Nwcml0ZUNvdW50ID09PSBfc3ByaXRlUG9vbExlbmd0aCApIHtcclxuXHJcblx0XHRcdHZhciBzcHJpdGUgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVNwcml0ZSgpO1xyXG5cdFx0XHRfc3ByaXRlUG9vbC5wdXNoKCBzcHJpdGUgKTtcclxuXHRcdFx0X3Nwcml0ZVBvb2xMZW5ndGggKys7XHJcblx0XHRcdF9zcHJpdGVDb3VudCArK1xyXG5cdFx0XHRyZXR1cm4gc3ByaXRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gX3Nwcml0ZVBvb2xbIF9zcHJpdGVDb3VudCArKyBdO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIHBhaW50ZXJTb3J0KCBhLCBiICkge1xyXG5cclxuXHRcdGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYi56IC0gYS56O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGEuaWQgIT09IGIuaWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjbGlwTGluZSggczEsIHMyICkge1xyXG5cclxuXHRcdHZhciBhbHBoYTEgPSAwLCBhbHBoYTIgPSAxLFxyXG5cclxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgYm91bmRhcnkgY29vcmRpbmF0ZSBvZiBlYWNoIHZlcnRleCBmb3IgdGhlIG5lYXIgYW5kIGZhciBjbGlwIHBsYW5lcyxcclxuXHRcdC8vIFogPSAtMSBhbmQgWiA9ICsxLCByZXNwZWN0aXZlbHkuXHJcblx0XHRiYzFuZWFyID0gIHMxLnogKyBzMS53LFxyXG5cdFx0YmMybmVhciA9ICBzMi56ICsgczIudyxcclxuXHRcdGJjMWZhciA9ICAtIHMxLnogKyBzMS53LFxyXG5cdFx0YmMyZmFyID0gIC0gczIueiArIHMyLnc7XHJcblxyXG5cdFx0aWYgKCBiYzFuZWFyID49IDAgJiYgYmMybmVhciA+PSAwICYmIGJjMWZhciA+PSAwICYmIGJjMmZhciA+PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gQm90aCB2ZXJ0aWNlcyBsaWUgZW50aXJlbHkgd2l0aGluIGFsbCBjbGlwIHBsYW5lcy5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCBiYzFuZWFyIDwgMCAmJiBiYzJuZWFyIDwgMCkgfHwgKGJjMWZhciA8IDAgJiYgYmMyZmFyIDwgMCApICkge1xyXG5cclxuXHRcdFx0Ly8gQm90aCB2ZXJ0aWNlcyBsaWUgZW50aXJlbHkgb3V0c2lkZSBvbmUgb2YgdGhlIGNsaXAgcGxhbmVzLlxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIFRoZSBsaW5lIHNlZ21lbnQgc3BhbnMgYXQgbGVhc3Qgb25lIGNsaXAgcGxhbmUuXHJcblxyXG5cdFx0XHRpZiAoIGJjMW5lYXIgPCAwICkge1xyXG5cclxuXHRcdFx0XHQvLyB2MSBsaWVzIG91dHNpZGUgdGhlIG5lYXIgcGxhbmUsIHYyIGluc2lkZVxyXG5cdFx0XHRcdGFscGhhMSA9IE1hdGgubWF4KCBhbHBoYTEsIGJjMW5lYXIgLyAoIGJjMW5lYXIgLSBiYzJuZWFyICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJjMm5lYXIgPCAwICkge1xyXG5cclxuXHRcdFx0XHQvLyB2MiBsaWVzIG91dHNpZGUgdGhlIG5lYXIgcGxhbmUsIHYxIGluc2lkZVxyXG5cdFx0XHRcdGFscGhhMiA9IE1hdGgubWluKCBhbHBoYTIsIGJjMW5lYXIgLyAoIGJjMW5lYXIgLSBiYzJuZWFyICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYmMxZmFyIDwgMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gdjEgbGllcyBvdXRzaWRlIHRoZSBmYXIgcGxhbmUsIHYyIGluc2lkZVxyXG5cdFx0XHRcdGFscGhhMSA9IE1hdGgubWF4KCBhbHBoYTEsIGJjMWZhciAvICggYmMxZmFyIC0gYmMyZmFyICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJjMmZhciA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHYyIGxpZXMgb3V0c2lkZSB0aGUgZmFyIHBsYW5lLCB2MiBpbnNpZGVcclxuXHRcdFx0XHRhbHBoYTIgPSBNYXRoLm1pbiggYWxwaGEyLCBiYzFmYXIgLyAoIGJjMWZhciAtIGJjMmZhciApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGFscGhhMiA8IGFscGhhMSApIHtcclxuXHJcblx0XHRcdFx0Ly8gVGhlIGxpbmUgc2VnbWVudCBzcGFucyB0d28gYm91bmRhcmllcywgYnV0IGlzIG91dHNpZGUgYm90aCBvZiB0aGVtLlxyXG5cdFx0XHRcdC8vIChUaGlzIGNhbid0IGhhcHBlbiB3aGVuIHdlJ3JlIG9ubHkgY2xpcHBpbmcgYWdhaW5zdCBqdXN0IG5lYXIvZmFyIGJ1dCBnb29kXHJcblx0XHRcdFx0Ly8gIHRvIGxlYXZlIHRoZSBjaGVjayBoZXJlIGZvciBmdXR1cmUgdXNhZ2UgaWYgb3RoZXIgY2xpcCBwbGFuZXMgYXJlIGFkZGVkLilcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIHMxIGFuZCBzMiB2ZXJ0aWNlcyB0byBtYXRjaCB0aGUgY2xpcHBlZCBsaW5lIHNlZ21lbnQuXHJcblx0XHRcdFx0czEubGVycCggczIsIGFscGhhMSApO1xyXG5cdFx0XHRcdHMyLmxlcnAoIHMxLCAxIC0gYWxwaGEyICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZhY2UzID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHR0aGlzLmEgPSBhO1xyXG5cdHRoaXMuYiA9IGI7XHJcblx0dGhpcy5jID0gYztcclxuXHJcblx0dGhpcy5ub3JtYWwgPSBub3JtYWwgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLnZlcnRleE5vcm1hbHMgPSBub3JtYWwgaW5zdGFuY2VvZiBBcnJheSA/IG5vcm1hbCA6IFsgXTtcclxuXHJcblx0dGhpcy5jb2xvciA9IGNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgPyBjb2xvciA6IG5ldyBUSFJFRS5Db2xvcigpO1xyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gY29sb3IgaW5zdGFuY2VvZiBBcnJheSA/IGNvbG9yIDogW107XHJcblxyXG5cdHRoaXMudmVydGV4VGFuZ2VudHMgPSBbXTtcclxuXHJcblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XHJcblxyXG5cdHRoaXMuY2VudHJvaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZhY2UzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkZhY2UzLFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG5cdFx0ZmFjZS5ub3JtYWwuY29weSggdGhpcy5ub3JtYWwgKTtcclxuXHRcdGZhY2UuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdFx0ZmFjZS5jZW50cm9pZC5jb3B5KCB0aGlzLmNlbnRyb2lkICk7XHJcblxyXG5cdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gdGhpcy5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdHZhciBpLCBpbDtcclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdID0gdGhpcy52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkgZmFjZS52ZXJ0ZXhDb2xvcnNbIGkgXSA9IHRoaXMudmVydGV4Q29sb3JzWyBpIF0uY2xvbmUoKTtcclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4VGFuZ2VudHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSBmYWNlLnZlcnRleFRhbmdlbnRzWyBpIF0gPSB0aGlzLnZlcnRleFRhbmdlbnRzWyBpIF0uY2xvbmUoKTtcclxuXHJcblx0XHRyZXR1cm4gZmFjZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZhY2U0ID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRUSFJFRS5vbndhcm5pbmcoICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicpXHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5pZCA9IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKztcclxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cdHRoaXMuY2xhc3NOYW1lID0gXCJCdWZmZXJHZW9tZXRyeVwiO1xyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHQvLyBhdHRyaWJ1dGVzXHJcblxyXG5cdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHQvLyBvZmZzZXRzIGZvciBjaHVua3Mgd2hlbiB1c2luZyBpbmRleGVkIGVsZW1lbnRzXHJcblxyXG5cdHRoaXMub2Zmc2V0cyA9IFtdO1xyXG5cclxuXHQvLyBib3VuZGluZ3NcclxuXHJcblx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyR2VvbWV0cnksXHJcblxyXG5cdGFkZEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lLCB0eXBlLCBudW1JdGVtcywgaXRlbVNpemUgKSB7XHJcblxyXG5cdFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSB7XHJcblxyXG5cdFx0XHRhcnJheTogbmV3IHR5cGUoIG51bUl0ZW1zICogaXRlbVNpemUgKSxcclxuXHRcdFx0aXRlbVNpemU6IGl0ZW1TaXplXHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bWF0cml4Lm11bHRpcGx5VmVjdG9yM0FycmF5KCBwb3NpdGlvbi5hcnJheSApO1xyXG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBub3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0bm9ybWFsTWF0cml4Lm11bHRpcGx5VmVjdG9yM0FycmF5KCBub3JtYWwuYXJyYXkgKTtcclxuXHRcdFx0bm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzWyBcInBvc2l0aW9uXCIgXS5hcnJheTtcclxuXHJcblx0XHRpZiAoIHBvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3g7XHJcblxyXG5cdFx0XHRpZiggcG9zaXRpb25zLmxlbmd0aCA+PSAzICkge1xyXG5cdFx0XHRcdGJiLm1pbi54ID0gYmIubWF4LnggPSBwb3NpdGlvbnNbIDAgXTtcclxuXHRcdFx0XHRiYi5taW4ueSA9IGJiLm1heC55ID0gcG9zaXRpb25zWyAxIF07XHJcblx0XHRcdFx0YmIubWluLnogPSBiYi5tYXgueiA9IHBvc2l0aW9uc1sgMiBdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDMsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB4ID0gcG9zaXRpb25zWyBpIF07XHJcblx0XHRcdFx0dmFyIHkgPSBwb3NpdGlvbnNbIGkgKyAxIF07XHJcblx0XHRcdFx0dmFyIHogPSBwb3NpdGlvbnNbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdC8vIGJvdW5kaW5nIGJveFxyXG5cclxuXHRcdFx0XHRpZiAoIHggPCBiYi5taW4ueCApIHtcclxuXHJcblx0XHRcdFx0XHRiYi5taW4ueCA9IHg7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHggPiBiYi5tYXgueCApIHtcclxuXHJcblx0XHRcdFx0XHRiYi5tYXgueCA9IHg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB5IDwgYmIubWluLnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0YmIubWluLnkgPSB5O1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB5ID4gYmIubWF4LnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0YmIubWF4LnkgPSB5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggeiA8IGJiLm1pbi56ICkge1xyXG5cclxuXHRcdFx0XHRcdGJiLm1pbi56ID0gejtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggeiA+IGJiLm1heC56ICkge1xyXG5cclxuXHRcdFx0XHRcdGJiLm1heC56ID0gejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHBvc2l0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9ucy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1pbi5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5tYXguc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzWyBcInBvc2l0aW9uXCIgXS5hcnJheTtcclxuXHJcblx0XHRcdGlmICggcG9zaXRpb25zICkge1xyXG5cclxuXHRcdFx0XHRib3gubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdHZlY3Rvci5zZXQoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApO1xyXG5cdFx0XHRcdFx0Ym94LmFkZFBvaW50KCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRib3guY2VudGVyKCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdHZlY3Rvci5zZXQoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApO1xyXG5cdFx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdmVjdG9yICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF0gKSB7XHJcblxyXG5cdFx0XHR2YXIgaSwgaWw7XHJcblx0XHRcdHZhciBqLCBqbDtcclxuXHJcblx0XHRcdHZhciBuVmVydGV4RWxlbWVudHMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdLmFycmF5Lmxlbmd0aDtcclxuXHJcblx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0gPSB7XHJcblxyXG5cdFx0XHRcdFx0aXRlbVNpemU6IDMsXHJcblx0XHRcdFx0XHRhcnJheTogbmV3IEZsb2F0MzJBcnJheSggblZlcnRleEVsZW1lbnRzIClcclxuXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmF0dHJpYnV0ZXNbIFwibm9ybWFsXCIgXS5hcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXNbIFwibm9ybWFsXCIgXS5hcnJheVsgaSBdID0gMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF0uYXJyYXk7XHJcblx0XHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0uYXJyYXk7XHJcblxyXG5cdFx0XHR2YXIgdkEsIHZCLCB2QywgeCwgeSwgeixcclxuXHJcblx0XHRcdHBBID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0cEIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRwQyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdFx0XHRjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdC8vIGluZGV4ZWQgZWxlbWVudHNcclxuXHJcblx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzWyBcImluZGV4XCIgXSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGluZGljZXMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwiaW5kZXhcIiBdLmFycmF5O1xyXG5cclxuXHRcdFx0XHR2YXIgb2Zmc2V0cyA9IHRoaXMub2Zmc2V0cztcclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gb2Zmc2V0cy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBvZmZzZXRzWyBqIF0uc3RhcnQ7XHJcblx0XHRcdFx0XHR2YXIgY291bnQgPSBvZmZzZXRzWyBqIF0uY291bnQ7XHJcblx0XHRcdFx0XHR2YXIgaW5kZXggPSBvZmZzZXRzWyBqIF0uaW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dkEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcclxuXHRcdFx0XHRcdFx0dkIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XHJcblx0XHRcdFx0XHRcdHZDID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IHBvc2l0aW9uc1sgdkEgKiAzIF07XHJcblx0XHRcdFx0XHRcdHkgPSBwb3NpdGlvbnNbIHZBICogMyArIDEgXTtcclxuXHRcdFx0XHRcdFx0eiA9IHBvc2l0aW9uc1sgdkEgKiAzICsgMiBdO1xyXG5cdFx0XHRcdFx0XHRwQS5zZXQoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdFx0XHRcdHggPSBwb3NpdGlvbnNbIHZCICogMyBdO1xyXG5cdFx0XHRcdFx0XHR5ID0gcG9zaXRpb25zWyB2QiAqIDMgKyAxIF07XHJcblx0XHRcdFx0XHRcdHogPSBwb3NpdGlvbnNbIHZCICogMyArIDIgXTtcclxuXHRcdFx0XHRcdFx0cEIuc2V0KCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR4ID0gcG9zaXRpb25zWyB2QyAqIDMgXTtcclxuXHRcdFx0XHRcdFx0eSA9IHBvc2l0aW9uc1sgdkMgKiAzICsgMSBdO1xyXG5cdFx0XHRcdFx0XHR6ID0gcG9zaXRpb25zWyB2QyAqIDMgKyAyIF07XHJcblx0XHRcdFx0XHRcdHBDLnNldCggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xyXG5cdFx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICogMyAgICAgXSArPSBjYi54O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QSAqIDMgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKiAzICsgMiBdICs9IGNiLno7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QiAqIDMgICAgIF0gKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKiAzICsgMSBdICs9IGNiLnk7XHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICogMyArIDIgXSArPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKiAzICAgICBdICs9IGNiLng7XHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDICogMyArIDEgXSArPSBjYi55O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QyAqIDMgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDkgKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IHBvc2l0aW9uc1sgaSBdO1xyXG5cdFx0XHRcdFx0eSA9IHBvc2l0aW9uc1sgaSArIDEgXTtcclxuXHRcdFx0XHRcdHogPSBwb3NpdGlvbnNbIGkgKyAyIF07XHJcblx0XHRcdFx0XHRwQS5zZXQoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdFx0XHR4ID0gcG9zaXRpb25zWyBpICsgMyBdO1xyXG5cdFx0XHRcdFx0eSA9IHBvc2l0aW9uc1sgaSArIDQgXTtcclxuXHRcdFx0XHRcdHogPSBwb3NpdGlvbnNbIGkgKyA1IF07XHJcblx0XHRcdFx0XHRwQi5zZXQoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdFx0XHR4ID0gcG9zaXRpb25zWyBpICsgNiBdO1xyXG5cdFx0XHRcdFx0eSA9IHBvc2l0aW9uc1sgaSArIDcgXTtcclxuXHRcdFx0XHRcdHogPSBwb3NpdGlvbnNbIGkgKyA4IF07XHJcblx0XHRcdFx0XHRwQy5zZXQoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcclxuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xyXG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSAgICAgXSA9IGNiLng7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xyXG5cclxuXHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwibm9ybWFsXCIgXS5hcnJheTtcclxuXHJcblx0XHR2YXIgeCwgeSwgeiwgbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0eCA9IG5vcm1hbHNbIGkgXTtcclxuXHRcdFx0eSA9IG5vcm1hbHNbIGkgKyAxIF07XHJcblx0XHRcdHogPSBub3JtYWxzWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0biA9IDEuMCAvIE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XHJcblxyXG5cdFx0XHRub3JtYWxzWyBpICAgICBdICo9IG47XHJcblx0XHRcdG5vcm1hbHNbIGkgKyAxIF0gKj0gbjtcclxuXHRcdFx0bm9ybWFsc1sgaSArIDIgXSAqPSBuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vY29kZS90YW5nZW50Lmh0bWxcclxuXHRcdC8vIChwZXIgdmVydGV4IHRhbmdlbnRzKVxyXG5cclxuXHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzWyBcImluZGV4XCIgXSA9PT0gdW5kZWZpbmVkIHx8XHJcblx0XHRcdCB0aGlzLmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0IHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0IHRoaXMuYXR0cmlidXRlc1sgXCJ1dlwiIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFRIUkVFLm9ud2FybmluZyggXCJNaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZXMgKGluZGV4LCBwb3NpdGlvbiwgbm9ybWFsIG9yIHV2KSBpbiBCdWZmZXJHZW9tZXRyeS5jb21wdXRlVGFuZ2VudHMoKVwiICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwiaW5kZXhcIiBdLmFycmF5O1xyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF0uYXJyYXk7XHJcblx0XHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdLmFycmF5O1xyXG5cdFx0dmFyIHV2cyA9IHRoaXMuYXR0cmlidXRlc1sgXCJ1dlwiIF0uYXJyYXk7XHJcblxyXG5cdFx0dmFyIG5WZXJ0aWNlcyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xyXG5cclxuXHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzWyBcInRhbmdlbnRcIiBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgblRhbmdlbnRFbGVtZW50cyA9IDQgKiBuVmVydGljZXM7XHJcblxyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNbIFwidGFuZ2VudFwiIF0gPSB7XHJcblxyXG5cdFx0XHRcdGl0ZW1TaXplOiA0LFxyXG5cdFx0XHRcdGFycmF5OiBuZXcgRmxvYXQzMkFycmF5KCBuVGFuZ2VudEVsZW1lbnRzIClcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YW5nZW50cyA9IHRoaXMuYXR0cmlidXRlc1sgXCJ0YW5nZW50XCIgXS5hcnJheTtcclxuXHJcblx0XHR2YXIgdGFuMSA9IFtdLCB0YW4yID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgblZlcnRpY2VzOyBrICsrICkge1xyXG5cclxuXHRcdFx0dGFuMVsgayBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dGFuMlsgayBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHhBLCB5QSwgekEsXHJcblx0XHRcdHhCLCB5QiwgekIsXHJcblx0XHRcdHhDLCB5QywgekMsXHJcblxyXG5cdFx0XHR1QSwgdkEsXHJcblx0XHRcdHVCLCB2QixcclxuXHRcdFx0dUMsIHZDLFxyXG5cclxuXHRcdFx0eDEsIHgyLCB5MSwgeTIsIHoxLCB6MixcclxuXHRcdFx0czEsIHMyLCB0MSwgdDIsIHI7XHJcblxyXG5cdFx0dmFyIHNkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0ZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVUcmlhbmdsZSggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdHhBID0gcG9zaXRpb25zWyBhICogMyBdO1xyXG5cdFx0XHR5QSA9IHBvc2l0aW9uc1sgYSAqIDMgKyAxIF07XHJcblx0XHRcdHpBID0gcG9zaXRpb25zWyBhICogMyArIDIgXTtcclxuXHJcblx0XHRcdHhCID0gcG9zaXRpb25zWyBiICogMyBdO1xyXG5cdFx0XHR5QiA9IHBvc2l0aW9uc1sgYiAqIDMgKyAxIF07XHJcblx0XHRcdHpCID0gcG9zaXRpb25zWyBiICogMyArIDIgXTtcclxuXHJcblx0XHRcdHhDID0gcG9zaXRpb25zWyBjICogMyBdO1xyXG5cdFx0XHR5QyA9IHBvc2l0aW9uc1sgYyAqIDMgKyAxIF07XHJcblx0XHRcdHpDID0gcG9zaXRpb25zWyBjICogMyArIDIgXTtcclxuXHJcblx0XHRcdHVBID0gdXZzWyBhICogMiBdO1xyXG5cdFx0XHR2QSA9IHV2c1sgYSAqIDIgKyAxIF07XHJcblxyXG5cdFx0XHR1QiA9IHV2c1sgYiAqIDIgXTtcclxuXHRcdFx0dkIgPSB1dnNbIGIgKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0dUMgPSB1dnNbIGMgKiAyIF07XHJcblx0XHRcdHZDID0gdXZzWyBjICogMiArIDEgXTtcclxuXHJcblx0XHRcdHgxID0geEIgLSB4QTtcclxuXHRcdFx0eDIgPSB4QyAtIHhBO1xyXG5cclxuXHRcdFx0eTEgPSB5QiAtIHlBO1xyXG5cdFx0XHR5MiA9IHlDIC0geUE7XHJcblxyXG5cdFx0XHR6MSA9IHpCIC0gekE7XHJcblx0XHRcdHoyID0gekMgLSB6QTtcclxuXHJcblx0XHRcdHMxID0gdUIgLSB1QTtcclxuXHRcdFx0czIgPSB1QyAtIHVBO1xyXG5cclxuXHRcdFx0dDEgPSB2QiAtIHZBO1xyXG5cdFx0XHR0MiA9IHZDIC0gdkE7XHJcblxyXG5cdFx0XHRyID0gMS4wIC8gKCBzMSAqIHQyIC0gczIgKiB0MSApO1xyXG5cclxuXHRcdFx0c2Rpci5zZXQoXHJcblx0XHRcdFx0KCB0MiAqIHgxIC0gdDEgKiB4MiApICogcixcclxuXHRcdFx0XHQoIHQyICogeTEgLSB0MSAqIHkyICkgKiByLFxyXG5cdFx0XHRcdCggdDIgKiB6MSAtIHQxICogejIgKSAqIHJcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHRkaXIuc2V0KFxyXG5cdFx0XHRcdCggczEgKiB4MiAtIHMyICogeDEgKSAqIHIsXHJcblx0XHRcdFx0KCBzMSAqIHkyIC0gczIgKiB5MSApICogcixcclxuXHRcdFx0XHQoIHMxICogejIgLSBzMiAqIHoxICkgKiByXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHR0YW4xWyBhIF0uYWRkKCBzZGlyICk7XHJcblx0XHRcdHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcclxuXHRcdFx0dGFuMVsgYyBdLmFkZCggc2RpciApO1xyXG5cclxuXHRcdFx0dGFuMlsgYSBdLmFkZCggdGRpciApO1xyXG5cdFx0XHR0YW4yWyBiIF0uYWRkKCB0ZGlyICk7XHJcblx0XHRcdHRhbjJbIGMgXS5hZGQoIHRkaXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGksIGlsO1xyXG5cdFx0dmFyIGosIGpsO1xyXG5cdFx0dmFyIGlBLCBpQiwgaUM7XHJcblxyXG5cdFx0dmFyIG9mZnNldHMgPSB0aGlzLm9mZnNldHM7XHJcblxyXG5cdFx0Zm9yICggaiA9IDAsIGpsID0gb2Zmc2V0cy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcclxuXHJcblx0XHRcdHZhciBzdGFydCA9IG9mZnNldHNbIGogXS5zdGFydDtcclxuXHRcdFx0dmFyIGNvdW50ID0gb2Zmc2V0c1sgaiBdLmNvdW50O1xyXG5cdFx0XHR2YXIgaW5kZXggPSBvZmZzZXRzWyBqIF0uaW5kZXg7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdGlBID0gaW5kZXggKyBpbmRpY2VzWyBpIF07XHJcblx0XHRcdFx0aUIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XHJcblx0XHRcdFx0aUMgPSBpbmRleCArIGluZGljZXNbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKCBpQSwgaUIsIGlDICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0bXAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHcsIHQsIHRlc3Q7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVmVydGV4KCB2ICkge1xyXG5cclxuXHRcdFx0bi54ID0gbm9ybWFsc1sgdiAqIDMgXTtcclxuXHRcdFx0bi55ID0gbm9ybWFsc1sgdiAqIDMgKyAxIF07XHJcblx0XHRcdG4ueiA9IG5vcm1hbHNbIHYgKiAzICsgMiBdO1xyXG5cclxuXHRcdFx0bjIuY29weSggbiApO1xyXG5cclxuXHRcdFx0dCA9IHRhbjFbIHYgXTtcclxuXHJcblx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXHJcblxyXG5cdFx0XHR0bXAuY29weSggdCApO1xyXG5cdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdC8vIENhbGN1bGF0ZSBoYW5kZWRuZXNzXHJcblxyXG5cdFx0XHR0bXAyLmNyb3NzVmVjdG9ycyggbjIsIHQgKTtcclxuXHRcdFx0dGVzdCA9IHRtcDIuZG90KCB0YW4yWyB2IF0gKTtcclxuXHRcdFx0dyA9ICggdGVzdCA8IDAuMCApID8gLTEuMCA6IDEuMDtcclxuXHJcblx0XHRcdHRhbmdlbnRzWyB2ICogNCAgICAgXSA9IHRtcC54O1xyXG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAxIF0gPSB0bXAueTtcclxuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMiBdID0gdG1wLno7XHJcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDMgXSA9IHc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGogPSAwLCBqbCA9IG9mZnNldHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XHJcblxyXG5cdFx0XHR2YXIgc3RhcnQgPSBvZmZzZXRzWyBqIF0uc3RhcnQ7XHJcblx0XHRcdHZhciBjb3VudCA9IG9mZnNldHNbIGogXS5jb3VudDtcclxuXHRcdFx0dmFyIGluZGV4ID0gb2Zmc2V0c1sgaiBdLmluZGV4O1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRpQSA9IGluZGV4ICsgaW5kaWNlc1sgaSBdO1xyXG5cdFx0XHRcdGlCID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMSBdO1xyXG5cdFx0XHRcdGlDID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGlBICk7XHJcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpQiApO1xyXG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaUMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdC8qXHJcblx0XHRjb21wdXRlT2Zmc2V0c1xyXG5cdFx0Q29tcHV0ZSB0aGUgZHJhdyBvZmZzZXQgZm9yIGxhcmdlIG1vZGVscyBieSBjaHVua2luZyB0aGUgaW5kZXggYnVmZmVyIGludG8gY2h1bmtzIG9mIDY1ayBhZGRyZXNzYWJsZSB2ZXJ0aWNlcy5cclxuXHRcdFRoaXMgbWV0aG9kIHdpbGwgZWZmZWN0aXZlbHkgcmV3cml0ZSB0aGUgaW5kZXggYnVmZmVyIGFuZCByZW1hcCBhbGwgYXR0cmlidXRlcyB0byBtYXRjaCB0aGUgbmV3IGluZGljZXMuXHJcblx0XHRXQVJOSU5HOiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gZXhwYW5kIHRoZSB2ZXJ0ZXggY291bnQgdG8gcHJldmVudCBzcHJhd2xlZCB0cmlhbmdsZXMgYWNyb3NzIGRyYXcgb2Zmc2V0cy5cclxuXHRcdGluZGV4QnVmZmVyU2l6ZSAtIERlZmF1bHRzIHRvIDY1NTM1LCBidXQgYWxsb3dzIGZvciBsYXJnZXIgb3Igc21hbGxlciBjaHVua3MuXHJcblx0Ki9cclxuXHRjb21wdXRlT2Zmc2V0czogZnVuY3Rpb24oaW5kZXhCdWZmZXJTaXplKSB7XHJcblxyXG5cdFx0dmFyIHNpemUgPSBpbmRleEJ1ZmZlclNpemU7XHJcblx0XHRpZihpbmRleEJ1ZmZlclNpemUgPT09IHVuZGVmaW5lZClcclxuXHRcdFx0c2l6ZSA9IDY1NTM1OyAvL1dlYkdMIGxpbWl0cyB0eXBlIG9mIGluZGV4IGJ1ZmZlciB2YWx1ZXMgdG8gMTYtYml0LlxyXG5cclxuXHRcdHZhciBzID0gRGF0ZS5ub3coKTtcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IHRoaXMuYXR0cmlidXRlc1snaW5kZXgnXS5hcnJheTtcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMuYXR0cmlidXRlc1sncG9zaXRpb24nXS5hcnJheTtcclxuXHJcblx0XHR2YXIgdmVydGljZXNDb3VudCA9ICh2ZXJ0aWNlcy5sZW5ndGgvMyk7XHJcblx0XHR2YXIgZmFjZXNDb3VudCA9IChpbmRpY2VzLmxlbmd0aC8zKTtcclxuXHJcblx0XHQvKlxyXG5cdFx0Y29uc29sZS5sb2coXCJDb21wdXRpbmcgYnVmZmVycyBpbiBvZmZzZXRzIG9mIFwiK3NpemUrXCIgLT4gaW5kaWNlczpcIitpbmRpY2VzLmxlbmd0aCtcIiB2ZXJ0aWNlczpcIit2ZXJ0aWNlcy5sZW5ndGgpO1xyXG5cdFx0Y29uc29sZS5sb2coXCJGYWNlcyB0byBwcm9jZXNzOiBcIisoaW5kaWNlcy5sZW5ndGgvMykpO1xyXG5cdFx0Y29uc29sZS5sb2coXCJSZW9yZGVyaW5nIFwiK3ZlcnRpY2VzQ291bnQrXCIgdmVydGljZXMuXCIpO1xyXG5cdFx0Ki9cclxuXHJcblx0XHR2YXIgc29ydGVkSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggaW5kaWNlcy5sZW5ndGggKTsgLy8xNi1iaXQgYnVmZmVyc1xyXG5cdFx0dmFyIGluZGV4UHRyID0gMDtcclxuXHRcdHZhciB2ZXJ0ZXhQdHIgPSAwO1xyXG5cclxuXHRcdHZhciBvZmZzZXRzID0gWyB7IHN0YXJ0OjAsIGNvdW50OjAsIGluZGV4OjAgfSBdO1xyXG5cdFx0dmFyIG9mZnNldCA9IG9mZnNldHNbMF07XHJcblxyXG5cdFx0dmFyIGR1cGxpY2F0ZWRWZXJ0aWNlcyA9IDA7XHJcblx0XHR2YXIgbmV3VmVydGljZU1hcHMgPSAwO1xyXG5cdFx0dmFyIGZhY2VWZXJ0aWNlcyA9IG5ldyBJbnQzMkFycmF5KDYpO1xyXG5cdFx0dmFyIHZlcnRleE1hcCA9IG5ldyBJbnQzMkFycmF5KCB2ZXJ0aWNlcy5sZW5ndGggKTtcclxuXHRcdHZhciByZXZWZXJ0ZXhNYXAgPSBuZXcgSW50MzJBcnJheSggdmVydGljZXMubGVuZ3RoICk7XHJcblx0XHRmb3IodmFyIGogPSAwOyBqIDwgdmVydGljZXMubGVuZ3RoOyBqKyspIHsgdmVydGV4TWFwW2pdID0gLTE7IHJldlZlcnRleE1hcFtqXSA9IC0xOyB9XHJcblxyXG5cdFx0LypcclxuXHRcdFx0VHJhdmVyc2UgZXZlcnkgZmFjZSBhbmQgcmVvcmRlciB2ZXJ0aWNlcyBpbiB0aGUgcHJvcGVyIG9mZnNldHMgb2YgNjVrLlxyXG5cdFx0XHRXZSBjYW4gaGF2ZSBtb3JlIHRoYW4gNjVrIGVudHJpZXMgaW4gdGhlIGluZGV4IGJ1ZmZlciBwZXIgb2Zmc2V0LCBidXQgb25seSByZWZlcmVuY2UgNjVrIHZhbHVlcy5cclxuXHRcdCovXHJcblx0XHRmb3IodmFyIGZpbmRleCA9IDA7IGZpbmRleCA8IGZhY2VzQ291bnQ7IGZpbmRleCsrKSB7XHJcblx0XHRcdG5ld1ZlcnRpY2VNYXBzID0gMDtcclxuXHJcblx0XHRcdGZvcih2YXIgdm8gPSAwOyB2byA8IDM7IHZvKyspIHtcclxuXHRcdFx0XHR2YXIgdmlkID0gaW5kaWNlc1sgZmluZGV4KjMgKyB2byBdO1xyXG5cdFx0XHRcdGlmKHZlcnRleE1hcFt2aWRdID09IC0xKSB7XHJcblx0XHRcdFx0XHQvL1VubWFwcGVkIHZlcnRpY2VcclxuXHRcdFx0XHRcdGZhY2VWZXJ0aWNlc1t2byoyXSA9IHZpZDtcclxuXHRcdFx0XHRcdGZhY2VWZXJ0aWNlc1t2byoyKzFdID0gLTE7XHJcblx0XHRcdFx0XHRuZXdWZXJ0aWNlTWFwcysrO1xyXG5cdFx0XHRcdH0gZWxzZSBpZih2ZXJ0ZXhNYXBbdmlkXSA8IG9mZnNldC5pbmRleCkge1xyXG5cdFx0XHRcdFx0Ly9SZXVzZWQgdmVydGljZXMgZnJvbSBwcmV2aW91cyBibG9jayAoZHVwbGljYXRlKVxyXG5cdFx0XHRcdFx0ZmFjZVZlcnRpY2VzW3ZvKjJdID0gdmlkO1xyXG5cdFx0XHRcdFx0ZmFjZVZlcnRpY2VzW3ZvKjIrMV0gPSAtMTtcclxuXHRcdFx0XHRcdGR1cGxpY2F0ZWRWZXJ0aWNlcysrO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvL1JldXNlZCB2ZXJ0aWNlIGluIHRoZSBjdXJyZW50IGJsb2NrXHJcblx0XHRcdFx0XHRmYWNlVmVydGljZXNbdm8qMl0gPSB2aWQ7XHJcblx0XHRcdFx0XHRmYWNlVmVydGljZXNbdm8qMisxXSA9IHZlcnRleE1hcFt2aWRdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGZhY2VNYXggPSB2ZXJ0ZXhQdHIgKyBuZXdWZXJ0aWNlTWFwcztcclxuXHRcdFx0aWYoZmFjZU1heCA+IChvZmZzZXQuaW5kZXggKyBzaXplKSkge1xyXG5cdFx0XHRcdHZhciBuZXdfb2Zmc2V0ID0geyBzdGFydDppbmRleFB0ciwgY291bnQ6MCwgaW5kZXg6dmVydGV4UHRyIH07XHJcblx0XHRcdFx0b2Zmc2V0cy5wdXNoKG5ld19vZmZzZXQpO1xyXG5cdFx0XHRcdG9mZnNldCA9IG5ld19vZmZzZXQ7XHJcblxyXG5cdFx0XHRcdC8vUmUtZXZhbHVhdGUgcmV1c2VkIHZlcnRpY2VzIGluIGxpZ2h0IG9mIG5ldyBvZmZzZXQuXHJcblx0XHRcdFx0Zm9yKHZhciB2ID0gMDsgdiA8IDY7IHYrPTIpIHtcclxuXHRcdFx0XHRcdHZhciBuZXdfdmlkID0gZmFjZVZlcnRpY2VzW3YrMV07XHJcblx0XHRcdFx0XHRpZihuZXdfdmlkID4gLTEgJiYgbmV3X3ZpZCA8IG9mZnNldC5pbmRleClcclxuXHRcdFx0XHRcdFx0ZmFjZVZlcnRpY2VzW3YrMV0gPSAtMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vUmVpbmRleCB0aGUgZmFjZS5cclxuXHRcdFx0Zm9yKHZhciB2ID0gMDsgdiA8IDY7IHYrPTIpIHtcclxuXHRcdFx0XHR2YXIgdmlkID0gZmFjZVZlcnRpY2VzW3ZdO1xyXG5cdFx0XHRcdHZhciBuZXdfdmlkID0gZmFjZVZlcnRpY2VzW3YrMV07XHJcblxyXG5cdFx0XHRcdGlmKG5ld192aWQgPT09IC0xKVxyXG5cdFx0XHRcdFx0bmV3X3ZpZCA9IHZlcnRleFB0cisrO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhNYXBbdmlkXSA9IG5ld192aWQ7XHJcblx0XHRcdFx0cmV2VmVydGV4TWFwW25ld192aWRdID0gdmlkO1xyXG5cdFx0XHRcdHNvcnRlZEluZGljZXNbaW5kZXhQdHIrK10gPSBuZXdfdmlkIC0gb2Zmc2V0LmluZGV4OyAvL1hYWCBvdmVyZmxvd3MgYXQgMTZiaXRcclxuXHRcdFx0XHRvZmZzZXQuY291bnQrKztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8qIE1vdmUgYWxsIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gbWFwIHRvIHRoZSBuZXcgY29tcHV0ZWQgaW5kaWNlcyAsIGFsc28gZXhwYW5kIHRoZSB2ZXJ0aWNlIHN0YWNrIHRvIG1hdGNoIG91ciBuZXcgdmVydGV4UHRyLiAqL1xyXG5cdFx0dGhpcy5yZW9yZGVyQnVmZmVycyhzb3J0ZWRJbmRpY2VzLCByZXZWZXJ0ZXhNYXAsIHZlcnRleFB0cik7XHJcblx0XHR0aGlzLm9mZnNldHMgPSBvZmZzZXRzO1xyXG5cclxuXHRcdC8qXHJcblx0XHR2YXIgb3JkZXJUaW1lID0gRGF0ZS5ub3coKTtcclxuXHRcdGNvbnNvbGUubG9nKFwiUmVvcmRlciB0aW1lOiBcIisob3JkZXJUaW1lLXMpK1wibXNcIik7XHJcblx0XHRjb25zb2xlLmxvZyhcIkR1cGxpY2F0ZWQgXCIrZHVwbGljYXRlZFZlcnRpY2VzK1wiIHZlcnRpY2VzLlwiKTtcclxuXHRcdGNvbnNvbGUubG9nKFwiQ29tcHV0ZSBCdWZmZXJzIHRpbWU6IFwiKyhEYXRlLm5vdygpLXMpK1wibXNcIik7XHJcblx0XHRjb25zb2xlLmxvZyhcIkRyYXcgb2Zmc2V0czogXCIrb2Zmc2V0cy5sZW5ndGgpO1xyXG5cdFx0Ki9cclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0cztcclxuXHR9LFxyXG5cclxuXHQvKlxyXG5cdFx0cmVvZGVyQnVmZmVyczpcclxuXHRcdFJlb3JkZXIgYXR0cmlidXRlcyBiYXNlZCBvbiBhIG5ldyBpbmRleEJ1ZmZlciBhbmQgaW5kZXhNYXAuXHJcblx0XHRpbmRleEJ1ZmZlciAtIFVpbnQxNkFycmF5IG9mIHRoZSBuZXcgb3JkZXJlZCBpbmRpY2VzLlxyXG5cdFx0aW5kZXhNYXAgLSBJbnQzMkFycmF5IHdoZXJlIHRoZSBwb3NpdGlvbiBpcyB0aGUgbmV3IHZlcnRleCBJRCBhbmQgdGhlIHZhbHVlIHRoZSBvbGQgdmVydGV4IElEIGZvciBlYWNoIHZlcnRleC5cclxuXHRcdHZlcnRleENvdW50IC0gQW1vdW50IG9mIHRvdGFsIHZlcnRpY2VzIGNvbnNpZGVyZWQgaW4gdGhpcyByZW9yZGVyaW5nIChpbiBjYXNlIHlvdSB3YW50IHRvIGdyb3cgdGhlIHZlcnRpY2Ugc3RhY2spLlxyXG5cdCovXHJcblx0cmVvcmRlckJ1ZmZlcnM6IGZ1bmN0aW9uKGluZGV4QnVmZmVyLCBpbmRleE1hcCwgdmVydGV4Q291bnQpIHtcclxuXHJcblx0XHQvKiBDcmVhdGUgYSBjb3B5IG9mIGFsbCBhdHRyaWJ1dGVzIGZvciByZW9yZGVyaW5nLiAqL1xyXG5cdFx0dmFyIHNvcnRlZEF0dHJpYnV0ZXMgPSB7fTtcclxuXHRcdHZhciB0eXBlcyA9IFsgSW50OEFycmF5LCBVaW50OEFycmF5LCBVaW50OENsYW1wZWRBcnJheSwgSW50MTZBcnJheSwgVWludDE2QXJyYXksIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheSBdO1xyXG5cdFx0Zm9yKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XHJcblx0XHRcdGlmKGF0dHIgPT0gJ2luZGV4JylcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0dmFyIHNvdXJjZUFycmF5ID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdLmFycmF5O1xyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdHlwZXMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcclxuXHRcdFx0XHR2YXIgdHlwZSA9IHR5cGVzW2ldO1xyXG5cdFx0XHRcdGlmIChzb3VyY2VBcnJheSBpbnN0YW5jZW9mIHR5cGUpIHtcclxuXHRcdFx0XHRcdHNvcnRlZEF0dHJpYnV0ZXNbYXR0cl0gPSBuZXcgdHlwZSggdGhpcy5hdHRyaWJ1dGVzW2F0dHJdLml0ZW1TaXplICogdmVydGV4Q291bnQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8qIE1vdmUgYXR0cmlidXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgbmV3IGluZGV4IG1hcCAqL1xyXG5cdFx0Zm9yKHZhciBuZXdfdmlkID0gMDsgbmV3X3ZpZCA8IHZlcnRleENvdW50OyBuZXdfdmlkKyspIHtcclxuXHRcdFx0dmFyIHZpZCA9IGluZGV4TWFwW25ld192aWRdO1xyXG5cdFx0XHRmb3IgKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XHJcblx0XHRcdFx0aWYoYXR0ciA9PSAnaW5kZXgnKVxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0dmFyIGF0dHJBcnJheSA9IHRoaXMuYXR0cmlidXRlc1thdHRyXS5hcnJheTtcclxuXHRcdFx0XHR2YXIgYXR0clNpemUgPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0uaXRlbVNpemU7XHJcblx0XHRcdFx0dmFyIHNvcnRlZEF0dHIgPSBzb3J0ZWRBdHRyaWJ1dGVzW2F0dHJdO1xyXG5cdFx0XHRcdGZvcih2YXIgayA9IDA7IGsgPCBhdHRyU2l6ZTsgaysrKVxyXG5cdFx0XHRcdFx0c29ydGVkQXR0clsgbmV3X3ZpZCAqIGF0dHJTaXplICsgayBdID0gYXR0ckFycmF5WyB2aWQgKiBhdHRyU2l6ZSArIGsgXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8qIENhcnJ5IHRoZSBuZXcgc29ydGVkIGJ1ZmZlcnMgbG9jYWxseSAqL1xyXG5cdFx0dGhpcy5hdHRyaWJ1dGVzWydpbmRleCddLmFycmF5ID0gaW5kZXhCdWZmZXI7XHJcblx0XHRmb3IgKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XHJcblx0XHRcdGlmKGF0dHIgPT0gJ2luZGV4JylcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzW2F0dHJdLmFycmF5ID0gc29ydGVkQXR0cmlidXRlc1thdHRyXTtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzW2F0dHJdLm51bUl0ZW1zID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdLml0ZW1TaXplICogdmVydGV4Q291bnQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcblx0XHR2YXIgdHlwZXMgPSBbIEludDhBcnJheSwgVWludDhBcnJheSwgVWludDhDbGFtcGVkQXJyYXksIEludDE2QXJyYXksIFVpbnQxNkFycmF5LCBJbnQzMkFycmF5LCBVaW50MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDY0QXJyYXkgXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgc291cmNlQXR0ciA9IHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdO1xyXG5cdFx0XHR2YXIgc291cmNlQXJyYXkgPSBzb3VyY2VBdHRyLmFycmF5O1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHtcclxuXHJcblx0XHRcdFx0aXRlbVNpemU6IHNvdXJjZUF0dHIuaXRlbVNpemUsXHJcblx0XHRcdFx0YXJyYXk6IG51bGxcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdHlwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0eXBlID0gdHlwZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBzb3VyY2VBcnJheSBpbnN0YW5jZW9mIHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLmFycmF5ID0gbmV3IHR5cGUoIHNvdXJjZUFycmF5ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuYXR0cmlidXRlc1sgYXR0ciBdID0gYXR0cmlidXRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5vZmZzZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0c1sgaSBdO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkub2Zmc2V0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdHN0YXJ0OiBvZmZzZXQuc3RhcnQsXHJcblx0XHRcdFx0aW5kZXg6IG9mZnNldC5pbmRleCxcclxuXHRcdFx0XHRjb3VudDogb2Zmc2V0LmNvdW50XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZW9tZXRyeTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmlkID0gVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrO1xyXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIkdlb21ldHJ5XCI7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzID0gW107XHJcblx0dGhpcy5jb2xvcnMgPSBbXTsgIC8vIG9uZS10by1vbmUgdmVydGV4IGNvbG9ycywgdXNlZCBpbiBQYXJ0aWNsZVN5c3RlbSBhbmQgTGluZVxyXG5cclxuXHR0aGlzLmZhY2VzID0gW107XHJcblxyXG5cdHRoaXMuZmFjZVZlcnRleFV2cyA9IFtbXV07XHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gW107XHJcblx0dGhpcy5tb3JwaENvbG9ycyA9IFtdO1xyXG5cdHRoaXMubW9ycGhOb3JtYWxzID0gW107XHJcblxyXG5cdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcclxuXHR0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblxyXG5cdHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0dGhpcy5oYXNUYW5nZW50cyA9IHRydWU7XHJcblxyXG5cdHRoaXMuZHluYW1pYyA9IHRydWU7IC8vIHRoZSBpbnRlcm1lZGlhdGUgdHlwZWQgYXJyYXlzIHdpbGwgYmUgZGVsZXRlZCB3aGVuIHNldCB0byBmYWxzZVxyXG5cclxuXHQvLyB1cGRhdGUgZmxhZ3NcclxuXHJcblx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLnRhbmdlbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5idWZmZXJzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkdlb21ldHJ5LFxyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG5cdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZhY2UuY2VudHJvaWQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94IGluc3RhbmNlb2YgVEhSRUUuQm94MyApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSBpbnN0YW5jZW9mIFRIUkVFLlNwaGVyZSApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQ2VudHJvaWRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGYsIGZsLCBmYWNlO1xyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cdFx0XHRmYWNlLmNlbnRyb2lkLnNldCggMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0ZmFjZS5jZW50cm9pZC5hZGQoIHRoaXMudmVydGljZXNbIGZhY2UuYSBdICk7XHJcblx0XHRcdGZhY2UuY2VudHJvaWQuYWRkKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG5cdFx0XHRmYWNlLmNlbnRyb2lkLmFkZCggdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuXHRcdFx0ZmFjZS5jZW50cm9pZC5kaXZpZGVTY2FsYXIoIDMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0dmFyIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xyXG5cdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcclxuXHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRjYi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XHJcblxyXG5cdFx0dmFyIHYsIHZsLCBmLCBmbCwgZmFjZSwgdmVydGljZXM7XHJcblxyXG5cdFx0dmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGFyZWFXZWlnaHRlZCApIHtcclxuXHJcblx0XHRcdC8vIHZlcnRleCBub3JtYWxzIHdlaWdodGVkIGJ5IHRyaWFuZ2xlIGFyZWFzXHJcblx0XHRcdC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cclxuXHJcblx0XHRcdHZhciB2QSwgdkIsIHZDLCB2RDtcclxuXHRcdFx0dmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRcdGRiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgZGMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBiYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0dkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XHJcblx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcblx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGNiICk7XHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBjYiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcclxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcclxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0gPSB2ZXJ0aWNlc1sgZmFjZS5jIF0uY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaSwgaWwsIGYsIGZsLCBmYWNlO1xyXG5cclxuXHRcdC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xyXG5cdFx0Ly8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXHJcblx0XHQvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyApIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gPSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVzZSB0ZW1wIGdlb21ldHJ5IHRvIGNvbXB1dGUgZmFjZSBhbmQgdmVydGV4IG5vcm1hbHMgZm9yIGVhY2ggbW9ycGhcclxuXHJcblx0XHR2YXIgdG1wR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0XHR0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly8gY3JlYXRlIG9uIGZpcnN0IGFjY2Vzc1xyXG5cclxuXHRcdFx0aWYgKCAhIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcclxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XHJcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XHJcblxyXG5cdFx0XHRcdHZhciBkc3ROb3JtYWxzRmFjZSA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHM7XHJcblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNWZXJ0ZXggPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0geyBhOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBiOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBjOiBuZXcgVEhSRUUuVmVjdG9yMygpIH07XHJcblxyXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xyXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0Ly8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxyXG5cclxuXHRcdFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgbW9ycGggbm9ybWFsc1xyXG5cclxuXHRcdFx0dG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdFx0XHR0bXBHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHRcdC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0ZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRmYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcclxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzID0gZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXHJcblx0XHQvLyB0YW5nZW50cyBnbyB0byB2ZXJ0aWNlc1xyXG5cclxuXHRcdHZhciBmLCBmbCwgdiwgdmwsIGksIGlsLCB2ZXJ0ZXhJbmRleCxcclxuXHRcdFx0ZmFjZSwgdXYsIHZBLCB2QiwgdkMsIHV2QSwgdXZCLCB1dkMsXHJcblx0XHRcdHgxLCB4MiwgeTEsIHkyLCB6MSwgejIsXHJcblx0XHRcdHMxLCBzMiwgdDEsIHQyLCByLCB0LCB0ZXN0LFxyXG5cdFx0XHR0YW4xID0gW10sIHRhbjIgPSBbXSxcclxuXHRcdFx0c2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHR0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0bXAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0biA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHc7XHJcblxyXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdHRhbjFbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHRhbjJbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKCBjb250ZXh0LCBhLCBiLCBjLCB1YSwgdWIsIHVjICkge1xyXG5cclxuXHRcdFx0dkEgPSBjb250ZXh0LnZlcnRpY2VzWyBhIF07XHJcblx0XHRcdHZCID0gY29udGV4dC52ZXJ0aWNlc1sgYiBdO1xyXG5cdFx0XHR2QyA9IGNvbnRleHQudmVydGljZXNbIGMgXTtcclxuXHJcblx0XHRcdHV2QSA9IHV2WyB1YSBdO1xyXG5cdFx0XHR1dkIgPSB1dlsgdWIgXTtcclxuXHRcdFx0dXZDID0gdXZbIHVjIF07XHJcblxyXG5cdFx0XHR4MSA9IHZCLnggLSB2QS54O1xyXG5cdFx0XHR4MiA9IHZDLnggLSB2QS54O1xyXG5cdFx0XHR5MSA9IHZCLnkgLSB2QS55O1xyXG5cdFx0XHR5MiA9IHZDLnkgLSB2QS55O1xyXG5cdFx0XHR6MSA9IHZCLnogLSB2QS56O1xyXG5cdFx0XHR6MiA9IHZDLnogLSB2QS56O1xyXG5cclxuXHRcdFx0czEgPSB1dkIueCAtIHV2QS54O1xyXG5cdFx0XHRzMiA9IHV2Qy54IC0gdXZBLng7XHJcblx0XHRcdHQxID0gdXZCLnkgLSB1dkEueTtcclxuXHRcdFx0dDIgPSB1dkMueSAtIHV2QS55O1xyXG5cclxuXHRcdFx0ciA9IDEuMCAvICggczEgKiB0MiAtIHMyICogdDEgKTtcclxuXHRcdFx0c2Rpci5zZXQoICggdDIgKiB4MSAtIHQxICogeDIgKSAqIHIsXHJcblx0XHRcdFx0XHQgICggdDIgKiB5MSAtIHQxICogeTIgKSAqIHIsXHJcblx0XHRcdFx0XHQgICggdDIgKiB6MSAtIHQxICogejIgKSAqIHIgKTtcclxuXHRcdFx0dGRpci5zZXQoICggczEgKiB4MiAtIHMyICogeDEgKSAqIHIsXHJcblx0XHRcdFx0XHQgICggczEgKiB5MiAtIHMyICogeTEgKSAqIHIsXHJcblx0XHRcdFx0XHQgICggczEgKiB6MiAtIHMyICogejEgKSAqIHIgKTtcclxuXHJcblx0XHRcdHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcclxuXHRcdFx0dGFuMVsgYiBdLmFkZCggc2RpciApO1xyXG5cdFx0XHR0YW4xWyBjIF0uYWRkKCBzZGlyICk7XHJcblxyXG5cdFx0XHR0YW4yWyBhIF0uYWRkKCB0ZGlyICk7XHJcblx0XHRcdHRhbjJbIGIgXS5hZGQoIHRkaXIgKTtcclxuXHRcdFx0dGFuMlsgYyBdLmFkZCggdGRpciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHRcdFx0dXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgZiBdOyAvLyB1c2UgVVYgbGF5ZXIgMCBmb3IgdGFuZ2VudHNcclxuXHJcblx0XHRcdGhhbmRsZVRyaWFuZ2xlKCB0aGlzLCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jLCAwLCAxLCAyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmYWNlSW5kZXggPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBNYXRoLm1pbiggZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCwgMyApOyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdG4uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0dmVydGV4SW5kZXggPSBmYWNlWyBmYWNlSW5kZXhbIGkgXSBdO1xyXG5cclxuXHRcdFx0XHR0ID0gdGFuMVsgdmVydGV4SW5kZXggXTtcclxuXHJcblx0XHRcdFx0Ly8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcclxuXHJcblx0XHRcdFx0dG1wLmNvcHkoIHQgKTtcclxuXHRcdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcclxuXHJcblx0XHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLCB0ICk7XHJcblx0XHRcdFx0dGVzdCA9IHRtcDIuZG90KCB0YW4yWyB2ZXJ0ZXhJbmRleCBdICk7XHJcblx0XHRcdFx0dyA9ICh0ZXN0IDwgMC4wKSA/IC0xLjAgOiAxLjA7XHJcblxyXG5cdFx0XHRcdGZhY2UudmVydGV4VGFuZ2VudHNbIGkgXSA9IG5ldyBUSFJFRS5WZWN0b3I0KCB0bXAueCwgdG1wLnksIHRtcC56LCB3ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuaGFzVGFuZ2VudHMgPSB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCApIHtcclxuXHJcblx0XHR2YXIgZCA9IDA7XHJcblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggaSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGQgKz0gdmVydGljZXNbIGkgXS5kaXN0YW5jZVRvKCB2ZXJ0aWNlc1sgaSAtIDEgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0LypcclxuXHQgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlcyB3aXRoIGhhc2htYXAuXHJcblx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxyXG5cdCAqIGFuZCBmYWNlcycgdmVydGljZXMgYXJlIHVwZGF0ZWQuXHJcblx0ICovXHJcblxyXG5cdG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxyXG5cdFx0dmFyIHVuaXF1ZSA9IFtdLCBjaGFuZ2VzID0gW107XHJcblxyXG5cdFx0dmFyIHYsIGtleTtcclxuXHRcdHZhciBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGVnLiA0IGZvciBlcHNpbG9uIG9mIDAuMDAwMVxyXG5cdFx0dmFyIHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XHJcblx0XHR2YXIgaSxpbCwgZmFjZTtcclxuXHRcdHZhciBpbmRpY2VzLCBrLCBqLCBqbCwgdTtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0diA9IHRoaXMudmVydGljZXNbIGkgXTtcclxuXHRcdFx0a2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcclxuXHRcdFx0XHR1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XHJcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xyXG5cdFx0XHRcdGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cclxuXHRcdC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2VcclxuXHRcdC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXHJcblx0XHR2YXIgZmFjZUluZGljZXNUb1JlbW92ZSA9IFtdO1xyXG5cclxuXHRcdGZvciggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0ZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XHJcblx0XHRcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0aW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0dmFyIGR1cEluZGV4ID0gLTE7XHJcblxyXG5cdFx0XHQvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXHJcblx0XHRcdC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBmYWNlIGFzIG5vdGhpbmcgY2FuIGJlIHNhdmVkXHJcblx0XHRcdGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XHJcblx0XHRcdFx0aWYgKCBpbmRpY2VzWyBuIF0gPT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xyXG5cclxuXHRcdFx0XHRcdGR1cEluZGV4ID0gbjtcclxuXHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XHJcblx0XHRcdHZhciBpZHggPSBmYWNlSW5kaWNlc1RvUmVtb3ZlWyBpIF07XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnNwbGljZSggaWR4LCAxICk7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaWR4LCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVzZSB1bmlxdWUgc2V0IG9mIHZlcnRpY2VzXHJcblxyXG5cdFx0dmFyIGRpZmYgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIHVuaXF1ZS5sZW5ndGg7XHJcblx0XHR0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xyXG5cdFx0cmV0dXJuIGRpZmY7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdlb21ldHJ5IHNwbGl0dGluZ1xyXG5cclxuXHRtYWtlR3JvdXBzOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnlHcm91cENvdW50ZXIgPSAwO1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB1c2VzRmFjZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0dmFyIGYsIGZsLCBmYWNlLCBtYXRlcmlhbEluZGV4LFxyXG5cdFx0XHRcdGdyb3VwSGFzaCwgaGFzaF9tYXAgPSB7fTtcclxuXHJcblx0XHRcdHZhciBudW1Nb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblx0XHRcdHZhciBudW1Nb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFscy5sZW5ndGg7XHJcblxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5R3JvdXBzID0ge307XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXggPSB1c2VzRmFjZU1hdGVyaWFsID8gZmFjZS5tYXRlcmlhbEluZGV4IDogMDtcclxuXHJcblx0XHRcdFx0aWYgKCAhICggbWF0ZXJpYWxJbmRleCBpbiBoYXNoX21hcCApICkge1xyXG5cclxuXHRcdFx0XHRcdGhhc2hfbWFwWyBtYXRlcmlhbEluZGV4IF0gPSB7ICdoYXNoJzogbWF0ZXJpYWxJbmRleCwgJ2NvdW50ZXInOiAwIH07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z3JvdXBIYXNoID0gaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5oYXNoICsgJ18nICsgaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5jb3VudGVyO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgKCBncm91cEhhc2ggaW4gdGhpcy5nZW9tZXRyeUdyb3VwcyApICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuZ2VvbWV0cnlHcm91cHNbIGdyb3VwSGFzaCBdID0geyAnZmFjZXMzJzogW10sICdtYXRlcmlhbEluZGV4JzogbWF0ZXJpYWxJbmRleCwgJ3ZlcnRpY2VzJzogMCwgJ251bU1vcnBoVGFyZ2V0cyc6IG51bU1vcnBoVGFyZ2V0cywgJ251bU1vcnBoTm9ybWFscyc6IG51bU1vcnBoTm9ybWFscyB9O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGhpcy5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0udmVydGljZXMgKyAzID4gNjU1MzUgKSB7XHJcblxyXG5cdFx0XHRcdFx0aGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5jb3VudGVyICs9IDE7XHJcblx0XHRcdFx0XHRncm91cEhhc2ggPSBoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdLmhhc2ggKyAnXycgKyBoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdLmNvdW50ZXI7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhICggZ3JvdXBIYXNoIGluIHRoaXMuZ2VvbWV0cnlHcm91cHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuZ2VvbWV0cnlHcm91cHNbIGdyb3VwSGFzaCBdID0geyAnZmFjZXMzJzogW10sICdtYXRlcmlhbEluZGV4JzogbWF0ZXJpYWxJbmRleCwgJ3ZlcnRpY2VzJzogMCwgJ251bU1vcnBoVGFyZ2V0cyc6IG51bU1vcnBoVGFyZ2V0cywgJ251bU1vcnBoTm9ybWFscyc6IG51bU1vcnBoTm9ybWFscyB9O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXS5mYWNlczMucHVzaCggZiApO1xyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnlHcm91cHNbIGdyb3VwSGFzaCBdLnZlcnRpY2VzICs9IDM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5R3JvdXBzTGlzdCA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGcgaW4gdGhpcy5nZW9tZXRyeUdyb3VwcyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5nZW9tZXRyeUdyb3Vwc1sgZyBdLmlkID0gZ2VvbWV0cnlHcm91cENvdW50ZXIgKys7XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2VvbWV0cnlHcm91cHNMaXN0LnB1c2goIHRoaXMuZ2VvbWV0cnlHcm91cHNbIGcgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblx0XHRcclxuXHR9ICkoKSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB1diA9IHV2c1sgaSBdLCB1dkNvcHkgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dXZDb3B5LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dlsgaiBdLngsIHV2WyBqIF0ueSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZDb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzLnNsaWNlKCAwICk7XHJcblx0XHRnZW9tZXRyeS5tb3JwaENvbG9ycyA9IHRoaXMubW9ycGhDb2xvcnMuc2xpY2UoIDAgKTtcclxuXHRcdGdlb21ldHJ5Lm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzLnNsaWNlKCAwICk7XHJcblx0XHRnZW9tZXRyeS5za2luV2VpZ2h0cyA9IHRoaXMuc2tpbldlaWdodHMuc2xpY2UoIDAgKTtcclxuXHRcdGdlb21ldHJ5LnNraW5JbmRpY2VzID0gdGhpcy5za2luSW5kaWNlcy5zbGljZSggMCApO1xyXG5cdFx0Z2VvbWV0cnkubGluZURpc3RhbmNlcyA9IHRoaXMubGluZURpc3RhbmNlcy5zbGljZSggMCApO1xyXG5cclxuXHRcdGlmKCB0aGlzLmJvdW5kaW5nQm94IClcdGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gdGhpcy5ib3VuZGluZ0JveC5jbG9uZSgpO1xyXG5cdFx0aWYoIHRoaXMuYm91bmRpbmdTcGhlcmUgKSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHRnZW9tZXRyeS5oYXNUYW5nZW50cyA9IHRoaXMuaGFzVGFuZ2VudHM7XHJcblxyXG5cdFx0Z2VvbWV0cnkuZHluYW1pYyA9IHRoaXMuZHluYW1pYzsgLy8gdGhlIGludGVybWVkaWF0ZSB0eXBlZCBhcnJheXMgd2lsbCBiZSBkZWxldGVkIHdoZW4gc2V0IHRvIGZhbHNlXHJcblxyXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkdlb21ldHJ5SWRDb3VudCA9IDA7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5HZW9tZXRyeTIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XHJcblxyXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHR0aGlzLmNsYXNzTmFtZSA9IFwiR2VvbWV0cnkyXCI7XHJcblxyXG5cdHRoaXMudmVydGljZXMgPSB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgRmxvYXQzMkFycmF5LCBzaXplLCAzICkuYXJyYXk7XHJcblx0dGhpcy5ub3JtYWxzID0gdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBGbG9hdDMyQXJyYXksIHNpemUsIDMgKS5hcnJheTtcclxuXHR0aGlzLnV2cyA9IHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBGbG9hdDMyQXJyYXksIHNpemUsIDIgKS5hcnJheTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuR2VvbWV0cnkyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiovXHJcblxyXG5USFJFRS5DYW1lcmEgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IGNhbWVyYXMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxyXG5cclxuXHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0bTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChjYW1lcmEpIHtcclxuXHJcblx0aWYgKCBjYW1lcmEgPT09IHVuZGVmaW5lZCApIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGNhbWVyYSApO1xyXG5cclxuXHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHRoaXMubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdHJldHVybiBjYW1lcmE7XHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgPSBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdHRoaXMucmlnaHQgPSByaWdodDtcclxuXHR0aGlzLnRvcCA9IHRvcDtcclxuXHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuXHJcblx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XHJcblx0dGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xyXG5cclxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyggdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20sIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgpO1xyXG5cclxuXHRUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGNhbWVyYSApO1xyXG5cclxuXHRjYW1lcmEubGVmdCA9IHRoaXMubGVmdDtcclxuXHRjYW1lcmEucmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG5cdGNhbWVyYS50b3AgPSB0aGlzLnRvcDtcclxuXHRjYW1lcmEuYm90dG9tID0gdGhpcy5ib3R0b207XHJcblx0XHJcblx0Y2FtZXJhLm5lYXIgPSB0aGlzLm5lYXI7XHJcblx0Y2FtZXJhLmZhciA9IHRoaXMuZmFyO1xyXG5cclxuXHRyZXR1cm4gY2FtZXJhO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgPSBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcclxuXHR0aGlzLmFzcGVjdCA9IGFzcGVjdCAhPT0gdW5kZWZpbmVkID8gYXNwZWN0IDogMTtcclxuXHR0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xyXG5cdHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xyXG5cclxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XHJcblxyXG5cclxuLyoqXHJcbiAqIFVzZXMgRm9jYWwgTGVuZ3RoIChpbiBtbSkgdG8gZXN0aW1hdGUgYW5kIHNldCBGT1ZcclxuICogMzVtbSAoZnVsbGZyYW1lKSBjYW1lcmEgaXMgdXNlZCBpZiBmcmFtZSBzaXplIGlzIG5vdCBzcGVjaWZpZWQ7XHJcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcclxuICovXHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xyXG5cclxuXHRpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xyXG5cclxuXHR0aGlzLmZvdiA9IDIgKiBUSFJFRS5NYXRoLnJhZFRvRGVnKCBNYXRoLmF0YW4oIGZyYW1lSGVpZ2h0IC8gKCBmb2NhbExlbmd0aCAqIDIgKSApICk7XHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFNldHMgYW4gb2Zmc2V0IGluIGEgbGFyZ2VyIGZydXN0dW0uIFRoaXMgaXMgdXNlZnVsIGZvciBtdWx0aS13aW5kb3cgb3JcclxuICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cclxuICpcclxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIDN4MiBtb25pdG9ycyBhbmQgZWFjaCBtb25pdG9yIGlzIDE5MjB4MTA4MCBhbmRcclxuICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xyXG4gKlxyXG4gKiAgICstLS0rLS0tKy0tLStcclxuICogICB8IEEgfCBCIHwgQyB8XHJcbiAqICAgKy0tLSstLS0rLS0tK1xyXG4gKiAgIHwgRCB8IEUgfCBGIHxcclxuICogICArLS0tKy0tLSstLS0rXHJcbiAqXHJcbiAqIHRoZW4gZm9yIGVhY2ggbW9uaXRvciB5b3Ugd291bGQgY2FsbCBpdCBsaWtlIHRoaXNcclxuICpcclxuICogICB2YXIgdyA9IDE5MjA7XHJcbiAqICAgdmFyIGggPSAxMDgwO1xyXG4gKiAgIHZhciBmdWxsV2lkdGggPSB3ICogMztcclxuICogICB2YXIgZnVsbEhlaWdodCA9IGggKiAyO1xyXG4gKlxyXG4gKiAgIC0tQS0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcclxuICogICAtLUItLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XHJcbiAqICAgLS1DLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xyXG4gKiAgIC0tRC0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcclxuICogICAtLUUtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XHJcbiAqICAgLS1GLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xyXG4gKlxyXG4gKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldFZpZXdPZmZzZXQgPSBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0dGhpcy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XHJcblx0dGhpcy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcclxuXHR0aGlzLnggPSB4O1xyXG5cdHRoaXMueSA9IHk7XHJcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5mdWxsV2lkdGggKSB7XHJcblxyXG5cdFx0dmFyIGFzcGVjdCA9IHRoaXMuZnVsbFdpZHRoIC8gdGhpcy5mdWxsSGVpZ2h0O1xyXG5cdFx0dmFyIHRvcCA9IE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aGlzLmZvdiAqIDAuNSApICkgKiB0aGlzLm5lYXI7XHJcblx0XHR2YXIgYm90dG9tID0gLXRvcDtcclxuXHRcdHZhciBsZWZ0ID0gYXNwZWN0ICogYm90dG9tO1xyXG5cdFx0dmFyIHJpZ2h0ID0gYXNwZWN0ICogdG9wO1xyXG5cdFx0dmFyIHdpZHRoID0gTWF0aC5hYnMoIHJpZ2h0IC0gbGVmdCApO1xyXG5cdFx0dmFyIGhlaWdodCA9IE1hdGguYWJzKCB0b3AgLSBib3R0b20gKTtcclxuXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZUZydXN0dW0oXHJcblx0XHRcdGxlZnQgKyB0aGlzLnggKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxyXG5cdFx0XHRsZWZ0ICsgKCB0aGlzLnggKyB0aGlzLndpZHRoICkgKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxyXG5cdFx0XHR0b3AgLSAoIHRoaXMueSArIHRoaXMuaGVpZ2h0ICkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXHJcblx0XHRcdHRvcCAtIHRoaXMueSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcclxuXHRcdFx0dGhpcy5uZWFyLFxyXG5cdFx0XHR0aGlzLmZhclxyXG5cdFx0KTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCB0aGlzLmZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xyXG5cclxuXHRUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGNhbWVyYSApO1xyXG5cclxuXHRjYW1lcmEuZm92ID0gdGhpcy5mb3Y7XHJcblx0Y2FtZXJhLmFzcGVjdCA9IHRoaXMuYXNwZWN0O1xyXG5cdGNhbWVyYS5uZWFyID0gdGhpcy5uZWFyO1xyXG5cdGNhbWVyYS5mYXIgPSB0aGlzLmZhcjtcclxuXHJcblx0cmV0dXJuIGNhbWVyYTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuIFxyXG5USFJFRS5MaWdodCA9IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggbGlnaHQgKSB7XHJcblxyXG5cdGlmICggbGlnaHQgPT09IHVuZGVmaW5lZCApIGxpZ2h0ID0gbmV3IFRIUkVFLkxpZ2h0KCk7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBsaWdodCApO1xyXG5cclxuXHRsaWdodC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdHJldHVybiBsaWdodDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BbWJpZW50TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBsaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoKTtcclxuXHJcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGxpZ2h0ICk7XHJcblxyXG5cdHJldHVybiBsaWdodDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICogQGF1dGhvciBNUGFua25pbiAvIGh0dHA6Ly93d3cucmVkcGxhbnQuZGUvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQXJlYUxpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXlFeHBvbmVudCApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcclxuXHJcblx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcclxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHR0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XHJcblx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xyXG5cdHRoaXMuZGVjYXlFeHBvbmVudCA9ICggZGVjYXlFeHBvbmVudCAhPT0gdW5kZWZpbmVkICkgPyBkZWNheUV4cG9uZW50IDogMDtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cclxuXHJcblx0dGhpcy53aWR0aCA9IDEuMDtcclxuXHR0aGlzLmhlaWdodCA9IDEuMDtcclxuXHJcblx0Ly8gVE9ETzogaW1wbGVtZW50IHNoYWRvdyBtYXBzLiAgLWJob3VzdG9uLCBPY3QgMTUsIDIwMTRcclxufTtcclxuXHJcblRIUkVFLkFyZWFMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkFyZWFMaWdodC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBsaWdodCA9IG5ldyBUSFJFRS5BcmVhTGlnaHQoKTtcclxuXHJcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGxpZ2h0ICk7XHJcblxyXG5cdGxpZ2h0LnRhcmdldCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XHJcblx0XHJcblx0bGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XHJcblx0bGlnaHQuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xyXG5cdGxpZ2h0LmRlY2F5RXhwb25lbnQgPSB0aGlzLmRlY2F5RXhwb25lbnQ7XHJcblxyXG5cdGxpZ2h0LndpZHRoID0gdGhpcy53aWR0aDtcclxuXHRsaWdodC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcblx0cmV0dXJuIGxpZ2h0O1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XHJcblxyXG5cdHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XHJcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG5cclxuXHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcclxuXHR0aGlzLm9ubHlTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmFGYXIgPSA1MDAwO1xyXG5cclxuXHR0aGlzLnNoYWRvd0NhbWVyYUxlZnQgPSAtNTAwO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhUmlnaHQgPSA1MDA7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmFUb3AgPSA1MDA7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmFCb3R0b20gPSAtNTAwO1xyXG5cclxuXHR0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zaGFkb3dCaWFzID0gMDtcclxuXHR0aGlzLnNoYWRvd0RhcmtuZXNzID0gMC41O1xyXG5cclxuXHR0aGlzLnNoYWRvd01hcFdpZHRoID0gNTEyO1xyXG5cdHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gNTEyO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLnNoYWRvd0Nhc2NhZGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0xMDAwICk7XHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlQ291bnQgPSAyO1xyXG5cclxuXHR0aGlzLnNoYWRvd0Nhc2NhZGVCaWFzID0gWyAwLCAwLCAwIF07XHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlV2lkdGggPSBbIDUxMiwgNTEyLCA1MTIgXTtcclxuXHR0aGlzLnNoYWRvd0Nhc2NhZGVIZWlnaHQgPSBbIDUxMiwgNTEyLCA1MTIgXTtcclxuXHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlTmVhclogPSBbIC0xLjAwMCwgMC45OTAsIDAuOTk4IF07XHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlRmFyWiAgPSBbICAwLjk5MCwgMC45OTgsIDEuMDAwIF07XHJcblxyXG5cdHRoaXMuc2hhZG93Q2FzY2FkZUFycmF5ID0gW107XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMuc2hhZG93TWFwID0gbnVsbDtcclxuXHR0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhID0gbnVsbDtcclxuXHR0aGlzLnNoYWRvd01hdHJpeCA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgpO1xyXG5cclxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcclxuXHJcblx0bGlnaHQudGFyZ2V0ID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcclxuXHJcblx0bGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XHJcblxyXG5cdGxpZ2h0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XHJcblx0bGlnaHQub25seVNoYWRvdyA9IHRoaXMub25seVNoYWRvdztcclxuXHJcblx0cmV0dXJuIGxpZ2h0O1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodCA9IGZ1bmN0aW9uICggc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIHNreUNvbG9yICk7XHJcblxyXG5cdHRoaXMucG9zaXRpb24uc2V0KCAwLCAxMDAsIDAgKTtcclxuXHJcblx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggZ3JvdW5kQ29sb3IgKTtcclxuXHR0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCgpO1xyXG5cclxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcclxuXHJcblx0bGlnaHQuZ3JvdW5kQ29sb3IuY29weSggdGhpcy5ncm91bmRDb2xvciApO1xyXG5cdGxpZ2h0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xyXG5cclxuXHRyZXR1cm4gbGlnaHQ7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yICk7XHJcblxyXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcclxuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XHJcblx0dGhpcy5kZWNheUV4cG9uZW50ID0gKCBkZWNheUV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5RXhwb25lbnQgOiAwOztcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cclxufTtcclxuXHJcblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGxpZ2h0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoKTtcclxuXHJcblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGxpZ2h0ICk7XHJcblxyXG5cdGxpZ2h0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xyXG5cdGxpZ2h0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcclxuXHRsaWdodC5kZWNheUV4cG9uZW50ID0gdGhpcy5kZWNheUV4cG9uZW50O1xyXG5cclxuXHRyZXR1cm4gbGlnaHQ7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIGV4cG9uZW50LCBkZWNheUV4cG9uZW50ICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcclxuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XHJcblx0dGhpcy5kZWNheUV4cG9uZW50ID0gKCBkZWNheUV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5RXhwb25lbnQgOiAwOztcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cclxuXHJcblx0dGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMztcclxuXHR0aGlzLmV4cG9uZW50ID0gKCBleHBvbmVudCAhPT0gdW5kZWZpbmVkICkgPyBleHBvbmVudCA6IDEwO1xyXG5cclxuXHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcclxuXHR0aGlzLm9ubHlTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmFGYXIgPSA1MDAwO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhRm92ID0gNTA7XHJcblxyXG5cdHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNoYWRvd0JpYXMgPSAwO1xyXG5cdHRoaXMuc2hhZG93RGFya25lc3MgPSAwLjU7XHJcblxyXG5cdHRoaXMuc2hhZG93TWFwV2lkdGggPSA1MTI7XHJcblx0dGhpcy5zaGFkb3dNYXBIZWlnaHQgPSA1MTI7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMuc2hhZG93TWFwID0gbnVsbDtcclxuXHR0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhID0gbnVsbDtcclxuXHR0aGlzLnNoYWRvd01hdHJpeCA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGxpZ2h0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCgpO1xyXG5cclxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcclxuXHJcblx0bGlnaHQudGFyZ2V0ID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcclxuXHJcblx0bGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XHJcblx0bGlnaHQuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xyXG5cdGxpZ2h0LmFuZ2xlID0gdGhpcy5hbmdsZTtcclxuXHRsaWdodC5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XHJcblx0bGlnaHQuZGVjYXlFeHBvbmVudCA9IHRoaXMuZGVjYXlFeHBvbmVudDtcclxuXHJcblx0bGlnaHQuY2FzdFNoYWRvdyA9IHRoaXMuY2FzdFNoYWRvdztcclxuXHRsaWdodC5vbmx5U2hhZG93ID0gdGhpcy5vbmx5U2hhZG93O1xyXG5cclxuXHRyZXR1cm4gbGlnaHQ7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTG9hZGVyID0gZnVuY3Rpb24gKCBzaG93U3RhdHVzICkge1xyXG5cclxuXHR0aGlzLnNob3dTdGF0dXMgPSBzaG93U3RhdHVzO1xyXG5cdHRoaXMuc3RhdHVzRG9tRWxlbWVudCA9IHNob3dTdGF0dXMgPyBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmFkZFN0YXR1c0VsZW1lbnQoKSA6IG51bGw7XHJcblxyXG5cdHRoaXMub25Mb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHR0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Mb2FkZXIsXHJcblxyXG5cdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXHJcblxyXG5cdGFkZFN0YXR1c0VsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcclxuXHJcblx0XHRlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG5cdFx0ZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XHJcblx0XHRlLnN0eWxlLnRvcCA9IFwiMHB4XCI7XHJcblx0XHRlLnN0eWxlLmZvbnRTaXplID0gXCIwLjhlbVwiO1xyXG5cdFx0ZS5zdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcclxuXHRcdGUuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiYSgwLDAsMCwwLjI1KVwiO1xyXG5cdFx0ZS5zdHlsZS5jb2xvciA9IFwiI2ZmZlwiO1xyXG5cdFx0ZS5zdHlsZS53aWR0aCA9IFwiMTIwcHhcIjtcclxuXHRcdGUuc3R5bGUucGFkZGluZyA9IFwiMC41ZW0gMC41ZW0gMC41ZW0gMC41ZW1cIjtcclxuXHRcdGUuc3R5bGUuekluZGV4ID0gMTAwMDtcclxuXHJcblx0XHRlLmlubmVySFRNTCA9IFwiTG9hZGluZyAuLi5cIjtcclxuXHJcblx0XHRyZXR1cm4gZTtcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uICggcHJvZ3Jlc3MgKSB7XHJcblxyXG5cdFx0dmFyIG1lc3NhZ2UgPSBcIkxvYWRlZCBcIjtcclxuXHJcblx0XHRpZiAoIHByb2dyZXNzLnRvdGFsICkge1xyXG5cclxuXHRcdFx0bWVzc2FnZSArPSAoIDEwMCAqIHByb2dyZXNzLmxvYWRlZCAvIHByb2dyZXNzLnRvdGFsICkudG9GaXhlZCgwKSArIFwiJVwiO1xyXG5cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWVzc2FnZSArPSAoIHByb2dyZXNzLmxvYWRlZCAvIDEwMDAgKS50b0ZpeGVkKDIpICsgXCIgS0JcIjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdGF0dXNEb21FbGVtZW50LmlubmVySFRNTCA9IG1lc3NhZ2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHR2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xyXG5cclxuXHRcdGlmICggcGFydHMubGVuZ3RoID09PSAxICkgcmV0dXJuICcuLyc7XHJcblxyXG5cdFx0cGFydHMucG9wKCk7XHJcblxyXG5cdFx0cmV0dXJuIHBhcnRzLmpvaW4oICcvJyApICsgJy8nO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbml0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFscywgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0dmFyIGFycmF5ID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKysgaSApIHtcclxuXHJcblx0XHRcdGFycmF5WyBpIF0gPSBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbHNbIGkgXSwgdGV4dHVyZVBhdGggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWVkc1RhbmdlbnRzOiBmdW5jdGlvbiAoIG1hdGVyaWFscyApIHtcclxuXHJcblx0XHRmb3IoIHZhciBpID0gMCwgaWwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbSA9IG1hdGVyaWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBtIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgKSByZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcmVhdGVNYXRlcmlhbDogZnVuY3Rpb24gKCBtLCB0ZXh0dXJlUGF0aCApIHtcclxuXHJcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGlzX3BvdzIoIG4gKSB7XHJcblxyXG5cdFx0XHR2YXIgbCA9IE1hdGgubG9nKCBuICkgLyBNYXRoLkxOMjtcclxuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoIGwgKSA9PSBsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBuZWFyZXN0X3BvdzIoIG4gKSB7XHJcblxyXG5cdFx0XHR2YXIgbCA9IE1hdGgubG9nKCBuICkgLyBNYXRoLkxOMjtcclxuXHRcdFx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLnJvdW5kKCAgbCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGxvYWRfaW1hZ2UoIHdoZXJlLCB1cmwgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHJcblx0XHRcdGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhaXNfcG93MiggdGhpcy53aWR0aCApIHx8ICFpc19wb3cyKCB0aGlzLmhlaWdodCApICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB3aWR0aCA9IG5lYXJlc3RfcG93MiggdGhpcy53aWR0aCApO1xyXG5cdFx0XHRcdFx0dmFyIGhlaWdodCA9IG5lYXJlc3RfcG93MiggdGhpcy5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHR3aGVyZS5pbWFnZS53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRcdFx0d2hlcmUuaW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0XHRcdFx0d2hlcmUuaW1hZ2UuZ2V0Q29udGV4dCggJzJkJyApLmRyYXdJbWFnZSggdGhpcywgMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHdoZXJlLmltYWdlID0gdGhpcztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR3aGVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0aWYgKCBfdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBfdGhpcy5jcm9zc09yaWdpbjtcclxuXHRcdFx0aW1hZ2Uuc3JjID0gdXJsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVfdGV4dHVyZSggd2hlcmUsIG5hbWUsIHNvdXJjZUZpbGUsIHJlcGVhdCwgb2Zmc2V0LCB3cmFwLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9IC9cXC5kZHMkL2kudGVzdCggc291cmNlRmlsZSApO1xyXG5cclxuXHRcdFx0dmFyIGZ1bGxQYXRoID0gdGV4dHVyZVBhdGggKyBzb3VyY2VGaWxlO1xyXG5cclxuXHRcdFx0aWYgKCBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUoIGZ1bGxQYXRoICk7XHJcblxyXG5cdFx0XHRcdHdoZXJlWyBuYW1lIF0gPSB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFyIHRleHR1cmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cclxuXHRcdFx0XHR3aGVyZVsgbmFtZSBdID0gbmV3IFRIUkVFLlRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHdoZXJlWyBuYW1lIF0uc291cmNlRmlsZSA9IHNvdXJjZUZpbGU7XHJcblxyXG5cdFx0XHRpZiggcmVwZWF0ICkge1xyXG5cclxuXHRcdFx0XHR3aGVyZVsgbmFtZSBdLnJlcGVhdC5zZXQoIHJlcGVhdFsgMCBdLCByZXBlYXRbIDEgXSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgd2hlcmVbIG5hbWUgXS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB3aGVyZVsgbmFtZSBdLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0d2hlcmVbIG5hbWUgXS5vZmZzZXQuc2V0KCBvZmZzZXRbIDAgXSwgb2Zmc2V0WyAxIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggd3JhcCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHdyYXBNYXAgPSB7XHJcblx0XHRcdFx0XHRcInJlcGVhdFwiOiBUSFJFRS5SZXBlYXRXcmFwcGluZyxcclxuXHRcdFx0XHRcdFwibWlycm9yXCI6IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggd3JhcE1hcFsgd3JhcFsgMCBdIF0gIT09IHVuZGVmaW5lZCApIHdoZXJlWyBuYW1lIF0ud3JhcFMgPSB3cmFwTWFwWyB3cmFwWyAwIF0gXTtcclxuXHRcdFx0XHRpZiAoIHdyYXBNYXBbIHdyYXBbIDEgXSBdICE9PSB1bmRlZmluZWQgKSB3aGVyZVsgbmFtZSBdLndyYXBUID0gd3JhcE1hcFsgd3JhcFsgMSBdIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFx0XHRcdHdoZXJlWyBuYW1lIF0uYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICEgaXNDb21wcmVzc2VkICkge1xyXG5cclxuXHRcdFx0XHRsb2FkX2ltYWdlKCB3aGVyZVsgbmFtZSBdLCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZ2IyaGV4KCByZ2IgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCByZ2JbIDAgXSAqIDI1NSA8PCAxNiApICsgKCByZ2JbIDEgXSAqIDI1NSA8PCA4ICkgKyByZ2JbIDIgXSAqIDI1NTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGVmYXVsdHNcclxuXHJcblx0XHR2YXIgbXR5cGUgPSBcIk1lc2hMYW1iZXJ0TWF0ZXJpYWxcIjtcclxuXHRcdHZhciBtcGFycyA9IHsgY29sb3I6IDB4ZWVlZWVlLCBvcGFjaXR5OiAxLjAsIG1hcDogbnVsbCwgbGlnaHRNYXA6IG51bGwsIG5vcm1hbE1hcDogbnVsbCwgYnVtcE1hcDogbnVsbCwgd2lyZWZyYW1lOiBmYWxzZSB9O1xyXG5cclxuXHRcdC8vIHBhcmFtZXRlcnMgZnJvbSBtb2RlbCBmaWxlXHJcblxyXG5cdFx0aWYgKCBtLnNoYWRpbmcgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2hhZGluZyA9IG0uc2hhZGluZy50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0aWYgKCBzaGFkaW5nID09PSBcInBob25nXCIgKSBtdHlwZSA9IFwiTWVzaFBob25nTWF0ZXJpYWxcIjtcclxuXHRcdFx0ZWxzZSBpZiAoIHNoYWRpbmcgPT09IFwiYmFzaWNcIiApIG10eXBlID0gXCJNZXNoQmFzaWNNYXRlcmlhbFwiO1xyXG5cdFx0XHRlbHNlIGlmICggc2hhZGluZyA9PT0gXCJwaHlzaWNhbFwiICkgbXR5cGUgPSBcIk1lc2hQaHlzaWNhbE1hdGVyaWFsXCI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICYmIFRIUkVFWyBtLmJsZW5kaW5nIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1wYXJzLmJsZW5kaW5nID0gVEhSRUVbIG0uYmxlbmRpbmcgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgfHwgbS5vcGFjaXR5IDwgMS4wICkge1xyXG5cclxuXHRcdFx0bXBhcnMudHJhbnNwYXJlbnQgPSBtLnRyYW5zcGFyZW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5kZXB0aFRlc3QgPSBtLmRlcHRoVGVzdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1wYXJzLmRlcHRoV3JpdGUgPSBtLmRlcHRoV3JpdGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy52aXNpYmxlID0gbS52aXNpYmxlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uZmxpcFNpZGVkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5zaWRlID0gVEhSRUUuQmFja1NpZGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5kb3VibGVTaWRlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bXBhcnMuc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1wYXJzLndpcmVmcmFtZSA9IG0ud2lyZWZyYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0udmVydGV4Q29sb3JzID09PSBcImZhY2VcIiApIHtcclxuXHJcblx0XHRcdFx0bXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuRmFjZUNvbG9ycztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG0udmVydGV4Q29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRtcGFycy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5WZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNvbG9yc1xyXG5cclxuXHRcdGlmICggbS5jb2xvckRpZmZ1c2UgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5jb2xvciA9IHJnYjJoZXgoIG0uY29sb3JEaWZmdXNlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbS5EYmdDb2xvciApIHtcclxuXHJcblx0XHRcdG1wYXJzLmNvbG9yID0gbS5EYmdDb2xvcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLmNvbG9yU3BlY3VsYXIgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5zcGVjdWxhciA9IHJnYjJoZXgoIG0uY29sb3JTcGVjdWxhciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uY29sb3JBbWJpZW50ICkge1xyXG5cclxuXHRcdFx0bXBhcnMuYW1iaWVudCA9IHJnYjJoZXgoIG0uY29sb3JBbWJpZW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vZGlmaWVyc1xyXG5cclxuXHRcdGlmICggbS50cmFuc3BhcmVuY3kgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5vcGFjaXR5ID0gbS50cmFuc3BhcmVuY3k7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5zcGVjdWxhckNvZWYgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5zaGluaW5lc3MgPSBtLnNwZWN1bGFyQ29lZjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGV4dHVyZXNcclxuXHJcblx0XHRpZiAoIG0ubWFwRGlmZnVzZSAmJiB0ZXh0dXJlUGF0aCApIHtcclxuXHJcblx0XHRcdGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgXCJtYXBcIiwgbS5tYXBEaWZmdXNlLCBtLm1hcERpZmZ1c2VSZXBlYXQsIG0ubWFwRGlmZnVzZU9mZnNldCwgbS5tYXBEaWZmdXNlV3JhcCwgbS5tYXBEaWZmdXNlQW5pc290cm9weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0ubWFwTGlnaHQgJiYgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0XHRjcmVhdGVfdGV4dHVyZSggbXBhcnMsIFwibGlnaHRNYXBcIiwgbS5tYXBMaWdodCwgbS5tYXBMaWdodFJlcGVhdCwgbS5tYXBMaWdodE9mZnNldCwgbS5tYXBMaWdodFdyYXAsIG0ubWFwTGlnaHRBbmlzb3Ryb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5tYXBCdW1wICYmIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCBcImJ1bXBNYXBcIiwgbS5tYXBCdW1wLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0ubWFwTm9ybWFsICYmIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCBcIm5vcm1hbE1hcFwiLCBtLm1hcE5vcm1hbCwgbS5tYXBOb3JtYWxSZXBlYXQsIG0ubWFwTm9ybWFsT2Zmc2V0LCBtLm1hcE5vcm1hbFdyYXAsIG0ubWFwTm9ybWFsQW5pc290cm9weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0ubWFwU3BlY3VsYXIgJiYgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0XHRjcmVhdGVfdGV4dHVyZSggbXBhcnMsIFwic3BlY3VsYXJNYXBcIiwgbS5tYXBTcGVjdWxhciwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBtLm1hcEJ1bXBTY2FsZSApIHtcclxuXHJcblx0XHRcdG1wYXJzLmJ1bXBTY2FsZSA9IG0ubWFwQnVtcFNjYWxlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIG5vcm1hbCBtYXBwZWQgbWF0ZXJpYWxcclxuXHJcblx0XHRpZiAoIG0ubWFwTm9ybWFsICkge1xyXG5cclxuXHRcdFx0dmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJub3JtYWxtYXBcIiBdO1xyXG5cdFx0XHR2YXIgdW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKTtcclxuXHJcblx0XHRcdHVuaWZvcm1zWyBcInROb3JtYWxcIiBdLnZhbHVlID0gbXBhcnMubm9ybWFsTWFwO1xyXG5cclxuXHRcdFx0aWYgKCBtLm1hcE5vcm1hbEZhY3RvciApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidU5vcm1hbFNjYWxlXCIgXS52YWx1ZS5zZXQoIG0ubWFwTm9ybWFsRmFjdG9yLCBtLm1hcE5vcm1hbEZhY3RvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtcGFycy5tYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInREaWZmdXNlXCIgXS52YWx1ZSA9IG1wYXJzLm1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVEaWZmdXNlXCIgXS52YWx1ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1wYXJzLnNwZWN1bGFyTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0U3BlY3VsYXJcIiBdLnZhbHVlID0gbXBhcnMuc3BlY3VsYXJNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlU3BlY3VsYXJcIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbXBhcnMubGlnaHRNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInRBT1wiIF0udmFsdWUgPSBtcGFycy5saWdodE1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVBT1wiIF0udmFsdWUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZm9yIHRoZSBtb21lbnQgZG9uJ3QgaGFuZGxlIGRpc3BsYWNlbWVudCB0ZXh0dXJlXHJcblxyXG5cdFx0XHR1bmlmb3Jtc1sgXCJkaWZmdXNlXCIgXS52YWx1ZS5zZXRIZXgoIG1wYXJzLmNvbG9yICk7XHJcblx0XHRcdHVuaWZvcm1zWyBcInNwZWN1bGFyXCIgXS52YWx1ZS5zZXRIZXgoIG1wYXJzLnNwZWN1bGFyICk7XHJcblx0XHRcdHVuaWZvcm1zWyBcImFtYmllbnRcIiBdLnZhbHVlLnNldEhleCggbXBhcnMuYW1iaWVudCApO1xyXG5cclxuXHRcdFx0dW5pZm9ybXNbIFwic2hpbmluZXNzXCIgXS52YWx1ZSA9IG1wYXJzLnNoaW5pbmVzcztcclxuXHJcblx0XHRcdGlmICggbXBhcnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJvcGFjaXR5XCIgXS52YWx1ZSA9IG1wYXJzLm9wYWNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHsgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogdW5pZm9ybXMsIGxpZ2h0czogdHJ1ZSwgZm9nOiB0cnVlIH07XHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdFx0aWYgKCBtcGFycy50cmFuc3BhcmVudCApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIG10eXBlIF0oIG1wYXJzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5EYmdOYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0gbS5EYmdOYW1lO1xyXG5cclxuXHRcdHJldHVybiBtYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlhIUkxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuWEhSTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlhIUkxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9uTG9hZCggZXZlbnQudGFyZ2V0LnJlc3BvbnNlVGV4dCApO1xyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHRcdFx0b25Qcm9ncmVzcyggZXZlbnQgKTtcclxuXHJcblx0XHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0XHRvbkVycm9yKCBldmVudCApO1xyXG5cclxuXHRcdFx0fSwgZmFsc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHJcblx0XHRyZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcclxuXHRcdHJlcXVlc3Quc2VuZCggbnVsbCApO1xyXG5cclxuXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSW1hZ2VMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkltYWdlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkltYWdlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblx0XHR2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW1nJyApO1xyXG5cclxuXHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblx0XHRcdFx0b25Mb2FkKCB0aGlzICk7XHJcblxyXG5cdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdG9uRXJyb3IoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHJcblx0XHRpbWFnZS5zcmMgPSB1cmw7XHJcblxyXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5KU09OTG9hZGVyID0gZnVuY3Rpb24gKCBzaG93U3RhdHVzICkge1xyXG5cclxuXHRUSFJFRS5Mb2FkZXIuY2FsbCggdGhpcywgc2hvd1N0YXR1cyApO1xyXG5cclxuXHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTG9hZGVyLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICggdXJsLCBjYWxsYmFjaywgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdC8vIHRvZG86IHVuaWZ5IGxvYWQgQVBJIHRvIGZvciBlYXNpZXIgU2NlbmVMb2FkZXIgdXNlXHJcblxyXG5cdHRleHR1cmVQYXRoID0gdGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGV4dHVyZVBhdGggPT09IFwic3RyaW5nXCIgKSA/IHRleHR1cmVQYXRoIDogdGhpcy5leHRyYWN0VXJsQmFzZSggdXJsICk7XHJcblxyXG5cdHRoaXMub25Mb2FkU3RhcnQoKTtcclxuXHR0aGlzLmxvYWRBamF4SlNPTiggdGhpcywgdXJsLCBjYWxsYmFjaywgdGV4dHVyZVBhdGggKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5sb2FkQWpheEpTT04gPSBmdW5jdGlvbiAoIGNvbnRleHQsIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoLCBjYWxsYmFja1Byb2dyZXNzICkge1xyXG5cclxuXHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG5cdHZhciBsZW5ndGggPSAwO1xyXG5cclxuXHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IHhoci5ET05FICkge1xyXG5cclxuXHRcdFx0aWYgKCB4aHIuc3RhdHVzID09PSAyMDAgfHwgeGhyLnN0YXR1cyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB4aHIucmVzcG9uc2VUZXh0ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBqc29uID0gSlNPTi5wYXJzZSggeGhyLnJlc3BvbnNlVGV4dCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICgganNvbi5tZXRhZGF0YS50eXBlID09PSAnc2NlbmUnICkge1xyXG5cclxuXHRcdFx0XHRcdFx0VEhSRUUub25lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6IFwiJyArIHVybCArICdcIiBzZWVtcyB0byBiZSBhIFNjZW5lLiBVc2UgVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XHJcblx0XHRcdFx0XHRjYWxsYmFjayggcmVzdWx0Lmdlb21ldHJ5LCByZXN1bHQubWF0ZXJpYWxzICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0VEhSRUUub25lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6IFwiJyArIHVybCArICdcIiBzZWVtcyB0byBiZSB1bnJlYWNoYWJsZSBvciB0aGUgZmlsZSBpcyBlbXB0eS4nICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gaW4gY29udGV4dCBvZiBtb3JlIGNvbXBsZXggYXNzZXQgaW5pdGlhbGl6YXRpb25cclxuXHRcdFx0XHQvLyBkbyBub3QgYmxvY2sgb24gc2luZ2xlIGZhaWxlZCBmaWxlXHJcblx0XHRcdFx0Ly8gbWF5YmUgc2hvdWxkIGdvIGV2ZW4gb25lIG1vcmUgbGV2ZWwgdXBcclxuXHJcblx0XHRcdFx0Y29udGV4dC5vbkxvYWRDb21wbGV0ZSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0VEhSRUUub25lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6IENvdWxkblxcJ3QgbG9hZCBcIicgKyB1cmwgKyAnXCIgKCcgKyB4aHIuc3RhdHVzICsgJyknICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IHhoci5MT0FESU5HICkge1xyXG5cclxuXHRcdFx0aWYgKCBjYWxsYmFja1Byb2dyZXNzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRsZW5ndGggPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoICdDb250ZW50LUxlbmd0aCcgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjYWxsYmFja1Byb2dyZXNzKCB7IHRvdGFsOiBsZW5ndGgsIGxvYWRlZDogeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGggfSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSB4aHIuSEVBREVSU19SRUNFSVZFRCApIHtcclxuXHJcblx0XHRcdGlmICggY2FsbGJhY2tQcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRsZW5ndGggPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1MZW5ndGhcIiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0eGhyLm9wZW4oIFwiR0VUXCIsIHVybCwgdHJ1ZSApO1xyXG5cdHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcclxuXHR4aHIuc2VuZCggbnVsbCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBqc29uLCB0ZXh0dXJlUGF0aCApIHtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcyxcclxuXHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpLFxyXG5cdHNjYWxlID0gKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSA/IDEuMCAvIGpzb24uc2NhbGUgOiAxLjA7XHJcblxyXG5cdHBhcnNlTW9kZWwoIHNjYWxlICk7XHJcblxyXG5cdHBhcnNlU2tpbigpO1xyXG5cdHBhcnNlTW9ycGhpbmcoIHNjYWxlICk7XHJcblxyXG5cdGdlb21ldHJ5LmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHRnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VNb2RlbCggc2NhbGUgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaXNCaXRTZXQoIHZhbHVlLCBwb3NpdGlvbiApIHtcclxuXHJcblx0XHRcdHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaSwgaiwgZmksXHJcblxyXG5cdFx0b2Zmc2V0LCB6TGVuZ3RoLFxyXG5cclxuXHRcdGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxyXG5cclxuXHRcdHR5cGUsXHJcblx0XHRpc1F1YWQsXHJcblx0XHRoYXNNYXRlcmlhbCxcclxuXHRcdGhhc0ZhY2VWZXJ0ZXhVdixcclxuXHRcdGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsXHJcblx0XHRoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcclxuXHJcblx0XHR2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgY29sb3IsIGhleCwgbm9ybWFsLFxyXG5cclxuXHRcdHV2TGF5ZXIsIHV2LCB1LCB2LFxyXG5cclxuXHRcdGZhY2VzID0ganNvbi5mYWNlcyxcclxuXHRcdHZlcnRpY2VzID0ganNvbi52ZXJ0aWNlcyxcclxuXHRcdG5vcm1hbHMgPSBqc29uLm5vcm1hbHMsXHJcblx0XHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcclxuXHJcblx0XHRuVXZMYXllcnMgPSAwO1xyXG5cclxuXHRcdGlmICgganNvbi51dnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwganNvbi51dnMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICgganNvbi51dnNbIGkgXS5sZW5ndGggKSBuVXZMYXllcnMgKys7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0b2Zmc2V0ID0gMDtcclxuXHRcdHpMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblx0XHRcdHZlcnRleC55ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0b2Zmc2V0ID0gMDtcclxuXHRcdHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblxyXG5cdFx0XHRpc1F1YWQgICAgICAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcclxuXHRcdFx0aGFzTWF0ZXJpYWwgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAxICk7XHJcblx0XHRcdGhhc0ZhY2VWZXJ0ZXhVdiAgICAgPSBpc0JpdFNldCggdHlwZSwgMyApO1xyXG5cdFx0XHRoYXNGYWNlTm9ybWFsICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDQgKTtcclxuXHRcdFx0aGFzRmFjZVZlcnRleE5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA1ICk7XHJcblx0XHRcdGhhc0ZhY2VDb2xvclx0ICAgID0gaXNCaXRTZXQoIHR5cGUsIDYgKTtcclxuXHRcdFx0aGFzRmFjZVZlcnRleENvbG9yICA9IGlzQml0U2V0KCB0eXBlLCA3ICk7XHJcblxyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcInR5cGVcIiwgdHlwZSwgXCJiaXRzXCIsIGlzUXVhZCwgaGFzTWF0ZXJpYWwsIGhhc0ZhY2VWZXJ0ZXhVdiwgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCwgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IpO1xyXG5cclxuXHRcdFx0aWYgKCBpc1F1YWQgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VBID0gbmV3IFRIUkVFLkZhY2UzKCk7XHJcblx0XHRcdFx0ZmFjZUEuYSA9IGZhY2VzWyBvZmZzZXQgXTtcclxuXHRcdFx0XHRmYWNlQS5iID0gZmFjZXNbIG9mZnNldCArIDEgXTtcclxuXHRcdFx0XHRmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcclxuXHJcblx0XHRcdFx0ZmFjZUIgPSBuZXcgVEhSRUUuRmFjZTMoKTtcclxuXHRcdFx0XHRmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcclxuXHRcdFx0XHRmYWNlQi5iID0gZmFjZXNbIG9mZnNldCArIDIgXTtcclxuXHRcdFx0XHRmYWNlQi5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ICs9IDQ7XHJcblxyXG5cdFx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cdFx0XHRcdFx0ZmFjZUIubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXHJcblxyXG5cdFx0XHRcdGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXSA9IFtdXHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0dXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGogIT09IDIgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIGogIT09IDAgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdLnB1c2goIHV2ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZUEubm9ybWFsLnNldChcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdGZhY2VBLmNvbG9yLnNldEhleCggaGV4ICk7XHJcblx0XHRcdFx0XHRmYWNlQi5jb2xvci5zZXRIZXgoIGhleCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcclxuXHRcdFx0XHRcdFx0aWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUEgKTtcclxuXHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG5ldyBUSFJFRS5GYWNlMygpO1xyXG5cdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRmYWNlLmIgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0ZmFjZS5jID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxyXG5cclxuXHRcdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0dXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcblx0XHRcdFx0XHRmYWNlLm5vcm1hbC5zZXQoXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cclxuXHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0XHRmYWNlLmNvbG9yLnNldEhleCggY29sb3JzWyBjb2xvckluZGV4IF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VTa2luKCkge1xyXG5cclxuXHRcdGlmICgganNvbi5za2luV2VpZ2h0cyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xyXG5cclxuXHRcdFx0XHR2YXIgeCA9IGpzb24uc2tpbldlaWdodHNbIGkgICAgIF07XHJcblx0XHRcdFx0dmFyIHkgPSBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdO1xyXG5cdFx0XHRcdHZhciB6ID0gMDtcclxuXHRcdFx0XHR2YXIgdyA9IDA7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhID0ganNvbi5za2luSW5kaWNlc1sgaSAgICAgXTtcclxuXHRcdFx0XHR2YXIgYiA9IGpzb24uc2tpbkluZGljZXNbIGkgKyAxIF07XHJcblx0XHRcdFx0dmFyIGMgPSAwO1xyXG5cdFx0XHRcdHZhciBkID0gMDtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuc2tpbkluZGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIGEsIGIsIGMsIGQgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeS5ib25lcyA9IGpzb24uYm9uZXM7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib25lcyAmJiBnZW9tZXRyeS5ib25lcy5sZW5ndGggPiAwICYmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICE9PSBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggfHwgZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICE9PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSApIHtcclxuXHJcblx0XHRcdFx0VEhSRUUub253YXJuaW5nKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcclxuXHRcdFx0XHRcdGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCArICcpLCBhbmQgc2tpbldlaWdodHMgKCcgKyBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKyAnKSBzaG91bGQgbWF0Y2guJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gY291bGQgY2hhbmdlIHRoaXMgdG8ganNvbi5hbmltYXRpb25zWzBdIG9yIHJlbW92ZSBjb21wbGV0ZWx5XHJcblx0XHRcclxuXHRcdGdlb21ldHJ5LmFuaW1hdGlvbiA9IGpzb24uYW5pbWF0aW9uO1xyXG5cdFx0Z2VvbWV0cnkuYW5pbWF0aW9ucyA9IGpzb24uYW5pbWF0aW9ucztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XHJcblxyXG5cdFx0aWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGksIGwsIHYsIHZsLCBkc3RWZXJ0aWNlcywgc3JjVmVydGljZXM7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xyXG5cdFx0XHRcdHNyY1ZlcnRpY2VzID0ganNvbi5tb3JwaFRhcmdldHMgWyBpIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdGZvciggdiA9IDAsIHZsID0gc3JjVmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0XHRcdHZlcnRleC54ID0gc3JjVmVydGljZXNbIHYgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdFx0dmVydGV4LnkgPSBzcmNWZXJ0aWNlc1sgdiArIDEgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdFx0dmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0XHRcdGRzdFZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5tb3JwaENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGksIGwsIGMsIGNsLCBkc3RDb2xvcnMsIHNyY0NvbG9ycywgY29sb3I7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGpzb24ubW9ycGhDb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdID0ge307XHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5uYW1lID0ganNvbi5tb3JwaENvbG9yc1sgaSBdLm5hbWU7XHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5jb2xvcnMgPSBbXTtcclxuXHJcblx0XHRcdFx0ZHN0Q29sb3JzID0gZ2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXS5jb2xvcnM7XHJcblx0XHRcdFx0c3JjQ29sb3JzID0ganNvbi5tb3JwaENvbG9ycyBbIGkgXS5jb2xvcnM7XHJcblxyXG5cdFx0XHRcdGZvciAoIGMgPSAwLCBjbCA9IHNyY0NvbG9ycy5sZW5ndGg7IGMgPCBjbDsgYyArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmYWEwMCApO1xyXG5cdFx0XHRcdFx0Y29sb3Iuc2V0UkdCKCBzcmNDb2xvcnNbIGMgXSwgc3JjQ29sb3JzWyBjICsgMSBdLCBzcmNDb2xvcnNbIGMgKyAyIF0gKTtcclxuXHRcdFx0XHRcdGRzdENvbG9ycy5wdXNoKCBjb2xvciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRpZiAoIGpzb24ubWF0ZXJpYWxzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHsgZ2VvbWV0cnk6IGdlb21ldHJ5IH07XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFscyA9IHRoaXMuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5lZWRzVGFuZ2VudHMoIG1hdGVyaWFscyApICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSwgbWF0ZXJpYWxzOiBtYXRlcmlhbHMgfTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxvYWRpbmdNYW5hZ2VyID0gZnVuY3Rpb24gKCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciBsb2FkZWQgPSAwLCB0b3RhbCA9IDA7XHJcblxyXG5cdHRoaXMub25Mb2FkID0gb25Mb2FkO1xyXG5cdHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XHJcblx0dGhpcy5vbkVycm9yID0gb25FcnJvcjtcclxuXHJcblx0dGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHR0b3RhbCArKztcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG5cdFx0bG9hZGVkICsrO1xyXG5cclxuXHRcdGlmICggc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0c2NvcGUub25Qcm9ncmVzcyggdXJsLCBsb2FkZWQsIHRvdGFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbG9hZGVkID09PSB0b3RhbCAmJiBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm9uTG9hZCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBuZXcgVEhSRUUuTG9hZGluZ01hbmFnZXIoKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBqc29uLmF0dHJpYnV0ZXM7XHJcblx0XHR2YXIgb2Zmc2V0cyA9IGpzb24ub2Zmc2V0cztcclxuXHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uYm91bmRpbmdTcGhlcmU7XHJcblxyXG5cdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPSB7XHJcblx0XHRcdFx0aXRlbVNpemU6IGF0dHJpYnV0ZS5pdGVtU2l6ZSxcclxuXHRcdFx0XHRhcnJheTogbmV3IHNlbGZbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvZmZzZXRzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5vZmZzZXRzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIG9mZnNldHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKS5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkID8gYm91bmRpbmdTcGhlcmUuY2VudGVyIDogWyAwLCAwLCAwIF0gKSxcclxuXHRcdFx0XHRib3VuZGluZ1NwaGVyZS5yYWRpdXNcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuR2VvbWV0cnkyTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5HZW9tZXRyeTJMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuR2VvbWV0cnkyTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoKTtcclxuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkyKCBqc29uLnZlcnRpY2VzLmxlbmd0aCAvIDMgKTtcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IFsgJ3ZlcnRpY2VzJywgJ25vcm1hbHMnLCAndXZzJyBdO1xyXG5cdFx0dmFyIGJvdW5kaW5nU3BoZXJlID0ganNvbi5ib3VuZGluZ1NwaGVyZTtcclxuXHJcblx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XHJcblx0XHRcdGdlb21ldHJ5WyBhdHRyaWJ1dGUgXS5zZXQoIGpzb25bIGF0dHJpYnV0ZSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZShcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLmZyb21BcnJheSggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgPyBib3VuZGluZ1NwaGVyZS5jZW50ZXIgOiBbIDAsIDAsIDAgXSApLFxyXG5cdFx0XHRcdGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRlcmlhbExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcclxuXHJcblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWF0ZXJpYWxMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWxMb2FkZXIsXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlcigpO1xyXG5cdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG5cdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsganNvbi50eXBlIF07XHJcblxyXG5cdFx0aWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcclxuXHRcdGlmICgganNvbi5hbWJpZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbWJpZW50LnNldEhleCgganNvbi5hbWJpZW50ICk7XHJcblx0XHRpZiAoIGpzb24uZW1pc3NpdmUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlLnNldEhleCgganNvbi5lbWlzc2l2ZSApO1xyXG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcclxuXHRcdGlmICgganNvbi5mYWxsb2ZmICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mYWxsb2ZmID0ganNvbi5mYWxsb2ZmO1xyXG5cdFx0aWYgKCBqc29uLmZhbGxvZmZDb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZmFsbG9mZkNvbG9yLnNldEhleCgganNvbi5mYWxsb2ZmQ29sb3IgKTtcclxuXHRcdGlmICgganNvbi5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzcyA9IGpzb24ucm91Z2huZXNzO1xyXG5cdFx0aWYgKCBqc29uLm1ldGFsbGljICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbGxpYyA9IGpzb24ubWV0YWxsaWM7XHJcblx0XHRpZiAoIGpzb24uY2xlYXJDb2F0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhckNvYXQgPSBqc29uLmNsZWFyQ29hdDtcclxuXHRcdGlmICgganNvbi5jbGVhckNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyA9IGpzb24uY2xlYXJDb2F0Um91Z2huZXNzO1xyXG5cdFx0aWYgKCBqc29uLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFuaXNvdHJvcHkgPSBqc29uLmFuaXNvdHJvcHk7XHJcblx0XHRpZiAoIGpzb24uYW5pc290cm9weVJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbmlzb3Ryb3B5Um90YXRpb24gPSBqc29uLmFuaXNvdHJvcHlSb3RhdGlvbjtcclxuXHRcdGlmICgganNvbi50cmFuc2x1Y2VuY3kgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zbHVjZW5jeS5zZXRIZXgoIGpzb24udHJhbnNsdWNlbmN5ICk7XHJcblx0XHRpZiAoIGpzb24udHJhbnNsdWNlbmN5Tm9ybWFsQWxwaGEgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zbHVjZW5jeU5vcm1hbEFscGhhID0ganNvbi50cmFuc2x1Y2VuY3lOb3JtYWxBbHBoYTtcclxuXHRcdGlmICgganNvbi50cmFuc2x1Y2VuY3lOb3JtYWxQb3dlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNsdWNlbmN5Tm9ybWFsUG93ZXIgPSBqc29uLnRyYW5zbHVjZW5jeU5vcm1hbFBvd2VyO1xyXG5cdFx0aWYgKCBqc29uLnRyYW5zbHVjZW5jeVZpZXdBbHBoYSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNsdWNlbmN5Vmlld0FscGhhID0ganNvbi50cmFuc2x1Y2VuY3lWaWV3QWxwaGE7XHJcblx0XHRpZiAoIGpzb24udHJhbnNsdWNlbmN5Vmlld1Bvd2VyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc2x1Y2VuY3lWaWV3UG93ZXIgPSBqc29uLnRyYW5zbHVjZW5jeVZpZXdQb3dlcjtcclxuXHRcdGlmICgganNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IGpzb24uc2hpbmluZXNzO1xyXG5cdFx0aWYgKCBqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XHJcblx0XHRpZiAoIGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kaW5nID0ganNvbi5ibGVuZGluZztcclxuXHRcdGlmICgganNvbi5zaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xyXG5cdFx0aWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XHJcblx0XHRpZiAoIGpzb24udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0ganNvbi50cmFuc3BhcmVudDtcclxuXHRcdGlmICgganNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xyXG5cclxuXHRcdGlmICgganNvbi5tYXRlcmlhbHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLnBhcnNlKCBqc29uLm1hdGVyaWFsc1sgaSBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuT2JqZWN0TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PYmplY3RMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0TG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMgKTtcclxuXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscyApO1xyXG5cdFx0dmFyIG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKTtcclxuXHJcblx0XHRyZXR1cm4gb2JqZWN0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZUdlb21ldHJpZXM6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xyXG5cclxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5TG9hZGVyID0gbmV3IFRIUkVFLkpTT05Mb2FkZXIoKTtcclxuXHRcdFx0dmFyIGdlb21ldHJ5MkxvYWRlciA9IG5ldyBUSFJFRS5HZW9tZXRyeTJMb2FkZXIoKTtcclxuXHRcdFx0dmFyIGJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyKCk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBnZW9tZXRyeTtcclxuXHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1BsYW5lR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEud2lkdGhTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdCb3hHZW9tZXRyeSc6XHJcblx0XHRcdFx0XHRjYXNlICdDdWJlR2VvbWV0cnknOiAvLyBERVBSRUNBVEVEXHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGVwdGgsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aFNlZ21lbnRzXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDaXJjbGVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdDeWxpbmRlckdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNUb3AsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNCb3R0b20sXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdTcGhlcmVHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdJY29zYWhlZHJvbkdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcclxuXHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnR1YmUsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLnR1YnVsYXJTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmFyY1xyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnVG9ydXNLbm90R2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5wLFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEucSxcclxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNjYWxlXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ0dlb21ldHJ5Mic6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGdlb21ldHJ5MkxvYWRlci5wYXJzZSggZGF0YS5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhLmRhdGEgKS5nZW9tZXRyeTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cmllcztcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWxzID0ge307XHJcblxyXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLk1hdGVyaWFsTG9hZGVyKCk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkYXRhID0ganNvblsgaSBdO1xyXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC51dWlkID0gZGF0YS51dWlkO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGRhdGEubmFtZTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWxzWyBkYXRhLnV1aWQgXSA9IG1hdGVyaWFsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZU9iamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRhdGEsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApIHtcclxuXHJcblx0XHRcdHZhciBvYmplY3Q7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1NjZW5lJzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggZGF0YS5sZWZ0LCBkYXRhLnJpZ2h0LCBkYXRhLnRvcCwgZGF0YS5ib3R0b20sIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnQW1iaWVudExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCBkYXRhLmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UgKTtcclxuXHRcdFx0XHRcdG9iamVjdC5kZWNheUV4cG9uZW50ID0gZGF0YS5kZWNheUV4cG9uZW50IHx8IDA7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNwb3RMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEuZXhwb25lbnQgKTtcclxuXHRcdFx0XHRcdG9iamVjdC5kZWNheUV4cG9uZW50ID0gZGF0YS5kZWNheUV4cG9uZW50IHx8IDA7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnQXJlYUxpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuQXJlYUxpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheUV4cG9uZW50ICk7XHJcblx0XHRcdFx0XHRvYmplY3Qud2lkdGggPSBkYXRhLndpZHRoIHx8IDE7XHJcblx0XHRcdFx0XHRvYmplY3QuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgMTtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ01lc2gnOlxyXG5cclxuXHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGRhdGEuZ2VvbWV0cnkgXTtcclxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG1hdGVyaWFsc1sgZGF0YS5tYXRlcmlhbCBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFRIUkVFLm9uZXJyb3IoICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeSAnICsgZGF0YS5nZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRUSFJFRS5vbmVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwgJyArIGRhdGEubWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdTcHJpdGUnOlxyXG5cclxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG1hdGVyaWFsc1sgZGF0YS5tYXRlcmlhbCBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFRIUkVFLm9uZXJyb3IoICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCAnICsgZGF0YS5tYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XHJcblx0XHRcdGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcclxuXHRcdFx0XHRtYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheSggZGF0YS5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5yb3RhdGlvbiApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xyXG5cdFx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggZGF0YS5jaGlsZHJlblsgY2hpbGQgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNjZW5lTG9hZGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uKCkge307XHJcblx0dGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuXHR0aGlzLmNhbGxiYWNrU3luYyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMuY2FsbGJhY2tQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5SGFuZGxlcnMgPSB7fTtcclxuXHR0aGlzLmhpZXJhcmNoeUhhbmRsZXJzID0ge307XHJcblxyXG5cdHRoaXMuYWRkR2VvbWV0cnlIYW5kbGVyKCBcImFzY2lpXCIsIFRIUkVFLkpTT05Mb2FkZXIgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TY2VuZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5TY2VuZUxvYWRlcixcclxuXHJcblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICksIG9uTG9hZCwgdXJsICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZEdlb21ldHJ5SGFuZGxlcjogZnVuY3Rpb24gKCB0eXBlSUQsIGxvYWRlckNsYXNzICkge1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnlIYW5kbGVyc1sgdHlwZUlEIF0gPSB7IFwibG9hZGVyQ2xhc3NcIjogbG9hZGVyQ2xhc3MgfTtcclxuXHJcblx0fSxcclxuXHJcblx0YWRkSGllcmFyY2h5SGFuZGxlcjogZnVuY3Rpb24gKCB0eXBlSUQsIGxvYWRlckNsYXNzICkge1xyXG5cclxuXHRcdHRoaXMuaGllcmFyY2h5SGFuZGxlcnNbIHR5cGVJRCBdID0geyBcImxvYWRlckNsYXNzXCI6IGxvYWRlckNsYXNzIH07XHJcblxyXG5cdH0sXHJcblxyXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIGNhbGxiYWNrRmluaXNoZWQsIHVybCApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciB1cmxCYXNlID0gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5leHRyYWN0VXJsQmFzZSggdXJsICk7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5LCBtYXRlcmlhbCwgY2FtZXJhLCBmb2csXHJcblx0XHRcdHRleHR1cmUsIGltYWdlcywgY29sb3IsXHJcblx0XHRcdGxpZ2h0LCBoZXgsIGludGVuc2l0eSxcclxuXHRcdFx0Y291bnRlcl9tb2RlbHMsIGNvdW50ZXJfdGV4dHVyZXMsXHJcblx0XHRcdHRvdGFsX21vZGVscywgdG90YWxfdGV4dHVyZXMsXHJcblx0XHRcdHJlc3VsdDtcclxuXHJcblx0XHR2YXIgdGFyZ2V0X2FycmF5ID0gW107XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBqc29uO1xyXG5cclxuXHRcdC8vIGFzeW5jIGdlb21ldHJ5IGxvYWRlcnNcclxuXHJcblx0XHRmb3IgKCB2YXIgdHlwZUlEIGluIHRoaXMuZ2VvbWV0cnlIYW5kbGVycyApIHtcclxuXHJcblx0XHRcdHZhciBsb2FkZXJDbGFzcyA9IHRoaXMuZ2VvbWV0cnlIYW5kbGVyc1sgdHlwZUlEIF1bIFwibG9hZGVyQ2xhc3NcIiBdO1xyXG5cdFx0XHR0aGlzLmdlb21ldHJ5SGFuZGxlcnNbIHR5cGVJRCBdWyBcImxvYWRlck9iamVjdFwiIF0gPSBuZXcgbG9hZGVyQ2xhc3MoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXN5bmMgaGllcmFjaHkgbG9hZGVyc1xyXG5cclxuXHRcdGZvciAoIHZhciB0eXBlSUQgaW4gdGhpcy5oaWVyYXJjaHlIYW5kbGVycyApIHtcclxuXHJcblx0XHRcdHZhciBsb2FkZXJDbGFzcyA9IHRoaXMuaGllcmFyY2h5SGFuZGxlcnNbIHR5cGVJRCBdWyBcImxvYWRlckNsYXNzXCIgXTtcclxuXHRcdFx0dGhpcy5oaWVyYXJjaHlIYW5kbGVyc1sgdHlwZUlEIF1bIFwibG9hZGVyT2JqZWN0XCIgXSA9IG5ldyBsb2FkZXJDbGFzcygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb3VudGVyX21vZGVscyA9IDA7XHJcblx0XHRjb3VudGVyX3RleHR1cmVzID0gMDtcclxuXHJcblx0XHRyZXN1bHQgPSB7XHJcblxyXG5cdFx0XHRzY2VuZTogbmV3IFRIUkVFLlNjZW5lKCksXHJcblx0XHRcdGdlb21ldHJpZXM6IHt9LFxyXG5cdFx0XHRmYWNlX21hdGVyaWFsczoge30sXHJcblx0XHRcdG1hdGVyaWFsczoge30sXHJcblx0XHRcdHRleHR1cmVzOiB7fSxcclxuXHRcdFx0b2JqZWN0czoge30sXHJcblx0XHRcdGNhbWVyYXM6IHt9LFxyXG5cdFx0XHRsaWdodHM6IHt9LFxyXG5cdFx0XHRmb2dzOiB7fSxcclxuXHRcdFx0ZW1wdGllczoge30sXHJcblx0XHRcdGdyb3Vwczoge31cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggZGF0YS50cmFuc2Zvcm0gKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBkYXRhLnRyYW5zZm9ybS5wb3NpdGlvbixcclxuXHRcdFx0XHRyb3RhdGlvbiA9IGRhdGEudHJhbnNmb3JtLnJvdGF0aW9uLFxyXG5cdFx0XHRcdHNjYWxlID0gZGF0YS50cmFuc2Zvcm0uc2NhbGU7XHJcblxyXG5cdFx0XHRpZiAoIHBvc2l0aW9uICkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQuc2NlbmUucG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByb3RhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0cmVzdWx0LnNjZW5lLnJvdGF0aW9uLmZyb21BcnJheSggcm90YXRpb24gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggc2NhbGUgKSB7XHJcblxyXG5cdFx0XHRcdHJlc3VsdC5zY2VuZS5zY2FsZS5mcm9tQXJyYXkoIHNjYWxlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHBvc2l0aW9uIHx8IHJvdGF0aW9uIHx8IHNjYWxlICkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQuc2NlbmUudXBkYXRlTWF0cml4KCk7XHJcblx0XHRcdFx0cmVzdWx0LnNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldF91cmwoIHNvdXJjZV91cmwsIHVybF90eXBlICkge1xyXG5cclxuXHRcdFx0aWYgKCB1cmxfdHlwZSA9PSBcInJlbGF0aXZlVG9IVE1MXCIgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBzb3VyY2VfdXJsO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHVybEJhc2UgKyBzb3VyY2VfdXJsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gdG9wbGV2ZWwgbG9hZGVyIGZ1bmN0aW9uLCBkZWxlZ2F0ZXMgdG8gaGFuZGxlX2NoaWxkcmVuXHJcblxyXG5cdFx0ZnVuY3Rpb24gaGFuZGxlX29iamVjdHMoKSB7XHJcblxyXG5cdFx0XHRoYW5kbGVfY2hpbGRyZW4oIHJlc3VsdC5zY2VuZSwgZGF0YS5vYmplY3RzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGhhbmRsZSBhbGwgdGhlIGNoaWxkcmVuIGZyb20gdGhlIGxvYWRlZCBqc29uIGFuZCBhdHRhY2ggdGhlbSB0byBnaXZlbiBwYXJlbnRcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVfY2hpbGRyZW4oIHBhcmVudCwgY2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0LCBkc3QsIHBvcywgcm90LCBzY2wsIHF1YXQ7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgb2JqSUQgaW4gY2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGJ5IGlkIGlmIGNoaWxkIGhhcyBhbHJlYWR5IGJlZW4gaGFuZGxlZCxcclxuXHRcdFx0XHQvLyBpZiBub3QsIGNyZWF0ZSBuZXcgb2JqZWN0XHJcblxyXG5cdFx0XHRcdHZhciBvYmplY3QgPSByZXN1bHQub2JqZWN0c1sgb2JqSUQgXTtcclxuXHRcdFx0XHR2YXIgb2JqSlNPTiA9IGNoaWxkcmVuWyBvYmpJRCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIG1lc2hlc1xyXG5cclxuXHRcdFx0XHRcdGlmICggb2JqSlNPTi50eXBlICYmICggb2JqSlNPTi50eXBlIGluIHNjb3BlLmhpZXJhcmNoeUhhbmRsZXJzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG9iakpTT04ubG9hZGluZyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgcmVzZXJ2ZWRUeXBlcyA9IHtcclxuXHRcdFx0XHRcdFx0XHRcdFwidHlwZVwiOiAxLCBcInVybFwiOiAxLCBcIm1hdGVyaWFsXCI6IDEsXHJcblx0XHRcdFx0XHRcdFx0XHRcInBvc2l0aW9uXCI6IDEsIFwicm90YXRpb25cIjogMSwgXCJzY2FsZVwiIDogMSxcclxuXHRcdFx0XHRcdFx0XHRcdFwidmlzaWJsZVwiOiAxLCBcImNoaWxkcmVuXCI6IDEsIFwidXNlckRhdGFcIjogMSxcclxuXHRcdFx0XHRcdFx0XHRcdFwic2tpblwiOiAxLCBcIm1vcnBoXCI6IDEsIFwibWlycm9yZWRMb29wXCI6IDEsIFwiZHVyYXRpb25cIjogMVxyXG5cdFx0XHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBsb2FkZXJQYXJhbWV0ZXJzID0ge307XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBwYXJUeXBlIGluIG9iakpTT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhICggcGFyVHlwZSBpbiByZXNlcnZlZFR5cGVzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRsb2FkZXJQYXJhbWV0ZXJzWyBwYXJUeXBlIF0gPSBvYmpKU09OWyBwYXJUeXBlIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gcmVzdWx0Lm1hdGVyaWFsc1sgb2JqSlNPTi5tYXRlcmlhbCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmpKU09OLmxvYWRpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgbG9hZGVyID0gc2NvcGUuaGllcmFyY2h5SGFuZGxlcnNbIG9iakpTT04udHlwZSBdWyBcImxvYWRlck9iamVjdFwiIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIENvbGxhZGFMb2FkZXJcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBsb2FkZXIub3B0aW9ucyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRsb2FkZXIubG9hZCggZ2V0X3VybCggb2JqSlNPTi51cmwsIGRhdGEudXJsQmFzZVR5cGUgKSwgY3JlYXRlX2NhbGxiYWNrX2hpZXJhY2h5KCBvYmpJRCwgcGFyZW50LCBtYXRlcmlhbCwgb2JqSlNPTiApICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIFVURjhMb2FkZXJcclxuXHRcdFx0XHRcdFx0XHQvLyBPQkpMb2FkZXJcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRsb2FkZXIubG9hZCggZ2V0X3VybCggb2JqSlNPTi51cmwsIGRhdGEudXJsQmFzZVR5cGUgKSwgY3JlYXRlX2NhbGxiYWNrX2hpZXJhY2h5KCBvYmpJRCwgcGFyZW50LCBtYXRlcmlhbCwgb2JqSlNPTiApLCBsb2FkZXJQYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvYmpKU09OLmdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IHJlc3VsdC5nZW9tZXRyaWVzWyBvYmpKU09OLmdlb21ldHJ5IF07XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBnZW9tZXRyeSBhbHJlYWR5IGxvYWRlZFxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIG5lZWRzVGFuZ2VudHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSByZXN1bHQubWF0ZXJpYWxzWyBvYmpKU09OLm1hdGVyaWFsIF07XHJcblx0XHRcdFx0XHRcdFx0bmVlZHNUYW5nZW50cyA9IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBvcyA9IG9iakpTT04ucG9zaXRpb247XHJcblx0XHRcdFx0XHRcdFx0cm90ID0gb2JqSlNPTi5yb3RhdGlvbjtcclxuXHRcdFx0XHRcdFx0XHRzY2wgPSBvYmpKU09OLnNjYWxlO1xyXG5cdFx0XHRcdFx0XHRcdG1hdCA9IG9iakpTT04ubWF0cml4O1xyXG5cdFx0XHRcdFx0XHRcdHF1YXQgPSBvYmpKU09OLnF1YXRlcm5pb247XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHVzZSBtYXRlcmlhbHMgZnJvbSB0aGUgbW9kZWwgZmlsZVxyXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIG1hdGVyaWFsIHNwZWNpZmllZCBpbiB0aGUgb2JqZWN0XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggISBvYmpKU09OLm1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwoIHJlc3VsdC5mYWNlX21hdGVyaWFsc1sgb2JqSlNPTi5nZW9tZXRyeSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gdXNlIG1hdGVyaWFscyBmcm9tIHRoZSBtb2RlbCBmaWxlXHJcblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMganVzdCBlbXB0eSBmYWNlIG1hdGVyaWFsXHJcblx0XHRcdFx0XHRcdFx0Ly8gKG11c3QgY3JlYXRlIG5ldyBtYXRlcmlhbCBhcyBlYWNoIG1vZGVsIGhhcyBpdHMgb3duIGZhY2UgbWF0ZXJpYWwpXHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSAmJiBtYXRlcmlhbC5tYXRlcmlhbHMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwoIHJlc3VsdC5mYWNlX21hdGVyaWFsc1sgb2JqSlNPTi5nZW9tZXRyeSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWwubWF0ZXJpYWxzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdG5lZWRzVGFuZ2VudHMgPSBuZWVkc1RhbmdlbnRzIHx8ICggbWF0ZXJpYWwubWF0ZXJpYWxzWyBpIF0gaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIG5lZWRzVGFuZ2VudHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBvYmpKU09OLnNraW4gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggb2JqSlNPTi5tb3JwaCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuTW9ycGhBbmltTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBvYmpKU09OLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRvYmplY3QuZHVyYXRpb24gPSBvYmpKU09OLmR1cmF0aW9uO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG9iakpTT04udGltZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0b2JqZWN0LnRpbWUgPSBvYmpKU09OLnRpbWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICggb2JqSlNPTi5taXJyb3JlZExvb3AgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdG9iamVjdC5taXJyb3JlZExvb3AgPSBvYmpKU09OLm1pcnJvcmVkTG9vcDtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5jb21wdXRlTW9ycGhOb3JtYWxzKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmplY3QubmFtZSA9IG9iaklEO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0Lm1hdHJpeC5zZXQoXHJcblx0XHRcdFx0XHRcdFx0XHRcdG1hdFswXSwgIG1hdFsxXSwgIG1hdFsyXSwgIG1hdFszXSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bWF0WzRdLCAgbWF0WzVdLCAgbWF0WzZdLCAgbWF0WzddLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXRbOF0sICBtYXRbOV0sICBtYXRbMTBdLCBtYXRbMTFdLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXRbMTJdLCBtYXRbMTNdLCBtYXRbMTRdLCBtYXRbMTVdXHJcblx0XHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIHBvcyApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICggcXVhdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdG9iamVjdC5xdWF0ZXJuaW9uLmZyb21BcnJheSggcXVhdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCByb3QgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0LnNjYWxlLmZyb21BcnJheSggc2NsICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnZpc2libGUgPSBvYmpKU09OLnZpc2libGU7XHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0LmNhc3RTaGFkb3cgPSBvYmpKU09OLmNhc3RTaGFkb3c7XHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBvYmpKU09OLnJlY2VpdmVTaGFkb3c7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBhcmVudC5hZGQoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQub2JqZWN0c1sgb2JqSUQgXSA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBsaWdodHNcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvYmpKU09OLnR5cGUgPT09IFwiQW1iaWVudExpZ2h0XCIgfHwgb2JqSlNPTi50eXBlID09PSBcIlBvaW50TGlnaHRcIiB8fFxyXG5cdFx0XHRcdFx0XHRvYmpKU09OLnR5cGUgPT09IFwiRGlyZWN0aW9uYWxMaWdodFwiIHx8IG9iakpTT04udHlwZSA9PT0gXCJTcG90TGlnaHRcIiB8fFxyXG5cdFx0XHRcdFx0XHRvYmpKU09OLnR5cGUgPT09IFwiSGVtaXNwaGVyZUxpZ2h0XCIgfHwgb2JqSlNPTi50eXBlID09PSBcIkFyZWFMaWdodFwiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGNvbG9yID0gb2JqSlNPTi5jb2xvcjtcclxuXHRcdFx0XHRcdFx0dmFyIGludGVuc2l0eSA9IG9iakpTT04uaW50ZW5zaXR5O1xyXG5cdFx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBvYmpKU09OLmRpc3RhbmNlO1xyXG5cdFx0XHRcdFx0XHR2YXIgcG9zaXRpb24gPSBvYmpKU09OLnBvc2l0aW9uO1xyXG5cdFx0XHRcdFx0XHR2YXIgcm90YXRpb24gPSBvYmpKU09OLnJvdGF0aW9uO1xyXG5cclxuXHRcdFx0XHRcdFx0c3dpdGNoICggb2JqSlNPTi50eXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlICdBbWJpZW50TGlnaHQnOlxyXG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCBjb2xvciApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxyXG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGxpZ2h0LnBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcclxuXHRcdFx0XHRcdFx0XHRcdGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGxpZ2h0LnBvc2l0aW9uLmZyb21BcnJheSggb2JqSlNPTi5kaXJlY3Rpb24gKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxyXG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuU3BvdExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgMSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQuYW5nbGUgPSBvYmpKU09OLmFuZ2xlO1xyXG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQucG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQudGFyZ2V0LnNldCggcG9zaXRpb25bIDAgXSwgcG9zaXRpb25bIDEgXSAtIGRpc3RhbmNlLCBwb3NpdGlvblsgMiBdICk7XHJcblx0XHRcdFx0XHRcdFx0XHRsaWdodC50YXJnZXQuYXBwbHlFdWxlciggbmV3IFRIUkVFLkV1bGVyKCByb3RhdGlvblsgMCBdLCByb3RhdGlvblsgMSBdLCByb3RhdGlvblsgMiBdLCAnWFlaJyApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcclxuXHRcdFx0XHRcdFx0XHRcdGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlICk7XHJcblx0XHRcdFx0XHRcdFx0XHRsaWdodC50YXJnZXQuc2V0KCBwb3NpdGlvblsgMCBdLCBwb3NpdGlvblsgMSBdIC0gZGlzdGFuY2UsIHBvc2l0aW9uWyAyIF0gKTtcclxuXHRcdFx0XHRcdFx0XHRcdGxpZ2h0LnRhcmdldC5hcHBseUV1bGVyKCBuZXcgVEhSRUUuRXVsZXIoIHJvdGF0aW9uWyAwIF0sIHJvdGF0aW9uWyAxIF0sIHJvdGF0aW9uWyAyIF0sICdYWVonICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlICdBcmVhTGlnaHQnOlxyXG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuQXJlYUxpZ2h0KGNvbG9yLCBpbnRlbnNpdHkpO1xyXG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQucG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0XHRcdFx0bGlnaHQud2lkdGggPSBvYmpKU09OLnNpemU7XHJcblx0XHRcdFx0XHRcdFx0XHRsaWdodC5oZWlnaHQgPSBvYmpKU09OLnNpemVfeTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cGFyZW50LmFkZCggbGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRcdGxpZ2h0Lm5hbWUgPSBvYmpJRDtcclxuXHRcdFx0XHRcdFx0cmVzdWx0LmxpZ2h0c1sgb2JqSUQgXSA9IGxpZ2h0O1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQub2JqZWN0c1sgb2JqSUQgXSA9IGxpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdC8vIGNhbWVyYXNcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvYmpKU09OLnR5cGUgPT09IFwiUGVyc3BlY3RpdmVDYW1lcmFcIiB8fCBvYmpKU09OLnR5cGUgPT09IFwiT3J0aG9ncmFwaGljQ2FtZXJhXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwb3MgPSBvYmpKU09OLnBvc2l0aW9uO1xyXG5cdFx0XHRcdFx0XHRyb3QgPSBvYmpKU09OLnJvdGF0aW9uO1xyXG5cdFx0XHRcdFx0XHRxdWF0ID0gb2JqSlNPTi5xdWF0ZXJuaW9uO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBvYmpKU09OLnR5cGUgPT09IFwiUGVyc3BlY3RpdmVDYW1lcmFcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBvYmpKU09OLmZvdiwgb2JqSlNPTi5hc3BlY3QsIG9iakpTT04ubmVhciwgb2JqSlNPTi5mYXIgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG9iakpTT04udHlwZSA9PT0gXCJPcnRob2dyYXBoaWNDYW1lcmFcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggb2JqSlNPTi5sZWZ0LCBvYmpKU09OLnJpZ2h0LCBvYmpKU09OLnRvcCwgb2JqSlNPTi5ib3R0b20sIG9iakpTT04ubmVhciwgb2JqSlNPTi5mYXIgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGNhbWVyYS5uYW1lID0gb2JqSUQ7XHJcblx0XHRcdFx0XHRcdGNhbWVyYS5wb3NpdGlvbi5mcm9tQXJyYXkoIHBvcyApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBxdWF0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhbWVyYS5xdWF0ZXJuaW9uLmZyb21BcnJheSggcXVhdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggcm90ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhbWVyYS5yb3RhdGlvbi5mcm9tQXJyYXkoIHJvdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cGFyZW50LmFkZCggY2FtZXJhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXN1bHQuY2FtZXJhc1sgb2JqSUQgXSA9IGNhbWVyYTtcclxuXHRcdFx0XHRcdFx0cmVzdWx0Lm9iamVjdHNbIG9iaklEIF0gPSBjYW1lcmE7XHJcblxyXG5cdFx0XHRcdFx0Ly8gcHVyZSBPYmplY3QzRFxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwb3MgPSBvYmpKU09OLnBvc2l0aW9uO1xyXG5cdFx0XHRcdFx0XHRyb3QgPSBvYmpKU09OLnJvdGF0aW9uO1xyXG5cdFx0XHRcdFx0XHRzY2wgPSBvYmpKU09OLnNjYWxlO1xyXG5cdFx0XHRcdFx0XHRxdWF0ID0gb2JqSlNPTi5xdWF0ZXJuaW9uO1xyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblx0XHRcdFx0XHRcdG9iamVjdC5uYW1lID0gb2JqSUQ7XHJcblx0XHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIHBvcyApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBxdWF0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5mcm9tQXJyYXkoIHF1YXQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5yb3RhdGlvbi5mcm9tQXJyYXkoIHJvdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0LnNjYWxlLmZyb21BcnJheSggc2NsICk7XHJcblx0XHRcdFx0XHRcdG9iamVjdC52aXNpYmxlID0gKCBvYmpKU09OLnZpc2libGUgIT09IHVuZGVmaW5lZCApID8gb2JqSlNPTi52aXNpYmxlIDogZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0XHRwYXJlbnQuYWRkKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRcdHJlc3VsdC5vYmplY3RzWyBvYmpJRCBdID0gb2JqZWN0O1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQuZW1wdGllc1sgb2JqSUQgXSA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG9iakpTT04udXNlckRhdGEgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBvYmpKU09OLnVzZXJEYXRhICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IG9iakpTT04udXNlckRhdGFbIGtleSBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0LnVzZXJEYXRhWyBrZXkgXSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG9iakpTT04uZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG9iakpTT04uZ3JvdXBzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBJRCA9IG9iakpTT04uZ3JvdXBzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXN1bHQuZ3JvdXBzWyBncm91cElEIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5ncm91cHNbIGdyb3VwSUQgXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQuZ3JvdXBzWyBncm91cElEIF0ucHVzaCggb2JqSUQgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICYmIG9iakpTT04uY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRoYW5kbGVfY2hpbGRyZW4oIG9iamVjdCwgb2JqSlNPTi5jaGlsZHJlbiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVfbWVzaCggZ2VvLCBtYXQsIGlkICkge1xyXG5cclxuXHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGlkIF0gPSBnZW87XHJcblx0XHRcdHJlc3VsdC5mYWNlX21hdGVyaWFsc1sgaWQgXSA9IG1hdDtcclxuXHRcdFx0aGFuZGxlX29iamVjdHMoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGhhbmRsZV9oaWVyYXJjaHkoIG5vZGUsIGlkLCBwYXJlbnQsIG1hdGVyaWFsLCBvYmogKSB7XHJcblxyXG5cdFx0XHR2YXIgcCA9IG9iai5wb3NpdGlvbjtcclxuXHRcdFx0dmFyIHIgPSBvYmoucm90YXRpb247XHJcblx0XHRcdHZhciBxID0gb2JqLnF1YXRlcm5pb247XHJcblx0XHRcdHZhciBzID0gb2JqLnNjYWxlO1xyXG5cclxuXHRcdFx0bm9kZS5wb3NpdGlvbi5mcm9tQXJyYXkoIHAgKTtcclxuXHJcblx0XHRcdGlmICggcSApIHtcclxuXHJcblx0XHRcdFx0bm9kZS5xdWF0ZXJuaW9uLmZyb21BcnJheSggcSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZS5yb3RhdGlvbi5mcm9tQXJyYXkoIHIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5vZGUuc2NhbGUuZnJvbUFycmF5KCBzICk7XHJcblxyXG5cdFx0XHQvLyBvdmVycmlkZSBjaGlsZHJlbiBtYXRlcmlhbHNcclxuXHRcdFx0Ly8gaWYgb2JqZWN0IG1hdGVyaWFsIHdhcyBzcGVjaWZpZWQgaW4gSlNPTiBleHBsaWNpdGx5XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRub2RlLnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xyXG5cclxuXHRcdFx0XHRcdGNoaWxkLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG92ZXJyaWRlIGNoaWxkcmVuIHZpc2liaWxpdHlcclxuXHRcdFx0Ly8gd2l0aCByb290IG5vZGUgdmlzaWJpbGl0eSBhcyBzcGVjaWZpZWQgaW4gSlNPTlxyXG5cclxuXHRcdFx0dmFyIHZpc2libGUgPSAoIG9iai52aXNpYmxlICE9PSB1bmRlZmluZWQgKSA/IG9iai52aXNpYmxlIDogdHJ1ZTtcclxuXHJcblx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XHJcblxyXG5cdFx0XHRcdGNoaWxkLnZpc2libGUgPSB2aXNpYmxlO1xyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0cGFyZW50LmFkZCggbm9kZSApO1xyXG5cclxuXHRcdFx0bm9kZS5uYW1lID0gaWQ7XHJcblxyXG5cdFx0XHRyZXN1bHQub2JqZWN0c1sgaWQgXSA9IG5vZGU7XHJcblx0XHRcdGhhbmRsZV9vYmplY3RzKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVfY2FsbGJhY2tfZ2VvbWV0cnkoIGlkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggZ2VvLCBtYXQgKSB7XHJcblxyXG5cdFx0XHRcdGdlby5uYW1lID0gaWQ7XHJcblxyXG5cdFx0XHRcdGhhbmRsZV9tZXNoKCBnZW8sIG1hdCwgaWQgKTtcclxuXHJcblx0XHRcdFx0Y291bnRlcl9tb2RlbHMgLT0gMTtcclxuXHJcblx0XHRcdFx0c2NvcGUub25Mb2FkQ29tcGxldGUoKTtcclxuXHJcblx0XHRcdFx0YXN5bmNfY2FsbGJhY2tfZ2F0ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlX2NhbGxiYWNrX2hpZXJhY2h5KCBpZCwgcGFyZW50LCBtYXRlcmlhbCwgb2JqICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciByZXN1bHQ7XHJcblxyXG5cdFx0XHRcdC8vIGxvYWRlcnMgd2hpY2ggdXNlIEV2ZW50RGlzcGF0Y2hlclxyXG5cclxuXHRcdFx0XHRpZiAoIGV2ZW50LmNvbnRlbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0ID0gZXZlbnQuY29udGVudDtcclxuXHJcblx0XHRcdFx0Ly8gQ29sbGFkYUxvYWRlclxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBldmVudC5kYWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0ID0gZXZlbnQuc2NlbmU7XHJcblxyXG5cclxuXHRcdFx0XHQvLyBVVEY4TG9hZGVyXHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0ID0gZXZlbnQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aGFuZGxlX2hpZXJhcmNoeSggcmVzdWx0LCBpZCwgcGFyZW50LCBtYXRlcmlhbCwgb2JqICk7XHJcblxyXG5cdFx0XHRcdGNvdW50ZXJfbW9kZWxzIC09IDE7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm9uTG9hZENvbXBsZXRlKCk7XHJcblxyXG5cdFx0XHRcdGFzeW5jX2NhbGxiYWNrX2dhdGUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZV9jYWxsYmFja19lbWJlZCggaWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBnZW8sIG1hdCApIHtcclxuXHJcblx0XHRcdFx0Z2VvLm5hbWUgPSBpZDtcclxuXHJcblx0XHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGlkIF0gPSBnZW87XHJcblx0XHRcdFx0cmVzdWx0LmZhY2VfbWF0ZXJpYWxzWyBpZCBdID0gbWF0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0ZnVuY3Rpb24gYXN5bmNfY2FsbGJhY2tfZ2F0ZSgpIHtcclxuXHJcblx0XHRcdHZhciBwcm9ncmVzcyA9IHtcclxuXHJcblx0XHRcdFx0dG90YWxNb2RlbHMgOiB0b3RhbF9tb2RlbHMsXHJcblx0XHRcdFx0dG90YWxUZXh0dXJlcyA6IHRvdGFsX3RleHR1cmVzLFxyXG5cdFx0XHRcdGxvYWRlZE1vZGVscyA6IHRvdGFsX21vZGVscyAtIGNvdW50ZXJfbW9kZWxzLFxyXG5cdFx0XHRcdGxvYWRlZFRleHR1cmVzIDogdG90YWxfdGV4dHVyZXMgLSBjb3VudGVyX3RleHR1cmVzXHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0c2NvcGUuY2FsbGJhY2tQcm9ncmVzcyggcHJvZ3Jlc3MsIHJlc3VsdCApO1xyXG5cclxuXHRcdFx0c2NvcGUub25Mb2FkUHJvZ3Jlc3MoKTtcclxuXHJcblx0XHRcdGlmICggY291bnRlcl9tb2RlbHMgPT09IDAgJiYgY291bnRlcl90ZXh0dXJlcyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0ZmluYWxpemUoKTtcclxuXHRcdFx0XHRjYWxsYmFja0ZpbmlzaGVkKCByZXN1bHQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZpbmFsaXplKCkge1xyXG5cclxuXHRcdFx0Ly8gdGFrZSBjYXJlIG9mIHRhcmdldHMgd2hpY2ggY291bGQgYmUgYXN5bmNocm9ub3VzbHkgbG9hZGVkIG9iamVjdHNcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRhcmdldF9hcnJheS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0YSA9IHRhcmdldF9hcnJheVsgaSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gcmVzdWx0Lm9iamVjdHNbIHRhLnRhcmdldE5hbWUgXTtcclxuXHJcblx0XHRcdFx0aWYgKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGEub2JqZWN0LnRhcmdldCA9IHRhcmdldDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBpZiB0aGVyZSB3YXMgZXJyb3IgYW5kIHRhcmdldCBvZiBzcGVjaWZpZWQgbmFtZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzY2VuZSBmaWxlXHJcblx0XHRcdFx0XHQvLyBjcmVhdGUgaW5zdGVhZCBkdW1teSB0YXJnZXRcclxuXHRcdFx0XHRcdC8vICh0YXJnZXQgbXVzdCBiZSBhZGRlZCB0byBzY2VuZSBleHBsaWNpdGx5IGFzIHBhcmVudCBpcyBhbHJlYWR5IGFkZGVkKVxyXG5cclxuXHRcdFx0XHRcdHRhLm9iamVjdC50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHRcdFx0XHRcdHJlc3VsdC5zY2VuZS5hZGQoIHRhLm9iamVjdC50YXJnZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0YS5vYmplY3QudGFyZ2V0LnVzZXJEYXRhLnRhcmdldEludmVyc2UgPSB0YS5vYmplY3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgY2FsbGJhY2tUZXh0dXJlID0gZnVuY3Rpb24gKCBjb3VudCApIHtcclxuXHJcblx0XHRcdGNvdW50ZXJfdGV4dHVyZXMgLT0gY291bnQ7XHJcblx0XHRcdGFzeW5jX2NhbGxiYWNrX2dhdGUoKTtcclxuXHJcblx0XHRcdHNjb3BlLm9uTG9hZENvbXBsZXRlKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBtdXN0IHVzZSB0aGlzIGluc3RlYWQgb2YganVzdCBkaXJlY3RseSBjYWxsaW5nIGNhbGxiYWNrVGV4dHVyZVxyXG5cdFx0Ly8gYmVjYXVzZSBvZiBjbG9zdXJlIGluIHRoZSBjYWxsaW5nIGNvbnRleHQgbG9vcFxyXG5cclxuXHRcdHZhciBnZW5lcmF0ZVRleHR1cmVDYWxsYmFjayA9IGZ1bmN0aW9uICggY291bnQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjYWxsYmFja1RleHR1cmUoIGNvdW50ICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0ZnVuY3Rpb24gdHJhdmVyc2VfanNvbl9oaWVyYXJjaHkoIG9iakpTT04sIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0Y2FsbGJhY2soIG9iakpTT04gKTtcclxuXHJcblx0XHRcdGlmICggb2JqSlNPTi5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgb2JqQ2hpbGRJRCBpbiBvYmpKU09OLmNoaWxkcmVuICkge1xyXG5cclxuXHRcdFx0XHRcdHRyYXZlcnNlX2pzb25faGllcmFyY2h5KCBvYmpKU09OLmNoaWxkcmVuWyBvYmpDaGlsZElEIF0sIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGZpcnN0IGdvIHN5bmNocm9ub3VzIGVsZW1lbnRzXHJcblxyXG5cdFx0Ly8gZm9nc1xyXG5cclxuXHRcdHZhciBmb2dJRCwgZm9nSlNPTjtcclxuXHJcblx0XHRmb3IgKCBmb2dJRCBpbiBkYXRhLmZvZ3MgKSB7XHJcblxyXG5cdFx0XHRmb2dKU09OID0gZGF0YS5mb2dzWyBmb2dJRCBdO1xyXG5cclxuXHRcdFx0aWYgKCBmb2dKU09OLnR5cGUgPT09IFwibGluZWFyXCIgKSB7XHJcblxyXG5cdFx0XHRcdGZvZyA9IG5ldyBUSFJFRS5Gb2coIDB4MDAwMDAwLCBmb2dKU09OLm5lYXIsIGZvZ0pTT04uZmFyICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmb2dKU09OLnR5cGUgPT09IFwiZXhwMlwiICkge1xyXG5cclxuXHRcdFx0XHRmb2cgPSBuZXcgVEhSRUUuRm9nRXhwMiggMHgwMDAwMDAsIGZvZ0pTT04uZGVuc2l0eSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29sb3IgPSBmb2dKU09OLmNvbG9yO1xyXG5cdFx0XHRmb2cuY29sb3Iuc2V0UkdCKCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdICk7XHJcblxyXG5cdFx0XHRyZXN1bHQuZm9nc1sgZm9nSUQgXSA9IGZvZztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbm93IGNvbWUgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzIGVsZW1lbnRzXHJcblxyXG5cdFx0Ly8gZ2VvbWV0cmllc1xyXG5cclxuXHRcdC8vIGNvdW50IGhvdyBtYW55IGdlb21ldHJpZXMgd2lsbCBiZSBsb2FkZWQgYXN5bmNocm9ub3VzbHlcclxuXHJcblx0XHR2YXIgZ2VvSUQsIGdlb0pTT047XHJcblxyXG5cdFx0Zm9yICggZ2VvSUQgaW4gZGF0YS5nZW9tZXRyaWVzICkge1xyXG5cclxuXHRcdFx0Z2VvSlNPTiA9IGRhdGEuZ2VvbWV0cmllc1sgZ2VvSUQgXTtcclxuXHJcblx0XHRcdGlmICggZ2VvSlNPTi50eXBlIGluIHRoaXMuZ2VvbWV0cnlIYW5kbGVycyApIHtcclxuXHJcblx0XHRcdFx0Y291bnRlcl9tb2RlbHMgKz0gMTtcclxuXHJcblx0XHRcdFx0c2NvcGUub25Mb2FkU3RhcnQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY291bnQgaG93IG1hbnkgaGllcmFyY2hpZXMgd2lsbCBiZSBsb2FkZWQgYXN5bmNocm9ub3VzbHlcclxuXHJcblx0XHRmb3IgKCB2YXIgb2JqSUQgaW4gZGF0YS5vYmplY3RzICkge1xyXG5cclxuXHRcdFx0dHJhdmVyc2VfanNvbl9oaWVyYXJjaHkoIGRhdGEub2JqZWN0c1sgb2JqSUQgXSwgZnVuY3Rpb24gKCBvYmpKU09OICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iakpTT04udHlwZSAmJiAoIG9iakpTT04udHlwZSBpbiBzY29wZS5oaWVyYXJjaHlIYW5kbGVycyApICkge1xyXG5cclxuXHRcdFx0XHRcdGNvdW50ZXJfbW9kZWxzICs9IDE7XHJcblxyXG5cdFx0XHRcdFx0c2NvcGUub25Mb2FkU3RhcnQoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRvdGFsX21vZGVscyA9IGNvdW50ZXJfbW9kZWxzO1xyXG5cclxuXHRcdGZvciAoIGdlb0lEIGluIGRhdGEuZ2VvbWV0cmllcyApIHtcclxuXHJcblx0XHRcdGdlb0pTT04gPSBkYXRhLmdlb21ldHJpZXNbIGdlb0lEIF07XHJcblxyXG5cdFx0XHRpZiAoIGdlb0pTT04udHlwZSA9PT0gXCJjdWJlXCIgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KCBnZW9KU09OLndpZHRoLCBnZW9KU09OLmhlaWdodCwgZ2VvSlNPTi5kZXB0aCwgZ2VvSlNPTi53aWR0aFNlZ21lbnRzLCBnZW9KU09OLmhlaWdodFNlZ21lbnRzLCBnZW9KU09OLmRlcHRoU2VnbWVudHMgKTtcclxuXHRcdFx0XHRnZW9tZXRyeS5uYW1lID0gZ2VvSUQ7XHJcblx0XHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGdlb0lEIF0gPSBnZW9tZXRyeTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGdlb0pTT04udHlwZSA9PT0gXCJwbGFuZVwiICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KCBnZW9KU09OLndpZHRoLCBnZW9KU09OLmhlaWdodCwgZ2VvSlNPTi53aWR0aFNlZ21lbnRzLCBnZW9KU09OLmhlaWdodFNlZ21lbnRzICk7XHJcblx0XHRcdFx0Z2VvbWV0cnkubmFtZSA9IGdlb0lEO1xyXG5cdFx0XHRcdHJlc3VsdC5nZW9tZXRyaWVzWyBnZW9JRCBdID0gZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9KU09OLnR5cGUgPT09IFwic3BoZXJlXCIgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBnZW9KU09OLnJhZGl1cywgZ2VvSlNPTi53aWR0aFNlZ21lbnRzLCBnZW9KU09OLmhlaWdodFNlZ21lbnRzICk7XHJcblx0XHRcdFx0Z2VvbWV0cnkubmFtZSA9IGdlb0lEO1xyXG5cdFx0XHRcdHJlc3VsdC5nZW9tZXRyaWVzWyBnZW9JRCBdID0gZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9KU09OLnR5cGUgPT09IFwiY3lsaW5kZXJcIiApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggZ2VvSlNPTi50b3BSYWQsIGdlb0pTT04uYm90UmFkLCBnZW9KU09OLmhlaWdodCwgZ2VvSlNPTi5yYWRTZWdzLCBnZW9KU09OLmhlaWdodFNlZ3MgKTtcclxuXHRcdFx0XHRnZW9tZXRyeS5uYW1lID0gZ2VvSUQ7XHJcblx0XHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGdlb0lEIF0gPSBnZW9tZXRyeTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGdlb0pTT04udHlwZSA9PT0gXCJ0b3J1c1wiICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KCBnZW9KU09OLnJhZGl1cywgZ2VvSlNPTi50dWJlLCBnZW9KU09OLnNlZ21lbnRzUiwgZ2VvSlNPTi5zZWdtZW50c1QgKTtcclxuXHRcdFx0XHRnZW9tZXRyeS5uYW1lID0gZ2VvSUQ7XHJcblx0XHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGdlb0lEIF0gPSBnZW9tZXRyeTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGdlb0pTT04udHlwZSA9PT0gXCJpY29zYWhlZHJvblwiICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCBnZW9KU09OLnJhZGl1cywgZ2VvSlNPTi5zdWJkaXZpc2lvbnMgKTtcclxuXHRcdFx0XHRnZW9tZXRyeS5uYW1lID0gZ2VvSUQ7XHJcblx0XHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGdlb0lEIF0gPSBnZW9tZXRyeTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGdlb0pTT04udHlwZSBpbiB0aGlzLmdlb21ldHJ5SGFuZGxlcnMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsb2FkZXJQYXJhbWV0ZXJzID0ge307XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBwYXJUeXBlIGluIGdlb0pTT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBwYXJUeXBlICE9PSBcInR5cGVcIiAmJiBwYXJUeXBlICE9PSBcInVybFwiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bG9hZGVyUGFyYW1ldGVyc1sgcGFyVHlwZSBdID0gZ2VvSlNPTlsgcGFyVHlwZSBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5nZW9tZXRyeUhhbmRsZXJzWyBnZW9KU09OLnR5cGUgXVsgXCJsb2FkZXJPYmplY3RcIiBdO1xyXG5cdFx0XHRcdGxvYWRlci5sb2FkKCBnZXRfdXJsKCBnZW9KU09OLnVybCwgZGF0YS51cmxCYXNlVHlwZSApLCBjcmVhdGVfY2FsbGJhY2tfZ2VvbWV0cnkoIGdlb0lEICksIGxvYWRlclBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGdlb0pTT04udHlwZSA9PT0gXCJlbWJlZGRlZFwiICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbW9kZWxKc29uID0gZGF0YS5lbWJlZHNbIGdlb0pTT04uaWQgXSxcclxuXHRcdFx0XHRcdHRleHR1cmVfcGF0aCA9IFwiXCI7XHJcblxyXG5cdFx0XHRcdC8vIHBhc3MgbWV0YWRhdGEgYWxvbmcgdG8ganNvbkxvYWRlciBzbyBpdCBrbm93cyB0aGUgZm9ybWF0IHZlcnNpb25cclxuXHJcblx0XHRcdFx0bW9kZWxKc29uLm1ldGFkYXRhID0gZGF0YS5tZXRhZGF0YTtcclxuXHJcblx0XHRcdFx0aWYgKCBtb2RlbEpzb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGpzb25Mb2FkZXIgPSB0aGlzLmdlb21ldHJ5SGFuZGxlcnNbIFwiYXNjaWlcIiBdWyBcImxvYWRlck9iamVjdFwiIF07XHJcblx0XHRcdFx0XHR2YXIgbW9kZWwgPSBqc29uTG9hZGVyLnBhcnNlKCBtb2RlbEpzb24sIHRleHR1cmVfcGF0aCApO1xyXG5cdFx0XHRcdFx0Y3JlYXRlX2NhbGxiYWNrX2VtYmVkKCBnZW9JRCApKCBtb2RlbC5nZW9tZXRyeSwgbW9kZWwubWF0ZXJpYWxzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGV4dHVyZXNcclxuXHJcblx0XHQvLyBjb3VudCBob3cgbWFueSB0ZXh0dXJlcyB3aWxsIGJlIGxvYWRlZCBhc3luY2hyb25vdXNseVxyXG5cclxuXHRcdHZhciB0ZXh0dXJlSUQsIHRleHR1cmVKU09OO1xyXG5cclxuXHRcdGZvciAoIHRleHR1cmVJRCBpbiBkYXRhLnRleHR1cmVzICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZUpTT04gPSBkYXRhLnRleHR1cmVzWyB0ZXh0dXJlSUQgXTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZUpTT04udXJsIGluc3RhbmNlb2YgQXJyYXkgKSB7XHJcblxyXG5cdFx0XHRcdGNvdW50ZXJfdGV4dHVyZXMgKz0gdGV4dHVyZUpTT04udXJsLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0Zm9yKCB2YXIgbiA9IDA7IG4gPCB0ZXh0dXJlSlNPTi51cmwubGVuZ3RoOyBuICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHNjb3BlLm9uTG9hZFN0YXJ0KCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvdW50ZXJfdGV4dHVyZXMgKz0gMTtcclxuXHJcblx0XHRcdFx0c2NvcGUub25Mb2FkU3RhcnQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dG90YWxfdGV4dHVyZXMgPSBjb3VudGVyX3RleHR1cmVzO1xyXG5cclxuXHRcdGZvciAoIHRleHR1cmVJRCBpbiBkYXRhLnRleHR1cmVzICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZUpTT04gPSBkYXRhLnRleHR1cmVzWyB0ZXh0dXJlSUQgXTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZUpTT04ubWFwcGluZyAhPT0gdW5kZWZpbmVkICYmIFRIUkVFWyB0ZXh0dXJlSlNPTi5tYXBwaW5nIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZUpTT04ubWFwcGluZyA9IG5ldyBUSFJFRVsgdGV4dHVyZUpTT04ubWFwcGluZyBdKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVKU09OLnVybCBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY291bnQgPSB0ZXh0dXJlSlNPTi51cmwubGVuZ3RoO1xyXG5cdFx0XHRcdHZhciB1cmxfYXJyYXkgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1cmxfYXJyYXlbIGkgXSA9IGdldF91cmwoIHRleHR1cmVKU09OLnVybFsgaSBdLCBkYXRhLnVybEJhc2VUeXBlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9IC9cXC5kZHMkL2kudGVzdCggdXJsX2FycmF5WyAwIF0gKTtcclxuXHJcblx0XHRcdFx0aWYgKCBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZSA9IFRIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSggdXJsX2FycmF5LCB0ZXh0dXJlSlNPTi5tYXBwaW5nLCBnZW5lcmF0ZVRleHR1cmVDYWxsYmFjayggY291bnQgKSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSggdXJsX2FycmF5LCB0ZXh0dXJlSlNPTi5tYXBwaW5nLCBnZW5lcmF0ZVRleHR1cmVDYWxsYmFjayggY291bnQgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgaXNDb21wcmVzc2VkID0gL1xcLmRkcyQvaS50ZXN0KCB0ZXh0dXJlSlNPTi51cmwgKTtcclxuXHRcdFx0XHR2YXIgZnVsbFVybCA9IGdldF91cmwoIHRleHR1cmVKU09OLnVybCwgZGF0YS51cmxCYXNlVHlwZSApO1xyXG5cdFx0XHRcdHZhciB0ZXh0dXJlQ2FsbGJhY2sgPSBnZW5lcmF0ZVRleHR1cmVDYWxsYmFjayggMSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGlzQ29tcHJlc3NlZCApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUoIGZ1bGxVcmwsIHRleHR1cmVKU09OLm1hcHBpbmcsIHRleHR1cmVDYWxsYmFjayApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKCBmdWxsVXJsLCB0ZXh0dXJlSlNPTi5tYXBwaW5nLCB0ZXh0dXJlQ2FsbGJhY2sgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIFRIUkVFWyB0ZXh0dXJlSlNPTi5taW5GaWx0ZXIgXSAhPT0gdW5kZWZpbmVkIClcclxuXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gVEhSRUVbIHRleHR1cmVKU09OLm1pbkZpbHRlciBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIFRIUkVFWyB0ZXh0dXJlSlNPTi5tYWdGaWx0ZXIgXSAhPT0gdW5kZWZpbmVkIClcclxuXHRcdFx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gVEhSRUVbIHRleHR1cmVKU09OLm1hZ0ZpbHRlciBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmVKU09OLmFuaXNvdHJvcHkgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSB0ZXh0dXJlSlNPTi5hbmlzb3Ryb3B5O1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmVKU09OLnJlcGVhdCApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLnJlcGVhdC5zZXQoIHRleHR1cmVKU09OLnJlcGVhdFsgMCBdLCB0ZXh0dXJlSlNPTi5yZXBlYXRbIDEgXSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGV4dHVyZUpTT04ucmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmVKU09OLnJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZUpTT04ub2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUub2Zmc2V0LnNldCggdGV4dHVyZUpTT04ub2Zmc2V0WyAwIF0sIHRleHR1cmVKU09OLm9mZnNldFsgMSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gaGFuZGxlIHdyYXAgYWZ0ZXIgcmVwZWF0IHNvIHRoYXQgZGVmYXVsdCByZXBlYXQgY2FuIGJlIG92ZXJyaWRlblxyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmVKU09OLndyYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHdyYXBNYXAgPSB7XHJcblx0XHRcdFx0XHRcdFwicmVwZWF0XCI6IFRIUkVFLlJlcGVhdFdyYXBwaW5nLFxyXG5cdFx0XHRcdFx0XHRcIm1pcnJvclwiOiBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB3cmFwTWFwWyB0ZXh0dXJlSlNPTi53cmFwWyAwIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwUyA9IHdyYXBNYXBbIHRleHR1cmVKU09OLndyYXBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0aWYgKCB3cmFwTWFwWyB0ZXh0dXJlSlNPTi53cmFwWyAxIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwVCA9IHdyYXBNYXBbIHRleHR1cmVKU09OLndyYXBbIDEgXSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXN1bHQudGV4dHVyZXNbIHRleHR1cmVJRCBdID0gdGV4dHVyZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbWF0ZXJpYWxzXHJcblxyXG5cdFx0dmFyIG1hdElELCBtYXRKU09OO1xyXG5cdFx0dmFyIHBhcklEO1xyXG5cclxuXHRcdGZvciAoIG1hdElEIGluIGRhdGEubWF0ZXJpYWxzICkge1xyXG5cclxuXHRcdFx0bWF0SlNPTiA9IGRhdGEubWF0ZXJpYWxzWyBtYXRJRCBdO1xyXG5cclxuXHRcdFx0Zm9yICggcGFySUQgaW4gbWF0SlNPTi5wYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBhcklEID09PSBcImVudk1hcFwiIHx8IHBhcklEID09PSBcIm1hcFwiIHx8IHBhcklEID09PSBcImxpZ2h0TWFwXCIgfHwgcGFySUQgPT09IFwiYnVtcE1hcFwiICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IHJlc3VsdC50ZXh0dXJlc1sgbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdIF07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcklEID09PSBcInNoYWRpbmdcIiApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSAoIG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9PT0gXCJmbGF0XCIgKSA/IFRIUkVFLkZsYXRTaGFkaW5nIDogVEhSRUUuU21vb3RoU2hhZGluZztcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggcGFySUQgPT09IFwic2lkZVwiICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID09IFwiZG91YmxlXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSBUSFJFRS5Eb3VibGVTaWRlO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9PSBcImJhY2tcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IFRIUkVFLkJhY2tTaWRlO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSBUSFJFRS5Gcm9udFNpZGU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJJRCA9PT0gXCJibGVuZGluZ1wiICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSBpbiBUSFJFRSA/IFRIUkVFWyBtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gXSA6IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJJRCA9PT0gXCJjb21iaW5lXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID0gbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdIGluIFRIUkVFID8gVEhSRUVbIG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSBdIDogVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcklEID09PSBcInZlcnRleENvbG9yc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID09IFwiZmFjZVwiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID0gVEhSRUUuRmFjZUNvbG9ycztcclxuXHJcblx0XHRcdFx0XHQvLyBkZWZhdWx0IHRvIHZlcnRleCBjb2xvcnMgaWYgXCJ2ZXJ0ZXhDb2xvcnNcIiBpcyBhbnl0aGluZyBlbHNlIGZhY2UgY29sb3JzIG9yIDAgLyBudWxsIC8gZmFsc2VcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSBUSFJFRS5WZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJJRCA9PT0gXCJ3cmFwUkdCXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHYzID0gbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdO1xyXG5cdFx0XHRcdFx0bWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoIHYzWyAwIF0sIHYzWyAxIF0sIHYzWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIG1hdEpTT04ucGFyYW1ldGVycy5vcGFjaXR5IDwgMS4wICkge1xyXG5cclxuXHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnMudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMubm9ybWFsTWFwICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcIm5vcm1hbG1hcFwiIF07XHJcblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0XHRcdHZhciBkaWZmdXNlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLmNvbG9yO1xyXG5cdFx0XHRcdHZhciBzcGVjdWxhciA9IG1hdEpTT04ucGFyYW1ldGVycy5zcGVjdWxhcjtcclxuXHRcdFx0XHR2YXIgYW1iaWVudCA9IG1hdEpTT04ucGFyYW1ldGVycy5hbWJpZW50O1xyXG5cdFx0XHRcdHZhciBzaGluaW5lc3MgPSBtYXRKU09OLnBhcmFtZXRlcnMuc2hpbmluZXNzO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0Tm9ybWFsXCIgXS52YWx1ZSA9IHJlc3VsdC50ZXh0dXJlc1sgbWF0SlNPTi5wYXJhbWV0ZXJzLm5vcm1hbE1hcCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5ub3JtYWxTY2FsZSApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc1sgXCJ1Tm9ybWFsU2NhbGVcIiBdLnZhbHVlLnNldCggbWF0SlNPTi5wYXJhbWV0ZXJzLm5vcm1hbFNjYWxlWyAwIF0sIG1hdEpTT04ucGFyYW1ldGVycy5ub3JtYWxTY2FsZVsgMSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMubWFwICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zWyBcInREaWZmdXNlXCIgXS52YWx1ZSA9IG1hdEpTT04ucGFyYW1ldGVycy5tYXA7XHJcblx0XHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVEaWZmdXNlXCIgXS52YWx1ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMuZW52TWFwICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zWyBcInRDdWJlXCIgXS52YWx1ZSA9IG1hdEpTT04ucGFyYW1ldGVycy5lbnZNYXA7XHJcblx0XHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVSZWZsZWN0aW9uXCIgXS52YWx1ZSA9IHRydWU7XHJcblx0XHRcdFx0XHR1bmlmb3Jtc1sgXCJyZWZsZWN0aXZpdHlcIiBdLnZhbHVlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLnJlZmxlY3Rpdml0eTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5saWdodE1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc1sgXCJ0QU9cIiBdLnZhbHVlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLmxpZ2h0TWFwO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlQU9cIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5zcGVjdWxhck1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc1sgXCJ0U3BlY3VsYXJcIiBdLnZhbHVlID0gcmVzdWx0LnRleHR1cmVzWyBtYXRKU09OLnBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgXTtcclxuXHRcdFx0XHRcdHVuaWZvcm1zWyBcImVuYWJsZVNwZWN1bGFyXCIgXS52YWx1ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zWyBcInREaXNwbGFjZW1lbnRcIiBdLnZhbHVlID0gcmVzdWx0LnRleHR1cmVzWyBtYXRKU09OLnBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwIF07XHJcblx0XHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVEaXNwbGFjZW1lbnRcIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc1sgXCJ1RGlzcGxhY2VtZW50Qmlhc1wiIF0udmFsdWUgPSBtYXRKU09OLnBhcmFtZXRlcnMuZGlzcGxhY2VtZW50QmlhcztcclxuXHRcdFx0XHRcdHVuaWZvcm1zWyBcInVEaXNwbGFjZW1lbnRTY2FsZVwiIF0udmFsdWUgPSBtYXRKU09OLnBhcmFtZXRlcnMuZGlzcGxhY2VtZW50U2NhbGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwiZGlmZnVzZVwiIF0udmFsdWUuc2V0SGV4KCBkaWZmdXNlICk7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwic3BlY3VsYXJcIiBdLnZhbHVlLnNldEhleCggc3BlY3VsYXIgKTtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJhbWJpZW50XCIgXS52YWx1ZS5zZXRIZXgoIGFtYmllbnQgKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwic2hpbmluZXNzXCIgXS52YWx1ZSA9IHNoaW5pbmVzcztcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMub3BhY2l0eSApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc1sgXCJvcGFjaXR5XCIgXS52YWx1ZSA9IG1hdEpTT04ucGFyYW1ldGVycy5vcGFjaXR5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJzID0geyBmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiB1bmlmb3JtcywgbGlnaHRzOiB0cnVlLCBmb2c6IHRydWUgfTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFWyBtYXRKU09OLnR5cGUgXSggbWF0SlNPTi5wYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5uYW1lID0gbWF0SUQ7XHJcblxyXG5cdFx0XHRyZXN1bHQubWF0ZXJpYWxzWyBtYXRJRCBdID0gbWF0ZXJpYWw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNlY29uZCBwYXNzIHRocm91Z2ggYWxsIG1hdGVyaWFscyB0byBpbml0aWFsaXplIE1lc2hGYWNlTWF0ZXJpYWxzXHJcblx0XHQvLyB0aGF0IGNvdWxkIGJlIHJlZmVycmluZyB0byBvdGhlciBtYXRlcmlhbHMgb3V0IG9mIG9yZGVyXHJcblxyXG5cdFx0Zm9yICggbWF0SUQgaW4gZGF0YS5tYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0XHRtYXRKU09OID0gZGF0YS5tYXRlcmlhbHNbIG1hdElEIF07XHJcblxyXG5cdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5tYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtYXRlcmlhbEFycmF5ID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdEpTT04ucGFyYW1ldGVycy5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBsYWJlbCA9IG1hdEpTT04ucGFyYW1ldGVycy5tYXRlcmlhbHNbIGkgXTtcclxuXHRcdFx0XHRcdG1hdGVyaWFsQXJyYXkucHVzaCggcmVzdWx0Lm1hdGVyaWFsc1sgbGFiZWwgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJlc3VsdC5tYXRlcmlhbHNbIG1hdElEIF0ubWF0ZXJpYWxzID0gbWF0ZXJpYWxBcnJheTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb2JqZWN0cyAoIHN5bmNocm9ub3VzIGluaXQgb2YgcHJvY2VkdXJhbCBwcmltaXRpdmVzIClcclxuXHJcblx0XHRoYW5kbGVfb2JqZWN0cygpO1xyXG5cclxuXHRcdC8vIGRlZmF1bHRzXHJcblxyXG5cdFx0aWYgKCByZXN1bHQuY2FtZXJhcyAmJiBkYXRhLmRlZmF1bHRzLmNhbWVyYSApIHtcclxuXHJcblx0XHRcdHJlc3VsdC5jdXJyZW50Q2FtZXJhID0gcmVzdWx0LmNhbWVyYXNbIGRhdGEuZGVmYXVsdHMuY2FtZXJhIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVzdWx0LmZvZ3MgJiYgZGF0YS5kZWZhdWx0cy5mb2cgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHQuc2NlbmUuZm9nID0gcmVzdWx0LmZvZ3NbIGRhdGEuZGVmYXVsdHMuZm9nIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHN5bmNocm9ub3VzIGNhbGxiYWNrXHJcblxyXG5cdFx0c2NvcGUuY2FsbGJhY2tTeW5jKCByZXN1bHQgKTtcclxuXHJcblx0XHQvLyBqdXN0IGluIGNhc2UgdGhlcmUgYXJlIG5vIGFzeW5jIGVsZW1lbnRzXHJcblxyXG5cdFx0YXN5bmNfY2FsbGJhY2tfZ2F0ZSgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5UZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xyXG5cclxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmVMb2FkZXIsXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBpbWFnZSApO1xyXG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWF0ZXJpYWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuaWQgPSBUSFJFRS5NYXRlcmlhbElkQ291bnQgKys7XHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcclxuXHJcblx0dGhpcy5vcGFjaXR5ID0gMTtcclxuXHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcclxuXHJcblx0dGhpcy5ibGVuZFNyYyA9IFRIUkVFLlNyY0FscGhhRmFjdG9yO1xyXG5cdHRoaXMuYmxlbmREc3QgPSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yO1xyXG5cdHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xyXG5cclxuXHR0aGlzLmRlcHRoVGVzdCA9IHRydWU7XHJcblx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XHJcblx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcclxuXHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XHJcblxyXG5cdHRoaXMuYWxwaGFUZXN0ID0gMDtcclxuXHJcblx0dGhpcy5vdmVyZHJhdyA9IDA7IC8vIE92ZXJkcmF3biBwaXhlbHMgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGZvciBmaXhpbmcgYW50aWFsaWFzaW5nIGdhcHMgaW4gQ2FudmFzUmVuZGVyZXJcclxuXHJcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWwsXHJcblxyXG5cdHNldFZhbHVlczogZnVuY3Rpb24gKCB2YWx1ZXMgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZXMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcclxuXHJcblx0XHRcdHZhciBuZXdWYWx1ZSA9IHZhbHVlc1sga2V5IF07XHJcblxyXG5cdFx0XHRpZiAoIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFRIUkVFLm9ud2FybmluZyggJ1RIUkVFLk1hdGVyaWFsOiBcXCcnICsga2V5ICsgJ1xcJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLicgKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgga2V5IGluIHRoaXMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjdXJyZW50VmFsdWUgPSB0aGlzWyBrZXkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICYmIG5ld1ZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyApIHtcclxuXHJcblx0XHRcdFx0XHRjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICgga2V5ID09ICdvdmVyZHJhdycpIHtcclxuXHJcblx0XHRcdFx0XHQvLyBlbnN1cmUgb3ZlcmRyYXcgaXMgYmFja3dhcmRzLWNvbXBhdGFibGUgd2l0aCBsZWdhY3kgYm9vbGVhbiB0eXBlXHJcblx0XHRcdFx0XHR0aGlzWyBrZXkgXSA9IE51bWJlcihuZXdWYWx1ZSk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpc1sga2V5IF0gPSBuZXdWYWx1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWF0ZXJpYWwoKTtcclxuXHJcblx0XHRtYXRlcmlhbC5uYW1lID0gdGhpcy5uYW1lO1xyXG5cclxuXHRcdG1hdGVyaWFsLnNpZGUgPSB0aGlzLnNpZGU7XHJcblxyXG5cdFx0bWF0ZXJpYWwub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuXHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdGhpcy50cmFuc3BhcmVudDtcclxuXHJcblx0XHRtYXRlcmlhbC5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XHJcblxyXG5cdFx0bWF0ZXJpYWwuYmxlbmRTcmMgPSB0aGlzLmJsZW5kU3JjO1xyXG5cdFx0bWF0ZXJpYWwuYmxlbmREc3QgPSB0aGlzLmJsZW5kRHN0O1xyXG5cdFx0bWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiA9IHRoaXMuYmxlbmRFcXVhdGlvbjtcclxuXHJcblx0XHRtYXRlcmlhbC5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcclxuXHRcdG1hdGVyaWFsLmRlcHRoV3JpdGUgPSB0aGlzLmRlcHRoV3JpdGU7XHJcblxyXG5cdFx0bWF0ZXJpYWwucG9seWdvbk9mZnNldCA9IHRoaXMucG9seWdvbk9mZnNldDtcclxuXHRcdG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I7XHJcblx0XHRtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSB0aGlzLnBvbHlnb25PZmZzZXRVbml0cztcclxuXHJcblx0XHRtYXRlcmlhbC5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcclxuXHJcblx0XHRtYXRlcmlhbC5vdmVyZHJhdyA9IHRoaXMub3ZlcmRyYXc7XHJcblxyXG5cdFx0bWF0ZXJpYWwudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcclxuXHJcblx0XHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTWF0ZXJpYWxJZENvdW50ID0gMDtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKiAgbGluZWNhcDogXCJyb3VuZFwiLFxyXG4gKiAgbGluZWpvaW46IFwicm91bmRcIixcclxuICpcclxuICogIHZlcnRleENvbG9yczogPGJvb2w+XHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHJcblx0dGhpcy5saW5ld2lkdGggPSAxO1xyXG5cdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XHJcblx0dGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdG1hdGVyaWFsLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xyXG5cdG1hdGVyaWFsLmxpbmVjYXAgPSB0aGlzLmxpbmVjYXA7XHJcblx0bWF0ZXJpYWwubGluZWpvaW4gPSB0aGlzLmxpbmVqb2luO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHNjYWxlOiA8ZmxvYXQ+LFxyXG4gKiAgZGFzaFNpemU6IDxmbG9hdD4sXHJcbiAqICBnYXBTaXplOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHJcblx0dGhpcy5saW5ld2lkdGggPSAxO1xyXG5cclxuXHR0aGlzLnNjYWxlID0gMTtcclxuXHR0aGlzLmRhc2hTaXplID0gMztcclxuXHR0aGlzLmdhcFNpemUgPSAxO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cclxuXHRtYXRlcmlhbC5saW5ld2lkdGggPSB0aGlzLmxpbmV3aWR0aDtcclxuXHJcblx0bWF0ZXJpYWwuc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG5cdG1hdGVyaWFsLmRhc2hTaXplID0gdGhpcy5kYXNoU2l6ZTtcclxuXHRtYXRlcmlhbC5nYXBTaXplID0gdGhpcy5nYXBTaXplO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xyXG5cclxuXHRtYXRlcmlhbC5saWdodE1hcCA9IHRoaXMubGlnaHRNYXA7XHJcblxyXG5cdG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcDtcclxuXHJcblx0bWF0ZXJpYWwuZW52TWFwID0gdGhpcy5lbnZNYXA7XHJcblx0bWF0ZXJpYWwuY29tYmluZSA9IHRoaXMuY29tYmluZTtcclxuXHRtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcclxuXHRtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XHJcblxyXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xyXG5cdG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBhbWJpZW50OiA8aGV4PixcclxuICogIGVtaXNzaXZlOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXHJcblx0dGhpcy5hbWJpZW50ID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblxyXG5cdHRoaXMud3JhcEFyb3VuZCA9IGZhbHNlO1xyXG5cdHRoaXMud3JhcFJHQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHRtYXRlcmlhbC5hbWJpZW50LmNvcHkoIHRoaXMuYW1iaWVudCApO1xyXG5cdG1hdGVyaWFsLmVtaXNzaXZlLmNvcHkoIHRoaXMuZW1pc3NpdmUgKTtcclxuXHJcblx0bWF0ZXJpYWwud3JhcEFyb3VuZCA9IHRoaXMud3JhcEFyb3VuZDtcclxuXHRtYXRlcmlhbC53cmFwUkdCLmNvcHkoIHRoaXMud3JhcFJHQiApO1xyXG5cclxuXHRtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcclxuXHJcblx0bWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwO1xyXG5cclxuXHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXA7XHJcblxyXG5cdG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZW52TWFwO1xyXG5cdG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XHJcblx0bWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7XHJcblx0bWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xyXG5cclxuXHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcclxuXHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcclxuXHRtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFscztcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgYW1iaWVudDogPGhleD4sXHJcbiAqICBlbWlzc2l2ZTogPGhleD4sXHJcbiAqICBzcGVjdWxhcjogPGhleD4sXHJcbiAqICBzaGluaW5lc3M6IDxmbG9hdD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcclxuICpcclxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG5cdHRoaXMuYW1iaWVudCA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcclxuXHR0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xyXG5cdHRoaXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblx0dGhpcy5zaGluaW5lc3MgPSAzMDtcclxuXHJcblx0dGhpcy53cmFwQXJvdW5kID0gZmFsc2U7XHJcblx0dGhpcy53cmFwUkdCID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBudWxsO1xyXG5cdHRoaXMub3BhY2l0eU1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBudWxsO1xyXG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xyXG5cdHRoaXMuYnVtcFNjYWxlID0gMTtcclxuXHJcblx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xyXG5cdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5lbnZNYXAgPSBudWxsO1xyXG5cdHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xyXG5cdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcclxuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblx0bWF0ZXJpYWwuYW1iaWVudC5jb3B5KCB0aGlzLmFtYmllbnQgKTtcclxuXHRtYXRlcmlhbC5lbWlzc2l2ZS5jb3B5KCB0aGlzLmVtaXNzaXZlICk7XHJcblx0bWF0ZXJpYWwuc3BlY3VsYXIuY29weSggdGhpcy5zcGVjdWxhciApO1xyXG5cdG1hdGVyaWFsLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xyXG5cclxuXHRtYXRlcmlhbC53cmFwQXJvdW5kID0gdGhpcy53cmFwQXJvdW5kO1xyXG5cdG1hdGVyaWFsLndyYXBSR0IuY29weSggdGhpcy53cmFwUkdCICk7XHJcblxyXG5cdG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xyXG5cdG1hdGVyaWFsLm9wYWNpdHlNYXAgPSB0aGlzLm9wYWNpdHlNYXA7XHJcblxyXG5cdG1hdGVyaWFsLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcDtcclxuXHRtYXRlcmlhbC5lbWlzc2l2ZU1hcCA9IHRoaXMuZW1pc3NpdmVNYXA7XHJcblxyXG5cdG1hdGVyaWFsLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXA7XHJcblx0bWF0ZXJpYWwuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XHJcblxyXG5cdG1hdGVyaWFsLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwO1xyXG5cdG1hdGVyaWFsLm5vcm1hbFNjYWxlLmNvcHkoIHRoaXMubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0bWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwO1xyXG5cclxuXHRtYXRlcmlhbC5lbnZNYXAgPSB0aGlzLmVudk1hcDtcclxuXHRtYXRlcmlhbC5jb21iaW5lID0gdGhpcy5jb21iaW5lO1xyXG5cdG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5O1xyXG5cdG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuXHRtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcclxuXHJcblx0bWF0ZXJpYWwuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcclxuXHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xyXG5cclxuXHRtYXRlcmlhbC5za2lubmluZyA9IHRoaXMuc2tpbm5pbmc7XHJcblx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XHJcblx0bWF0ZXJpYWwubW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICpcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuICpcclxuICovXHJcblxyXG5USFJFRS5NZXNoUGh5c2ljYWxNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXHJcblx0dGhpcy5tYXAgPSBudWxsO1xyXG5cdHRoaXMub3BhY2l0eU1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuZmFsbG9mZiA9IGZhbHNlO1xyXG5cdHRoaXMuZmFsbG9mZkNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cdHRoaXMuZmFsbG9mZk1hcCA9IG51bGw7XHJcblx0dGhpcy5mYWxsb2ZmQmxlbmRQYXJhbXMgPSBuZXcgVEhSRUUuVmVjdG9yNCggMS4wLCAwLjAsIDAuMCwgMS4wICk7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblx0XHJcblx0dGhpcy5yb3VnaG5lc3MgPSAwLjU7XHJcblx0dGhpcy5yb3VnaG5lc3NNYXAgPSBudWxsO1xyXG5cdFxyXG5cdHRoaXMubWV0YWxsaWMgPSAwLjA7XHJcblx0dGhpcy5tZXRhbGxpY01hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuY2xlYXJDb2F0ID0gMC4wO1x0Ly8gMCBtZWFucyBubyBjbGVhciBjb2F0LCAxIG1lYW5zIGNvbXBsZXRlIGNsZWFyIGNvYXQuXHJcblx0dGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgPSAwLjI7XHJcblxyXG5cdHRoaXMuYW5pc290cm9weSA9IDAuMDtcdC8vIHZhbGlkIHJhbmdlIGlzIFstMSwxXS4tMSBpcyBtYXggdmVydGljYWwgZWxvbmdhdGlvbiwgMCBpcyBub3JtYWwsICsxIGlzIG1heCBob3Jpem9udGFsIGVsb25nYXRpb25cclxuXHR0aGlzLmFuaXNvdHJvcHlNYXAgPSBudWxsO1x0Ly8gb25seSBSIGlzIHJlYWQgYW5kIGNvbnNpZGVyZWQgdG8gYmUgYW5pc290cm9weS4gIFRvIGdldCBuZWdhdGl2ZSB2YWx1ZXMsIHVzZSB0ZXh0dXJlIGJyaWdodG5lc3MsIGdhaW5cclxuXHR0aGlzLmFuaXNvdHJvcHlSb3RhdGlvbiA9IDAuMDsgLy8gY29udmVydGVkIHRvIHJhZGlhcyB2aWEgbXVsdGlwbGljYXRpb24gYnkgMipQSS4gIFRodXMgdGhlIHJhbmdlIFsgMCAtIDEgXSBtYXBzIHRvIHJhZGlhbiBbMCwgUEldLlxyXG5cdHRoaXMuYW5pc290cm9weVJvdGF0aW9uTWFwID0gbnVsbDsgIC8vIG9ubHkgUiBpcyByZWFkIGFuZCBjb25zaWRlcmVkIHRvIGJlIGFuaXNvdHJvcHlSb3RhdGlvbi5cclxuXHJcblx0dGhpcy50cmFuc2x1Y2VuY3kgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0dGhpcy50cmFuc2x1Y2VuY3lNYXAgPSBudWxsO1xyXG5cdHRoaXMudHJhbnNsdWNlbmN5Tm9ybWFsQWxwaGEgPSAwLjc1O1xyXG5cdHRoaXMudHJhbnNsdWNlbmN5Tm9ybWFsUG93ZXIgPSAxLjA7XHJcblx0dGhpcy50cmFuc2x1Y2VuY3lWaWV3UG93ZXIgPSAyLjA7XHJcblx0dGhpcy50cmFuc2x1Y2VuY3lWaWV3QWxwaGEgPSAwLjc1O1xyXG5cclxuXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xyXG5cdHRoaXMuYnVtcFNjYWxlID0gMTtcclxuXHJcblx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xyXG5cdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHR0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xyXG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsOyBcdC8vIGdpdmVuIG9mZiBhcmJpdHJhcmlseSBieSB0aGUgb2JqZWN0IGluIGFsbCBkaXJlY3Rpb25zLiAgQmFzaWNhbGx5IEdJLlxyXG5cclxuXHR0aGlzLmFtYmllbnQgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0dGhpcy5saWdodE1hcCA9IG51bGw7IC8vIGluY29taW5nIGxpZ2h0XHJcblxyXG5cdHRoaXMuZW52TWFwID0gbnVsbDsgIC8vIEluY29taW5nIGVudmlyb25tZW50YWwgbGlnaHQuXHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuQWRkT3BlcmF0aW9uO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nXHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdHRoaXMuYmxlbmRpbmcgPSBUSFJFRS5DdXN0b21CbGVuZGluZztcclxuXHR0aGlzLmJsZW5kU3JjID0gVEhSRUUuT25lRmFjdG9yO1x0Ly8gb3V0cHV0IG9mIHNoYWRlciBtdXN0IGJlIHByZW11bHRpcGxpZWRcclxuXHR0aGlzLmJsZW5kRHN0ID0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvcjtcclxuXHR0aGlzLmJsZW5kRXF1YXRpb24gPSBUSFJFRS5BZGRFcXVhdGlvbjtcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxufTtcclxuXHJcblRIUkVFLk1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBoeXNpY2FsTWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHRtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcclxuXHRtYXRlcmlhbC5vcGFjaXR5TWFwID0gdGhpcy5vcGFjaXR5TWFwO1xyXG5cclxuXHRtYXRlcmlhbC5mYWxsb2ZmID0gdGhpcy5mYWxsb2ZmO1xyXG5cdG1hdGVyaWFsLmZhbGxvZmZDb2xvci5jb3B5KCB0aGlzLmZhbGxvZmZDb2xvciApO1xyXG5cdG1hdGVyaWFsLmZhbGxvZmZNYXAgPSB0aGlzLmZhbGxvZmZNYXA7XHJcblx0bWF0ZXJpYWwuZmFsbG9mZkJsZW5kUGFyYW1zLmNvcHkoIHRoaXMuZmFsbG9mZkJsZW5kUGFyYW1zICk7XHJcblxyXG5cdG1hdGVyaWFsLnNwZWN1bGFyLmNvcHkoIHRoaXMuc3BlY3VsYXIgKTtcclxuXHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXA7XHJcblxyXG5cdG1hdGVyaWFsLnJvdWdobmVzcyA9IHRoaXMucm91Z2huZXNzO1xyXG5cdG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IHRoaXMucm91Z2huZXNzTWFwO1xyXG5cdG1hdGVyaWFsLm1ldGFsbGljID0gdGhpcy5tZXRhbGxpYztcclxuXHRtYXRlcmlhbC5tZXRhbGxpY01hcCA9IHRoaXMubWV0YWxsaWNNYXA7XHJcblxyXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XHJcblxyXG5cdG1hdGVyaWFsLnRyYW5zbHVjZW5jeS5jb3B5KCB0aGlzLnRyYW5zbHVjZW5jeSApO1xyXG5cdG1hdGVyaWFsLnRyYW5zbHVjZW5jeU1hcCA9IHRoaXMudHJhbnNsdWNlbmN5TWFwO1xyXG5cdG1hdGVyaWFsLnRyYW5zbHVjZW5jeU5vcm1hbEFscGhhID0gdGhpcy50cmFuc2x1Y2VuY3lOb3JtYWxBbHBoYTtcclxuXHRtYXRlcmlhbC50cmFuc2x1Y2VuY3lOb3JtYWxQb3dlciA9IHRoaXMudHJhbnNsdWNlbmN5Tm9ybWFsUG93ZXI7XHJcblx0bWF0ZXJpYWwudHJhbnNsdWNlbmN5Vmlld1Bvd2VyID0gdGhpcy50cmFuc2x1Y2VuY3lWaWV3UG93ZXI7XHJcblx0bWF0ZXJpYWwudHJhbnNsdWNlbmN5Vmlld0FscGhhID0gdGhpcy50cmFuc2x1Y2VuY3lWaWV3QWxwaGE7XHJcblxyXG5cdG1hdGVyaWFsLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXA7XHJcblx0bWF0ZXJpYWwuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XHJcblxyXG5cdG1hdGVyaWFsLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwO1xyXG5cdG1hdGVyaWFsLm5vcm1hbFNjYWxlLmNvcHkoIHRoaXMubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0bWF0ZXJpYWwuZW1pc3NpdmUuY29weSggdGhpcy5lbWlzc2l2ZSApO1xyXG5cdG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gdGhpcy5lbWlzc2l2ZU1hcDtcclxuXHJcblx0bWF0ZXJpYWwuYW1iaWVudC5jb3B5KCB0aGlzLmFtYmllbnQgKTtcclxuXHRtYXRlcmlhbC5saWdodE1hcCA9IHRoaXMubGlnaHRNYXA7XHJcblxyXG5cdG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZW52TWFwO1xyXG5cdG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XHJcblxyXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xyXG5cdG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xyXG5cdG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5GbGF0U2hhZGluZztcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcclxuXHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NZXNoRmFjZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoRmFjZU1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwoKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgc2l6ZTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuc2l6ZSA9IDE7XHJcblx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSB0cnVlO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cclxuXHRtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcclxuXHJcblx0bWF0ZXJpYWwuc2l6ZSA9IHRoaXMuc2l6ZTtcclxuXHRtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG5cclxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IFRIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWw7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGZyYWdtZW50U2hhZGVyOiA8c3RyaW5nPixcclxuICogIHZlcnRleFNoYWRlcjogPHN0cmluZz4sXHJcbiAqXHJcbiAqICB1bmlmb3JtczogeyBcInBhcmFtZXRlcjFcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LCBcInBhcmFtZXRlcjJcIjogeyB0eXBlOiBcImlcIiB2YWx1ZTI6IDIgfSB9LFxyXG4gKlxyXG4gKiAgZGVmaW5lczogeyBcImxhYmVsXCIgOiBcInZhbHVlXCIgfSxcclxuICpcclxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgbGlnaHRzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcclxuICpcclxuICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxyXG4gKlxyXG4gKlx0Zm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLlNoYWRlck1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBcInZvaWQgbWFpbigpIHt9XCI7XHJcblx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBcInZvaWQgbWFpbigpIHt9XCI7XHJcblx0dGhpcy51bmlmb3JtcyA9IHt9O1xyXG5cdHRoaXMuZGVmaW5lcyA9IHt9O1xyXG5cdHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdHRoaXMubGluZXdpZHRoID0gMTtcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXHJcblxyXG5cdHRoaXMubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7IC8vIHNldCB0byB1c2UgXCJjb2xvclwiIGF0dHJpYnV0ZSBzdHJlYW1cclxuXHJcblx0dGhpcy5za2lubmluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNraW5uaW5nIGF0dHJpYnV0ZSBzdHJlYW1zXHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggdGFyZ2V0c1xyXG5cdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggbm9ybWFsc1xyXG5cclxuXHQvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcclxuXHQvLyB1c2UgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaW4gV2ViR0wuIFRoaXMgYXZvaWRzIGVycm9ycyB3aGVuIGJ1ZmZlciBkYXRhIGlzIG1pc3NpbmcuXHJcblx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xyXG5cdFx0XCJjb2xvclwiIDogWyAxLCAxLCAxXSxcclxuXHRcdFwidXZcIiA6IFsgMCwgMCBdLFxyXG5cdFx0XCJ1djJcIiA6IFsgMCwgMCBdXHJcblx0fTtcclxuXHJcblx0Ly8gQnkgZGVmYXVsdCwgYmluZCBwb3NpdGlvbiB0byBhdHRyaWJ1dGUgaW5kZXggMC4gSW4gV2ViR0wsIGF0dHJpYnV0ZSAwXHJcblx0Ly8gc2hvdWxkIGFsd2F5cyBiZSB1c2VkIHRvIGF2b2lkIHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBlbXVsYXRpb24uXHJcblx0dGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gXCJwb3NpdGlvblwiO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcclxuXHRtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcclxuXHJcblx0bWF0ZXJpYWwudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCB0aGlzLnVuaWZvcm1zICk7XHJcblxyXG5cdG1hdGVyaWFsLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblx0bWF0ZXJpYWwuZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcclxuXHJcblx0bWF0ZXJpYWwuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcclxuXHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRtYXRlcmlhbC5saWdodHMgPSB0aGlzLmxpZ2h0cztcclxuXHJcblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcclxuXHJcblx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XHJcblx0bWF0ZXJpYWwubW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICpcdHV2T2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gKlx0dXZTY2FsZTogbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5TcHJpdGVNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHQvLyBkZWZhdWx0c1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5yb3RhdGlvbiA9IDA7XHJcblxyXG5cdHRoaXMuZm9nID0gZmFsc2U7XHJcblxyXG5cdC8vIHNldCBwYXJhbWV0ZXJzXHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xyXG5cclxuXHRtYXRlcmlhbC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBwcm9ncmFtOiA8ZnVuY3Rpb24+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZ1xyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlQ2FudmFzTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHR0aGlzLnByb2dyYW0gPSBmdW5jdGlvbiAoIGNvbnRleHQsIGNvbG9yICkge307XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3ByaXRlQ2FudmFzTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5TcHJpdGVDYW52YXNNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVDYW52YXNNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdG1hdGVyaWFsLnByb2dyYW0gPSB0aGlzLnByb2dyYW07XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cclxuVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbCA9IFRIUkVFLlNwcml0ZUNhbnZhc01hdGVyaWFsO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cHM6Ly9jbGFyYS5pby9cclxuICovXHJcblxyXG5USFJFRS5UZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHR0aGlzLmlkID0gVEhSRUUuVGV4dHVyZUlkQ291bnQgKys7XHJcblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuaW1hZ2UgPSBpbWFnZTtcclxuXHR0aGlzLm1pcG1hcHMgPSBbXTtcclxuXHJcblx0dGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IG5ldyBUSFJFRS5VVk1hcHBpbmcoKTtcclxuXHJcblx0dGhpcy53cmFwUyA9IHdyYXBTICE9PSB1bmRlZmluZWQgPyB3cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblx0dGhpcy53cmFwVCA9IHdyYXBUICE9PSB1bmRlZmluZWQgPyB3cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG5cdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcclxuXHJcblx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XHJcblxyXG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBUSFJFRS5SR0JBRm9ybWF0O1xyXG5cdHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xyXG5cclxuXHR0aGlzLm9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XHJcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHQvLyBmb3JtdWxhIHVzZWRcclxuXHQvLyB4JyA9ICggeCAtIGdhaW5QaXZvdCApICogZ2FpbiArIGJyaWdodG5lc3MgKyBnYWluUGl2b3RcclxuXHQvLyBmb3Igc3RhbmRhcmQgY29udHJhc3QgYWRqdXN0LCBzZXQgZ2FpbiB0byBjb250cmFzdCwgYW5kIGdhaW5QaXZvdCB0byAwLjVcclxuXHR0aGlzLmdhaW5QaXZvdCA9IDAuMDtcclxuXHR0aGlzLmdhaW4gPSAxLjA7XHJcblx0dGhpcy5icmlnaHRuZXNzID0gMC4wO1xyXG5cclxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XHJcblx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XHJcblx0dGhpcy5mbGlwWSA9IHRydWU7XHJcblx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0OyAvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcclxuXHJcblx0dGhpcy5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLm9uVXBkYXRlID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0dXJlLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXHJcblxyXG5cdGdldCBuZWVkc1VwZGF0ZSAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX25lZWRzVXBkYXRlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgbmVlZHNVcGRhdGUgKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGlmICggdGV4dHVyZSA9PT0gdW5kZWZpbmVkICkgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XHJcblxyXG5cdFx0dGV4dHVyZS5pbWFnZSA9IHRoaXMuaW1hZ2U7XHJcblx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0aGlzLm1pcG1hcHMuc2xpY2UoMCk7XHJcblxyXG5cdFx0dGV4dHVyZS5tYXBwaW5nID0gdGhpcy5tYXBwaW5nO1xyXG5cclxuXHRcdHRleHR1cmUud3JhcFMgPSB0aGlzLndyYXBTO1xyXG5cdFx0dGV4dHVyZS53cmFwVCA9IHRoaXMud3JhcFQ7XHJcblxyXG5cdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSB0aGlzLm1hZ0ZpbHRlcjtcclxuXHRcdHRleHR1cmUubWluRmlsdGVyID0gdGhpcy5taW5GaWx0ZXI7XHJcblxyXG5cdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdGhpcy5hbmlzb3Ryb3B5O1xyXG5cclxuXHRcdHRleHR1cmUuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XHJcblx0XHR0ZXh0dXJlLnR5cGUgPSB0aGlzLnR5cGU7XHJcblxyXG5cdFx0dGV4dHVyZS5vZmZzZXQuY29weSggdGhpcy5vZmZzZXQgKTtcclxuXHRcdHRleHR1cmUucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XHJcblxyXG5cdFx0dGV4dHVyZS5nYWluUGl2b3QgPSB0aGlzLmdhaW5QaXZvdDtcclxuXHRcdHRleHR1cmUuZ2FpbiA9IHRoaXMuZ2FpbjtcclxuXHRcdHRleHR1cmUuYnJpZ2h0bmVzcyA9IHRoaXMuYnJpZ2h0bmVzcztcclxuXHJcblx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cdFx0dGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID0gdGhpcy5wcmVtdWx0aXBseUFscGhhO1xyXG5cdFx0dGV4dHVyZS5mbGlwWSA9IHRoaXMuZmxpcFk7XHJcblx0XHR0ZXh0dXJlLnVucGFja0FsaWdubWVudCA9IHRoaXMudW5wYWNrQWxpZ25tZW50O1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3VwZGF0ZScgfSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuVGV4dHVyZUlkQ291bnQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiAoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cdHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7IC8vIFdlYkdMIGN1cnJlbnRseSBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzLCB0aGV5IG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xyXG5cclxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XHJcblxyXG5cdHJldHVybiB0ZXh0dXJlO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRhdGFUZXh0dXJlID0gZnVuY3Rpb24gKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG5cdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSgpO1xyXG5cclxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XHJcblxyXG5cdHJldHVybiB0ZXh0dXJlO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlBhcnRpY2xlU3lzdGVtID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcclxuXHJcblx0dGhpcy5zb3J0UGFydGljbGVzID0gZmFsc2U7XHJcblx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFydGljbGVTeXN0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5QYXJ0aWNsZVN5c3RlbS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5QYXJ0aWNsZVN5c3RlbSggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xyXG5cclxuXHRvYmplY3Quc29ydFBhcnRpY2xlcyA9IHRoaXMuc29ydFBhcnRpY2xlcztcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xyXG5cclxuXHRyZXR1cm4gb2JqZWN0O1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxpbmUgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdHlwZSApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcclxuXHJcblx0dGhpcy50eXBlID0gKCB0eXBlICE9PSB1bmRlZmluZWQgKSA/IHR5cGUgOiBUSFJFRS5MaW5lU3RyaXA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZVN0cmlwID0gMDtcclxuVEhSRUUuTGluZVBpZWNlcyA9IDE7XHJcblxyXG5USFJFRS5MaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLnR5cGUgKTtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xyXG5cclxuXHRyZXR1cm4gb2JqZWN0O1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xyXG5cclxuXHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS51cGRhdGVNb3JwaFRhcmdldHMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdHRoaXMubW9ycGhUYXJnZXRCYXNlID0gLTE7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0Rm9yY2VkT3JkZXIgPSBbXTtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRpZiAoIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcclxuXHJcblx0fVxyXG5cclxuXHRUSFJFRS5vbndhcm5pbmcoIFwiVEhSRUUuTWVzaC5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lOiBtb3JwaCB0YXJnZXQgXCIgKyBuYW1lICsgXCIgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLlwiICk7XHJcblxyXG5cdHJldHVybiAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XHJcblxyXG5cdHJldHVybiBvYmplY3Q7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQm9uZSA9IGZ1bmN0aW9uKCBiZWxvbmdzVG9Ta2luICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuc2tpbiA9IGJlbG9uZ3NUb1NraW47XHJcblx0dGhpcy5za2luTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb25lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQm9uZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBwYXJlbnRTa2luTWF0cml4LCBmb3JjZVVwZGF0ZSApIHtcclxuXHJcblx0Ly8gdXBkYXRlIGxvY2FsXHJcblxyXG5cdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkge1xyXG5cclxuXHRcdGZvcmNlVXBkYXRlIHw9IHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gdXBkYXRlIHNraW4gbWF0cml4XHJcblxyXG5cdGlmICggZm9yY2VVcGRhdGUgfHwgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdGlmKCBwYXJlbnRTa2luTWF0cml4ICkge1xyXG5cclxuXHRcdFx0dGhpcy5za2luTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHBhcmVudFNraW5NYXRyaXgsIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuc2tpbk1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHRcdGZvcmNlVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0dmFyIGNoaWxkLCBpLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR0aGlzLmNoaWxkcmVuWyBpIF0udXBkYXRlKCB0aGlzLnNraW5NYXRyaXgsIGZvcmNlVXBkYXRlICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0VEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XHJcblxyXG5cdC8vIGluaXQgYm9uZXNcclxuXHJcblx0dGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdHRoaXMuYm9uZXMgPSBbXTtcclxuXHR0aGlzLmJvbmVNYXRyaWNlcyA9IFtdO1xyXG5cclxuXHR2YXIgYiwgYm9uZSwgZ2JvbmUsIHAsIHEsIHM7XHJcblxyXG5cdGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmJvbmVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0Zm9yICggYiA9IDA7IGIgPCB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiArKyApIHtcclxuXHJcblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xyXG5cclxuXHRcdFx0cCA9IGdib25lLnBvcztcclxuXHRcdFx0cSA9IGdib25lLnJvdHE7XHJcblx0XHRcdHMgPSBnYm9uZS5zY2w7XHJcblxyXG5cdFx0XHRib25lID0gdGhpcy5hZGRCb25lKCk7XHJcblxyXG5cdFx0XHRib25lLm5hbWUgPSBnYm9uZS5uYW1lO1xyXG5cdFx0XHRib25lLnBvc2l0aW9uLnNldCggcFswXSwgcFsxXSwgcFsyXSApO1xyXG5cdFx0XHRib25lLnF1YXRlcm5pb24uc2V0KCBxWzBdLCBxWzFdLCBxWzJdLCBxWzNdICk7XHJcblx0XHRcclxuXHRcdFx0aWYgKCBzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGJvbmUuc2NhbGUuc2V0KCBzWzBdLCBzWzFdLCBzWzJdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRib25lLnNjYWxlLnNldCggMSwgMSwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBiID0gMDsgYiA8IHRoaXMuYm9uZXMubGVuZ3RoOyBiICsrICkge1xyXG5cclxuXHRcdFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XHJcblx0XHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XHJcblxyXG5cdFx0XHRpZiAoIGdib25lLnBhcmVudCA9PT0gLTEgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkKCBib25lICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvbmVzWyBnYm9uZS5wYXJlbnQgXS5hZGQoIGJvbmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgbkJvbmVzID0gdGhpcy5ib25lcy5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXHJcblx0XHRcdC8vXHRSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxyXG5cdFx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICAoOCAqIDggIC8gNClcclxuXHRcdFx0Ly8gIFx0IDE2eDE2IHBpeGVsIHRleHR1cmUgbWF4ICAgNjQgYm9uZXMgKDE2ICogMTYgLyA0KVxyXG5cdFx0XHQvLyAgXHQgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAoMzIgKiAzMiAvIDQpXHJcblx0XHRcdC8vICBcdCA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICg2NCAqIDY0IC8gNClcclxuXHJcblx0XHRcdHZhciBzaXplO1xyXG5cclxuXHRcdFx0aWYgKCBuQm9uZXMgPiAyNTYgKVxyXG5cdFx0XHRcdHNpemUgPSA2NDtcclxuXHRcdFx0ZWxzZSBpZiAoIG5Cb25lcyA+IDY0IClcclxuXHRcdFx0XHRzaXplID0gMzI7XHJcblx0XHRcdGVsc2UgaWYgKCBuQm9uZXMgPiAxNiApXHJcblx0XHRcdFx0c2l6ZSA9IDE2O1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0c2l6ZSA9IDg7XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlV2lkdGggPSBzaXplO1xyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ID0gc2l6ZTtcclxuXHJcblx0XHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5ib25lVGV4dHVyZVdpZHRoICogdGhpcy5ib25lVGV4dHVyZUhlaWdodCAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcclxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggdGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgVEhSRUUuUkdCQUZvcm1hdCwgVEhSRUUuRmxvYXRUeXBlICk7XHJcblx0XHRcdHRoaXMuYm9uZVRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlLmZsaXBZID0gZmFsc2U7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiBuQm9uZXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5wb3NlKCk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmFkZEJvbmUgPSBmdW5jdGlvbiggYm9uZSApIHtcclxuXHJcblx0aWYgKCBib25lID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0Ym9uZSA9IG5ldyBUSFJFRS5Cb25lKCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5ib25lcy5wdXNoKCBib25lICk7XHJcblxyXG5cdHJldHVybiBib25lO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG9mZnNldE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoIGZvcmNlICkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSAmJiB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBtYXRyaXhXb3JsZFxyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcblx0XHRcdFx0Y2hpbGQudXBkYXRlKCB0aGlzLmlkZW50aXR5TWF0cml4LCBmYWxzZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y2hpbGQudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbWFrZSBhIHNuYXBzaG90IG9mIHRoZSBib25lcycgcmVzdCBwb3NpdGlvblxyXG5cclxuXHRcdGlmICggdGhpcy5ib25lSW52ZXJzZXMgPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLnNraW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcclxuXHJcblx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtO1xyXG5cclxuXHRcdFx0Ly8gVE9ETzogd2UgY291bGQgZ2V0IHJpZCBvZiB0aGlzIG11bHRpcGxpY2F0aW9uIHN0ZXAgaWYgdGhlIHNraW5NYXRyaXhcclxuXHRcdFx0Ly8gd2FzIGFscmVhZHkgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQ7IGhvd2V2ZXIsIHRoaXMgcmVxdWlyZXMgc29tZVxyXG5cdFx0XHQvLyBtYWpvciBjaGFuZ2VzIHRvIHRoZSBhbmltYXRpb24gc3lzdGVtXHJcblxyXG5cdFx0XHRvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5ib25lc1sgYiBdLnNraW5NYXRyaXgsIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcclxuXHRcdFx0b2Zmc2V0TWF0cml4LmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB0aGlzLmJvbmVNYXRyaWNlcywgYiAqIDE2ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0dGhpcy5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5ub3JtYWxpemVTa2luV2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0aWYgKCB0aGlzLmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgc3cgPSB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF07XHJcblxyXG5cdFx0XHR2YXIgc2NhbGUgPSAxLjAgLyBzdy5sZW5ndGhNYW5oYXR0YW4oKTtcclxuXHJcblx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xyXG5cclxuXHRcdFx0XHRzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHN3LnNldCggMSApOyAvLyB0aGlzIHdpbGwgYmUgbm9ybWFsaXplZCBieSB0aGUgc2hhZGVyIGFueXdheVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHQvLyBza2lubmluZyB3ZWlnaHRzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCBmb3IgVEhSRUUuQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdG9iamVjdCA9IG5ldyBUSFJFRS5Ta2lubmVkTWVzaCggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCwgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0VEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XHJcblxyXG5cdHJldHVybiBvYmplY3Q7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTW9ycGhBbmltTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHQvLyBBUElcclxuXHJcblx0dGhpcy5kdXJhdGlvbiA9IDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xyXG5cdHRoaXMubWlycm9yZWRMb29wID0gZmFsc2U7XHJcblx0dGhpcy50aW1lID0gMDtcclxuXHJcblx0Ly8gaW50ZXJuYWxzXHJcblxyXG5cdHRoaXMubGFzdEtleWZyYW1lID0gMDtcclxuXHR0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IDA7XHJcblxyXG5cdHRoaXMuZGlyZWN0aW9uID0gMTtcclxuXHR0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldEZyYW1lUmFuZ2UoIDAsIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCAtIDEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXRGcmFtZVJhbmdlID0gZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xyXG5cclxuXHR0aGlzLnN0YXJ0S2V5ZnJhbWUgPSBzdGFydDtcclxuXHR0aGlzLmVuZEtleWZyYW1lID0gZW5kO1xyXG5cclxuXHR0aGlzLmxlbmd0aCA9IHRoaXMuZW5kS2V5ZnJhbWUgLSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldERpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZGlyZWN0aW9uID0gMTtcclxuXHR0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldERpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmRpcmVjdGlvbiA9IC0xO1xyXG5cdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5wYXJzZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG5cdGlmICggISBnZW9tZXRyeS5hbmltYXRpb25zICkgZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IHt9O1xyXG5cclxuXHR2YXIgZmlyc3RBbmltYXRpb24sIGFuaW1hdGlvbnMgPSBnZW9tZXRyeS5hbmltYXRpb25zO1xyXG5cclxuXHR2YXIgcGF0dGVybiA9IC8oW2Etel0rKShcXGQrKS87XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XHJcblx0XHR2YXIgcGFydHMgPSBtb3JwaC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XHJcblxyXG5cdFx0aWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0dmFyIGxhYmVsID0gcGFydHNbIDEgXTtcclxuXHRcdFx0dmFyIG51bSA9IHBhcnRzWyAyIF07XHJcblxyXG5cdFx0XHRpZiAoICEgYW5pbWF0aW9uc1sgbGFiZWwgXSApIGFuaW1hdGlvbnNbIGxhYmVsIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtSW5maW5pdHkgfTtcclxuXHJcblx0XHRcdHZhciBhbmltYXRpb24gPSBhbmltYXRpb25zWyBsYWJlbCBdO1xyXG5cclxuXHRcdFx0aWYgKCBpIDwgYW5pbWF0aW9uLnN0YXJ0ICkgYW5pbWF0aW9uLnN0YXJ0ID0gaTtcclxuXHRcdFx0aWYgKCBpID4gYW5pbWF0aW9uLmVuZCApIGFuaW1hdGlvbi5lbmQgPSBpO1xyXG5cclxuXHRcdFx0aWYgKCAhIGZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBsYWJlbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2VvbWV0cnkuZmlyc3RBbmltYXRpb24gPSBmaXJzdEFuaW1hdGlvbjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25MYWJlbCA9IGZ1bmN0aW9uICggbGFiZWwsIHN0YXJ0LCBlbmQgKSB7XHJcblxyXG5cdGlmICggISB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnMgKSB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnMgPSB7fTtcclxuXHJcblx0dGhpcy5nZW9tZXRyeS5hbmltYXRpb25zWyBsYWJlbCBdID0geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbGFiZWwsIGZwcyApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1sgbGFiZWwgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5zZXRGcmFtZVJhbmdlKCBhbmltYXRpb24uc3RhcnQsIGFuaW1hdGlvbi5lbmQgKTtcclxuXHRcdHRoaXMuZHVyYXRpb24gPSAxMDAwICogKCAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGZwcyApO1xyXG5cdFx0dGhpcy50aW1lID0gMDtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoIFwiYW5pbWF0aW9uW1wiICsgbGFiZWwgKyBcIl0gdW5kZWZpbmVkXCIgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XHJcblxyXG5cdHZhciBmcmFtZVRpbWUgPSB0aGlzLmR1cmF0aW9uIC8gdGhpcy5sZW5ndGg7XHJcblxyXG5cdHRoaXMudGltZSArPSB0aGlzLmRpcmVjdGlvbiAqIGRlbHRhO1xyXG5cclxuXHRpZiAoIHRoaXMubWlycm9yZWRMb29wICkge1xyXG5cclxuXHRcdGlmICggdGhpcy50aW1lID4gdGhpcy5kdXJhdGlvbiB8fCB0aGlzLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5kaXJlY3Rpb24gKj0gLTE7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudGltZSA+IHRoaXMuZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XHJcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnRpbWUgPSAwO1xyXG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMudGltZSA9IHRoaXMudGltZSAlIHRoaXMuZHVyYXRpb247XHJcblxyXG5cdFx0aWYgKCB0aGlzLnRpbWUgPCAwICkgdGhpcy50aW1lICs9IHRoaXMuZHVyYXRpb247XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGtleWZyYW1lID0gdGhpcy5zdGFydEtleWZyYW1lICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggdGhpcy50aW1lIC8gZnJhbWVUaW1lICksIDAsIHRoaXMubGVuZ3RoIC0gMSApO1xyXG5cclxuXHRpZiAoIGtleWZyYW1lICE9PSB0aGlzLmN1cnJlbnRLZXlmcmFtZSApIHtcclxuXHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5sYXN0S2V5ZnJhbWUgXSA9IDA7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IDE7XHJcblxyXG5cdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xyXG5cclxuXHRcdHRoaXMubGFzdEtleWZyYW1lID0gdGhpcy5jdXJyZW50S2V5ZnJhbWU7XHJcblx0XHR0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IGtleWZyYW1lO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBtaXggPSAoIHRoaXMudGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xyXG5cclxuXHRpZiAoIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzICkge1xyXG5cclxuXHRcdG1peCA9IDEgLSBtaXg7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMuY3VycmVudEtleWZyYW1lIF0gPSBtaXg7XHJcblx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMubGFzdEtleWZyYW1lIF0gPSAxIC0gbWl4O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTW9ycGhBbmltTWVzaCggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xyXG5cclxuXHRvYmplY3QuZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xyXG5cdG9iamVjdC5taXJyb3JlZExvb3AgPSB0aGlzLm1pcnJvcmVkTG9vcDtcclxuXHRvYmplY3QudGltZSA9IHRoaXMudGltZTtcclxuXHJcblx0b2JqZWN0Lmxhc3RLZXlmcmFtZSA9IHRoaXMubGFzdEtleWZyYW1lO1xyXG5cdG9iamVjdC5jdXJyZW50S2V5ZnJhbWUgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZTtcclxuXHJcblx0b2JqZWN0LmRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uO1xyXG5cdG9iamVjdC5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcztcclxuXHJcblx0VEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XHJcblxyXG5cdHJldHVybiBvYmplY3Q7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTE9EID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMub2JqZWN0cyA9IFtdO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLmFkZExldmVsID0gZnVuY3Rpb24gKCBvYmplY3QsIGRpc3RhbmNlICkge1xyXG5cclxuXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XHJcblxyXG5cdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XHJcblxyXG5cdGZvciAoIHZhciBsID0gMDsgbCA8IHRoaXMub2JqZWN0cy5sZW5ndGg7IGwgKysgKSB7XHJcblxyXG5cdFx0aWYgKCBkaXN0YW5jZSA8IHRoaXMub2JqZWN0c1sgbCBdLmRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMub2JqZWN0cy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBvYmplY3Q6IG9iamVjdCB9ICk7XHJcblx0dGhpcy5hZGQoIG9iamVjdCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLm9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRpZiAoIGRpc3RhbmNlIDwgdGhpcy5vYmplY3RzWyBpIF0uZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXMub2JqZWN0c1sgaSAtIDEgXS5vYmplY3Q7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTE9ELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggY2FtZXJhICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5vYmplY3RzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG5cdFx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdHZhciBkaXN0YW5jZSA9IHYxLmRpc3RhbmNlVG8oIHYyICk7XHJcblxyXG5cdFx0XHR0aGlzLm9iamVjdHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLm9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA+PSB0aGlzLm9iamVjdHNbIGkgXS5kaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm9iamVjdHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcclxuXHRcdFx0XHRcdHRoaXMub2JqZWN0c1sgaSAgICAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciggOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5vYmplY3RzWyBpIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTE9EKCk7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5vYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblx0XHR2YXIgeCA9IHRoaXMub2JqZWN0c1tpXS5vYmplY3QuY2xvbmUoKTtcclxuXHRcdHgudmlzaWJsZSA9IGkgPT09IDA7XHJcblx0XHRvYmplY3QuYWRkTGV2ZWwoIHgsIHRoaXMub2JqZWN0c1tpXS5kaXN0YW5jZSApO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG9iamVjdDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcHJpdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5MiggMyApO1xyXG5cdGdlb21ldHJ5LnZlcnRpY2VzLnNldCggWyAtIDAuNSwgLSAwLjUsIDAsIDAuNSwgLSAwLjUsIDAsIDAuNSwgMC41LCAwIF0gKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XHJcblxyXG5cdH07XHJcblxyXG59ICkoKTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcbi8qXHJcbiAqIEN1c3RvbSB1cGRhdGUgbWF0cml4XHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS51cGRhdGVNYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xyXG5cclxuXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5TcHJpdGUoIHRoaXMubWF0ZXJpYWwgKTtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xyXG5cclxuXHRyZXR1cm4gb2JqZWN0O1xyXG5cclxufTtcclxuXHJcbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG5USFJFRS5QYXJ0aWNsZSA9IFRIUkVFLlNwcml0ZTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2NlbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5mb2cgPSBudWxsO1xyXG5cdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuX19saWdodHMgPSBbXTtcclxuXHJcblx0dGhpcy5fX29iamVjdHNBZGRlZCA9IFtdO1xyXG5cdHRoaXMuX19vYmplY3RzUmVtb3ZlZCA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU2NlbmUucHJvdG90eXBlLl9fYWRkT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGlnaHQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9fbGlnaHRzLmluZGV4T2YoIG9iamVjdCApID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9fbGlnaHRzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC50YXJnZXQgJiYgb2JqZWN0LnRhcmdldC5wYXJlbnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuYWRkKCBvYmplY3QudGFyZ2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2UgaWYgKCAhKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApICkge1xyXG5cclxuXHRcdHRoaXMuX19vYmplY3RzQWRkZWQucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgcHJldmlvdXNseSByZW1vdmVkXHJcblxyXG5cdFx0dmFyIGkgPSB0aGlzLl9fb2JqZWN0c1JlbW92ZWQuaW5kZXhPZiggb2JqZWN0ICk7XHJcblxyXG5cdFx0aWYgKCBpICE9PSAtMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX19vYmplY3RzUmVtb3ZlZC5zcGxpY2UoIGksIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdvYmplY3RBZGRlZCcsIG9iamVjdDogb2JqZWN0IH0gKTtcclxuXHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWRUb1NjZW5lJywgc2NlbmU6IHRoaXMgfSApO1xyXG5cclxuXHRmb3IgKCB2YXIgYyA9IDA7IGMgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBjICsrICkge1xyXG5cclxuXHRcdHRoaXMuX19hZGRPYmplY3QoIG9iamVjdC5jaGlsZHJlblsgYyBdICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuX19yZW1vdmVPYmplY3QgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcclxuXHJcblx0XHR2YXIgaSA9IHRoaXMuX19saWdodHMuaW5kZXhPZiggb2JqZWN0ICk7XHJcblxyXG5cdFx0aWYgKCBpICE9PSAtMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX19saWdodHMuc3BsaWNlKCBpLCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0LnNoYWRvd0Nhc2NhZGVBcnJheSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IG9iamVjdC5zaGFkb3dDYXNjYWRlQXJyYXkubGVuZ3RoOyB4ICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl9fcmVtb3ZlT2JqZWN0KCBvYmplY3Quc2hhZG93Q2FzY2FkZUFycmF5WyB4IF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoICEoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYSApICkge1xyXG5cclxuXHRcdHRoaXMuX19vYmplY3RzUmVtb3ZlZC5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHQvLyBjaGVjayBpZiBwcmV2aW91c2x5IGFkZGVkXHJcblxyXG5cdFx0dmFyIGkgPSB0aGlzLl9fb2JqZWN0c0FkZGVkLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggaSAhPT0gLTEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9fb2JqZWN0c0FkZGVkLnNwbGljZSggaSwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ29iamVjdFJlbW92ZWQnLCBvYmplY3Q6IG9iamVjdCB9ICk7XHJcblx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWRGcm9tU2NlbmUnLCBzY2VuZTogdGhpcyB9ICk7XHJcblxyXG5cdGZvciAoIHZhciBjID0gMDsgYyA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGMgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5fX3JlbW92ZU9iamVjdCggb2JqZWN0LmNoaWxkcmVuWyBjIF0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsIG9iamVjdCk7XHJcblxyXG5cdGlmICggdGhpcy5mb2cgIT09IG51bGwgKSBvYmplY3QuZm9nID0gdGhpcy5mb2cuY2xvbmUoKTtcclxuXHRpZiAoIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIG9iamVjdC5vdmVycmlkZU1hdGVyaWFsID0gdGhpcy5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XHJcblxyXG5cdG9iamVjdC5hdXRvVXBkYXRlID0gdGhpcy5hdXRvVXBkYXRlO1xyXG5cdG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gdGhpcy5tYXRyaXhBdXRvVXBkYXRlO1xyXG5cclxuXHRyZXR1cm4gb2JqZWN0O1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZvZyA9IGZ1bmN0aW9uICggY29sb3IsIG5lYXIsIGZhciApIHtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XHJcblxyXG5cdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcclxuXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Gb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Gb2dFeHAyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVuc2l0eSApIHtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XHJcblx0dGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkZvZ0V4cDIoIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMuZGVuc2l0eSApO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRjb25zb2xlLmxvZyggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyJywgVEhSRUUuUkVWSVNJT04gKTtcclxuXHJcblx0dmFyIHNtb290aHN0ZXAgPSBUSFJFRS5NYXRoLnNtb290aHN0ZXA7XHJcblxyXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xyXG5cclxuXHR2YXIgX3RoaXMgPSB0aGlzLFxyXG5cdF9yZW5kZXJEYXRhLCBfZWxlbWVudHMsIF9saWdodHMsXHJcblx0X3Byb2plY3RvciA9IG5ldyBUSFJFRS5Qcm9qZWN0b3IoKSxcclxuXHJcblx0X2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWRcclxuXHRcdFx0PyBwYXJhbWV0ZXJzLmNhbnZhc1xyXG5cdFx0XHQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICksXHJcblxyXG5cdF9jYW52YXNXaWR0aCA9IF9jYW52YXMud2lkdGgsXHJcblx0X2NhbnZhc0hlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxyXG5cdF9jYW52YXNXaWR0aEhhbGYgPSBNYXRoLmZsb29yKCBfY2FudmFzV2lkdGggLyAyICksXHJcblx0X2NhbnZhc0hlaWdodEhhbGYgPSBNYXRoLmZsb29yKCBfY2FudmFzSGVpZ2h0IC8gMiApLFxyXG5cdFxyXG5cdF9jb250ZXh0ID0gX2NhbnZhcy5nZXRDb250ZXh0KCAnMmQnLCB7XHJcblx0XHRhbHBoYTogcGFyYW1ldGVycy5hbHBoYSA9PT0gdHJ1ZVxyXG5cdH0gKSxcclxuXHJcblx0X2NsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICksXHJcblx0X2NsZWFyQWxwaGEgPSAwLFxyXG5cclxuXHRfY29udGV4dEdsb2JhbEFscGhhID0gMSxcclxuXHRfY29udGV4dEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IDAsXHJcblx0X2NvbnRleHRTdHJva2VTdHlsZSA9IG51bGwsXHJcblx0X2NvbnRleHRGaWxsU3R5bGUgPSBudWxsLFxyXG5cdF9jb250ZXh0TGluZVdpZHRoID0gbnVsbCxcclxuXHRfY29udGV4dExpbmVDYXAgPSBudWxsLFxyXG5cdF9jb250ZXh0TGluZUpvaW4gPSBudWxsLFxyXG5cdF9jb250ZXh0RGFzaFNpemUgPSBudWxsLFxyXG5cdF9jb250ZXh0R2FwU2l6ZSA9IDAsXHJcblxyXG5cdF9jYW1lcmEsXHJcblxyXG5cdF92MSwgX3YyLCBfdjMsIF92NCxcclxuXHRfdjUgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpLFxyXG5cdF92NiA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCksXHJcblxyXG5cdF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksXHJcblx0X3Y0eCwgX3Y0eSwgX3Y1eCwgX3Y1eSwgX3Y2eCwgX3Y2eSxcclxuXHJcblx0X2NvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X2NvbG9yMSA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cdF9jb2xvcjIgPSBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHRfY29sb3IzID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X2NvbG9yNCA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cclxuXHRfZGlmZnVzZUNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X2VtaXNzaXZlQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHJcblx0X2xpZ2h0Q29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHJcblx0X3BhdHRlcm5zID0ge30sXHJcblxyXG5cdF9uZWFyLCBfZmFyLFxyXG5cclxuXHRfaW1hZ2UsIF91dnMsXHJcblx0X3V2MXgsIF91djF5LCBfdXYyeCwgX3V2MnksIF91djN4LCBfdXYzeSxcclxuXHJcblx0X2NsaXBCb3ggPSBuZXcgVEhSRUUuQm94MigpLFxyXG5cdF9jbGVhckJveCA9IG5ldyBUSFJFRS5Cb3gyKCksXHJcblx0X2VsZW1Cb3ggPSBuZXcgVEhSRUUuQm94MigpLFxyXG5cclxuXHRfYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X2RpcmVjdGlvbmFsTGlnaHRzID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X3BvaW50TGlnaHRzID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblxyXG5cdF92ZWN0b3IzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgLy8gTmVlZGVkIGZvciBQb2ludExpZ2h0XHJcblx0X25vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0X25vcm1hbFZpZXdNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLFxyXG5cclxuXHRfcGl4ZWxNYXAsIF9waXhlbE1hcENvbnRleHQsIF9waXhlbE1hcEltYWdlLCBfcGl4ZWxNYXBEYXRhLFxyXG5cdF9ncmFkaWVudE1hcCwgX2dyYWRpZW50TWFwQ29udGV4dCwgX2dyYWRpZW50TWFwUXVhbGl0eSA9IDE2O1xyXG5cclxuXHRfcGl4ZWxNYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cdF9waXhlbE1hcC53aWR0aCA9IF9waXhlbE1hcC5oZWlnaHQgPSAyO1xyXG5cclxuXHRfcGl4ZWxNYXBDb250ZXh0ID0gX3BpeGVsTWFwLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRfcGl4ZWxNYXBDb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDEpJztcclxuXHRfcGl4ZWxNYXBDb250ZXh0LmZpbGxSZWN0KCAwLCAwLCAyLCAyICk7XHJcblxyXG5cdF9waXhlbE1hcEltYWdlID0gX3BpeGVsTWFwQ29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIDIsIDIgKTtcclxuXHRfcGl4ZWxNYXBEYXRhID0gX3BpeGVsTWFwSW1hZ2UuZGF0YTtcclxuXHJcblx0X2dyYWRpZW50TWFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxuXHRfZ3JhZGllbnRNYXAud2lkdGggPSBfZ3JhZGllbnRNYXAuaGVpZ2h0ID0gX2dyYWRpZW50TWFwUXVhbGl0eTtcclxuXHJcblx0X2dyYWRpZW50TWFwQ29udGV4dCA9IF9ncmFkaWVudE1hcC5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0X2dyYWRpZW50TWFwQ29udGV4dC50cmFuc2xhdGUoIC0gX2dyYWRpZW50TWFwUXVhbGl0eSAvIDIsIC0gX2dyYWRpZW50TWFwUXVhbGl0eSAvIDIgKTtcclxuXHRfZ3JhZGllbnRNYXBDb250ZXh0LnNjYWxlKCBfZ3JhZGllbnRNYXBRdWFsaXR5LCBfZ3JhZGllbnRNYXBRdWFsaXR5ICk7XHJcblxyXG5cdF9ncmFkaWVudE1hcFF1YWxpdHkgLS07IC8vIEZpeCBVVnNcclxuXHJcblx0Ly8gZGFzaCtnYXAgZmFsbGJhY2tzIGZvciBGaXJlZm94IGFuZCBldmVyeXRoaW5nIGVsc2VcclxuXHJcblx0aWYgKCBfY29udGV4dC5zZXRMaW5lRGFzaCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggX2NvbnRleHQubW96RGFzaCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc2V0TGluZURhc2ggPSBmdW5jdGlvbiAoIHZhbHVlcyApIHtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQubW96RGFzaCA9IHZhbHVlc1sgMCBdICE9PSBudWxsID8gdmFsdWVzIDogbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc2V0TGluZURhc2ggPSBmdW5jdGlvbiAoKSB7fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xyXG5cclxuXHR0aGlzLmRldmljZVBpeGVsUmF0aW8gPSBwYXJhbWV0ZXJzLmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZFxyXG5cdFx0XHRcdD8gcGFyYW1ldGVycy5kZXZpY2VQaXhlbFJhdGlvXHJcblx0XHRcdFx0OiBzZWxmLmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZFxyXG5cdFx0XHRcdFx0PyBzZWxmLmRldmljZVBpeGVsUmF0aW9cclxuXHRcdFx0XHRcdDogMTtcclxuXHJcblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xyXG5cdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xyXG5cdHRoaXMuc29ydEVsZW1lbnRzID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5pbmZvID0ge1xyXG5cclxuXHRcdHJlbmRlcjoge1xyXG5cclxuXHRcdFx0dmVydGljZXM6IDAsXHJcblx0XHRcdGZhY2VzOiAwXHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIFdlYkdMUmVuZGVyZXIgY29tcGF0aWJpbGl0eVxyXG5cclxuXHR0aGlzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHR0aGlzLnNldEZhY2VDdWxsaW5nID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5cdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUgKSB7XHJcblxyXG5cdFx0X2NhbnZhc1dpZHRoID0gd2lkdGggKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XHJcblx0XHRfY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xyXG5cclxuXHRcdF9jYW52YXNXaWR0aEhhbGYgPSBNYXRoLmZsb29yKCBfY2FudmFzV2lkdGggLyAyICk7XHJcblx0XHRfY2FudmFzSGVpZ2h0SGFsZiA9IE1hdGguZmxvb3IoIF9jYW52YXNIZWlnaHQgLyAyICk7XHJcblxyXG5cdFx0X2NhbnZhcy53aWR0aCA9IF9jYW52YXNXaWR0aDtcclxuXHRcdF9jYW52YXMuaGVpZ2h0ID0gX2NhbnZhc0hlaWdodDtcclxuXHJcblx0XHRpZiAoIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gMSAmJiB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG5cdFx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9jbGlwQm94Lm1pbi5zZXQoIC0gX2NhbnZhc1dpZHRoSGFsZiwgLSBfY2FudmFzSGVpZ2h0SGFsZiApLFxyXG5cdFx0X2NsaXBCb3gubWF4LnNldCggICBfY2FudmFzV2lkdGhIYWxmLCAgIF9jYW52YXNIZWlnaHRIYWxmICk7XHJcblxyXG5cdFx0X2NsZWFyQm94Lm1pbi5zZXQoIC0gX2NhbnZhc1dpZHRoSGFsZiwgLSBfY2FudmFzSGVpZ2h0SGFsZiApO1xyXG5cdFx0X2NsZWFyQm94Lm1heC5zZXQoICAgX2NhbnZhc1dpZHRoSGFsZiwgICBfY2FudmFzSGVpZ2h0SGFsZiApO1xyXG5cclxuXHRcdF9jb250ZXh0R2xvYmFsQWxwaGEgPSAxO1xyXG5cdFx0X2NvbnRleHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAwO1xyXG5cdFx0X2NvbnRleHRTdHJva2VTdHlsZSA9IG51bGw7XHJcblx0XHRfY29udGV4dEZpbGxTdHlsZSA9IG51bGw7XHJcblx0XHRfY29udGV4dExpbmVXaWR0aCA9IG51bGw7XHJcblx0XHRfY29udGV4dExpbmVDYXAgPSBudWxsO1xyXG5cdFx0X2NvbnRleHRMaW5lSm9pbiA9IG51bGw7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xyXG5cclxuXHRcdF9jbGVhckNvbG9yLnNldCggY29sb3IgKTtcclxuXHRcdF9jbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcclxuXHJcblx0XHRfY2xlYXJCb3gubWluLnNldCggLSBfY2FudmFzV2lkdGhIYWxmLCAtIF9jYW52YXNIZWlnaHRIYWxmICk7XHJcblx0XHRfY2xlYXJCb3gubWF4LnNldCggICBfY2FudmFzV2lkdGhIYWxmLCAgIF9jYW52YXNIZWlnaHRIYWxmICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Q2xlYXJDb2xvckhleCA9IGZ1bmN0aW9uICggaGV4LCBhbHBoYSApIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoICdERVBSRUNBVEVEOiAuc2V0Q2xlYXJDb2xvckhleCgpIGlzIGJlaW5nIHJlbW92ZWQuIFVzZSAuc2V0Q2xlYXJDb2xvcigpIGluc3RlYWQuJyApO1xyXG5cdFx0dGhpcy5zZXRDbGVhckNvbG9yKCBoZXgsIGFscGhhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0TWF4QW5pc290cm9weSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRfY29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIC0gMSwgX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKTtcclxuXHJcblx0XHRpZiAoIF9jbGVhckJveC5lbXB0eSgpID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdF9jbGVhckJveC5pbnRlcnNlY3QoIF9jbGlwQm94ICk7XHJcblx0XHRcdF9jbGVhckJveC5leHBhbmRCeVNjYWxhciggMiApO1xyXG5cclxuXHRcdFx0aWYgKCBfY2xlYXJBbHBoYSA8IDEgKSB7XHJcblxyXG5cdFx0XHRcdF9jb250ZXh0LmNsZWFyUmVjdChcclxuXHRcdFx0XHRcdF9jbGVhckJveC5taW4ueCB8IDAsXHJcblx0XHRcdFx0XHRfY2xlYXJCb3gubWluLnkgfCAwLFxyXG5cdFx0XHRcdFx0KCBfY2xlYXJCb3gubWF4LnggLSBfY2xlYXJCb3gubWluLnggKSB8IDAsXHJcblx0XHRcdFx0XHQoIF9jbGVhckJveC5tYXgueSAtIF9jbGVhckJveC5taW4ueSApIHwgMFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIF9jbGVhckFscGhhID4gMCApIHtcclxuXHJcblx0XHRcdFx0c2V0QmxlbmRpbmcoIFRIUkVFLk5vcm1hbEJsZW5kaW5nICk7XHJcblx0XHRcdFx0c2V0T3BhY2l0eSggMSApO1xyXG5cclxuXHRcdFx0XHRzZXRGaWxsU3R5bGUoICdyZ2JhKCcgKyBNYXRoLmZsb29yKCBfY2xlYXJDb2xvci5yICogMjU1ICkgKyAnLCcgKyBNYXRoLmZsb29yKCBfY2xlYXJDb2xvci5nICogMjU1ICkgKyAnLCcgKyBNYXRoLmZsb29yKCBfY2xlYXJDb2xvci5iICogMjU1ICkgKyAnLCcgKyBfY2xlYXJBbHBoYSArICcpJyApO1xyXG5cclxuXHRcdFx0XHRfY29udGV4dC5maWxsUmVjdChcclxuXHRcdFx0XHRcdF9jbGVhckJveC5taW4ueCB8IDAsXHJcblx0XHRcdFx0XHRfY2xlYXJCb3gubWluLnkgfCAwLFxyXG5cdFx0XHRcdFx0KCBfY2xlYXJCb3gubWF4LnggLSBfY2xlYXJCb3gubWluLnggKSB8IDAsXHJcblx0XHRcdFx0XHQoIF9jbGVhckJveC5tYXgueSAtIF9jbGVhckJveC5taW4ueSApIHwgMFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfY2xlYXJCb3gubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBjb21wYXRpYmlsaXR5XHJcblxyXG5cdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFRIUkVFLm9uZXJyb3IoICdUSFJFRS5DYW52YXNSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYXV0b0NsZWFyID09PSB0cnVlICkgdGhpcy5jbGVhcigpO1xyXG5cclxuXHRcdF9jb250ZXh0LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgLSAxLCBfY2FudmFzV2lkdGhIYWxmLCBfY2FudmFzSGVpZ2h0SGFsZiApO1xyXG5cclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzID0gMDtcclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzID0gMDtcclxuXHJcblx0XHRfcmVuZGVyRGF0YSA9IF9wcm9qZWN0b3IucHJvamVjdFNjZW5lKCBzY2VuZSwgY2FtZXJhLCB0aGlzLnNvcnRPYmplY3RzLCB0aGlzLnNvcnRFbGVtZW50cyApO1xyXG5cdFx0X2VsZW1lbnRzID0gX3JlbmRlckRhdGEuZWxlbWVudHM7XHJcblx0XHRfbGlnaHRzID0gX3JlbmRlckRhdGEubGlnaHRzO1xyXG5cdFx0X2NhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0XHRfbm9ybWFsVmlld01hdHJpeC5nZXROb3JtYWxNYXRyaXgoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHJcblx0XHQvKiBERUJVR1xyXG5cdFx0c2V0RmlsbFN0eWxlKCAncmdiYSggMCwgMjU1LCAyNTUsIDAuNSApJyApO1xyXG5cdFx0X2NvbnRleHQuZmlsbFJlY3QoIF9jbGlwQm94Lm1pbi54LCBfY2xpcEJveC5taW4ueSwgX2NsaXBCb3gubWF4LnggLSBfY2xpcEJveC5taW4ueCwgX2NsaXBCb3gubWF4LnkgLSBfY2xpcEJveC5taW4ueSApO1xyXG5cdFx0Ki9cclxuXHJcblx0XHRjYWxjdWxhdGVMaWdodHMoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZSA9IDAsIGVsID0gX2VsZW1lbnRzLmxlbmd0aDsgZSA8IGVsOyBlICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGVsZW1lbnQgPSBfZWxlbWVudHNbIGUgXTtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IGVsZW1lbnQubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgfHwgbWF0ZXJpYWwudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdF9lbGVtQm94Lm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdFx0aWYgKCBlbGVtZW50IGluc3RhbmNlb2YgVEhSRUUuUmVuZGVyYWJsZVNwcml0ZSApIHtcclxuXHJcblx0XHRcdFx0X3YxID0gZWxlbWVudDtcclxuXHRcdFx0XHRfdjEueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjEueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHJcblx0XHRcdFx0cmVuZGVyU3ByaXRlKCBfdjEsIGVsZW1lbnQsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50IGluc3RhbmNlb2YgVEhSRUUuUmVuZGVyYWJsZUxpbmUgKSB7XHJcblxyXG5cdFx0XHRcdF92MSA9IGVsZW1lbnQudjE7IF92MiA9IGVsZW1lbnQudjI7XHJcblxyXG5cdFx0XHRcdF92MS5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92MS5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cdFx0XHRcdF92Mi5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92Mi5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cclxuXHRcdFx0XHRfZWxlbUJveC5zZXRGcm9tUG9pbnRzKCBbXHJcblx0XHRcdFx0XHRfdjEucG9zaXRpb25TY3JlZW4sXHJcblx0XHRcdFx0XHRfdjIucG9zaXRpb25TY3JlZW5cclxuXHRcdFx0XHRdICk7XHJcblxyXG5cdFx0XHRcdGlmICggX2NsaXBCb3guaXNJbnRlcnNlY3Rpb25Cb3goIF9lbGVtQm94ICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyTGluZSggX3YxLCBfdjIsIGVsZW1lbnQsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQgaW5zdGFuY2VvZiBUSFJFRS5SZW5kZXJhYmxlRmFjZSApIHtcclxuXHJcblx0XHRcdFx0X3YxID0gZWxlbWVudC52MTsgX3YyID0gZWxlbWVudC52MjsgX3YzID0gZWxlbWVudC52MztcclxuXHJcblx0XHRcdFx0aWYgKCBfdjEucG9zaXRpb25TY3JlZW4ueiA8IC0xIHx8IF92MS5wb3NpdGlvblNjcmVlbi56ID4gMSApIGNvbnRpbnVlO1xyXG5cdFx0XHRcdGlmICggX3YyLnBvc2l0aW9uU2NyZWVuLnogPCAtMSB8fCBfdjIucG9zaXRpb25TY3JlZW4ueiA+IDEgKSBjb250aW51ZTtcclxuXHRcdFx0XHRpZiAoIF92My5wb3NpdGlvblNjcmVlbi56IDwgLTEgfHwgX3YzLnBvc2l0aW9uU2NyZWVuLnogPiAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdF92MS5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92MS5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cdFx0XHRcdF92Mi5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92Mi5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cdFx0XHRcdF92My5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92My5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLm92ZXJkcmF3ID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRleHBhbmQoIF92MS5wb3NpdGlvblNjcmVlbiwgX3YyLnBvc2l0aW9uU2NyZWVuLCBtYXRlcmlhbC5vdmVyZHJhdyApO1xyXG5cdFx0XHRcdFx0ZXhwYW5kKCBfdjIucG9zaXRpb25TY3JlZW4sIF92My5wb3NpdGlvblNjcmVlbiwgbWF0ZXJpYWwub3ZlcmRyYXcgKTtcclxuXHRcdFx0XHRcdGV4cGFuZCggX3YzLnBvc2l0aW9uU2NyZWVuLCBfdjEucG9zaXRpb25TY3JlZW4sIG1hdGVyaWFsLm92ZXJkcmF3ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2VsZW1Cb3guc2V0RnJvbVBvaW50cyggW1xyXG5cdFx0XHRcdFx0X3YxLnBvc2l0aW9uU2NyZWVuLFxyXG5cdFx0XHRcdFx0X3YyLnBvc2l0aW9uU2NyZWVuLFxyXG5cdFx0XHRcdFx0X3YzLnBvc2l0aW9uU2NyZWVuXHJcblx0XHRcdFx0XSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIF9jbGlwQm94LmlzSW50ZXJzZWN0aW9uQm94KCBfZWxlbUJveCApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlckZhY2UzKCBfdjEsIF92MiwgX3YzLCAwLCAxLCAyLCBlbGVtZW50LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiBERUJVR1xyXG5cdFx0XHRzZXRMaW5lV2lkdGgoIDEgKTtcclxuXHRcdFx0c2V0U3Ryb2tlU3R5bGUoICdyZ2JhKCAwLCAyNTUsIDAsIDAuNSApJyApO1xyXG5cdFx0XHRfY29udGV4dC5zdHJva2VSZWN0KCBfZWxlbUJveC5taW4ueCwgX2VsZW1Cb3gubWluLnksIF9lbGVtQm94Lm1heC54IC0gX2VsZW1Cb3gubWluLngsIF9lbGVtQm94Lm1heC55IC0gX2VsZW1Cb3gubWluLnkgKTtcclxuXHRcdFx0Ki9cclxuXHJcblx0XHRcdF9jbGVhckJveC51bmlvbiggX2VsZW1Cb3ggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0LyogREVCVUdcclxuXHRcdHNldExpbmVXaWR0aCggMSApO1xyXG5cdFx0c2V0U3Ryb2tlU3R5bGUoICdyZ2JhKCAyNTUsIDAsIDAsIDAuNSApJyApO1xyXG5cdFx0X2NvbnRleHQuc3Ryb2tlUmVjdCggX2NsZWFyQm94Lm1pbi54LCBfY2xlYXJCb3gubWluLnksIF9jbGVhckJveC5tYXgueCAtIF9jbGVhckJveC5taW4ueCwgX2NsZWFyQm94Lm1heC55IC0gX2NsZWFyQm94Lm1pbi55ICk7XHJcblx0XHQqL1xyXG5cclxuXHRcdF9jb250ZXh0LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgMSwgMCwgMCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBjYWxjdWxhdGVMaWdodHMoKSB7XHJcblxyXG5cdFx0X2FtYmllbnRMaWdodC5zZXRSR0IoIDAsIDAsIDAgKTtcclxuXHRcdF9kaXJlY3Rpb25hbExpZ2h0cy5zZXRSR0IoIDAsIDAsIDAgKTtcclxuXHRcdF9wb2ludExpZ2h0cy5zZXRSR0IoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgbCA9IDAsIGxsID0gX2xpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcclxuXHJcblx0XHRcdHZhciBsaWdodCA9IF9saWdodHNbIGwgXTtcclxuXHRcdFx0dmFyIGxpZ2h0Q29sb3IgPSBsaWdodC5jb2xvcjtcclxuXHJcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5BbWJpZW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdF9hbWJpZW50TGlnaHQuYWRkKCBsaWdodENvbG9yICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGZvciBzcHJpdGVzXHJcblxyXG5cdFx0XHRcdF9kaXJlY3Rpb25hbExpZ2h0cy5hZGQoIGxpZ2h0Q29sb3IgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0Ly8gZm9yIHNwcml0ZXNcclxuXHJcblx0XHRcdFx0X3BvaW50TGlnaHRzLmFkZCggbGlnaHRDb2xvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjYWxjdWxhdGVMaWdodCggcG9zaXRpb24sIG5vcm1hbCwgY29sb3IgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGwgPSAwLCBsbCA9IF9saWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbGlnaHQgPSBfbGlnaHRzWyBsIF07XHJcblxyXG5cdFx0XHRfbGlnaHRDb2xvci5jb3B5KCBsaWdodC5jb2xvciApO1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsaWdodFBvc2l0aW9uID0gX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHR2YXIgYW1vdW50ID0gbm9ybWFsLmRvdCggbGlnaHRQb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGFtb3VudCA8PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGFtb3VudCAqPSBsaWdodC5pbnRlbnNpdHk7XHJcblxyXG5cdFx0XHRcdGNvbG9yLmFkZCggX2xpZ2h0Q29sb3IubXVsdGlwbHlTY2FsYXIoIGFtb3VudCApICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsaWdodFBvc2l0aW9uID0gX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHR2YXIgYW1vdW50ID0gbm9ybWFsLmRvdCggX3ZlY3RvcjMuc3ViVmVjdG9ycyggbGlnaHRQb3NpdGlvbiwgcG9zaXRpb24gKS5ub3JtYWxpemUoKSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGFtb3VudCA8PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGFtb3VudCAqPSBsaWdodC5kaXN0YW5jZSA9PSAwID8gMSA6IDEgLSBNYXRoLm1pbiggcG9zaXRpb24uZGlzdGFuY2VUbyggbGlnaHRQb3NpdGlvbiApIC8gbGlnaHQuZGlzdGFuY2UsIDEgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBhbW91bnQgPT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRhbW91bnQgKj0gbGlnaHQuaW50ZW5zaXR5O1xyXG5cclxuXHRcdFx0XHRjb2xvci5hZGQoIF9saWdodENvbG9yLm11bHRpcGx5U2NhbGFyKCBhbW91bnQgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJTcHJpdGUoIHYxLCBlbGVtZW50LCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRzZXRPcGFjaXR5KCBtYXRlcmlhbC5vcGFjaXR5ICk7XHJcblx0XHRzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcgKTtcclxuXHJcblx0XHR2YXIgc2NhbGVYID0gZWxlbWVudC5zY2FsZS54ICogX2NhbnZhc1dpZHRoSGFsZjtcclxuXHRcdHZhciBzY2FsZVkgPSBlbGVtZW50LnNjYWxlLnkgKiBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHJcblx0XHR2YXIgZGlzdCA9IDAuNSAqIE1hdGguc3FydCggc2NhbGVYICogc2NhbGVYICsgc2NhbGVZICogc2NhbGVZICk7IC8vIGFsbG93IGZvciByb3RhdGVkIHNwcml0ZVxyXG5cdFx0X2VsZW1Cb3gubWluLnNldCggdjEueCAtIGRpc3QsIHYxLnkgLSBkaXN0ICk7XHJcblx0XHRfZWxlbUJveC5tYXguc2V0KCB2MS54ICsgZGlzdCwgdjEueSArIGRpc3QgKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlTWF0ZXJpYWwgfHxcclxuXHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCApIHsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlID0gbWF0ZXJpYWwubWFwO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUuaGFzRXZlbnRMaXN0ZW5lciggJ3VwZGF0ZScsIG9uVGV4dHVyZVVwZGF0ZSApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmUuaW1hZ2UgIT09IHVuZGVmaW5lZCAmJiB0ZXh0dXJlLmltYWdlLndpZHRoID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRleHR1cmVUb1BhdHRlcm4oIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAndXBkYXRlJywgb25UZXh0dXJlVXBkYXRlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHBhdHRlcm4gPSBfcGF0dGVybnNbIHRleHR1cmUuaWQgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXR0ZXJuICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0RmlsbFN0eWxlKCBwYXR0ZXJuICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0RmlsbFN0eWxlKCAncmdiYSggMCwgMCwgMCwgMSApJyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vXHJcblxyXG5cdFx0XHRcdHZhciBiaXRtYXAgPSB0ZXh0dXJlLmltYWdlO1xyXG5cclxuXHRcdFx0XHR2YXIgb3ggPSBiaXRtYXAud2lkdGggKiB0ZXh0dXJlLm9mZnNldC54O1xyXG5cdFx0XHRcdHZhciBveSA9IGJpdG1hcC5oZWlnaHQgKiB0ZXh0dXJlLm9mZnNldC55O1xyXG5cclxuXHRcdFx0XHR2YXIgc3ggPSBiaXRtYXAud2lkdGggKiB0ZXh0dXJlLnJlcGVhdC54O1xyXG5cdFx0XHRcdHZhciBzeSA9IGJpdG1hcC5oZWlnaHQgKiB0ZXh0dXJlLnJlcGVhdC55O1xyXG5cclxuXHRcdFx0XHR2YXIgY3ggPSBzY2FsZVggLyBzeDtcclxuXHRcdFx0XHR2YXIgY3kgPSBzY2FsZVkgLyBzeTtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuc2F2ZSgpO1xyXG5cdFx0XHRcdF9jb250ZXh0LnRyYW5zbGF0ZSggdjEueCwgdjEueSApO1xyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwucm90YXRpb24gIT09IDAgKSBfY29udGV4dC5yb3RhdGUoIG1hdGVyaWFsLnJvdGF0aW9uICk7XHJcblx0XHRcdFx0X2NvbnRleHQudHJhbnNsYXRlKCAtIHNjYWxlWCAvIDIsIC0gc2NhbGVZIC8gMiApO1xyXG5cdFx0XHRcdF9jb250ZXh0LnNjYWxlKCBjeCwgY3kgKTtcclxuXHRcdFx0XHRfY29udGV4dC50cmFuc2xhdGUoIC0gb3gsIC0gb3kgKTtcclxuXHRcdFx0XHRfY29udGV4dC5maWxsUmVjdCggb3gsIG95LCBzeCwgc3kgKTtcclxuXHRcdFx0XHRfY29udGV4dC5yZXN0b3JlKCk7XHJcblxyXG5cdFx0XHR9IGVsc2UgeyAvLyBubyB0ZXh0dXJlXHJcblxyXG5cdFx0XHRcdHNldEZpbGxTdHlsZSggbWF0ZXJpYWwuY29sb3IuZ2V0U3R5bGUoKSApO1xyXG5cclxuXHRcdFx0XHRfY29udGV4dC5zYXZlKCk7XHJcblx0XHRcdFx0X2NvbnRleHQudHJhbnNsYXRlKCB2MS54LCB2MS55ICk7XHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5yb3RhdGlvbiAhPT0gMCApIF9jb250ZXh0LnJvdGF0ZSggbWF0ZXJpYWwucm90YXRpb24gKTtcclxuXHRcdFx0XHRfY29udGV4dC5zY2FsZSggc2NhbGVYLCAtIHNjYWxlWSApO1xyXG5cdFx0XHRcdF9jb250ZXh0LmZpbGxSZWN0KCAtIDAuNSwgLSAwLjUsIDEsIDEgKTtcclxuXHRcdFx0XHRfY29udGV4dC5yZXN0b3JlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGVDYW52YXNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNldFN0cm9rZVN0eWxlKCBtYXRlcmlhbC5jb2xvci5nZXRTdHlsZSgpICk7XHJcblx0XHRcdHNldEZpbGxTdHlsZSggbWF0ZXJpYWwuY29sb3IuZ2V0U3R5bGUoKSApO1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc2F2ZSgpO1xyXG5cdFx0XHRfY29udGV4dC50cmFuc2xhdGUoIHYxLngsIHYxLnkgKTtcclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5yb3RhdGlvbiAhPT0gMCApIF9jb250ZXh0LnJvdGF0ZSggbWF0ZXJpYWwucm90YXRpb24gKTtcclxuXHRcdFx0X2NvbnRleHQuc2NhbGUoIHNjYWxlWCwgc2NhbGVZICk7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5wcm9ncmFtKCBfY29udGV4dCApO1xyXG5cclxuXHRcdFx0X2NvbnRleHQucmVzdG9yZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvKiBERUJVR1xyXG5cdFx0c2V0U3Ryb2tlU3R5bGUoICdyZ2IoMjU1LDI1NSwwKScgKTtcclxuXHRcdF9jb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0X2NvbnRleHQubW92ZVRvKCB2MS54IC0gMTAsIHYxLnkgKTtcclxuXHRcdF9jb250ZXh0LmxpbmVUbyggdjEueCArIDEwLCB2MS55ICk7XHJcblx0XHRfY29udGV4dC5tb3ZlVG8oIHYxLngsIHYxLnkgLSAxMCApO1xyXG5cdFx0X2NvbnRleHQubGluZVRvKCB2MS54LCB2MS55ICsgMTAgKTtcclxuXHRcdF9jb250ZXh0LnN0cm9rZSgpO1xyXG5cdFx0Ki9cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJMaW5lKCB2MSwgdjIsIGVsZW1lbnQsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHNldE9wYWNpdHkoIG1hdGVyaWFsLm9wYWNpdHkgKTtcclxuXHRcdHNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZyApO1xyXG5cclxuXHRcdF9jb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0X2NvbnRleHQubW92ZVRvKCB2MS5wb3NpdGlvblNjcmVlbi54LCB2MS5wb3NpdGlvblNjcmVlbi55ICk7XHJcblx0XHRfY29udGV4dC5saW5lVG8oIHYyLnBvc2l0aW9uU2NyZWVuLngsIHYyLnBvc2l0aW9uU2NyZWVuLnkgKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xyXG5cdFx0XHRzZXRMaW5lQ2FwKCBtYXRlcmlhbC5saW5lY2FwICk7XHJcblx0XHRcdHNldExpbmVKb2luKCBtYXRlcmlhbC5saW5lam9pbiApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLlZlcnRleENvbG9ycyApIHtcclxuXHJcblx0XHRcdFx0c2V0U3Ryb2tlU3R5bGUoIG1hdGVyaWFsLmNvbG9yLmdldFN0eWxlKCkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZhciBjb2xvclN0eWxlMSA9IGVsZW1lbnQudmVydGV4Q29sb3JzWzBdLmdldFN0eWxlKCk7XHJcblx0XHRcdFx0dmFyIGNvbG9yU3R5bGUyID0gZWxlbWVudC52ZXJ0ZXhDb2xvcnNbMV0uZ2V0U3R5bGUoKTtcclxuXHJcblx0XHRcdFx0aWYgKCBjb2xvclN0eWxlMSA9PT0gY29sb3JTdHlsZTIgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0U3Ryb2tlU3R5bGUoIGNvbG9yU3R5bGUxICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBncmFkID0gX2NvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoXHJcblx0XHRcdFx0XHRcdFx0djEucG9zaXRpb25TY3JlZW4ueCxcclxuXHRcdFx0XHRcdFx0XHR2MS5wb3NpdGlvblNjcmVlbi55LFxyXG5cdFx0XHRcdFx0XHRcdHYyLnBvc2l0aW9uU2NyZWVuLngsXHJcblx0XHRcdFx0XHRcdFx0djIucG9zaXRpb25TY3JlZW4ueVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRncmFkLmFkZENvbG9yU3RvcCggMCwgY29sb3JTdHlsZTEgKTtcclxuXHRcdFx0XHRcdFx0Z3JhZC5hZGRDb2xvclN0b3AoIDEsIGNvbG9yU3R5bGUyICk7XHJcblxyXG5cdFx0XHRcdFx0fSBjYXRjaCAoIGV4Y2VwdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdyYWQgPSBjb2xvclN0eWxlMTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c2V0U3Ryb2tlU3R5bGUoIGdyYWQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2NvbnRleHQuc3Ryb2tlKCk7XHJcblx0XHRcdF9lbGVtQm94LmV4cGFuZEJ5U2NhbGFyKCBtYXRlcmlhbC5saW5ld2lkdGggKiAyICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xyXG5cdFx0XHRzZXRMaW5lQ2FwKCBtYXRlcmlhbC5saW5lY2FwICk7XHJcblx0XHRcdHNldExpbmVKb2luKCBtYXRlcmlhbC5saW5lam9pbiApO1xyXG5cdFx0XHRzZXRTdHJva2VTdHlsZSggbWF0ZXJpYWwuY29sb3IuZ2V0U3R5bGUoKSApO1xyXG5cdFx0XHRzZXREYXNoQW5kR2FwKCBtYXRlcmlhbC5kYXNoU2l6ZSwgbWF0ZXJpYWwuZ2FwU2l6ZSApO1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc3Ryb2tlKCk7XHJcblxyXG5cdFx0XHRfZWxlbUJveC5leHBhbmRCeVNjYWxhciggbWF0ZXJpYWwubGluZXdpZHRoICogMiApO1xyXG5cclxuXHRcdFx0c2V0RGFzaEFuZEdhcCggbnVsbCwgbnVsbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJGYWNlMyggdjEsIHYyLCB2MywgdXYxLCB1djIsIHV2MywgZWxlbWVudCwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gMztcclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICsrO1xyXG5cclxuXHRcdHNldE9wYWNpdHkoIG1hdGVyaWFsLm9wYWNpdHkgKTtcclxuXHRcdHNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZyApO1xyXG5cclxuXHRcdF92MXggPSB2MS5wb3NpdGlvblNjcmVlbi54OyBfdjF5ID0gdjEucG9zaXRpb25TY3JlZW4ueTtcclxuXHRcdF92MnggPSB2Mi5wb3NpdGlvblNjcmVlbi54OyBfdjJ5ID0gdjIucG9zaXRpb25TY3JlZW4ueTtcclxuXHRcdF92M3ggPSB2My5wb3NpdGlvblNjcmVlbi54OyBfdjN5ID0gdjMucG9zaXRpb25TY3JlZW4ueTtcclxuXHJcblx0XHRkcmF3VHJpYW5nbGUoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3kgKTtcclxuXHJcblx0XHRpZiAoICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHwgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGh5c2ljYWxNYXRlcmlhbCApICYmIG1hdGVyaWFsLm1hcCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdF9kaWZmdXNlQ29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcclxuXHRcdFx0X2VtaXNzaXZlQ29sb3IuY29weSggbWF0ZXJpYWwuZW1pc3NpdmUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwudmVydGV4Q29sb3JzID09PSBUSFJFRS5GYWNlQ29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRfZGlmZnVzZUNvbG9yLm11bHRpcGx5KCBlbGVtZW50LmNvbG9yICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gZmFsc2UgJiYgbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuU21vb3RoU2hhZGluZyAmJiBlbGVtZW50LnZlcnRleE5vcm1hbHNMZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdF9jb2xvcjEuY29weSggX2FtYmllbnRMaWdodCApO1xyXG5cdFx0XHRcdF9jb2xvcjIuY29weSggX2FtYmllbnRMaWdodCApO1xyXG5cdFx0XHRcdF9jb2xvcjMuY29weSggX2FtYmllbnRMaWdodCApO1xyXG5cclxuXHRcdFx0XHRjYWxjdWxhdGVMaWdodCggZWxlbWVudC52MS5wb3NpdGlvbldvcmxkLCBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFsgMCBdLCBfY29sb3IxICk7XHJcblx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIGVsZW1lbnQudjIucG9zaXRpb25Xb3JsZCwgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIDEgXSwgX2NvbG9yMiApO1xyXG5cdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBlbGVtZW50LnYzLnBvc2l0aW9uV29ybGQsIGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsWyAyIF0sIF9jb2xvcjMgKTtcclxuXHJcblx0XHRcdFx0X2NvbG9yMS5tdWx0aXBseSggX2RpZmZ1c2VDb2xvciApLmFkZCggX2VtaXNzaXZlQ29sb3IgKTtcclxuXHRcdFx0XHRfY29sb3IyLm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cdFx0XHRcdF9jb2xvcjMubXVsdGlwbHkoIF9kaWZmdXNlQ29sb3IgKS5hZGQoIF9lbWlzc2l2ZUNvbG9yICk7XHJcblx0XHRcdFx0X2NvbG9yNC5hZGRDb2xvcnMoIF9jb2xvcjIsIF9jb2xvcjMgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdF9pbWFnZSA9IGdldEdyYWRpZW50VGV4dHVyZSggX2NvbG9yMSwgX2NvbG9yMiwgX2NvbG9yMywgX2NvbG9yNCApO1xyXG5cclxuXHRcdFx0XHRjbGlwSW1hZ2UoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIDAsIDAsIDEsIDAsIDAsIDEsIF9pbWFnZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2NvbG9yLmNvcHkoIF9hbWJpZW50TGlnaHQgKTtcclxuXHJcblx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIGVsZW1lbnQuY2VudHJvaWRNb2RlbCwgZWxlbWVudC5ub3JtYWxNb2RlbCwgX2NvbG9yICk7XHJcblxyXG5cdFx0XHRcdF9jb2xvci5tdWx0aXBseSggX2RpZmZ1c2VDb2xvciApLmFkZCggX2VtaXNzaXZlQ29sb3IgKTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlXHJcblx0XHRcdFx0XHQ/IHN0cm9rZVBhdGgoIF9jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApXHJcblx0XHRcdFx0XHQ6IGZpbGxQYXRoKCBfY29sb3IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubWFwLm1hcHBpbmcgaW5zdGFuY2VvZiBUSFJFRS5VVk1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3V2cyA9IGVsZW1lbnQudXZzWyAwIF07XHJcblx0XHRcdFx0XHRwYXR0ZXJuUGF0aCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3V2c1sgdXYxIF0ueCwgX3V2c1sgdXYxIF0ueSwgX3V2c1sgdXYyIF0ueCwgX3V2c1sgdXYyIF0ueSwgX3V2c1sgdXYzIF0ueCwgX3V2c1sgdXYzIF0ueSwgbWF0ZXJpYWwubWFwICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5lbnZNYXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgaW5zdGFuY2VvZiBUSFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRfbm9ybWFsLmNvcHkoIGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsWyB1djEgXSApLmFwcGx5TWF0cml4MyggX25vcm1hbFZpZXdNYXRyaXggKTtcclxuXHRcdFx0XHRcdF91djF4ID0gMC41ICogX25vcm1hbC54ICsgMC41O1xyXG5cdFx0XHRcdFx0X3V2MXkgPSAwLjUgKiBfbm9ybWFsLnkgKyAwLjU7XHJcblxyXG5cdFx0XHRcdFx0X25vcm1hbC5jb3B5KCBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFsgdXYyIF0gKS5hcHBseU1hdHJpeDMoIF9ub3JtYWxWaWV3TWF0cml4ICk7XHJcblx0XHRcdFx0XHRfdXYyeCA9IDAuNSAqIF9ub3JtYWwueCArIDAuNTtcclxuXHRcdFx0XHRcdF91djJ5ID0gMC41ICogX25vcm1hbC55ICsgMC41O1xyXG5cclxuXHRcdFx0XHRcdF9ub3JtYWwuY29weSggZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIHV2MyBdICkuYXBwbHlNYXRyaXgzKCBfbm9ybWFsVmlld01hdHJpeCApO1xyXG5cdFx0XHRcdFx0X3V2M3ggPSAwLjUgKiBfbm9ybWFsLnggKyAwLjU7XHJcblx0XHRcdFx0XHRfdXYzeSA9IDAuNSAqIF9ub3JtYWwueSArIDAuNTtcclxuXHJcblx0XHRcdFx0XHRwYXR0ZXJuUGF0aCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3V2MXgsIF91djF5LCBfdXYyeCwgX3V2MnksIF91djN4LCBfdXYzeSwgbWF0ZXJpYWwuZW52TWFwICk7XHJcblxyXG5cdFx0XHRcdH0vKiBlbHNlIGlmICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgPT09IFRIUkVFLlNwaGVyaWNhbFJlZnJhY3Rpb25NYXBwaW5nICkge1xyXG5cclxuXHJcblxyXG5cdFx0XHRcdH0qL1xyXG5cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9PT0gVEhSRUUuRmFjZUNvbG9ycyApIHtcclxuXHJcblx0XHRcdFx0XHRfY29sb3IubXVsdGlwbHkoIGVsZW1lbnQuY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWVcclxuXHRcdFx0XHRcdD8gc3Ryb2tlUGF0aCggX2NvbG9yLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGgsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luIClcclxuXHRcdFx0XHRcdDogZmlsbFBhdGgoIF9jb2xvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRfbmVhciA9IF9jYW1lcmEubmVhcjtcclxuXHRcdFx0X2ZhciA9IF9jYW1lcmEuZmFyO1xyXG5cclxuXHRcdFx0X2NvbG9yMS5yID0gX2NvbG9yMS5nID0gX2NvbG9yMS5iID0gMSAtIHNtb290aHN0ZXAoIHYxLnBvc2l0aW9uU2NyZWVuLnogKiB2MS5wb3NpdGlvblNjcmVlbi53LCBfbmVhciwgX2ZhciApO1xyXG5cdFx0XHRfY29sb3IyLnIgPSBfY29sb3IyLmcgPSBfY29sb3IyLmIgPSAxIC0gc21vb3Roc3RlcCggdjIucG9zaXRpb25TY3JlZW4ueiAqIHYyLnBvc2l0aW9uU2NyZWVuLncsIF9uZWFyLCBfZmFyICk7XHJcblx0XHRcdF9jb2xvcjMuciA9IF9jb2xvcjMuZyA9IF9jb2xvcjMuYiA9IDEgLSBzbW9vdGhzdGVwKCB2My5wb3NpdGlvblNjcmVlbi56ICogdjMucG9zaXRpb25TY3JlZW4udywgX25lYXIsIF9mYXIgKTtcclxuXHRcdFx0X2NvbG9yNC5hZGRDb2xvcnMoIF9jb2xvcjIsIF9jb2xvcjMgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRfaW1hZ2UgPSBnZXRHcmFkaWVudFRleHR1cmUoIF9jb2xvcjEsIF9jb2xvcjIsIF9jb2xvcjMsIF9jb2xvcjQgKTtcclxuXHJcblx0XHRcdGNsaXBJbWFnZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgMCwgMCwgMSwgMCwgMCwgMSwgX2ltYWdlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xyXG5cclxuXHRcdFx0XHRfbm9ybWFsLmNvcHkoIGVsZW1lbnQubm9ybWFsTW9kZWwgKS5hcHBseU1hdHJpeDMoIF9ub3JtYWxWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdF9jb2xvci5zZXRSR0IoIF9ub3JtYWwueCwgX25vcm1hbC55LCBfbm9ybWFsLnogKS5tdWx0aXBseVNjYWxhciggMC41ICkuYWRkU2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlXHJcblx0XHRcdFx0XHQ/IHN0cm9rZVBhdGgoIF9jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApXHJcblx0XHRcdFx0XHQ6IGZpbGxQYXRoKCBfY29sb3IgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLlNtb290aFNoYWRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdF9ub3JtYWwuY29weSggZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIHV2MSBdICkuYXBwbHlNYXRyaXgzKCBfbm9ybWFsVmlld01hdHJpeCApO1xyXG5cdFx0XHRcdF9jb2xvcjEuc2V0UkdCKCBfbm9ybWFsLngsIF9ub3JtYWwueSwgX25vcm1hbC56ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApLmFkZFNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdF9ub3JtYWwuY29weSggZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIHV2MiBdICkuYXBwbHlNYXRyaXgzKCBfbm9ybWFsVmlld01hdHJpeCApO1xyXG5cdFx0XHRcdF9jb2xvcjIuc2V0UkdCKCBfbm9ybWFsLngsIF9ub3JtYWwueSwgX25vcm1hbC56ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApLmFkZFNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdF9ub3JtYWwuY29weSggZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIHV2MyBdICkuYXBwbHlNYXRyaXgzKCBfbm9ybWFsVmlld01hdHJpeCApO1xyXG5cdFx0XHRcdF9jb2xvcjMuc2V0UkdCKCBfbm9ybWFsLngsIF9ub3JtYWwueSwgX25vcm1hbC56ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApLmFkZFNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdF9jb2xvcjQuYWRkQ29sb3JzKCBfY29sb3IyLCBfY29sb3IzICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0XHRfaW1hZ2UgPSBnZXRHcmFkaWVudFRleHR1cmUoIF9jb2xvcjEsIF9jb2xvcjIsIF9jb2xvcjMsIF9jb2xvcjQgKTtcclxuXHJcblx0XHRcdFx0Y2xpcEltYWdlKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LCAwLCAwLCAxLCAwLCAwLCAxLCBfaW1hZ2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyICkge1xyXG5cclxuXHRcdF9jb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0X2NvbnRleHQubW92ZVRvKCB4MCwgeTAgKTtcclxuXHRcdF9jb250ZXh0LmxpbmVUbyggeDEsIHkxICk7XHJcblx0XHRfY29udGV4dC5saW5lVG8oIHgyLCB5MiApO1xyXG5cdFx0X2NvbnRleHQuY2xvc2VQYXRoKCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc3Ryb2tlUGF0aCggY29sb3IsIGxpbmV3aWR0aCwgbGluZWNhcCwgbGluZWpvaW4gKSB7XHJcblxyXG5cdFx0c2V0TGluZVdpZHRoKCBsaW5ld2lkdGggKTtcclxuXHRcdHNldExpbmVDYXAoIGxpbmVjYXAgKTtcclxuXHRcdHNldExpbmVKb2luKCBsaW5lam9pbiApO1xyXG5cdFx0c2V0U3Ryb2tlU3R5bGUoIGNvbG9yLmdldFN0eWxlKCkgKTtcclxuXHJcblx0XHRfY29udGV4dC5zdHJva2UoKTtcclxuXHJcblx0XHRfZWxlbUJveC5leHBhbmRCeVNjYWxhciggbGluZXdpZHRoICogMiApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZpbGxQYXRoKCBjb2xvciApIHtcclxuXHJcblx0XHRzZXRGaWxsU3R5bGUoIGNvbG9yLmdldFN0eWxlKCkgKTtcclxuXHRcdF9jb250ZXh0LmZpbGwoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblRleHR1cmVVcGRhdGUgKCBldmVudCApIHtcclxuXHJcblx0XHR0ZXh0dXJlVG9QYXR0ZXJuKCBldmVudC50YXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXh0dXJlVG9QYXR0ZXJuKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHZhciByZXBlYXRYID0gdGV4dHVyZS53cmFwUyA9PT0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblx0XHR2YXIgcmVwZWF0WSA9IHRleHR1cmUud3JhcFQgPT09IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cclxuXHRcdHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XHJcblxyXG5cdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG5cdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cdFx0Y29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIC0gMSwgMCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAgKTtcclxuXHJcblx0XHRfcGF0dGVybnNbIHRleHR1cmUuaWQgXSA9IF9jb250ZXh0LmNyZWF0ZVBhdHRlcm4oXHJcblx0XHRcdGNhbnZhcywgcmVwZWF0WCA9PT0gdHJ1ZSAmJiByZXBlYXRZID09PSB0cnVlXHJcblx0XHRcdFx0PyAncmVwZWF0J1xyXG5cdFx0XHRcdDogcmVwZWF0WCA9PT0gdHJ1ZSAmJiByZXBlYXRZID09PSBmYWxzZVxyXG5cdFx0XHRcdFx0PyAncmVwZWF0LXgnXHJcblx0XHRcdFx0XHQ6IHJlcGVhdFggPT09IGZhbHNlICYmIHJlcGVhdFkgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0PyAncmVwZWF0LXknXHJcblx0XHRcdFx0XHRcdDogJ25vLXJlcGVhdCdcclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGF0dGVyblBhdGgoIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHUwLCB2MCwgdTEsIHYxLCB1MiwgdjIsIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmUgKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmhhc0V2ZW50TGlzdGVuZXIoICd1cGRhdGUnLCBvblRleHR1cmVVcGRhdGUgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuaW1hZ2UgIT09IHVuZGVmaW5lZCAmJiB0ZXh0dXJlLmltYWdlLndpZHRoID4gMCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZVRvUGF0dGVybiggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAndXBkYXRlJywgb25UZXh0dXJlVXBkYXRlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwYXR0ZXJuID0gX3BhdHRlcm5zWyB0ZXh0dXJlLmlkIF07XHJcblxyXG5cdFx0aWYgKCBwYXR0ZXJuICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzZXRGaWxsU3R5bGUoIHBhdHRlcm4gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c2V0RmlsbFN0eWxlKCAncmdiYSgwLDAsMCwxKScgKTtcclxuXHRcdFx0X2NvbnRleHQuZmlsbCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cdFxyXG5cclxuXHRcdC8vIGh0dHA6Ly9leHRyZW1lbHlzYXRpc2ZhY3Rvcnl0b3RhbGl0YXJpYW5pc20uY29tL2Jsb2cvP3A9MjEyMFxyXG5cclxuXHRcdHZhciBhLCBiLCBjLCBkLCBlLCBmLCBkZXQsIGlkZXQsXHJcblx0XHRvZmZzZXRYID0gdGV4dHVyZS5vZmZzZXQueCAvIHRleHR1cmUucmVwZWF0LngsXHJcblx0XHRvZmZzZXRZID0gdGV4dHVyZS5vZmZzZXQueSAvIHRleHR1cmUucmVwZWF0LnksXHJcblx0XHR3aWR0aCA9IHRleHR1cmUuaW1hZ2Uud2lkdGggKiB0ZXh0dXJlLnJlcGVhdC54LFxyXG5cdFx0aGVpZ2h0ID0gdGV4dHVyZS5pbWFnZS5oZWlnaHQgKiB0ZXh0dXJlLnJlcGVhdC55O1xyXG5cclxuXHRcdHUwID0gKCB1MCArIG9mZnNldFggKSAqIHdpZHRoO1xyXG5cdFx0djAgPSAoIHYwICsgb2Zmc2V0WSApICogaGVpZ2h0O1xyXG5cclxuXHRcdHUxID0gKCB1MSArIG9mZnNldFggKSAqIHdpZHRoO1xyXG5cdFx0djEgPSAoIHYxICsgb2Zmc2V0WSApICogaGVpZ2h0O1xyXG5cclxuXHRcdHUyID0gKCB1MiArIG9mZnNldFggKSAqIHdpZHRoO1xyXG5cdFx0djIgPSAoIHYyICsgb2Zmc2V0WSApICogaGVpZ2h0O1xyXG5cclxuXHRcdHgxIC09IHgwOyB5MSAtPSB5MDtcclxuXHRcdHgyIC09IHgwOyB5MiAtPSB5MDtcclxuXHJcblx0XHR1MSAtPSB1MDsgdjEgLT0gdjA7XHJcblx0XHR1MiAtPSB1MDsgdjIgLT0gdjA7XHJcblxyXG5cdFx0ZGV0ID0gdTEgKiB2MiAtIHUyICogdjE7XHJcblxyXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0aWRldCA9IDEgLyBkZXQ7XHJcblxyXG5cdFx0YSA9ICggdjIgKiB4MSAtIHYxICogeDIgKSAqIGlkZXQ7XHJcblx0XHRiID0gKCB2MiAqIHkxIC0gdjEgKiB5MiApICogaWRldDtcclxuXHRcdGMgPSAoIHUxICogeDIgLSB1MiAqIHgxICkgKiBpZGV0O1xyXG5cdFx0ZCA9ICggdTEgKiB5MiAtIHUyICogeTEgKSAqIGlkZXQ7XHJcblxyXG5cdFx0ZSA9IHgwIC0gYSAqIHUwIC0gYyAqIHYwO1xyXG5cdFx0ZiA9IHkwIC0gYiAqIHUwIC0gZCAqIHYwO1xyXG5cclxuXHRcdF9jb250ZXh0LnNhdmUoKTtcclxuXHRcdF9jb250ZXh0LnRyYW5zZm9ybSggYSwgYiwgYywgZCwgZSwgZiApO1xyXG5cdFx0X2NvbnRleHQuZmlsbCgpO1xyXG5cdFx0X2NvbnRleHQucmVzdG9yZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNsaXBJbWFnZSggeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgdTAsIHYwLCB1MSwgdjEsIHUyLCB2MiwgaW1hZ2UgKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL2V4dHJlbWVseXNhdGlzZmFjdG9yeXRvdGFsaXRhcmlhbmlzbS5jb20vYmxvZy8/cD0yMTIwXHJcblxyXG5cdFx0dmFyIGEsIGIsIGMsIGQsIGUsIGYsIGRldCwgaWRldCxcclxuXHRcdHdpZHRoID0gaW1hZ2Uud2lkdGggLSAxLFxyXG5cdFx0aGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0IC0gMTtcclxuXHJcblx0XHR1MCAqPSB3aWR0aDsgdjAgKj0gaGVpZ2h0O1xyXG5cdFx0dTEgKj0gd2lkdGg7IHYxICo9IGhlaWdodDtcclxuXHRcdHUyICo9IHdpZHRoOyB2MiAqPSBoZWlnaHQ7XHJcblxyXG5cdFx0eDEgLT0geDA7IHkxIC09IHkwO1xyXG5cdFx0eDIgLT0geDA7IHkyIC09IHkwO1xyXG5cclxuXHRcdHUxIC09IHUwOyB2MSAtPSB2MDtcclxuXHRcdHUyIC09IHUwOyB2MiAtPSB2MDtcclxuXHJcblx0XHRkZXQgPSB1MSAqIHYyIC0gdTIgKiB2MTtcclxuXHJcblx0XHRpZGV0ID0gMSAvIGRldDtcclxuXHJcblx0XHRhID0gKCB2MiAqIHgxIC0gdjEgKiB4MiApICogaWRldDtcclxuXHRcdGIgPSAoIHYyICogeTEgLSB2MSAqIHkyICkgKiBpZGV0O1xyXG5cdFx0YyA9ICggdTEgKiB4MiAtIHUyICogeDEgKSAqIGlkZXQ7XHJcblx0XHRkID0gKCB1MSAqIHkyIC0gdTIgKiB5MSApICogaWRldDtcclxuXHJcblx0XHRlID0geDAgLSBhICogdTAgLSBjICogdjA7XHJcblx0XHRmID0geTAgLSBiICogdTAgLSBkICogdjA7XHJcblxyXG5cdFx0X2NvbnRleHQuc2F2ZSgpO1xyXG5cdFx0X2NvbnRleHQudHJhbnNmb3JtKCBhLCBiLCBjLCBkLCBlLCBmICk7XHJcblx0XHRfY29udGV4dC5jbGlwKCk7XHJcblx0XHRfY29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwICk7XHJcblx0XHRfY29udGV4dC5yZXN0b3JlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0R3JhZGllbnRUZXh0dXJlKCBjb2xvcjEsIGNvbG9yMiwgY29sb3IzLCBjb2xvcjQgKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL21yZG9vYi5jb20vYmxvZy9wb3N0LzcxMFxyXG5cclxuXHRcdF9waXhlbE1hcERhdGFbIDAgXSA9ICggY29sb3IxLnIgKiAyNTUgKSB8IDA7XHJcblx0XHRfcGl4ZWxNYXBEYXRhWyAxIF0gPSAoIGNvbG9yMS5nICogMjU1ICkgfCAwO1xyXG5cdFx0X3BpeGVsTWFwRGF0YVsgMiBdID0gKCBjb2xvcjEuYiAqIDI1NSApIHwgMDtcclxuXHJcblx0XHRfcGl4ZWxNYXBEYXRhWyA0IF0gPSAoIGNvbG9yMi5yICogMjU1ICkgfCAwO1xyXG5cdFx0X3BpeGVsTWFwRGF0YVsgNSBdID0gKCBjb2xvcjIuZyAqIDI1NSApIHwgMDtcclxuXHRcdF9waXhlbE1hcERhdGFbIDYgXSA9ICggY29sb3IyLmIgKiAyNTUgKSB8IDA7XHJcblxyXG5cdFx0X3BpeGVsTWFwRGF0YVsgOCBdID0gKCBjb2xvcjMuciAqIDI1NSApIHwgMDtcclxuXHRcdF9waXhlbE1hcERhdGFbIDkgXSA9ICggY29sb3IzLmcgKiAyNTUgKSB8IDA7XHJcblx0XHRfcGl4ZWxNYXBEYXRhWyAxMCBdID0gKCBjb2xvcjMuYiAqIDI1NSApIHwgMDtcclxuXHJcblx0XHRfcGl4ZWxNYXBEYXRhWyAxMiBdID0gKCBjb2xvcjQuciAqIDI1NSApIHwgMDtcclxuXHRcdF9waXhlbE1hcERhdGFbIDEzIF0gPSAoIGNvbG9yNC5nICogMjU1ICkgfCAwO1xyXG5cdFx0X3BpeGVsTWFwRGF0YVsgMTQgXSA9ICggY29sb3I0LmIgKiAyNTUgKSB8IDA7XHJcblxyXG5cdFx0X3BpeGVsTWFwQ29udGV4dC5wdXRJbWFnZURhdGEoIF9waXhlbE1hcEltYWdlLCAwLCAwICk7XHJcblx0XHRfZ3JhZGllbnRNYXBDb250ZXh0LmRyYXdJbWFnZSggX3BpeGVsTWFwLCAwLCAwICk7XHJcblxyXG5cdFx0cmV0dXJuIF9ncmFkaWVudE1hcDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBIaWRlIGFudGktYWxpYXMgZ2Fwc1xyXG5cclxuXHRmdW5jdGlvbiBleHBhbmQoIHYxLCB2MiwgcGl4ZWxzICkge1xyXG5cclxuXHRcdHZhciB4ID0gdjIueCAtIHYxLngsIHkgPSB2Mi55IC0gdjEueSxcclxuXHRcdGRldCA9IHggKiB4ICsgeSAqIHksIGlkZXQ7XHJcblxyXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0aWRldCA9IHBpeGVscyAvIE1hdGguc3FydCggZGV0ICk7XHJcblxyXG5cdFx0eCAqPSBpZGV0OyB5ICo9IGlkZXQ7XHJcblxyXG5cdFx0djIueCArPSB4OyB2Mi55ICs9IHk7XHJcblx0XHR2MS54IC09IHg7IHYxLnkgLT0geTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBDb250ZXh0IGNhY2hlZCBtZXRob2RzLlxyXG5cclxuXHRmdW5jdGlvbiBzZXRPcGFjaXR5KCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0R2xvYmFsQWxwaGEgIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuZ2xvYmFsQWxwaGEgPSB2YWx1ZTtcclxuXHRcdFx0X2NvbnRleHRHbG9iYWxBbHBoYSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRCbGVuZGluZyggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCBfY29udGV4dEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiAhPT0gdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSBUSFJFRS5Ob3JtYWxCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHRfY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbGlnaHRlcic7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rhcmtlcic7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfY29udGV4dEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRMaW5lV2lkdGgoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggX2NvbnRleHRMaW5lV2lkdGggIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQubGluZVdpZHRoID0gdmFsdWU7XHJcblx0XHRcdF9jb250ZXh0TGluZVdpZHRoID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldExpbmVDYXAoIHZhbHVlICkge1xyXG5cclxuXHRcdC8vIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0TGluZUNhcCAhPT0gdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRfY29udGV4dC5saW5lQ2FwID0gdmFsdWU7XHJcblx0XHRcdF9jb250ZXh0TGluZUNhcCA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRMaW5lSm9pbiggdmFsdWUgKSB7XHJcblxyXG5cdFx0Ly8gXCJyb3VuZFwiLCBcImJldmVsXCIsIFwibWl0ZXJcIlxyXG5cclxuXHRcdGlmICggX2NvbnRleHRMaW5lSm9pbiAhPT0gdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRfY29udGV4dC5saW5lSm9pbiA9IHZhbHVlO1xyXG5cdFx0XHRfY29udGV4dExpbmVKb2luID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldFN0cm9rZVN0eWxlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0U3Ryb2tlU3R5bGUgIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc3Ryb2tlU3R5bGUgPSB2YWx1ZTtcclxuXHRcdFx0X2NvbnRleHRTdHJva2VTdHlsZSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRGaWxsU3R5bGUoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggX2NvbnRleHRGaWxsU3R5bGUgIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuZmlsbFN0eWxlID0gdmFsdWU7XHJcblx0XHRcdF9jb250ZXh0RmlsbFN0eWxlID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldERhc2hBbmRHYXAoIGRhc2hTaXplVmFsdWUsIGdhcFNpemVWYWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0RGFzaFNpemUgIT09IGRhc2hTaXplVmFsdWUgfHwgX2NvbnRleHRHYXBTaXplICE9PSBnYXBTaXplVmFsdWUgKSB7XHJcblxyXG5cdFx0XHRfY29udGV4dC5zZXRMaW5lRGFzaCggWyBkYXNoU2l6ZVZhbHVlLCBnYXBTaXplVmFsdWUgXSApO1xyXG5cdFx0XHRfY29udGV4dERhc2hTaXplID0gZGFzaFNpemVWYWx1ZTtcclxuXHRcdFx0X2NvbnRleHRHYXBTaXplID0gZ2FwU2l6ZVZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTaGFkZXIgY2h1bmtzIGZvciBXZWJMRyBTaGFkZXIgbGlicmFyeVxyXG4gKiBcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby8gXHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmsgPSB7XHJcblxyXG5cdC8vIEZPR1xyXG5cclxuXHRjb21tb246IFtcclxuXHJcblx0XHRcIiNkZWZpbmUgUEkgMy4xNDE1OVwiLFxyXG5cdFx0XCIjZGVmaW5lIFBJMiA2LjI4MzE4XCIsXHJcblx0XHRcIiNkZWZpbmUgTE9HMiAxLjQ0MjY5NVwiLFxyXG5cdFx0XCJmbG9hdCBzcXVhcmUoIGluIGZsb2F0IGEgKSB7IHJldHVybiBhKmE7IH1cIixcclxuXHRcdFwidmVjMiAgc3F1YXJlKCBpbiB2ZWMyIGEgKSAgeyByZXR1cm4gdmVjMiggYS54KmEueCwgYS55KmEueSApOyB9XCIsXHJcblx0XHRcInZlYzMgIHNxdWFyZSggaW4gdmVjMyBhICkgIHsgcmV0dXJuIHZlYzMoIGEueCphLngsIGEueSphLnksIGEueiphLnogKTsgfVwiLFxyXG5cdFx0XCJ2ZWM0ICBzcXVhcmUoIGluIHZlYzQgYSApICB7IHJldHVybiB2ZWM0KCBhLngqYS54LCBhLnkqYS55LCBhLnoqYS56LCBhLncqYS53ICk7IH1cIixcclxuXHRcdFwiZmxvYXQgc2F0dXJhdGUoIGluIGZsb2F0IGEgKSB7IHJldHVybiBjbGFtcCggYSwgMC4wLCAxLjAgKTsgfVwiLFxyXG5cdFx0XCJ2ZWMyICBzYXR1cmF0ZSggaW4gdmVjMiBhICkgIHsgcmV0dXJuIGNsYW1wKCBhLCAwLjAsIDEuMCApOyB9XCIsXHJcblx0XHRcInZlYzMgIHNhdHVyYXRlKCBpbiB2ZWMzIGEgKSAgeyByZXR1cm4gY2xhbXAoIGEsIDAuMCwgMS4wICk7IH1cIixcclxuXHRcdFwidmVjNCAgc2F0dXJhdGUoIGluIHZlYzQgYSApICB7IHJldHVybiBjbGFtcCggYSwgMC4wLCAxLjAgKTsgfVwiLFxyXG5cdFx0XCJmbG9hdCBhdmVyYWdlKCBpbiBmbG9hdCBhICkgeyByZXR1cm4gYTsgfVwiLFxyXG5cdFx0XCJmbG9hdCBhdmVyYWdlKCBpbiB2ZWMyIGEgKSAgeyByZXR1cm4gKCBhLnggKyBhLnkpICogMC41OyB9XCIsXHJcblx0XHRcImZsb2F0IGF2ZXJhZ2UoIGluIHZlYzMgYSApICB7IHJldHVybiAoIGEueCArIGEueSArIGEueikgKiAwLjMzMzMzMzMzMzM7IH1cIixcclxuXHRcdFwiZmxvYXQgYXZlcmFnZSggaW4gdmVjNCBhICkgIHsgcmV0dXJuICggYS54ICsgYS55ICsgYS56ICsgYS53KSAqIDAuMjU7IH1cIixcclxuXHRcdFwiZmxvYXQgd2hpdGVDb21wbGltZW50KCBpbiBmbG9hdCBhICkgeyByZXR1cm4gc2F0dXJhdGUoIDEuMCAtIGEgKTsgfVwiLFxyXG5cdFx0XCJ2ZWMyICB3aGl0ZUNvbXBsaW1lbnQoIGluIHZlYzIgYSApICB7IHJldHVybiBzYXR1cmF0ZSggdmVjMigxLjApIC0gYSApOyB9XCIsXHJcblx0XHRcInZlYzMgIHdoaXRlQ29tcGxpbWVudCggaW4gdmVjMyBhICkgIHsgcmV0dXJuIHNhdHVyYXRlKCB2ZWMzKDEuMCkgLSBhICk7IH1cIixcclxuXHRcdFwidmVjNCAgd2hpdGVDb21wbGltZW50KCBpbiB2ZWM0IGEgKSAgeyByZXR1cm4gc2F0dXJhdGUoIHZlYzQoMS4wKSAtIGEgKTsgfVwiLFxyXG5cdFx0XCJ2ZWMzIHByb2plY3RPblBsYW5lKGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsKSB7XCIsXHJcbiAgICBcdFx0XCJmbG9hdCBkaXN0YW5jZSA9IGRvdCggcGxhbmVOb3JtYWwsIHBvaW50LXBvaW50T25QbGFuZSApO1wiLFxyXG4gICAgXHRcdFwicmV0dXJuIHBvaW50IC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbDtcIixcclxuXHRcdFwifVwiLFxyXG5cdFx0XCJmbG9hdCBzaWRlT2ZQbGFuZSggaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XCIsXHJcbiAgIFx0XHRcdFwicmV0dXJuIHNpZ24oIGRvdCggcG9pbnQgLSBwb2ludE9uUGxhbmUsIHBsYW5lTm9ybWFsICkgKTtcIixcclxuXHRcdFwifVwiLFxyXG5cdFx0XCJ2ZWMzIGxpbmVQbGFuZUludGVyc2VjdCggaW4gdmVjMyBwb2ludE9uTGluZSwgaW4gdmVjMyBsaW5lRGlyZWN0aW9uLCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcIixcclxuICAgXHRcdFx0XCJyZXR1cm4gcG9pbnRPbkxpbmUgKyBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICk7XCIsXHJcblx0XHRcIn1cIixcclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIEZPR1xyXG5cclxuXHRmb2dfcGFyc19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9GT0dcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRk9HX0VYUDJcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBmb2dOZWFyO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBmb2dGYXI7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRmb2dfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfRk9HXCIsXHJcblxyXG5cdFx0XHRcImZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEZPR19FWFAyXCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgZm9nRmFjdG9yID0gZXhwMiggLSBzcXVhcmUoIGZvZ0RlbnNpdHkgKSAqIHNxdWFyZSggZGVwdGggKSAqIExPRzIgKTtcIixcclxuXHRcdFx0XHRcImZvZ0ZhY3RvciA9IDEuMCAtIHNhdHVyYXRlKCBmb2dGYWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBFTlZJUk9OTUVOVCBNQVBcclxuXHJcblx0ZW52bWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQIClcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfRU5WTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGludCBjb21iaW5lO1wiLFxyXG5cclxuXHRcdFx0XCIjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGJvb2wgdXNlUmVmcmFjdDtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGVudm1hcF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9FTlZNQVBcIixcclxuXHJcblx0XHRcdFwidmVjMyByZWZsZWN0VmVjO1wiLFxyXG5cclxuXHRcdFx0XCIjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcIixcclxuXHJcblx0XHRcdFx0XCJpZiAoIHVzZVJlZnJhY3QgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0Ly8gdmlld1Bvc2l0aW9uIG1heSBpbnZlcnRlZFxyXG5cdFx0XHRcdFx0XCJyZWZsZWN0VmVjID0gcmVmcmFjdCggdmlld1Bvc2l0aW9uLCBub3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1wiLFxyXG5cclxuXHRcdFx0XHRcIn0gZWxzZSB7IFwiLFxyXG5cclxuXHRcdFx0XHRcdFwicmVmbGVjdFZlYyA9IHJlZmxlY3QoIHZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcInJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBmbGlwTm9ybWFsID0gKCAtMS4wICsgMi4wICogZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKTtcIixcclxuXHRcdFx0XHRcInZlYzQgY3ViZUNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgY3ViZUNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XCJjdWJlQ29sb3IueHl6ICo9IGN1YmVDb2xvci54eXo7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJmbG9hdCBmcmVzbmVsUmVmbGVjdGl2aXR5ID0gc2F0dXJhdGUoIHJlZmxlY3Rpdml0eSApO1wiLFxyXG5cclxuXHRcdFx0XCIjaWYgZGVmaW5lZCggUEhZU0lDQUwgKVwiLFxyXG5cclxuXHRcdFx0XHQvLyB0aGlzIHVzZXMgcmVmbGVjdGl2aXR5U3RyZW5ndGggYmVjYXVzZSB3aXRoIHBoeXNpY2FsIHdlIGFsbG93IGl0IHRvIHZhcnkuXHJcblx0XHRcdFx0XCJ7XCIsXHJcblxyXG5cdFx0XHRcdFx0Ly8gZGlmZnVzZVx0XHRcdFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBuRG90TCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld1Bvc2l0aW9uICkgKTtcIixcclxuXHRcdFx0XHJcblx0XHRcdFx0ICAgIFwiZmxvYXQgZnJlc25lbCA9IEZyZXNuZWxfU2NobGljayhyZWZsZWN0aXZpdHlTdHJlbmd0aCwgbm9ybWFsLCB2aWV3UG9zaXRpb24ueHl6ICk7XCIsXHJcblxyXG5cdCAgICBcdFx0XHQvLyBmcmVzbmVsIGJlY29tZXMgd2hpdGUgYXQgcGVycGVuZGljdWxhciBhbmdsZXNcclxuXHRcdFx0XHRcdFwidmVjMyBmcmVzbmVsQ29sb3IgPSBtaXgoIHNwZWN1bGFyLCBkaWZmdXNlQ29sb3IsIG1ldGFsbGljU3RyZW5ndGggKTtcIixcclxuXHRcdFx0XHQgICAgXCJmcmVzbmVsQ29sb3IgPSBtaXgoIGZyZXNuZWxDb2xvciwgdmVjMyggMS4wICksIChmcmVzbmVsIC0gcmVmbGVjdGl2aXR5U3RyZW5ndGgpICk7XCIsXHJcblx0ICAgIFx0XHJcblx0XHRcdFx0ICAgIC8vIFB1dCBpdCBhbGwgdG9nZXRoZXJcclxuXHRcdFx0XHQgICAgXCJ2ZWMzIHNwZWN1bGFyQ29sb3JDb2VmZmljaWVudCA9IGZyZXNuZWwgKiBmcmVzbmVsQ29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ICs9IHNwZWN1bGFyQ29sb3JDb2VmZmljaWVudCAqIGN1YmVDb2xvci54eXogKiBuRG90TDtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHRcdFx0XHJcblxyXG5cdFx0XHRcdFwiaWYgKCBjb21iaW5lID09IDEgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBjdWJlQ29sb3IueHl6LCBmcmVzbmVsUmVmbGVjdGl2aXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwifSBlbHNlIGlmICggY29tYmluZSA9PSAyICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiArPSBjdWJlQ29sb3IueHl6ICogZnJlc25lbFJlZmxlY3Rpdml0eTtcIixcclxuXHJcblx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peCggZ2xfRnJhZ0NvbG9yLnh5eiwgZ2xfRnJhZ0NvbG9yLnh5eiAqIGN1YmVDb2xvci54eXosIGZyZXNuZWxSZWZsZWN0aXZpdHkgKTtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRlbnZtYXBfcGFyc192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XCIsXHJcblx0XHRcdFwidW5pZm9ybSBib29sIHVzZVJlZnJhY3Q7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHdvcmxkcG9zX3ZlcnRleCA6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBMQU1CRVJUICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiBza2lubmVkO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKSAmJiAhIGRlZmluZWQoIFVTRV9TS0lOTklORyApXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBtb3JwaGVkLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZiAhIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKSAmJiAhIGRlZmluZWQoIFVTRV9TS0lOTklORyApXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRlbnZtYXBfdmVydGV4IDogW1xyXG5cclxuXHRcdFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcIixcclxuXHJcblx0XHRcdFwidmVjMyB3b3JsZE5vcm1hbCA9IG1hdDMoIG1vZGVsTWF0cml4WyAwIF0ueHl6LCBtb2RlbE1hdHJpeFsgMSBdLnh5eiwgbW9kZWxNYXRyaXhbIDIgXS54eXogKSAqIG9iamVjdE5vcm1hbDtcIixcclxuXHRcdFx0XCJ3b3JsZE5vcm1hbCA9IG5vcm1hbGl6ZSggd29ybGROb3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFwidmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1wiLFxyXG5cclxuXHRcdFx0XCJpZiAoIHVzZVJlZnJhY3QgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1wiLFxyXG5cclxuXHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcInZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gQ09MT1IgTUFQIChwYXJ0aWNsZXMpXHJcblxyXG5cdG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX01BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cclxuXHRtYXBfcGFydGljbGVfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTUFQXCIsXHJcblxyXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIENPTE9SIE1BUCAodHJpYW5nbGVzKVxyXG5cclxuXHRtYXBfcGFyc192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX1JFRkxFQ1RJVklUWU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxMSUNNQVAgKSB8fCBkZWZpbmVkKCBVU0VfT1BBQ0lUWU1BUCApIHx8IGRlZmluZWQoIFVTRV9GQUxMT0ZGTUFQICkgfHwgZGVmaW5lZCggVVNFX1RSQU5TTFVDRU5DWU1BUCApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFlST1RBVElPTk1BUCApXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX1JFRkxFQ1RJVklUWU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxMSUNNQVAgKSB8fCBkZWZpbmVkKCBVU0VfT1BBQ0lUWU1BUCApIHx8IGRlZmluZWQoIFVTRV9GQUxMT0ZGTUFQICkgfHwgZGVmaW5lZCggVVNFX1RSQU5TTFVDRU5DWU1BUCApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFlST1RBVElPTk1BUCApXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWM0IGdhaW5CcmlnaHRuZXNzO1wiLFxyXG5cclxuXHJcblx0XHRcdFwidmVjNCBhcHBseUdhaW5CcmlnaHRuZXNzKCB2ZWM0IHRleGVsLCB2ZWM0IGdhaW5CcmlnaHRuZXNzQ29lZmYgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidGV4ZWwueHl6ID0gKCB0ZXhlbC54eXogLSB2ZWMzKCBnYWluQnJpZ2h0bmVzc0NvZWZmLnggKSApICogZ2FpbkJyaWdodG5lc3NDb2VmZi55ICsgdmVjMyggZ2FpbkJyaWdodG5lc3NDb2VmZi56ICsgZ2FpbkJyaWdodG5lc3NDb2VmZi54ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwicmV0dXJuIHRleGVsO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHRcdFxyXG5cclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9NQVBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRtYXBfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9SRUZMRUNUSVZJVFlNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUk9VR0hORVNTTUFQICkgfHwgZGVmaW5lZCggVVNFX01FVEFMTElDTUFQICkgfHwgZGVmaW5lZCggVVNFX09QQUNJVFlNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRkFMTE9GRk1BUCApIHx8IGRlZmluZWQoIFVTRV9UUkFOU0xVQ0VOQ1lNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWU1BUCApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZUk9UQVRJT05NQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2VXYgPSB1diAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bWFwX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX01BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHRleGVsQ29sb3IgPSBhcHBseUdhaW5CcmlnaHRuZXNzKCB0ZXh0dXJlMkQoIG1hcCwgdlV2ICksIGdhaW5CcmlnaHRuZXNzICk7XCIsXHRcdFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XCJ0ZXhlbENvbG9yLnh5eiAqPSB0ZXhlbENvbG9yLnh5ejtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleGVsQ29sb3I7XCIsXHJcblxyXG5cdFx0XHRcIiNpZiBkZWZpbmVkKCBQSFlTSUNBTCApIHx8IGRlZmluZWQoIFBIT05HIClcIixcclxuXHJcblx0XHRcdFx0XCJkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvci54eXo7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLCAvLyBQSFlTSUNBTFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBGQUxMT0ZGIE1BUFxyXG5cclxuXHRmYWxsb2ZmbWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfRkFMTE9GRk1BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBmYWxsb2ZmTWFwO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBPUEFDSVRZIE1BUFxyXG5cclxuXHRvcGFjaXR5bWFwX3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX09QQUNJVFlNQVBcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZPcGFjaXR5VXY7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWM0IG9wYWNpdHlPZmZzZXRSZXBlYXQ7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdG9wYWNpdHltYXBfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX09QQUNJVFlNQVBcIixcclxuXHJcblx0XHRcdFwidk9wYWNpdHlVdiA9IHV2ICogb3BhY2l0eU9mZnNldFJlcGVhdC56dyArIG9wYWNpdHlPZmZzZXRSZXBlYXQueHk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdG9wYWNpdHltYXBfcGFyc19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9PUEFDSVRZTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG9wYWNpdHlNYXA7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZPcGFjaXR5VXY7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWM0IG9wYWNpdHlHYWluQnJpZ2h0bmVzcztcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblxyXG5cdG9wYWNpdHltYXBfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfT1BBQ0lUWU1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHRleGVsT3BhY2l0eSA9IGFwcGx5R2FpbkJyaWdodG5lc3MoIHRleHR1cmUyRCggb3BhY2l0eU1hcCwgdk9wYWNpdHlVdiApLCBvcGFjaXR5R2FpbkJyaWdodG5lc3MgKTtcIixcclxuXHJcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yLncgPSBnbF9GcmFnQ29sb3IudyAqIHRleGVsT3BhY2l0eS5yO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBUUkFOU0xVQ0VOQ1kgTUFQXHJcblxyXG5cdHRyYW5zbHVjZW5jeW1hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9UUkFOU0xVQ0VOQ1lNQVBcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZUcmFuc2x1Y2VuY3lVdjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzQgdHJhbnNsdWNlbmN5T2Zmc2V0UmVwZWF0O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHR0cmFuc2x1Y2VuY3ltYXBfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1RSQU5TTFVDRU5DWU1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2VHJhbnNsdWNlbmN5VXYgPSB1diAqIHRyYW5zbHVjZW5jeU9mZnNldFJlcGVhdC56dyArIHRyYW5zbHVjZW5jeU9mZnNldFJlcGVhdC54eTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0dHJhbnNsdWNlbmN5bWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfVFJBTlNMVUNFTkNZTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbHVjZW5jeU1hcDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlRyYW5zbHVjZW5jeVV2O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjNCB0cmFuc2x1Y2VuY3lHYWluQnJpZ2h0bmVzcztcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0dHJhbnNsdWNlbmN5bWFwX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1RSQU5TTFVDRU5DWU1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHRleGVsVHJhbnNsdWNlbmN5ID0gYXBwbHlHYWluQnJpZ2h0bmVzcyggdGV4dHVyZTJEKCB0cmFuc2x1Y2VuY3lNYXAsIHZUcmFuc2x1Y2VuY3lVdiApLCB0cmFuc2x1Y2VuY3lHYWluQnJpZ2h0bmVzcyApO1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XCJ0ZXhlbFRyYW5zbHVjZW5jeS54eXogKj0gdGV4ZWxUcmFuc2x1Y2VuY3kueHl6O1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwidHJhbnNsdWNlbmN5Q29sb3IueHl6ICo9IHRleGVsVHJhbnNsdWNlbmN5Lnh5ejtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gTElHSFQgTUFQXHJcblxyXG5cdGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2MjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGxpZ2h0bWFwX3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQIClcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGxpZ2h0bWFwX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0xJR0hUTUFQXCIsXHJcblxyXG5cdFx0XHQvL1wiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRsaWdodG1hcF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2VXYyID0gdXYyO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHJcblx0Ly8gQlVNUCBNQVBcclxuXHJcblx0YnVtcG1hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9CVU1QTUFQXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2QnVtcFV2O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjNCBidW1wT2Zmc2V0UmVwZWF0O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRidW1wbWFwX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9CVU1QTUFQXCIsXHJcblxyXG5cdFx0XHRcInZCdW1wVXYgPSB1diAqIGJ1bXBPZmZzZXRSZXBlYXQuencgKyBidW1wT2Zmc2V0UmVwZWF0Lnh5O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRidW1wbWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfQlVNUE1BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2QnVtcFV2O1wiLFxyXG5cdFxyXG5cdFx0XHQvLyBEZXJpdmF0aXZlIG1hcHMgLSBidW1wIG1hcHBpbmcgdW5wYXJhbWV0cml6ZWQgc3VyZmFjZXMgYnkgTW9ydGVuIE1pa2tlbHNlblxyXG5cdFx0XHQvL1x0aHR0cDovL21taWtrZWxzZW4zZC5ibG9nc3BvdC5zay8yMDExLzA3L2Rlcml2YXRpdmUtbWFwcy5odG1sXHJcblxyXG5cdFx0XHQvLyBFdmFsdWF0ZSB0aGUgZGVyaXZhdGl2ZSBvZiB0aGUgaGVpZ2h0IHcuci50LiBzY3JlZW4tc3BhY2UgdXNpbmcgZm9yd2FyZCBkaWZmZXJlbmNpbmcgKGxpc3RpbmcgMilcclxuXHJcblx0XHRcdFwidmVjMiBkSGR4eV9md2QoKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMiBkU1RkeCA9IGRGZHgoIHZCdW1wVXYgKTtcIixcclxuXHRcdFx0XHRcInZlYzIgZFNUZHkgPSBkRmR5KCB2QnVtcFV2ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2QnVtcFV2ICkueDtcIixcclxuXHRcdFx0XHRcImZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBVdiArIGRTVGR4ICkueCAtIEhsbDtcIixcclxuXHRcdFx0XHRcImZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBVdiArIGRTVGR5ICkueCAtIEhsbDtcIixcclxuXHJcblx0XHRcdFx0XCJyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5ICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIHZTaWdtYVkgPSBkRmR5KCBzdXJmX3BvcyApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyB2TiA9IHN1cmZfbm9ybTtcIixcdFx0Ly8gbm9ybWFsaXplZFxyXG5cclxuXHRcdFx0XHRcInZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcIixcclxuXHRcdFx0XHRcInZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1wiLFxyXG5cdFx0XHRcdFwicmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIExJR0hUIEFUVEVOVUFUSU9OIGZ1bmN0aW9uXHJcblxyXG5cdGxpZ2h0YXR0ZW51YXRpb25fZnVuY19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiZmxvYXQgY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBmbG9hdCBkZWNheUV4cG9uZW50ICkge1wiLFxyXG5cdFx0XHRcImZsb2F0IGRpc3RhbmNlQXR0ZW51YXRpb24gPSAxLjAgLyBwb3coIGxpZ2h0RGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgKTtcIixcclxuXHRcdFx0XCJpZiAoIGN1dG9mZkRpc3RhbmNlID4gMC4wICkge1wiLFxyXG5cdFx0XHRcdFwiZGlzdGFuY2VBdHRlbnVhdGlvbiAqPSAxLjAgLSBtaW4oIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSwgMS4wICk7XCIsXHJcblx0XHRcdFwifVwiLFxyXG5cdFx0XHRcInJldHVybiBkaXN0YW5jZUF0dGVudWF0aW9uO1wiLFxyXG5cdFx0XCJ9XCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBOT1JNQUwgTUFQXHJcblxyXG5cdG5vcm1hbG1hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZOb3JtYWxVdjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzQgbm9ybWFsT2Zmc2V0UmVwZWF0O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRub3JtYWxtYXBfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX05PUk1BTE1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2Tm9ybWFsVXYgPSB1diAqIG5vcm1hbE9mZnNldFJlcGVhdC56dyArIG5vcm1hbE9mZnNldFJlcGVhdC54eTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTk9STUFMTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdk5vcm1hbFV2O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcIixcclxuXHJcblx0XHRcdC8vIFBlci1QaXhlbCBUYW5nZW50IFNwYWNlIE5vcm1hbCBNYXBwaW5nXHJcblx0XHRcdC8vIGh0dHA6Ly9oYWNrc29mbGlmZS5ibG9nc3BvdC5jaC8yMDA5LzExL3Blci1waXhlbC10YW5nZW50LXNwYWNlLW5vcm1hbC1tYXBwaW5nLmh0bWxcclxuXHJcblx0XHRcdFwidmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcIixcclxuXHRcdFx0XHRcInZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1wiLFxyXG5cdFx0XHRcdFwidmVjMiBzdDAgPSBkRmR4KCB2Tm9ybWFsVXYuc3QgKTtcIixcclxuXHRcdFx0XHRcInZlYzIgc3QxID0gZEZkeSggdk5vcm1hbFV2LnN0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBTID0gbm9ybWFsaXplKCAgcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2Tm9ybWFsVXYgKS54eXogKiAyLjAgLSAxLjA7XCIsXHJcblx0XHRcdFx0XCJtYXBOLnh5ID0gbm9ybWFsU2NhbGUgKiBtYXBOLnh5O1wiLFxyXG5cdFx0XHRcdFwibWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XCIsXHJcblx0XHRcdFx0XCJyZXR1cm4gbm9ybWFsaXplKCB0c24gKiBtYXBOICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gQU5JU09UUk9QWSBNQVBcclxuXHJcblx0YW5pc290cm9weW1hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9BTklTT1RST1BZTUFQXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2QW5pc290cm9weVV2O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjNCBhbmlzb3Ryb3B5T2Zmc2V0UmVwZWF0O1wiLFxyXG5cclxuXHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEFOSVNPVFJPUFlcIixcclxuXHJcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdkFuaXNvdHJvcHlVdjtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0YW5pc290cm9weW1hcF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2QW5pc290cm9weVV2ID0gdXYgKiBhbmlzb3Ryb3B5T2Zmc2V0UmVwZWF0Lnp3ICsgYW5pc290cm9weU9mZnNldFJlcGVhdC54eTtcIixcclxuXHJcblx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBBTklTT1RST1BZXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUkVGTEVDVElWSVRZTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTExJQ01BUCApIHx8IGRlZmluZWQoIFVTRV9PUEFDSVRZTUFQICkgfHwgZGVmaW5lZCggVVNFX0ZBTExPRkZNQVAgKSB8fCBkZWZpbmVkKCBVU0VfVFJBTlNMVUNFTkNZTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFlNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWVJPVEFUSU9OTUFQIClcIixcclxuXHJcblx0XHRcdFx0XHRcInZBbmlzb3Ryb3B5VXYgPSB2VXY7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcInZBbmlzb3Ryb3B5VXYgPSB2ZWMyKCAwLCAwICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHJcblx0YW5pc290cm9weW1hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgYW5pc290cm9weU1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzQgYW5pc290cm9weUdhaW5CcmlnaHRuZXNzO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2QW5pc290cm9weVV2O1wiLFxyXG5cclxuXHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEFOSVNPVFJPUFlcIixcclxuXHJcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdkFuaXNvdHJvcHlVdjtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0YW5pc290cm9weW1hcF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiZmxvYXQgYW5pc290cm9weVN0cmVuZ3RoID0gYW5pc290cm9weTtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHRleGVsQW5pc290cm9weSA9IGFwcGx5R2FpbkJyaWdodG5lc3MoIHRleHR1cmUyRCggYW5pc290cm9weU1hcCwgdkFuaXNvdHJvcHlVdiApLCBhbmlzb3Ryb3B5R2FpbkJyaWdodG5lc3MgKTtcIixcclxuXHRcdFx0XCJhbmlzb3Ryb3B5U3RyZW5ndGggKz0gdGV4ZWxBbmlzb3Ryb3B5LnI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIEFOSVNPVFJPUFkgUk9UQVRJT04gTUFQXHJcblxyXG5cdGFuaXNvdHJvcHlyb3RhdGlvbm1hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9BTklTT1RST1BZUk9UQVRJT05NQVBcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZBbmlzb3Ryb3B5Um90YXRpb25VdjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzQgYW5pc290cm9weVJvdGF0aW9uT2Zmc2V0UmVwZWF0O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRhbmlzb3Ryb3B5cm90YXRpb25tYXBfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0FOSVNPVFJPUFlST1RBVElPTk1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2QW5pc290cm9weVJvdGF0aW9uVXYgPSB1diAqIGFuaXNvdHJvcHlSb3RhdGlvbk9mZnNldFJlcGVhdC56dyArIGFuaXNvdHJvcHlSb3RhdGlvbk9mZnNldFJlcGVhdC54eTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblxyXG5cdGFuaXNvdHJvcHlyb3RhdGlvbm1hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0FOSVNPVFJPUFlST1RBVElPTk1BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBhbmlzb3Ryb3B5Um90YXRpb25NYXA7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWM0IGFuaXNvdHJvcHlSb3RhdGlvbkdhaW5CcmlnaHRuZXNzO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2QW5pc290cm9weVJvdGF0aW9uVXY7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGFuaXNvdHJvcHlyb3RhdGlvbm1hcF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiZmxvYXQgYW5pc290cm9weVJvdGF0aW9uU3RyZW5ndGggPSBhbmlzb3Ryb3B5Um90YXRpb247XCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0FOSVNPVFJPUFlST1RBVElPTk1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHRleGVsQW5pc290cm9weVJvdGF0aW9uID0gYXBwbHlHYWluQnJpZ2h0bmVzcyggdGV4dHVyZTJEKCBhbmlzb3Ryb3B5Um90YXRpb25NYXAsIHZBbmlzb3Ryb3B5Um90YXRpb25VdiApLCBhbmlzb3Ryb3B5Um90YXRpb25HYWluQnJpZ2h0bmVzcyApO1wiLFxyXG5cdFx0XHRcImFuaXNvdHJvcHlSb3RhdGlvblN0cmVuZ3RoICs9IHRleGVsQW5pc290cm9weVJvdGF0aW9uLnI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIE1FVEFMTElDIE1BUFxyXG5cclxuXHRtZXRhbGxpY21hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9NRVRBTExJQ01BUFwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdk1ldGFsbGljVXY7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWM0IG1ldGFsbGljT2Zmc2V0UmVwZWF0O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRtZXRhbGxpY21hcF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTUVUQUxMSUNNQVBcIixcclxuXHJcblx0XHRcdFwidk1ldGFsbGljVXYgPSB1diAqIG1ldGFsbGljT2Zmc2V0UmVwZWF0Lnp3ICsgbWV0YWxsaWNPZmZzZXRSZXBlYXQueHk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cclxuXHRtZXRhbGxpY21hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX01FVEFMTElDTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbGljTWFwO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjNCBtZXRhbGxpY0dhaW5CcmlnaHRuZXNzO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2TWV0YWxsaWNVdjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bWV0YWxsaWNtYXBfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcImZsb2F0IG1ldGFsbGljU3RyZW5ndGggPSBtZXRhbGxpYztcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTUVUQUxMSUNNQVBcIixcclxuXHJcblx0XHRcdFwidmVjNCB0ZXhlbE1ldGFsbGljID0gYXBwbHlHYWluQnJpZ2h0bmVzcyggdGV4dHVyZTJEKCBtZXRhbGxpY01hcCwgdk1ldGFsbGljVXYgKSwgbWV0YWxsaWNHYWluQnJpZ2h0bmVzcyApO1wiLFxyXG5cdFx0XHRcIm1ldGFsbGljU3RyZW5ndGggKz0gdGV4ZWxNZXRhbGxpYy5yO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBST1VHSE5FU1MgTUFQXHJcblxyXG5cdHJvdWdobmVzc21hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZSb3VnaG5lc3NVdjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzQgcm91Z2huZXNzT2Zmc2V0UmVwZWF0O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRyb3VnaG5lc3NtYXBfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1JPVUdITkVTU01BUFwiLFxyXG5cclxuXHRcdFx0XCJ2Um91Z2huZXNzVXYgPSB1diAqIHJvdWdobmVzc09mZnNldFJlcGVhdC56dyArIHJvdWdobmVzc09mZnNldFJlcGVhdC54eTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblxyXG5cdHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1JPVUdITkVTU01BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZSb3VnaG5lc3NVdjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzQgcm91Z2huZXNzR2FpbkJyaWdodG5lc3M7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHJvdWdobmVzc21hcF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiZmxvYXQgcm91Z2huZXNzU3RyZW5ndGggPSByb3VnaG5lc3M7XCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1JPVUdITkVTU01BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHRleGVsUm91Z2huZXNzID0gYXBwbHlHYWluQnJpZ2h0bmVzcyggdGV4dHVyZTJEKCByb3VnaG5lc3NNYXAsIHZSb3VnaG5lc3NVdiApLCByb3VnaG5lc3NHYWluQnJpZ2h0bmVzcyApO1wiLFxyXG5cdFx0XHRcInJvdWdobmVzc1N0cmVuZ3RoICo9IHRleGVsUm91Z2huZXNzLnI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIFNQRUNVTEFSIE1BUFxyXG5cclxuXHRzcGVjdWxhcm1hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyVXY7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWM0IHNwZWN1bGFyT2Zmc2V0UmVwZWF0O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRzcGVjdWxhcm1hcF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcIixcclxuXHJcblx0XHRcdFwidlNwZWN1bGFyVXYgPSB1diAqIHNwZWN1bGFyT2Zmc2V0UmVwZWF0Lnp3ICsgc3BlY3VsYXJPZmZzZXRSZXBlYXQueHk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWM0IHNwZWN1bGFyR2FpbkJyaWdodG5lc3M7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZTcGVjdWxhclV2O1wiLFxyXG5cdFxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNwZWN1bGFybWFwX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1wiLFxyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHRleGVsU3BlY3VsYXIgPSBhcHBseUdhaW5CcmlnaHRuZXNzKCB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKSwgc3BlY3VsYXJHYWluQnJpZ2h0bmVzcyApO1wiLFxyXG5cdFx0XHRcInNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7XCIsXHJcblxyXG5cdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XCJzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBMSUdIVFMgTEFNQkVSVFxyXG5cclxuXHRsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnQ7XCIsXHJcblx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXHJcblxyXG5cdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheUV4cG9uZW50WyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0FSRUFfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYXJlYUxpZ2h0Q29sb3JbIE1BWF9BUkVBX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBhcmVhTGlnaHRQb3NpdGlvblsgTUFYX0FSRUFfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFyZWFMaWdodFdpZHRoWyBNQVhfQVJFQV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYXJlYUxpZ2h0SGVpZ2h0WyBNQVhfQVJFQV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGFyZWFMaWdodERpc3RhbmNlWyBNQVhfQVJFQV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGFyZWFMaWdodERlY2F5RXhwb25lbnRbIE1BWF9BUkVBX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHdyYXBSR0I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGxpZ2h0c19sYW1iZXJ0X3ZlcnRleDogW1xyXG5cclxuXHRcdFwidkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFwidkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJ0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcInZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxyXG5cdFx0XHRcInZlYzMgZGlyVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XCJmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCB0cmFuc2Zvcm1lZE5vcm1hbCwgZGlyVmVjdG9yICk7XCIsXHJcblx0XHRcdFwidmVjMyBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nID0gdmVjMyggbWF4KCBkb3RQcm9kdWN0LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nQmFjayA9IHZlYzMoIG1heCggLWRvdFByb2R1Y3QsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmQmFjayA9IHZlYzMoIG1heCggLTAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmID0gdmVjMyggbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1wiLFxyXG5cdFx0XHRcdFwiZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZyA9IG1peCggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZywgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGYsIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nQmFjayA9IG1peCggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0JhY2ssIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmQmFjaywgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwidkxpZ2h0RnJvbnQgKz0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nO1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFwidkxpZ2h0QmFjayArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6IC0gbXZQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgZGlzdGFuY2VBdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodERpc3RhbmNlWyBpIF0sIHBvaW50TGlnaHREZWNheUV4cG9uZW50W2ldICk7XCIsXHJcblxyXG5cdFx0XHRcdFwibFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmcgPSB2ZWMzKCBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayA9IHZlYzMoIG1heCggLWRvdFByb2R1Y3QsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBwb2ludExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2sgPSB2ZWMzKCBtYXgoIC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmID0gdmVjMyggbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJwb2ludExpZ2h0V2VpZ2h0aW5nID0gbWl4KCBwb2ludExpZ2h0V2VpZ2h0aW5nLCBwb2ludExpZ2h0V2VpZ2h0aW5nSGFsZiwgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayA9IG1peCggcG9pbnRMaWdodFdlaWdodGluZ0JhY2ssIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmQmFjaywgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwidkxpZ2h0RnJvbnQgKz0gcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludExpZ2h0V2VpZ2h0aW5nICogZGlzdGFuY2VBdHRlbnVhdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2TGlnaHRCYWNrICs9IHBvaW50TGlnaHRDb2xvclsgaSBdICogcG9pbnRMaWdodFdlaWdodGluZ0JhY2sgKiBkaXN0YW5jZUF0dGVudWF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRpc3RhbmNlQXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHNwb3RMaWdodERpc3RhbmNlWyBpIF0sIHNwb3RMaWdodERlY2F5RXhwb25lbnRbaV0gKTtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBzcG90TGlnaHRQb3NpdGlvblsgaSBdIC0gd29ybGRQb3NpdGlvbi54eXogKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcImlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJzcG90RWZmZWN0ID0gbWF4KCBwb3coIHNwb3RFZmZlY3QsIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHRcImxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBsVmVjdG9yICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nID0gdmVjMyggbWF4KCBkb3RQcm9kdWN0LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0JhY2sgPSB2ZWMzKCBtYXgoIC1kb3RQcm9kdWN0LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0hhbGZCYWNrID0gdmVjMyggbWF4KCAtMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwic3BvdExpZ2h0V2VpZ2h0aW5nID0gbWl4KCBzcG90TGlnaHRXZWlnaHRpbmcsIHNwb3RMaWdodFdlaWdodGluZ0hhbGYsIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInNwb3RMaWdodFdlaWdodGluZ0JhY2sgPSBtaXgoIHNwb3RMaWdodFdlaWdodGluZ0JhY2ssIHNwb3RMaWdodFdlaWdodGluZ0hhbGZCYWNrLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2TGlnaHRGcm9udCArPSBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdExpZ2h0V2VpZ2h0aW5nICogZGlzdGFuY2VBdHRlbnVhdGlvbiAqIHNwb3RFZmZlY3Q7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZMaWdodEJhY2sgKz0gc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RMaWdodFdlaWdodGluZ0JhY2sgKiBkaXN0YW5jZUF0dGVudWF0aW9uICogc3BvdEVmZmVjdDtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBsVmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHRCYWNrID0gLTAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XCIsXHJcblxyXG5cdFx0XHRcdFwidkxpZ2h0RnJvbnQgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XHRcInZMaWdodEJhY2sgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodEJhY2sgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJ2TGlnaHRGcm9udCA9ICggdkxpZ2h0RnJvbnQgKyBhbWJpZW50TGlnaHRDb2xvciArIGFtYmllbnQpICogZGlmZnVzZSArIGVtaXNzaXZlO1wiLFxyXG5cclxuXHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XCJ2TGlnaHRCYWNrID0gKCB2TGlnaHRGcm9udCArIGFtYmllbnRMaWdodENvbG9yICsgYW1iaWVudCkgKiBkaWZmdXNlICsgZW1pc3NpdmU7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIExJR0hUUyBQSFlTSUNBTFxyXG5cclxuXHRsaWdodHNfcGh5c2ljYWxfcGFyc192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IE1BWF9BUkVBX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU5WTUFQIClcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHJcblx0bGlnaHRzX3BoeXNpY2FsX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgTUFYX0FSRUFfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcInZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWROb3JtYWwueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcInZlYzQgc2tpbm5lZFRhbmdlbnQgPSBza2luTWF0cml4ICogdmVjNCggdGFuZ2VudC54eXosIDAuMCApO1wiLFxyXG5cdFx0XHRcInZUYW5nZW50ID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBza2lubmVkVGFuZ2VudC54eXogKTtcIixcclxuXHJcblx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcInZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxyXG5cdFx0XHRcInZUYW5nZW50ID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiB0YW5nZW50Lnh5eiApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJ2Qmlub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCB2Tm9ybWFsLCB2VGFuZ2VudCApICogdGFuZ2VudC53ICk7XCIsXHJcblxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheUV4cG9uZW50WyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0FSRUFfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYXJlYUxpZ2h0Q29sb3JbIE1BWF9BUkVBX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBhcmVhTGlnaHRQb3NpdGlvblsgTUFYX0FSRUFfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFyZWFMaWdodFdpZHRoWyBNQVhfQVJFQV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYXJlYUxpZ2h0SGVpZ2h0WyBNQVhfQVJFQV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGFyZWFMaWdodERpc3RhbmNlWyBNQVhfQVJFQV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGFyZWFMaWdodERlY2F5RXhwb25lbnRbIE1BWF9BUkVBX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBNQVhfQVJFQV9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQIClcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHdyYXBSR0I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxyXG5cdFx0XCJ2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XCIsXHJcblx0XHRcInZhcnlpbmcgdmVjMyB2Qmlub3JtYWw7XCIsXHJcblx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdC8vIGNsYXNzaWMgRnJlc25lbCBTY2hsaWNrXHJcblx0XHRcImZsb2F0IEZyZXNuZWxfU2NobGljayggZmxvYXQgaERvdFYgKSB7XCIsXHJcblx0XHRcdFwiZmxvYXQgRjAgPSAwLjA0O1wiLFxyXG5cdFx0XHRcInJldHVybiBGMCArICggMS4wIC0gRjAgKSAqIHBvdyggMS4wIC0gaERvdFYsIDUuMCApO1wiLFxyXG5cdFx0XCJ9XCIsXHJcblxyXG5cdFx0Ly8gQ2FsY3VhdGUgdGhlIEZyZXNuZWwgdGVybSB1c2luZyB0aGUgU2NobGljayBhcHByb3hpbWF0aW9uICh1c2luZyBVbnJlYWwncyBibGVuZCB0byB3aGl0ZSBtZXRob2QpICBWQUxJREFURURcclxuXHRcdFwidmVjMyBGcmVzbmVsX1NjaGxpY2tfU3BlY3VsYXJCbGVuZFRvV2hpdGUodmVjMyBzcGVjdWxhckNvbG9yLCBmbG9hdCBoRG90Vikge1wiLFxyXG5cdFx0XHRcImZsb2F0IEZjID0gcG93KDEuMCAtIGhEb3RWLCA1LjApO1wiLFxyXG4gICAgXHRcdFwicmV0dXJuIHNhdHVyYXRlKCA1MC4wICogYXZlcmFnZSggc3BlY3VsYXJDb2xvciApICkgKiBGYyArICgxLjAgLSBGYykgKiBzcGVjdWxhckNvbG9yO1wiLFxyXG5cdFx0XCJ9XCIsXHJcblxyXG5cdCAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RyaWJ1dGlvbiB0ZXJtICBWQUxJREFURURcclxuXHRcdFwiZmxvYXQgRGlzdHJpYnV0aW9uX0dHWCggZmxvYXQgcm91Z2huZXNzMiwgZmxvYXQgbkRvdEggKSB7XCIsXHJcblx0XHRcdFwiZmxvYXQgZGVub20gPSBuRG90SCAqIG5Eb3RIICogKHJvdWdobmVzczIgLSAxLjApICsgMS4wO1wiLFxyXG4gICAgXHRcdFwicmV0dXJuIHJvdWdobmVzczIgLyAoIFBJICogc3F1YXJlKCBkZW5vbSApICk7XCIsXHJcblx0XHRcIn1cIixcclxuXHJcblx0XHQvLyBDYWxjdWxhdGVkIHRoZSBhbmlzb3Ryb3BpYyBHR1ogZGlzdHJ1YnRpb24gdGVybSAgICAgVkFMSURBVEVEXHJcblx0XHRcImZsb2F0IERpc3RyaWJ1dGlvbl9HR1hBbmlzbyggdmVjMiBhbmlzb3Ryb3BpY00sIHZlYzIgeHlEb3RILCBmbG9hdCBuRG90SCApIHtcIixcclxuICAgIFx0XHRcImZsb2F0IGFuaXNvVGVybSA9ICggeHlEb3RILnggKiB4eURvdEgueCAvICggYW5pc290cm9waWNNLnggKiBhbmlzb3Ryb3BpY00ueCApICsgeHlEb3RILnkgKiB4eURvdEgueSAvICggYW5pc290cm9waWNNLnkgKiBhbmlzb3Ryb3BpY00ueSApICsgbkRvdEggKiBuRG90SCApO1wiLFxyXG4gICAgXHRcdFwicmV0dXJuIDEuMCAvICggUEkgKiBhbmlzb3Ryb3BpY00ueCAqIGFuaXNvdHJvcGljTS55ICogYW5pc29UZXJtICogYW5pc29UZXJtICk7XCIsXHJcblx0XHRcIn1cIixcclxuXHJcblx0XHQvLyB1c2VmdWwgZm9yIGNsZWFyIGNvYXQgc3VyZmFjZXMsIHVzZSB3aXRoIERpc3RyaWJ1dGlvbl9HR1guXHJcblx0XHRcImZsb2F0IFZpc2liaWxpdHlfS2VsZW1lbiggZmxvYXQgdkRvdEggKSB7XCIsXHJcblx0XHRcdFwicmV0dXJuIDEuMCAvICggNC4wICogdkRvdEggKiB2RG90SCApO1wiLFxyXG5cdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCJmbG9hdCBWaXNpYmlsaXR5X1NjaGxpY2soaW4gZmxvYXQgcm91Z2huZXNzMiwgaW4gZmxvYXQgbkRvdEwsIGluIGZsb2F0IG5Eb3RWKSB7XCIsXHJcbiAgICBcdFx0XCJmbG9hdCB0ZXJtTCA9IChuRG90TCArIHNxcnQocm91Z2huZXNzMiArICgxLjAgLSByb3VnaG5lc3MyKSAqIG5Eb3RMICogbkRvdEwpKTtcIixcclxuICAgIFx0XHRcImZsb2F0IHRlcm1WID0gKG5Eb3RWICsgc3FydChyb3VnaG5lc3MyICsgKDEuMCAtIHJvdWdobmVzczIpICogbkRvdFYgKiBuRG90VikpO1wiLFxyXG4gICAgXHRcdFwicmV0dXJuIDEuMCAvICggdGVybUwgKiB0ZXJtViApO1wiLFxyXG5cdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCJmbG9hdCBEaWZmdXNlX0xhbWJlcnQoKSB7XCIsXHJcbiAgICBcdFx0XCJyZXR1cm4gMS4wIC8gUEk7XCIsXHJcblx0XHRcIn1cIixcclxuXHJcblx0XHRcImZsb2F0IERpZmZ1c2VfT3Jlbk5heWVyKGluIGZsb2F0IG0yLCBpbiBmbG9hdCBuRG90ViwgaW4gZmxvYXQgbkRvdEwsIGluIGZsb2F0IHZEb3RIICkge1wiLFxyXG5cdFx0XHRcImZsb2F0IHRlcm1BID0gMS4wIC0gMC41ICogbTIgLyAobTIgKyAwLjMzKTtcIixcclxuXHRcdFx0XCJmbG9hdCBDb3NyaSA9IDIuMCAqIHZEb3RIIC0gMS4wIC0gbkRvdFYgKiBuRG90TDtcIixcclxuXHRcdFx0XCJmbG9hdCB0ZXJtQiA9IDAuNDUgKiBtMiAvIChtMiArIDAuMDkpICogQ29zcmkgKiAoIENvc3JpID49IDAuMCA/IG1pbiggMS4wLCBuRG90TCAvIG5Eb3RWICkgOiBuRG90TCApO1wiLFxyXG5cdFx0XHRcInJldHVybiAxLjAgLyBQSSAqICggbkRvdEwgKiB0ZXJtQSArIHRlcm1CICk7XCIsXHJcblx0XHRcIn1cIixcclxuXHJcblx0XHQvLyBIZWxwZXIgZm9yIGFuaXNvdHJvcHkgcm90YXRpb25cclxuXHRcdFwibWF0MiBjcmVhdGVSb3RhdGlvbk1hdDIoaW4gZmxvYXQgcmFkcykge1wiLFxyXG5cdFx0XHRcImZsb2F0IGNvc19yYWRzID0gY29zKCByYWRzICk7XCIsXHJcblx0XHRcdFwiZmxvYXQgc2luX3JhZHMgPSBzaW4oIHJhZHMgKTtcIixcclxuICAgIFx0XHRcInJldHVybiBtYXQyKCB2ZWMyKCBjb3NfcmFkcywgc2luX3JhZHMgKSwgdmVjMiggLXNpbl9yYWRzLCBjb3NfcmFkcyApICk7XCIsXHJcblx0XHRcIn1cIixcclxuXHJcblx0XHQvLyBIZWxwZXIgZm9yIGFuaXNvdHJvcHkgcm90YXRpb25cclxuXHRcdFwidmVjMiBjYWxjQW5pc290cm9weVVWKGluIGZsb2F0IGFuaXNvdHJvcHlMb2NhbCkge1wiLFxyXG5cdFx0XHRcImZsb2F0IG9uZU1pbnVzQWJzQW5pc290cm9weSA9IDEuMCAtIG1pbiggYWJzKCBhbmlzb3Ryb3B5TG9jYWwgKSAqIDAuOSwgMC45ICk7XCIsXHJcblx0XHRcdFwidmVjMiBhbmlzb3Ryb3B5VVYgPSB2ZWMyICggMS4wIC8gb25lTWludXNBYnNBbmlzb3Ryb3B5LCBvbmVNaW51c0Fic0FuaXNvdHJvcHkgKTtcIixcclxuXHRcdFx0XCJpZiggYW5pc290cm9weSA8IDAuMCApIHtcIixcclxuXHRcdFx0XHRcImFuaXNvdHJvcHlVVi54eSA9IGFuaXNvdHJvcHlVVi55eDtcIiwgLy8gc3dpenplbFxyXG5cdFx0XHRcIn1cIixcclxuICAgIFx0XHRcInJldHVybiBhbmlzb3Ryb3B5VVY7XCIsXHJcblx0XHRcIn1cIlxyXG5cclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIm1hdDMgdHNiID0gbWF0Myggbm9ybWFsaXplKCB2VGFuZ2VudCApLCBub3JtYWxpemUoIHZCaW5vcm1hbCApLCBub3JtYWwgKTtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTk9STUFMTUFQXCIsXHJcblxyXG5cdFx0XHRcIm5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHQvKlwidmVjMyBub3JtYWxUZXggPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdk5vcm1hbFV2ICkueHl6ICogMi4wIC0gMS4wO1wiLFxyXG5cdFx0XHRcIm5vcm1hbFRleC54eSAqPSBub3JtYWxTY2FsZTtcIixcclxuXHRcdFx0XCJub3JtYWxUZXggPSBwZXJ0dXJiTm9ybWFsMkFyYiggLVZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XCIsXHJcblx0XHRcdFxyXG5cdFx0XHRcIm5vcm1hbCA9IHRzYiAqIG5vcm1hbFRleDtcIiwqL1xyXG5cclxuXHRcdFwiI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcIm5vcm1hbCA9IG5vcm1hbCAqICggLTEuMCArIDIuMCAqIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZmRlZiBGQUxMT0ZGXCIsXHJcblxyXG5cdFx0XHRcInZlYzMgbW9kdWxhdGVkRmFsbG9mZkNvbG9yID0gZmFsbG9mZkNvbG9yO1wiLFxyXG5cdFx0XHRcclxuXHRcdFx0XCIjaWZkZWYgVVNFX0ZBTExPRkZNQVBcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGZhbGxvZmZUZXhlbENvbG9yID0gdGV4dHVyZTJEKCBmYWxsb2ZmTWFwLCB2VXYgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XHRcImZhbGxvZmZUZXhlbENvbG9yLnh5eiAqPSBmYWxsb2ZmVGV4ZWxDb2xvci54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwibW9kdWxhdGVkRmFsbG9mZkNvbG9yID0gbW9kdWxhdGVkRmFsbG9mZkNvbG9yICogZmFsbG9mZlRleGVsQ29sb3IueHl6O1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiZmxvYXQgZm0gPSBhYnMoIGRvdCggbm9ybWFsLCB2aWV3UG9zaXRpb24gKSApO1wiLFxyXG5cclxuXHRcdFx0Ly8gdGhpcyBpcyBhIGhhY2ssIGl0IG5lZWRzIHRvIGJlIGZpeGVkLlxyXG5cdFx0XHRcImZtID0gLypmYWxsb2ZmQmxlbmRQYXJhbXMueCAqIGZtICsgZmFsbG9mZkJsZW5kUGFyYW1zLnkgKiAqLyAoIGZtICogZm0gKiAoIDMuMCAtIDIuMCAqIGZtICkgKTtcIixcclxuXHJcblx0XHRcdFwiZGlmZnVzZUNvbG9yID0gbWl4KCBtb2R1bGF0ZWRGYWxsb2ZmQ29sb3IsIGRpZmZ1c2VDb2xvciwgZm0gKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiZmxvYXQgbkRvdFYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdQb3NpdGlvbiApICk7XCIsXHJcblx0XHRcImZsb2F0IG0yID0gcG93KCBjbGFtcCggcm91Z2huZXNzU3RyZW5ndGgsIDAuMDEsIDEuMCApLCA0LjAgKTtcIixcclxuXHRcdC8vIHNwZWN1bGFyIGlzIHNjYWxlZCBieSAwLjA4IHBlciBEaXNuZXkgUEJSIHJlY29tbWVuZGF0aW9ucy5cclxuXHRcdFwidmVjMyBzcGVjdWxhckNvbG9yID0gbWl4KCBzcGVjdWxhciwgZGlmZnVzZUNvbG9yLCBtZXRhbGxpY1N0cmVuZ3RoICk7XCIsXHJcblx0XHRcImZsb2F0IG0yQ2xlYXJDb2F0ID0gcG93KCBjbGFtcCggY2xlYXJDb2F0Um91Z2huZXNzLCAwLjAxLCAxLjAgKSwgNC4wICk7XCIsXHJcblx0XHRcImRpZmZ1c2VDb2xvciA9IG1peCggZGlmZnVzZUNvbG9yLCB2ZWMzKDApLCBtZXRhbGxpY1N0cmVuZ3RoICk7XCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgQU5JU09UUk9QWVwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMyIGFuaXNvdHJvcGljTSA9IGNhbGNBbmlzb3Ryb3B5VVYoIGFuaXNvdHJvcHlTdHJlbmd0aCApICogc3FydCggbTIgKTtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEFOSVNPVFJPUFlST1RBVElPTlwiLFxyXG5cdFx0XHRcdFwibWF0MiBhbmlzb3Ryb3BpY1JvdGF0aW9uTWF0cml4ID0gY3JlYXRlUm90YXRpb25NYXQyKCBhbmlzb3Ryb3B5Um90YXRpb25TdHJlbmd0aCAqIDIuMCAqIFBJICk7XCIsXHJcbiAgICBcdFx0XCIjZW5kaWZcIixcclxuXHRcdFx0XHJcblx0XHRcdFwidmVjMyBhbmlzb3Ryb3BpY1MgPSB0c2JbMV07XCIsXHQvLyBiaW5vcm1hbCBpbiBleWUgc3BhY2UuXHJcblx0XHRcdFwidmVjMyBhbmlzb3Ryb3BpY1QgPSB0c2JbMF07XCIsXHQvLyB0YW5nZW50IGluIGV5ZSBzcGFjZS5cclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwidmVjMyB0b3RhbExpZ2h0aW5nICA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcImZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRpc3RhbmNlQXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdLCBwb2ludExpZ2h0RGVjYXlFeHBvbmVudFtpXSApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgaW5jaWRlbnRMaWdodCA9IHBvaW50TGlnaHRDb2xvclsgaSBdICogZGlzdGFuY2VBdHRlbnVhdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XCJsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHRcdFxyXG5cdFx0XHRcdFwidmVjMyBoVmVjdG9yID0gbm9ybWFsaXplKCB2aWV3UG9zaXRpb24ueHl6ICsgbFZlY3Rvci54eXogKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IG5Eb3RIID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoVmVjdG9yICkgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IG5Eb3RMID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsVmVjdG9yICkgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGhEb3RWID0gc2F0dXJhdGUoIGRvdCggaFZlY3Rvciwgdmlld1Bvc2l0aW9uICkgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgQ0xFQVJDT0FUXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkQ2xlYXJDb2F0ID0gRGlzdHJpYnV0aW9uX0dHWCggbTJDbGVhckNvYXQsIG5Eb3RIICk7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IHZpc0NsZWFyQ29hdCA9IFZpc2liaWxpdHlfS2VsZW1lbiggaERvdFYgKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgZnJlc25lbENsZWFyQ29hdCA9IEZyZXNuZWxfU2NobGljayggaERvdFYgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBzcGVjQ2xlYXJDb2F0ID0gdmVjMyggMS4wICkgKiAoIGRDbGVhckNvYXQgKiB2aXNDbGVhckNvYXQgKiBmcmVzbmVsQ2xlYXJDb2F0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIEFOSVNPVFJPUFlcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzIgeHlEb3RIID0gdmVjMiggZG90KCBhbmlzb3Ryb3BpY1MsIGhWZWN0b3IgKSwgZG90KCBhbmlzb3Ryb3BpY1QsIGhWZWN0b3IgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIEFOSVNPVFJPUFlST1RBVElPTlwiLFxyXG5cdCAgICBcdFx0XHRcdFwieHlEb3RIID0gYW5pc290cm9waWNSb3RhdGlvbk1hdHJpeCAqIHh5RG90SDtcIixcclxuXHRcdCAgICBcdFx0XCIjZW5kaWZcIixcclxuXHRcclxuXHRcdFx0XHRcdFwiZmxvYXQgZCA9IERpc3RyaWJ1dGlvbl9HR1hBbmlzbyggYW5pc290cm9waWNNLCB4eURvdEgsIG5Eb3RIICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0ICAgIFwiZmxvYXQgZCA9IERpc3RyaWJ1dGlvbl9HR1goIG0yLCBuRG90SCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IHZpcyA9IFZpc2liaWxpdHlfU2NobGljayhtMiwgbkRvdEwsIG5Eb3RWKTtcIixcclxuXHRcdFx0ICAgIFwidmVjMyBmcmVzbmVsQ29sb3IgPSBGcmVzbmVsX1NjaGxpY2tfU3BlY3VsYXJCbGVuZFRvV2hpdGUoIHNwZWN1bGFyQ29sb3IgKiAwLjE4LCBoRG90ViApO1wiLFxyXG4gICAgIFx0XHJcblx0XHRcdCAgICAvLyBQdXQgaXQgYWxsIHRvZ2V0aGVyXHJcblx0XHRcdCAgICBcInZlYzMgc3BlYyA9IGQgKiB2aXMgKiBmcmVzbmVsQ29sb3I7XCIsXHJcblx0XHRcdCAgICBcInZlYzMgZGlmZiA9IERpZmZ1c2VfTGFtYmVydCgpICogZGlmZnVzZUNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBUUkFOU0xVQ0VOQ1lcIixcclxuXHJcblx0XHRcdFx0ICAgIFwiZGlmZiAqPSB3aGl0ZUNvbXBsaW1lbnQoIHRyYW5zbHVjZW5jeUNvbG9yLnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0ICAgIFwidmVjMyBzaGFkaW5nUmVzdWx0ID0gc3BlYyArIGRpZmY7XCIsXHJcblxyXG5cdFx0XHQgICAgXCIjaWZkZWYgQ0xFQVJDT0FUXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJzaGFkaW5nUmVzdWx0ID0gbWl4KCBzaGFkaW5nUmVzdWx0LCBzcGVjQ2xlYXJDb2F0LCBjbGVhckNvYXQgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcdFxyXG5cdFx0XHRcdFx0XHRcdCAgICAvLyBkaWZmdXNlXHJcblx0XHRcdFx0XCJ0b3RhbExpZ2h0aW5nICArPSBpbmNpZGVudExpZ2h0ICogbkRvdEwgKiBzaGFkaW5nUmVzdWx0O1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBUUkFOU0xVQ0VOQ1lcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGxpZ2h0Tm9ybWFsVEwgPSBtaXgoIDEuMCwgcG93KCBhYnMoIGRvdCggbFZlY3Rvci54eXosIG5vcm1hbCApICksIHRyYW5zbHVjZW5jeU5vcm1hbFBvd2VyICksIHRyYW5zbHVjZW5jeU5vcm1hbEFscGhhICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCB2aWV3Tm9ybWFsVEwgPSBtaXgoIDEuMCwgcG93KCBhYnMoIGRvdCggdmlld1Bvc2l0aW9uLnh5eiwgbFZlY3Rvci54eXopICksIHRyYW5zbHVjZW5jeVZpZXdQb3dlciApLCB0cmFuc2x1Y2VuY3lWaWV3QWxwaGEgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInRvdGFsTGlnaHRpbmcgKz0gbGlnaHROb3JtYWxUTCAqIHZpZXdOb3JtYWxUTCAqIHRyYW5zbHVjZW5jeUNvbG9yLnJnYiAqIGluY2lkZW50TGlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwiZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFwiZmxvYXQgZGlzdGFuY2VBdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlFeHBvbmVudFtpXSApO1wiLFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFwidmVjMyBpbmNpZGVudExpZ2h0ID0gc3BvdExpZ2h0Q29sb3JbIGkgXSAqIGRpc3RhbmNlQXR0ZW51YXRpb247XCIsXHJcblx0XHRcdFxyXG5cdFx0XHRcdFwibFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB2V29ybGRQb3NpdGlvbiApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInNwb3RFZmZlY3QgPSBtYXgoIHBvdyggc3BvdEVmZmVjdCwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFx0XCJpbmNpZGVudExpZ2h0ICo9IHNwb3RFZmZlY3Q7XCIsXHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHRcdFwidmVjMyBoVmVjdG9yID0gbm9ybWFsaXplKCB2aWV3UG9zaXRpb24ueHl6ICsgbFZlY3Rvci54eXogKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgbkRvdEggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhWZWN0b3IgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBuRG90TCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbFZlY3RvciApICk7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IGhEb3RWID0gc2F0dXJhdGUoIGRvdCggaFZlY3Rvciwgdmlld1Bvc2l0aW9uICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBDTEVBUkNPQVRcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZENsZWFyQ29hdCA9IERpc3RyaWJ1dGlvbl9HR1goIG0yQ2xlYXJDb2F0LCBuRG90SCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHZpc0NsZWFyQ29hdCA9IFZpc2liaWxpdHlfS2VsZW1lbiggaERvdFYgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBmcmVzbmVsQ2xlYXJDb2F0ID0gRnJlc25lbF9TY2hsaWNrKCBoRG90ViApO1wiLFxyXG5cdFx0XHRcdFx0XHRcInZlYzMgc3BlY0NsZWFyQ29hdCA9IHZlYzMoIDEuMCApICogKCBkQ2xlYXJDb2F0ICogdmlzQ2xlYXJDb2F0ICogZnJlc25lbENsZWFyQ29hdCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgQU5JU09UUk9QWVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMyIHh5RG90SCA9IHZlYzIoIGRvdCggYW5pc290cm9waWNTLCBoVmVjdG9yICksIGRvdCggYW5pc290cm9waWNULCBoVmVjdG9yICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2lmZGVmIEFOSVNPVFJPUFlST1RBVElPTlwiLFxyXG5cdFx0ICAgIFx0XHRcdFx0XCJ4eURvdEggPSBhbmlzb3Ryb3BpY1JvdGF0aW9uTWF0cml4ICogeHlEb3RIO1wiLFxyXG5cdFx0XHQgICAgXHRcdFwiI2VuZGlmXCIsXHJcblx0XHRcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkID0gRGlzdHJpYnV0aW9uX0dHWEFuaXNvKCBhbmlzb3Ryb3BpY00sIHh5RG90SCwgbkRvdEggKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0ICAgIFwiZmxvYXQgZCA9IERpc3RyaWJ1dGlvbl9HR1goIG0yLCBuRG90SCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCB2aXMgPSBWaXNpYmlsaXR5X1NjaGxpY2sobTIsIG5Eb3RMLCBuRG90Vik7XCIsXHJcblx0XHRcdFx0ICAgIFwidmVjMyBmcmVzbmVsQ29sb3IgPSBGcmVzbmVsX1NjaGxpY2tfU3BlY3VsYXJCbGVuZFRvV2hpdGUoIHNwZWN1bGFyQ29sb3IgKiAwLjA4LCBoRG90ViApO1wiLFxyXG5cdCAgICBcdFxyXG5cdFx0ICAgXHRcdFx0Ly8gUHV0IGl0IGFsbCB0b2dldGhlclxyXG5cdFx0XHRcdCAgICBcInZlYzMgc3BlYyA9IGQgKiB2aXMgKiBmcmVzbmVsQ29sb3I7XCIsXHJcblx0XHRcdFx0ICAgIFwidmVjMyBkaWZmID0gRGlmZnVzZV9MYW1iZXJ0KCkgKiBkaWZmdXNlQ29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgVFJBTlNMVUNFTkNZXCIsXHJcblxyXG5cdFx0XHRcdFx0ICAgIFwiZGlmZiAqPSB3aGl0ZUNvbXBsaW1lbnQoIHRyYW5zbHVjZW5jeUNvbG9yLnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdCAgICBcInZlYzMgc2hhZGluZ1Jlc3VsdCA9IHNwZWMgKyBkaWZmO1wiLFxyXG5cclxuXHRcdFx0XHQgICAgXCIjaWZkZWYgQ0xFQVJDT0FUXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInNoYWRpbmdSZXN1bHQgPSBtaXgoIHNoYWRpbmdSZXN1bHQsIHNwZWNDbGVhckNvYXQsIGNsZWFyQ29hdCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHRcclxuXHRcdFx0XHRcdFx0XHRcdCAgICAvLyBkaWZmdXNlXHJcblx0XHRcdFx0XHRcInRvdGFsTGlnaHRpbmcgICs9IGluY2lkZW50TGlnaHQgKiBuRG90TCAqIHNoYWRpbmdSZXN1bHQ7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgVFJBTlNMVUNFTkNZXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGxpZ2h0Tm9ybWFsVEwgPSBtaXgoIDEuMCwgcG93KCBhYnMoIGRvdCggbFZlY3Rvci54eXosIG5vcm1hbCApICksIHRyYW5zbHVjZW5jeU5vcm1hbFBvd2VyICksIHRyYW5zbHVjZW5jeU5vcm1hbEFscGhhICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHZpZXdOb3JtYWxUTCA9IG1peCggMS4wLCBwb3coIGFicyggZG90KCB2aWV3UG9zaXRpb24ueHl6LCBsVmVjdG9yLnh5eikgKSwgdHJhbnNsdWNlbmN5Vmlld1Bvd2VyICksIHRyYW5zbHVjZW5jeVZpZXdBbHBoYSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ0b3RhbExpZ2h0aW5nICs9IGxpZ2h0Tm9ybWFsVEwgKiB2aWV3Tm9ybWFsVEwgKiB0cmFuc2x1Y2VuY3lDb2xvci5yZ2IgKiBpbmNpZGVudExpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGluY2lkZW50TGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXTtcIixcclxuXHRcclxuXHRcdFx0XHRcInZlYzMgaFZlY3RvciA9IG5vcm1hbGl6ZSggdmlld1Bvc2l0aW9uLnh5eiArIGxWZWN0b3IueHl6ICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBuRG90SCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaFZlY3RvciApICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBuRG90TCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbFZlY3RvciApICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBoRG90ViA9IHNhdHVyYXRlKCBkb3QoIGhWZWN0b3IsIHZpZXdQb3NpdGlvbiApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIENMRUFSQ09BVFwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgZENsZWFyQ29hdCA9IERpc3RyaWJ1dGlvbl9HR1goIG0yQ2xlYXJDb2F0LCBuRG90SCApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCB2aXNDbGVhckNvYXQgPSBWaXNpYmlsaXR5X0tlbGVtZW4oIGhEb3RWICk7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IGZyZXNuZWxDbGVhckNvYXQgPSBGcmVzbmVsX1NjaGxpY2soIGhEb3RWICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzMgc3BlY0NsZWFyQ29hdCA9IHZlYzMoIDEuMCApICogKCBkQ2xlYXJDb2F0ICogdmlzQ2xlYXJDb2F0ICogZnJlc25lbENsZWFyQ29hdCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBBTklTT1RST1BZXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMyIHh5RG90SCA9IHZlYzIoIGRvdCggYW5pc290cm9waWNTLCBoVmVjdG9yICksIGRvdCggYW5pc290cm9waWNULCBoVmVjdG9yICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBBTklTT1RST1BZUk9UQVRJT05cIixcclxuXHQgICAgXHRcdFx0XHRcInh5RG90SCA9IGFuaXNvdHJvcGljUm90YXRpb25NYXRyaXggKiB4eURvdEg7XCIsXHJcblx0XHQgICAgXHRcdFwiI2VuZGlmXCIsXHJcblx0XHJcblx0XHRcdFx0XHRcImZsb2F0IGQgPSBEaXN0cmlidXRpb25fR0dYQW5pc28oIGFuaXNvdHJvcGljTSwgeHlEb3RILCBuRG90SCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdCAgICBcImZsb2F0IGQgPSBEaXN0cmlidXRpb25fR0dYKCBtMiwgbkRvdEggKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCB2aXMgPSBWaXNpYmlsaXR5X1NjaGxpY2sobTIsIG5Eb3RMLCBuRG90Vik7XCIsXHJcblx0XHRcdCAgICBcInZlYzMgZnJlc25lbENvbG9yID0gRnJlc25lbF9TY2hsaWNrX1NwZWN1bGFyQmxlbmRUb1doaXRlKCBzcGVjdWxhckNvbG9yICogMC4wOCwgaERvdFYgKTtcIixcclxuXHQgICAgICAgIFx0XHJcblx0ICAgXHRcdFx0Ly8gUHV0IGl0IGFsbCB0b2dldGhlclxyXG5cdFx0XHQgICAgXCJ2ZWMzIHNwZWMgPSBkICogdmlzICogZnJlc25lbENvbG9yO1wiLFxyXG5cdFx0XHQgICAgXCJ2ZWMzIGRpZmYgPSBEaWZmdXNlX0xhbWJlcnQoKSAqIGRpZmZ1c2VDb2xvcjtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgVFJBTlNMVUNFTkNZXCIsXHJcblxyXG5cdFx0XHRcdCAgICBcImRpZmYgKj0gd2hpdGVDb21wbGltZW50KCB0cmFuc2x1Y2VuY3lDb2xvci54eXogKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdCAgICBcInZlYzMgc2hhZGluZ1Jlc3VsdCA9IHNwZWMgKyBkaWZmO1wiLFxyXG5cclxuXHRcdFx0ICAgIFwiI2lmZGVmIENMRUFSQ09BVFwiLFxyXG5cclxuXHRcdFx0XHRcdFwic2hhZGluZ1Jlc3VsdCA9IG1peCggc2hhZGluZ1Jlc3VsdCwgc3BlY0NsZWFyQ29hdCwgY2xlYXJDb2F0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHRcclxuXHRcdFx0XHRcdFx0XHQgICAgLy8gZGlmZnVzZVxyXG5cdFx0XHRcdFwidG90YWxMaWdodGluZyAgKz0gaW5jaWRlbnRMaWdodCAqIG5Eb3RMICogc2hhZGluZ1Jlc3VsdDtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgVFJBTlNMVUNFTkNZXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBsaWdodE5vcm1hbFRMID0gbWl4KCAxLjAsIHBvdyggYWJzKCBkb3QoIGxWZWN0b3IueHl6LCBub3JtYWwgKSApLCB0cmFuc2x1Y2VuY3lOb3JtYWxQb3dlciApLCB0cmFuc2x1Y2VuY3lOb3JtYWxBbHBoYSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgdmlld05vcm1hbFRMID0gbWl4KCAxLjAsIHBvdyggYWJzKCBkb3QoIHZpZXdQb3NpdGlvbi54eXosIGxWZWN0b3IueHl6KSApLCB0cmFuc2x1Y2VuY3lWaWV3UG93ZXIgKSwgdHJhbnNsdWNlbmN5Vmlld0FscGhhICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ0b3RhbExpZ2h0aW5nICs9IGxpZ2h0Tm9ybWFsVEwgKiB2aWV3Tm9ybWFsVEwgKiB0cmFuc2x1Y2VuY3lDb2xvci5yZ2IgKiBpbmNpZGVudExpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBuRG90TCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vIGJhc2VkIG9uIHBhZ2UgMzI1IG9mIFJlYWwtVGltZSBSZW5kZXJpbmcuLCBlcXVhdGlvbiAoOC40MylcclxuXHRcdFx0XHRcInZlYzMgaGVtaUNvbG9yID0gKCBQSSAvIDIuMCApICogKCAoIDEuMCArIG5Eb3RMICkgKiBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdICsgKCAxLjAgLSBuRG90TCApICogaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XCJ0b3RhbExpZ2h0aW5nICs9IGRpZmZ1c2VDb2xvciAqIGhlbWlDb2xvcjtcIixcclxuXHRcdFx0XHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0FSRUFfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9BUkVBX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGxQb3NpdGlvbiA9ICggdmlld01hdHJpeCAqIHZlYzQoIGFyZWFMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApICkueHl6O1wiLFxyXG5cdFx0XHRcdC8vXCJ2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XCIsXHJcblx0XHRcclxuXHRcdFx0XHRcInZlYzMgd2lkdGggPSBhcmVhTGlnaHRXaWR0aFsgaSBdO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBoZWlnaHQgPSBhcmVhTGlnaHRIZWlnaHRbIGkgXTtcIixcclxuXHRcdFx0XHRcInZlYzMgdXAgPSBub3JtYWxpemUoICggdmlld01hdHJpeCAqIHZlYzQoIGhlaWdodCwgMC4wICkgKS54eXogKTtcIixcclxuXHRcdFx0XHRcInZlYzMgcmlnaHQgPSBub3JtYWxpemUoICggdmlld01hdHJpeCAqIHZlYzQoIHdpZHRoLCAwLjAgKSApLnh5eiApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBwbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggcmlnaHQsIHVwICkgKTtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCB3aWR0aFNjYWxhciA9IGxlbmd0aCggd2lkdGggKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGhlaWdodFNjYWxhciA9IGxlbmd0aCggaGVpZ2h0ICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vcHJvamVjdCBvbnRvIHBsYW5lIGFuZCBjYWxjdWxhdGUgZGlyZWN0aW9uIGZyb20gY2VudGVyIHRvIHRoZSBwcm9qZWN0aW9uLlxyXG5cdFx0XHRcdFwidmVjMyBwcm9qZWN0aW9uID0gcHJvamVjdE9uUGxhbmUoIC12Vmlld1Bvc2l0aW9uLnh5eiwgbFBvc2l0aW9uLCBwbm9ybWFsICk7XCIsICAvLyBwcm9qZWN0aW9uIGluIHBsYW5lXHJcblx0XHRcdFx0XCJ2ZWMzIGRpciA9IHByb2plY3Rpb24gLSBsUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdC8vY2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gYXJlYTpcclxuXHRcdFx0XHRcInZlYzIgZGlhZ29uYWwgPSB2ZWMyKCBkb3QoIGRpciwgcmlnaHQgKSwgZG90KCBkaXIsIHVwICkgKTtcIixcclxuXHRcdFx0XHRcInZlYzIgbmVhcmVzdDJEID0gdmVjMiggY2xhbXAoIGRpYWdvbmFsLngsIC13aWR0aFNjYWxhciwgd2lkdGhTY2FsYXIgKSwgY2xhbXAoIGRpYWdvbmFsLnksIC1oZWlnaHRTY2FsYXIsIGhlaWdodFNjYWxhciApICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIG5lYXJlc3RQb2ludEluc2lkZSA9IGxQb3NpdGlvbiArICggcmlnaHQgKm5lYXJlc3QyRC54ICsgdXAgKiBuZWFyZXN0MkQueSApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9ICggbmVhcmVzdFBvaW50SW5zaWRlICsgdlZpZXdQb3NpdGlvbi54eXogKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGRpc3RhbmNlQXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIGFyZWFMaWdodERpc3RhbmNlWyBpIF0sIGFyZWFMaWdodERlY2F5RXhwb25lbnRbaV0gKTtcIixcclxuXHRcdFx0XHRcImxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcIixcclxuXHRcdFx0XHJcblx0XHRcdFx0XCJ2ZWMzIGluY2lkZW50TGlnaHQgPSBhcmVhTGlnaHRDb2xvclsgaSBdICogZGlzdGFuY2VBdHRlbnVhdGlvbiAqIDAuMDE7XCIsIC8vIHRoZSAwLjAxIGlzIHRoZSBhcmVhIGxpZ2h0IGludGVuc2l0eSBzY2FsaW5nLlxyXG5cclxuXHRcdFx0XHRcImZsb2F0IG5Eb3RMRGlmZnVzZSA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbFZlY3RvciApICk7XCIsXHJcblxyXG5cdFx0ICAgXHRcdFwidmVjMyBkaWZmID0gRGlmZnVzZV9MYW1iZXJ0KCkgKiBkaWZmdXNlQ29sb3IgKiB3aWR0aFNjYWxhciAqIGhlaWdodFNjYWxhcjtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHZpZXdSZWZsZWN0aW9uID0gcmVmbGVjdCggdmlld1Bvc2l0aW9uLnh5eiwgbm9ybWFsICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIHJlZmxlY3Rpb25MaWdodFBsYW5lSW50ZXJzZWN0aW9uID0gbGluZVBsYW5lSW50ZXJzZWN0KCAtdlZpZXdQb3NpdGlvbi54eXosIHZpZXdSZWZsZWN0aW9uLCBsUG9zaXRpb24sIHBub3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBzcGVjQW5nbGUgPSBkb3QoIHZpZXdSZWZsZWN0aW9uLCBwbm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCBzcGVjQW5nbGUgPCAwLjAgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGRpclNwZWMgPSByZWZsZWN0aW9uTGlnaHRQbGFuZUludGVyc2VjdGlvbiAtIGxQb3NpdGlvbjtcIixcclxuXHRcdFx0XHRcdFwidmVjMiBkaXJTcGVjMkQgPSB2ZWMyKCBkb3QoIGRpclNwZWMsIHJpZ2h0ICksIGRvdCggZGlyU3BlYywgdXAgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWMyIG5lYXJlc3RTcGVjMkQgPSB2ZWMyKCBjbGFtcCggZGlyU3BlYzJELngsIC13aWR0aFNjYWxhciwgd2lkdGhTY2FsYXIgKSwgY2xhbXAoIGRpclNwZWMyRC55LCAtaGVpZ2h0U2NhbGFyLCBoZWlnaHRTY2FsYXIgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJsVmVjdG9yID0gbm9ybWFsaXplKCBsUG9zaXRpb24gKyAoIHJpZ2h0ICpuZWFyZXN0U3BlYzJELnggKyB1cCAqIG5lYXJlc3RTcGVjMkQueSApICsgdlZpZXdQb3NpdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFx0XCJ9IGVsc2UgeyBcIixcclxuXHJcblx0XHRcdFx0XHRcImxWZWN0b3IgPSB2ZWMzKCAwICk7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFwidmVjMyBoVmVjdG9yID0gbm9ybWFsaXplKCB2aWV3UG9zaXRpb24ueHl6ICsgbFZlY3Rvci54eXogKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IG5Eb3RIID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoVmVjdG9yICkgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IG5Eb3RMID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsVmVjdG9yICkgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGhEb3RWID0gc2F0dXJhdGUoIGRvdCggaFZlY3Rvciwgdmlld1Bvc2l0aW9uICkgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgQ0xFQVJDT0FUXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkQ2xlYXJDb2F0ID0gRGlzdHJpYnV0aW9uX0dHWCggbTJDbGVhckNvYXQsIG5Eb3RIICk7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IHZpc0NsZWFyQ29hdCA9IFZpc2liaWxpdHlfS2VsZW1lbiggaERvdFYgKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgZnJlc25lbENsZWFyQ29hdCA9IEZyZXNuZWxfU2NobGljayggaERvdFYgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBzcGVjQ2xlYXJDb2F0ID0gdmVjMyggMS4wICkgKiAoIGRDbGVhckNvYXQgKiB2aXNDbGVhckNvYXQgKiBmcmVzbmVsQ2xlYXJDb2F0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFRSQU5TTFVDRU5DWVwiLFxyXG5cclxuXHRcdFx0XHQgICAgXCJkaWZmICo9IHdoaXRlQ29tcGxpbWVudCggdHJhbnNsdWNlbmN5Q29sb3IueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIENMRUFSQ09BVFwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZGlmZiA9IG1peCggZGlmZiwgc3BlY0NsZWFyQ29hdCwgY2xlYXJDb2F0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwidG90YWxMaWdodGluZyAgKz0gaW5jaWRlbnRMaWdodCAqIG5Eb3RMRGlmZnVzZSAqIGRpZmY7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIEFOSVNPVFJPUFlcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzIgeHlEb3RIID0gdmVjMiggZG90KCBhbmlzb3Ryb3BpY1MsIGhWZWN0b3IgKSwgZG90KCBhbmlzb3Ryb3BpY1QsIGhWZWN0b3IgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIEFOSVNPVFJPUFlST1RBVElPTlwiLFxyXG5cdCAgICBcdFx0XHRcdFwieHlEb3RIID0gYW5pc290cm9waWNSb3RhdGlvbk1hdHJpeCAqIHh5RG90SDtcIixcclxuXHRcdCAgICBcdFx0XCIjZW5kaWZcIixcclxuXHRcclxuXHRcdFx0XHRcdFwiZmxvYXQgZCA9IERpc3RyaWJ1dGlvbl9HR1hBbmlzbyggYW5pc290cm9waWNNLCB4eURvdEgsIG5Eb3RIICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0ICAgIFwiZmxvYXQgZCA9IERpc3RyaWJ1dGlvbl9HR1goIG0yLCBuRG90SCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IHZpcyA9IFZpc2liaWxpdHlfU2NobGljayhtMiwgbkRvdEwsIG5Eb3RWKTtcIixcclxuXHRcdFx0XHRcInZlYzMgZnJlc25lbENvbG9yID0gRnJlc25lbF9TY2hsaWNrX1NwZWN1bGFyQmxlbmRUb1doaXRlKCBzcGVjdWxhckNvbG9yICogMC4wOCwgaERvdFYgKTtcIixcclxuICAgIFxyXG5cdCAgIFx0XHRcdC8vIFB1dCBpdCBhbGwgdG9nZXRoZXJcclxuXHRcdFx0ICAgIFwidmVjMyBzcGVjID0gZCAqIHZpcyAqIGZyZXNuZWxDb2xvcjtcIixcclxuXHJcblx0XHRcdFx0XCJ0b3RhbExpZ2h0aW5nICArPSBpbmNpZGVudExpZ2h0ICogbkRvdEwgKiBzcGVjO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBUUkFOU0xVQ0VOQ1lcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGxpZ2h0Tm9ybWFsVEwgPSBtaXgoIDEuMCwgcG93KCBhYnMoIGRvdCggbFZlY3Rvci54eXosIG5vcm1hbCApICksIHRyYW5zbHVjZW5jeU5vcm1hbFBvd2VyICksIHRyYW5zbHVjZW5jeU5vcm1hbEFscGhhICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCB2aWV3Tm9ybWFsVEwgPSBtaXgoIDEuMCwgcG93KCBhYnMoIGRvdCggdmlld1Bvc2l0aW9uLnh5eiwgbFZlY3Rvci54eXopICksIHRyYW5zbHVjZW5jeVZpZXdQb3dlciApLCB0cmFuc2x1Y2VuY3lWaWV3QWxwaGEgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInRvdGFsTGlnaHRpbmcgKz0gbGlnaHROb3JtYWxUTCAqIHZpZXdOb3JtYWxUTCAqIHRyYW5zbHVjZW5jeUNvbG9yLnJnYiAqIGluY2lkZW50TGlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblx0XHRcclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZmRlZiBDTEVBUkNPQVRcIixcclxuXHJcblx0XHRcdFwidG90YWxMaWdodGluZyArPSBkaWZmdXNlQ29sb3IgKiAoIGFtYmllbnRMaWdodENvbG9yICogKCAxLjAgLSBjbGVhckNvYXQgKSApO1wiLFxyXG5cdFx0XHJcblx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcInRvdGFsTGlnaHRpbmcgKz0gZGlmZnVzZUNvbG9yICogYW1iaWVudExpZ2h0Q29sb3I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcImdsX0ZyYWdDb2xvci54eXogKz0gdG90YWxMaWdodGluZztcIixcclxuXHJcblx0XHRcInZlYzMgZW1pc3NpdmVMb2NhbCA9IGVtaXNzaXZlO1wiLFxyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYyICkueHl6O1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XCJlbWlzc2l2ZUNvbG9yICo9IGVtaXNzaXZlQ29sb3I7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJlbWlzc2l2ZUxvY2FsICo9IGVtaXNzaXZlQ29sb3I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcImdsX0ZyYWdDb2xvci54eXogKz0gZW1pc3NpdmVMb2NhbDtcIixcclxuXHJcblx0XHRcInZlYzMgYW1iaWVudExvY2FsID0gYW1iaWVudDtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTElHSFRNQVBcIixcclxuXHJcblx0XHRcdFwidmVjMyBhbWJpZW50Q29sb3IgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6O1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XCJhbWJpZW50Q29sb3IgKj0gYW1iaWVudENvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiYW1iaWVudExvY2FsICo9IGFtYmllbnRDb2xvcjtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIENMRUFSQ09BVFwiLFxyXG5cclxuXHRcdFx0XHRcImFtYmllbnRMb2NhbCAqPSAoIDEuMCAtIGNsZWFyQ29hdCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHRcclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJnbF9GcmFnQ29sb3IueHl6ICs9IGRpZmZ1c2VDb2xvciAqIGFtYmllbnRMb2NhbDtcIixcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBMSUdIVFMgUEhPTkdcclxuXHJcblx0bGlnaHRzX3Bob25nX3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cclxuXHRsaWdodHNfcGhvbmdfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1wiLFxyXG5cclxuXHRcdFwiI2lmbmRlZiBVU0VfRU5WTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheUV4cG9uZW50WyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0FSRUFfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYXJlYUxpZ2h0Q29sb3JbIE1BWF9BUkVBX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBhcmVhTGlnaHRQb3NpdGlvblsgTUFYX0FSRUFfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFyZWFMaWdodFdpZHRoWyBNQVhfQVJFQV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYXJlYUxpZ2h0SGVpZ2h0WyBNQVhfQVJFQV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGFyZWFMaWdodERpc3RhbmNlWyBNQVhfQVJFQV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGFyZWFMaWdodERlY2F5RXhwb25lbnRbIE1BWF9BUkVBX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBNQVhfQVJFQV9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQIClcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHdyYXBSR0I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxyXG5cdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGxpZ2h0c19waG9uZ19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwidmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTtcIixcclxuXHRcdFwidmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFwibm9ybWFsID0gbm9ybWFsICogKCAtMS4wICsgMi4wICogZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcIixcclxuXHJcblx0XHRcdFwibm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwgKTtcIixcclxuXHJcblx0XHRcIiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcIixcclxuXHJcblx0XHRcdFwibm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInZlYzMgcG9pbnREaWZmdXNlICA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcInZlYzMgcG9pbnRTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XCJmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBkaXN0YW5jZUF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSwgcG9pbnRMaWdodERlY2F5RXhwb25lbnRbaV0gKTtcIixcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcImxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gZGlmZnVzZVxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IHBvaW50RGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwicG9pbnREaWZmdXNlICArPSBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50RGlmZnVzZVdlaWdodCAqIGRpc3RhbmNlQXR0ZW51YXRpb247XCIsXHJcblxyXG5cdFx0XHRcdC8vIHNwZWN1bGFyXHJcblxyXG5cdFx0XHRcdFwidmVjMyBwb2ludEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHQvLyAyLjAgPT4gMi4wMDAxIGlzIGhhY2sgdG8gd29yayBhcm91bmQgQU5HTEUgYnVnXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCBzaGluaW5lc3MgKyAyLjAwMDEgKSAvIDguMDtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBsVmVjdG9yLCBwb2ludEhhbGZWZWN0b3IgKSwgMC4wICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFwicG9pbnRTcGVjdWxhciArPSBzY2hsaWNrICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogZGlzdGFuY2VBdHRlbnVhdGlvbiAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIHNwb3REaWZmdXNlICA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcInZlYzMgc3BvdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcImZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBkaXN0YW5jZUF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBzcG90TGlnaHREaXN0YW5jZVsgaSBdLCBzcG90TGlnaHREZWNheUV4cG9uZW50W2ldICk7XCIsXHJcblxyXG5cdFx0XHRcdFwibFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB2V29ybGRQb3NpdGlvbiApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInNwb3RFZmZlY3QgPSBtYXgoIHBvdyggc3BvdEVmZmVjdCwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgc3BvdERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMgKCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggc3BvdERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFwic3BvdERpZmZ1c2UgKz0gc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3REaWZmdXNlV2VpZ2h0ICogZGlzdGFuY2VBdHRlbnVhdGlvbiAqIHNwb3RFZmZlY3Q7XCIsXHJcblxyXG5cdFx0XHRcdFx0Ly8gc3BlY3VsYXJcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgc3BvdEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgc3BvdERvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBzcG90SGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgc3BvdFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBzcG90RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdC8vIDIuMCA9PiAyLjAwMDEgaXMgaGFjayB0byB3b3JrIGFyb3VuZCBBTkdMRSBidWdcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBsVmVjdG9yLCBzcG90SGFsZlZlY3RvciApLCAwLjAgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcInNwb3RTcGVjdWxhciArPSBzY2hsaWNrICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RTcGVjdWxhcldlaWdodCAqIHNwb3REaWZmdXNlV2VpZ2h0ICogZGlzdGFuY2VBdHRlbnVhdGlvbiAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqIHNwb3RFZmZlY3Q7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidmVjMyBkaXJEaWZmdXNlICA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcInZlYzMgZGlyU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIiAsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gZGlmZnVzZVxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IGRpckRpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyRGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggZGlyRGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJkaXJEaWZmdXNlICArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpckRpZmZ1c2VXZWlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdC8vIHNwZWN1bGFyXHJcblxyXG5cdFx0XHRcdFwidmVjMyBkaXJIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBkaXJWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGRpckRvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBkaXJIYWxmVmVjdG9yICksIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgZGlyU3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIGRpckRvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdC8vXCJkaXJTcGVjdWxhciArPSBzcGVjdWxhciAqIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyU3BlY3VsYXJXZWlnaHQgKiBkaXJEaWZmdXNlV2VpZ2h0ICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogZnJlc25lbDtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIG1heCggMS4wIC0gZG90KCBkaXJWZWN0b3IsIGRpckhhbGZWZWN0b3IgKSwgMC4wICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFwiZGlyU3BlY3VsYXIgKz0gc2NobGljayAqIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyU3BlY3VsYXJXZWlnaHQgKiBkaXJEaWZmdXNlV2VpZ2h0ICogc3BlY3VsYXJOb3JtYWxpemF0aW9uO1wiLFxyXG5cclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIGhlbWlEaWZmdXNlICA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcInZlYzMgaGVtaVNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIgLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBoZW1pQ29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaGVtaURpZmZ1c2UgKz0gaGVtaUNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHQvLyBzcGVjdWxhciAoc2t5IGxpZ2h0KVxyXG5cclxuXHRcdFx0XHRcInZlYzMgaGVtaUhhbGZWZWN0b3JTa3kgPSBub3JtYWxpemUoIGxWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGhlbWlEb3ROb3JtYWxIYWxmU2t5ID0gMC41ICogZG90KCBub3JtYWwsIGhlbWlIYWxmVmVjdG9yU2t5ICkgKyAwLjU7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIGhlbWlEb3ROb3JtYWxIYWxmU2t5LCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vIHNwZWN1bGFyIChncm91bmQgbGlnaHQpXHJcblxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yR3JvdW5kID0gLWxWZWN0b3I7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBoZW1pSGFsZlZlY3Rvckdyb3VuZCA9IG5vcm1hbGl6ZSggbFZlY3Rvckdyb3VuZCArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZHcm91bmQgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSArIDAuNTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCA9IHNwZWN1bGFyU3RyZW5ndGggKiBtYXgoIHBvdyggaGVtaURvdE5vcm1hbEhhbGZHcm91bmQsIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBkb3RQcm9kdWN0R3JvdW5kID0gZG90KCBub3JtYWwsIGxWZWN0b3JHcm91bmQgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBzY2hsaWNrU2t5ID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3RvciwgaGVtaUhhbGZWZWN0b3JTa3kgKSwgMC4wICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBzY2hsaWNrR3JvdW5kID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3Rvckdyb3VuZCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSwgMC4wICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFwiaGVtaVNwZWN1bGFyICs9IGhlbWlDb2xvciAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqICggc2NobGlja1NreSAqIGhlbWlTcGVjdWxhcldlaWdodFNreSAqIG1heCggZG90UHJvZHVjdCwgMC4wICkgKyBzY2hsaWNrR3JvdW5kICogaGVtaVNwZWN1bGFyV2VpZ2h0R3JvdW5kICogbWF4KCBkb3RQcm9kdWN0R3JvdW5kLCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfQVJFQV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInZlYzMgYXJlYURpZmZ1c2UgID0gdmVjMyggMC4wICk7XCIsXHJcblx0XHRcdFwidmVjMyBhcmVhU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfQVJFQV9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBsUG9zaXRpb24gPSAoIHZpZXdNYXRyaXggKiB2ZWM0KCBhcmVhTGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKSApLnh5ejtcIixcclxuXHRcdFx0XHQvL1widmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxyXG5cdFx0XHJcblx0XHRcdFx0XCJ2ZWMzIHdpZHRoID0gYXJlYUxpZ2h0V2lkdGhbIGkgXTtcIixcclxuXHRcdFx0XHRcInZlYzMgaGVpZ2h0ID0gYXJlYUxpZ2h0SGVpZ2h0WyBpIF07XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIHVwID0gbm9ybWFsaXplKCAoIHZpZXdNYXRyaXggKiB2ZWM0KCBoZWlnaHQsIDAuMCApICkueHl6ICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIHJpZ2h0ID0gbm9ybWFsaXplKCAoIHZpZXdNYXRyaXggKiB2ZWM0KCB3aWR0aCwgMC4wICkgKS54eXogKTtcIixcclxuXHRcdFx0XHRcInZlYzMgcG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHJpZ2h0LCB1cCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgd2lkdGhTY2FsYXIgPSBsZW5ndGgoIHdpZHRoICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBoZWlnaHRTY2FsYXIgPSBsZW5ndGgoIGhlaWdodCApO1wiLFxyXG5cclxuXHRcdFx0XHQvL3Byb2plY3Qgb250byBwbGFuZSBhbmQgY2FsY3VsYXRlIGRpcmVjdGlvbiBmcm9tIGNlbnRlciB0byB0aGUgcHJvamVjdGlvbi5cclxuXHRcdFx0XHRcInZlYzMgcHJvamVjdGlvbiA9IHByb2plY3RPblBsYW5lKCAtdlZpZXdQb3NpdGlvbi54eXosIGxQb3NpdGlvbiwgcG5vcm1hbCApO1wiLCAgLy8gcHJvamVjdGlvbiBpbiBwbGFuZVxyXG5cdFx0XHRcdFwidmVjMyBkaXIgPSBwcm9qZWN0aW9uIC0gbFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHQvL2NhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIGFyZWE6XHJcblx0XHRcdFx0XCJ2ZWMyIGRpYWdvbmFsID0gdmVjMiggZG90KCBkaXIsIHJpZ2h0ICksIGRvdCggZGlyLCB1cCApICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMyIG5lYXJlc3QyRCA9IHZlYzIoIGNsYW1wKCBkaWFnb25hbC54LCAtd2lkdGhTY2FsYXIsIHdpZHRoU2NhbGFyICksIGNsYW1wKCBkaWFnb25hbC55LCAtaGVpZ2h0U2NhbGFyLCBoZWlnaHRTY2FsYXIgKSApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBuZWFyZXN0UG9pbnRJbnNpZGUgPSBsUG9zaXRpb24gKyAoIHJpZ2h0ICpuZWFyZXN0MkQueCArIHVwICogbmVhcmVzdDJELnkgKTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSAoIG5lYXJlc3RQb2ludEluc2lkZSArIHZWaWV3UG9zaXRpb24ueHl6ICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBkaXN0YW5jZUF0dGVudWF0aW9uID0gY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGxlbmd0aCggbFZlY3RvciApLCBhcmVhTGlnaHREaXN0YW5jZVsgaSBdLCBhcmVhTGlnaHREZWNheUV4cG9uZW50W2ldICk7XCIsXHJcblx0XHRcdFx0XCJsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XCIsXHJcblx0XHRcdFxyXG5cdFx0XHRcdFwiZmxvYXQgbkRvdExEaWZmdXNlID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsVmVjdG9yICkgKTtcIixcclxuXHRcdCAgIFxyXG5cdFx0XHRcdFwidmVjMyB2aWV3UmVmbGVjdGlvbiA9IHJlZmxlY3QoIHZpZXdQb3NpdGlvbi54eXosIG5vcm1hbCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyByZWZsZWN0aW9uTGlnaHRQbGFuZUludGVyc2VjdGlvbiA9IGxpbmVQbGFuZUludGVyc2VjdCggLXZWaWV3UG9zaXRpb24ueHl6LCB2aWV3UmVmbGVjdGlvbiwgbFBvc2l0aW9uLCBwbm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgc3BlY0FuZ2xlID0gZG90KCB2aWV3UmVmbGVjdGlvbiwgcG5vcm1hbCApO1wiLFxyXG5cclxuXHRcdFx0XHRcImlmICggc3BlY0FuZ2xlIDwgMC4wICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBkaXJTcGVjID0gcmVmbGVjdGlvbkxpZ2h0UGxhbmVJbnRlcnNlY3Rpb24gLSBsUG9zaXRpb247XCIsXHJcblx0XHRcdFx0XHRcInZlYzIgZGlyU3BlYzJEID0gdmVjMiggZG90KCBkaXJTcGVjLCByaWdodCApLCBkb3QoIGRpclNwZWMsIHVwICkgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMiBuZWFyZXN0U3BlYzJEID0gdmVjMiggY2xhbXAoIGRpclNwZWMyRC54LCAtd2lkdGhTY2FsYXIsIHdpZHRoU2NhbGFyICksIGNsYW1wKCBkaXJTcGVjMkQueSwgLWhlaWdodFNjYWxhciwgaGVpZ2h0U2NhbGFyICkgKTtcIixcclxuXHRcdFx0XHRcdFwibFZlY3RvciA9IG5vcm1hbGl6ZSggbFBvc2l0aW9uICsgKCByaWdodCAqbmVhcmVzdFNwZWMyRC54ICsgdXAgKiBuZWFyZXN0U3BlYzJELnkgKSArIHZWaWV3UG9zaXRpb24ueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwifSBlbHNlIHsgXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJsVmVjdG9yID0gdmVjMyggMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0Ly8gZGlmZnVzZVxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBuRG90TERpZmZ1c2U7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgYXJlYURpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcImFyZWFEaWZmdXNlICArPSBhcmVhTGlnaHRDb2xvclsgaSBdICogYXJlYURpZmZ1c2VXZWlnaHQgKiBkaXN0YW5jZUF0dGVudWF0aW9uICogd2lkdGhTY2FsYXIgKiBoZWlnaHRTY2FsYXIgKiAwLjAxO1wiLCAgLy8gdGhlIDAuMDEgaXMgdGhlIGFyZWEgbGlnaHQgaW50ZW5zaXR5IHNjYWxpbmcuXHJcblxyXG5cdFx0XHRcdC8vIHNwZWN1bGFyXHJcblxyXG5cdFx0XHRcdFwidmVjMyBhcmVhSGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgYXJlYURvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBhcmVhSGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGFyZWFTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyU3RyZW5ndGggKiBtYXgoIHBvdyggYXJlYURvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3RvciwgYXJlYUhhbGZWZWN0b3IgKSwgMC4wICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFwiYXJlYVNwZWN1bGFyICs9IHNjaGxpY2sgKiBhcmVhTGlnaHRDb2xvclsgaSBdICogYXJlYVNwZWN1bGFyV2VpZ2h0ICogYXJlYURpZmZ1c2VXZWlnaHQgKiBkaXN0YW5jZUF0dGVudWF0aW9uICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogMC4wMTtcIiwgIC8vIHRoZSAwLjAxIGlzIHRoZSBhcmVhIGxpZ2h0IGludGVuc2l0eSBzY2FsaW5nLlxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcInZlYzMgdG90YWxEaWZmdXNlID0gdmVjMyggMC4wICk7XCIsXHJcblx0XHRcInZlYzMgdG90YWxTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gZGlyRGlmZnVzZTtcIixcclxuXHRcdFx0XCJ0b3RhbFNwZWN1bGFyICs9IGRpclNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gaGVtaURpZmZ1c2U7XCIsXHJcblx0XHRcdFwidG90YWxTcGVjdWxhciArPSBoZW1pU3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gcG9pbnREaWZmdXNlO1wiLFxyXG5cdFx0XHRcInRvdGFsU3BlY3VsYXIgKz0gcG9pbnRTcGVjdWxhcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidG90YWxEaWZmdXNlICs9IHNwb3REaWZmdXNlO1wiLFxyXG5cdFx0XHRcInRvdGFsU3BlY3VsYXIgKz0gc3BvdFNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0FSRUFfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gYXJlYURpZmZ1c2U7XCIsXHJcblx0XHRcdFwidG90YWxTcGVjdWxhciArPSBhcmVhU3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHRcdFwidmVjMyBhbWJpZW50TG9jYWwgPSBhbWJpZW50O1wiLFxyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9MSUdIVE1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIGFtYmllbnRDb2xvciA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXo7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBHQU1NQV9JTlBVVFwiLFxyXG5cclxuXHRcdFx0XHRcImFtYmllbnRDb2xvciAqPSBhbWJpZW50Q29sb3I7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJhbWJpZW50TG9jYWwgKj0gYW1iaWVudENvbG9yO1wiLFxyXG5cdFxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBkaWZmdXNlQ29sb3IgKiAoIHRvdGFsRGlmZnVzZSArIGFtYmllbnRMaWdodENvbG9yICsgYW1iaWVudExvY2FsICkgKyB0b3RhbFNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFwidmVjMyBlbWlzc2l2ZUxvY2FsID0gZW1pc3NpdmU7XCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXCIsXHJcblxyXG5cdFx0XHRcInZlYzMgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZVdjIgKS54eXo7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBHQU1NQV9JTlBVVFwiLFxyXG5cclxuXHRcdFx0XHRcImVtaXNzaXZlQ29sb3IgKj0gZW1pc3NpdmVDb2xvcjtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcImVtaXNzaXZlTG9jYWwgKj0gZW1pc3NpdmVDb2xvcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiArPSBlbWlzc2l2ZUxvY2FsLnh5ejtcIixcclxuXHRcdFxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gVkVSVEVYIENPTE9SU1xyXG5cclxuXHRjb2xvcl9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0NPTE9SXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Q29sb3I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cclxuXHRjb2xvcl9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9DT0xPUlwiLFxyXG5cclxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB2ZWM0KCB2Q29sb3IsIDEuMCApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRjb2xvcl9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9DT0xPUlwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkNvbG9yO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHJcblx0Y29sb3JfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0NPTE9SXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBHQU1NQV9JTlBVVFwiLFxyXG5cclxuXHRcdFx0XHRcInZDb2xvciA9IGNvbG9yICogY29sb3I7XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFwidkNvbG9yID0gY29sb3I7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBTS0lOTklOR1xyXG5cclxuXHRza2lubmluZ19wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgQk9ORV9URVhUVVJFXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGludCBib25lVGV4dHVyZVdpZHRoO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSBpbnQgYm9uZVRleHR1cmVIZWlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFwibWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgaiA9IGkgKiA0LjA7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IHggPSBtb2QoIGosIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZUhlaWdodCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwieSA9IGR5ICogKCB5ICsgMC41ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwicmV0dXJuIGJvbmU7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gbWF0NCBib25lR2xvYmFsTWF0cmljZXNbIE1BWF9CT05FUyBdO1wiLFxyXG5cclxuXHRcdFx0XHRcIm1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcIm1hdDQgYm9uZSA9IGJvbmVHbG9iYWxNYXRyaWNlc1sgaW50KGkpIF07XCIsXHJcblx0XHRcdFx0XHRcInJldHVybiBib25lO1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNraW5iYXNlX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxyXG5cclxuXHRcdFx0XCJtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcIixcclxuXHRcdFx0XCJtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcIixcclxuXHRcdFx0XCJtYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTtcIixcclxuXHRcdFx0XCJtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0c2tpbm5pbmdfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXHJcblxyXG5cdFx0XHRcInZlYzQgc2tpblZlcnRleCA9IHZlYzQoIG1vcnBoZWQsIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHNraW5WZXJ0ZXggPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHNraW5uZWQgID0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1wiLFxyXG5cdFx0XHRcInNraW5uZWQgICAgICArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XCIsXHJcblx0XHRcdFwic2tpbm5lZCAgICAgICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcIixcclxuXHRcdFx0XCJza2lubmVkICAgICAgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBNT1JQSElOR1xyXG5cclxuXHRtb3JwaHRhcmdldF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRtb3JwaHRhcmdldF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXHJcblxyXG5cdFx0XHRcInZlYzMgbW9ycGhlZCA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XCIsXHJcblx0XHRcdFwibW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcIixcclxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XCIsXHJcblxyXG5cdFx0XHRcIiNpZm5kZWYgVVNFX01PUlBITk9STUFMU1wiLFxyXG5cclxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XCIsXHJcblx0XHRcdFwibW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcIixcclxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwibW9ycGhlZCArPSBwb3NpdGlvbjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0ZGVmYXVsdF92ZXJ0ZXggOiBbXHJcblxyXG5cdFx0XCJ2ZWM0IG12UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcIm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBza2lubmVkO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKVwiLFxyXG5cclxuXHRcdFx0XCJtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggbW9ycGhlZCwgMS4wICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgISBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTIClcIixcclxuXHJcblx0XHRcdFwibXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdG1vcnBobm9ybWFsX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcIixcclxuXHJcblx0XHRcdFwidmVjMyBtb3JwaGVkTm9ybWFsID0gdmVjMyggMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcIm1vcnBoZWROb3JtYWwgKz0gICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcIixcclxuXHRcdFx0XCJtb3JwaGVkTm9ybWFsICs9ICAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XCIsXHJcblx0XHRcdFwibW9ycGhlZE5vcm1hbCArPSAgKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWROb3JtYWwgKz0gICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcIixcclxuXHJcblx0XHRcdFwibW9ycGhlZE5vcm1hbCArPSBub3JtYWw7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNraW5ub3JtYWxfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcIm1hdDQgc2tpbk1hdHJpeCA9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1wiLFxyXG5cdFx0XHRcInNraW5NYXRyaXggXHQrPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcIixcclxuXHJcblx0XHRcdFwidmVjNCBza2lubmVkTm9ybWFsID0gc2tpbk1hdHJpeCAqIHZlYzQoIG1vcnBoZWROb3JtYWwsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHNraW5uZWROb3JtYWwgPSBza2luTWF0cml4ICogdmVjNCggbm9ybWFsLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGRlZmF1bHRub3JtYWxfdmVydGV4OiBbXHJcblxyXG5cdFx0XCJ2ZWMzIG9iamVjdE5vcm1hbDtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFwib2JqZWN0Tm9ybWFsID0gc2tpbm5lZE5vcm1hbC54eXo7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgZGVmaW5lZCggVVNFX01PUlBITk9STUFMUyApXCIsXHJcblxyXG5cdFx0XHRcIm9iamVjdE5vcm1hbCA9IG1vcnBoZWROb3JtYWw7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgISBkZWZpbmVkKCBVU0VfTU9SUEhOT1JNQUxTIClcIixcclxuXHJcblx0XHRcdFwib2JqZWN0Tm9ybWFsID0gbm9ybWFsO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgRkxJUF9TSURFRFwiLFxyXG5cclxuXHRcdFx0XCJvYmplY3ROb3JtYWwgPSAtb2JqZWN0Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJ2ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1wiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gU0hBRE9XIE1BUFxyXG5cclxuXHQvLyBiYXNlZCBvbiBTcGlkZXJHTCBzaGFkb3cgbWFwIGFuZCBGYWJpZW4gU2FuZ2xhcmQncyBHTFNMIHNoYWRvdyBtYXBwaW5nIGV4YW1wbGVzXHJcblx0Ly8gIGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxyXG5cdC8vIFx0aHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nXHJcblxyXG5cdHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NIQURPV01BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dNYXBbIE1BWF9TSEFET1dTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMyIHNoYWRvd01hcFNpemVbIE1BWF9TSEFET1dTIF07XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2hhZG93RGFya25lc3NbIE1BWF9TSEFET1dTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGFkb3dCaWFzWyBNQVhfU0hBRE9XUyBdO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1wiLFxyXG5cclxuXHRcdFx0XCJmbG9hdCB1bnBhY2tEZXB0aCggY29uc3QgaW4gdmVjNCByZ2JhX2RlcHRoICkge1wiLFxyXG5cclxuXHRcdFx0XHRcImNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGRlcHRoID0gZG90KCByZ2JhX2RlcHRoLCBiaXRfc2hpZnQgKTtcIixcclxuXHRcdFx0XHRcInJldHVybiBkZXB0aDtcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRzaGFkb3dtYXBfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBTSEFET1dNQVBfREVCVUdcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGZydXN0dW1Db2xvcnNbM107XCIsXHJcblx0XHRcdFx0XCJmcnVzdHVtQ29sb3JzWzBdID0gdmVjMyggMS4wLCAwLjUsIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwiZnJ1c3R1bUNvbG9yc1sxXSA9IHZlYzMoIDAuMCwgMS4wLCAwLjggKTtcIixcclxuXHRcdFx0XHRcImZydXN0dW1Db2xvcnNbMl0gPSB2ZWMzKCAwLjAsIDAuNSwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcIixcclxuXHJcblx0XHRcdFx0XCJpbnQgaW5GcnVzdHVtQ291bnQgPSAwO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiZmxvYXQgZkRlcHRoO1wiLFxyXG5cdFx0XHRcInZlYzMgc2hhZG93Q29sb3IgPSB2ZWMzKCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHNoYWRvd0Nvb3JkID0gdlNoYWRvd0Nvb3JkWyBpIF0ueHl6IC8gdlNoYWRvd0Nvb3JkWyBpIF0udztcIixcclxuXHJcblx0XHRcdFx0Ly8gXCJpZiAoIHNvbWV0aGluZyAmJiBzb21ldGhpbmcgKVwiIFx0XHQgYnJlYWtzIEFUSSBPcGVuR0wgc2hhZGVyIGNvbXBpbGVyXHJcblx0XHRcdFx0Ly8gXCJpZiAoIGFsbCggc29tZXRoaW5nLCBzb21ldGhpbmcgKSApXCIgIHVzaW5nIHRoaXMgaW5zdGVhZFxyXG5cclxuXHRcdFx0XHRcImJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcIixcclxuXHRcdFx0XHRcImJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gZG9uJ3Qgc2hhZG93IHBpeGVscyBvdXRzaWRlIG9mIGxpZ2h0IGZydXN0dW1cclxuXHRcdFx0XHQvLyB1c2UganVzdCBmaXJzdCBmcnVzdHVtIChmb3IgY2FzY2FkZXMpXHJcblx0XHRcdFx0Ly8gZG9uJ3Qgc2hhZG93IHBpeGVscyBiZWhpbmQgZmFyIHBsYW5lIG9mIGxpZ2h0IGZydXN0dW1cclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcIixcclxuXHJcblx0XHRcdFx0XHRcImluRnJ1c3R1bUNvdW50ICs9IGludCggaW5GcnVzdHVtICk7XCIsXHJcblx0XHRcdFx0XHRcImJ2ZWMzIGZydXN0dW1UZXN0VmVjID0gYnZlYzMoIGluRnJ1c3R1bSwgaW5GcnVzdHVtQ291bnQgPT0gMSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiYnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcImJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCBmcnVzdHVtVGVzdCApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xyXG5cdFx0XHRcdFx0XHQvLyAoOSBwaXhlbCBrZXJuZWwpXHJcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgc2hhZG93ID0gMC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdFx0Ly8gbmVzdGVkIGxvb3BzIGJyZWFrcyBzaGFkZXIgY29tcGlsZXIgLyB2YWxpZGF0b3Igb24gc29tZSBBVEkgY2FyZHMgd2hlbiB1c2luZyBPcGVuR0xcclxuXHRcdFx0XHRcdFx0Ly8gbXVzdCBlbnJvbGwgbG9vcCBtYW51YWxseVxyXG5cclxuXHRcdFx0XHRcdFx0XCJmb3IgKCBmbG9hdCB5ID0gLTEuMjU7IHkgPD0gMS4yNTsgeSArPSAxLjI1IClcIixcclxuXHRcdFx0XHRcdFx0XHRcImZvciAoIGZsb2F0IHggPSAtMS4yNTsgeCA8PSAxLjI1OyB4ICs9IDEuMjUgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZG9lc24ndCBzZWVtIHRvIHByb2R1Y2UgYW55IG5vdGljZWFibGUgdmlzdWFsIGRpZmZlcmVuY2UgY29tcGFyZWQgdG8gc2ltcGxlIFwidGV4dHVyZTJEXCIgbG9va3VwXHJcblx0XHRcdFx0XHRcdFx0XHQvL1widmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkRQcm9qKCBzaGFkb3dNYXBbIGkgXSwgdmVjNCggdlNoYWRvd0Nvb3JkWyBpIF0udyAqICggdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKSwgMC4wNSwgdlNoYWRvd0Nvb3JkWyBpIF0udyApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcInNoYWRvdyArPSAxLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XHRcdFwic2hhZG93IC89IDkuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdCovXHJcblxyXG5cdFx0XHRcdFx0XHRcImNvbnN0IGZsb2F0IHNoYWRvd0RlbHRhID0gMS4wIC8gOS4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHgwID0gLTEuMjUgKiB4UGl4ZWxPZmZzZXQ7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHkwID0gLTEuMjUgKiB5UGl4ZWxPZmZzZXQ7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHgxID0gMS4yNSAqIHhQaXhlbE9mZnNldDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkeTEgPSAxLjI1ICogeVBpeGVsT2Zmc2V0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKiBzaGFkb3cgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcclxuXHRcdFx0XHRcdFx0Ly8gKDkgcGl4ZWwga2VybmVsKVxyXG5cdFx0XHRcdFx0XHQvLyBodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdQQ0YvXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNoYWRvdyA9IDAuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgeVBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLnk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGR4MCA9IC0xLjAgKiB4UGl4ZWxPZmZzZXQ7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHkwID0gLTEuMCAqIHlQaXhlbE9mZnNldDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkeDEgPSAxLjAgKiB4UGl4ZWxPZmZzZXQ7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHkxID0gMS4wICogeVBpeGVsT2Zmc2V0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJtYXQzIHNoYWRvd0tlcm5lbDtcIixcclxuXHRcdFx0XHRcdFx0XCJtYXQzIGRlcHRoS2VybmVsO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFswXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzBdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiZGVwdGhLZXJuZWxbMF1bMl0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFsxXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzFdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFsxXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzJdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiZGVwdGhLZXJuZWxbMl1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFsyXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNoYWRvd1ogPSB2ZWMzKCBzaGFkb3dDb29yZC56ICk7XCIsXHJcblx0XHRcdFx0XHRcdFwic2hhZG93S2VybmVsWzBdID0gdmVjMyhsZXNzVGhhbihkZXB0aEtlcm5lbFswXSwgc2hhZG93WiApKTtcIixcclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dLZXJuZWxbMF0gKj0gdmVjMygwLjI1KTtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dLZXJuZWxbMV0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzFdLCBzaGFkb3daICkpO1wiLFxyXG5cdFx0XHRcdFx0XHRcInNoYWRvd0tlcm5lbFsxXSAqPSB2ZWMzKDAuMjUpO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dLZXJuZWxbMl0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzJdLCBzaGFkb3daICkpO1wiLFxyXG5cdFx0XHRcdFx0XHRcInNoYWRvd0tlcm5lbFsyXSAqPSB2ZWMzKDAuMjUpO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMyIGZyYWN0aW9uYWxDb29yZCA9IDEuMCAtIGZyYWN0KCBzaGFkb3dDb29yZC54eSAqIHNoYWRvd01hcFNpemVbaV0ueHkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwic2hhZG93S2VybmVsWzBdID0gbWl4KCBzaGFkb3dLZXJuZWxbMV0sIHNoYWRvd0tlcm5lbFswXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcIixcclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dLZXJuZWxbMV0gPSBtaXgoIHNoYWRvd0tlcm5lbFsyXSwgc2hhZG93S2VybmVsWzFdLCBmcmFjdGlvbmFsQ29vcmQueCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IHNoYWRvd1ZhbHVlcztcIixcclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWzBdWzFdLCBzaGFkb3dLZXJuZWxbMF1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XCIsXHJcblx0XHRcdFx0XHRcdFwic2hhZG93VmFsdWVzLnkgPSBtaXgoIHNoYWRvd0tlcm5lbFswXVsyXSwgc2hhZG93S2VybmVsWzBdWzFdLCBmcmFjdGlvbmFsQ29vcmQueSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcInNoYWRvd1ZhbHVlcy56ID0gbWl4KCBzaGFkb3dLZXJuZWxbMV1bMV0sIHNoYWRvd0tlcm5lbFsxXVswXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWzFdWzJdLCBzaGFkb3dLZXJuZWxbMV1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInNoYWRvdyA9IGRvdCggc2hhZG93VmFsdWVzLCB2ZWM0KCAxLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICogc2hhZG93ICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHNwb3Qgd2l0aCBtdWx0aXBsZSBzaGFkb3dzIGlzIGRhcmtlclxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHNwb3Qgd2l0aCBtdWx0aXBsZSBzaGFkb3dzIGhhcyB0aGUgc2FtZSBjb2xvciBhcyBzaW5nbGUgc2hhZG93IHNwb3RcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly9cInNoYWRvd0NvbG9yID0gbWluKCBzaGFkb3dDb2xvciwgdmVjMyggc2hhZG93RGFya25lc3NbIGkgXSApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBTSEFET1dNQVBfREVCVUdcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIGluRnJ1c3R1bSAmJiBpbkZydXN0dW1Db3VudCA9PSAxICkgZ2xfRnJhZ0NvbG9yLnh5eiAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIGluRnJ1c3R1bSApIGdsX0ZyYWdDb2xvci54eXogKj0gZnJ1c3R1bUNvbG9yc1sgaSBdO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEdBTU1BX09VVFBVVFwiLFxyXG5cclxuXHRcdFx0XHRcInNoYWRvd0NvbG9yICo9IHNoYWRvd0NvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiBzaGFkb3dDb2xvcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0c2hhZG93bWFwX3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NIQURPV01BUFwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gbWF0NCBzaGFkb3dNYXRyaXhbIE1BWF9TSEFET1dTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNoYWRvd21hcF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXCIsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidlNoYWRvd0Nvb3JkWyBpIF0gPSBzaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gQUxQSEFURVNUXHJcblxyXG5cdGFscGhhdGVzdF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIEFMUEhBVEVTVFwiLFxyXG5cclxuXHRcdFx0XCJpZiAoIGdsX0ZyYWdDb2xvci5hIDwgQUxQSEFURVNUICkgZGlzY2FyZDtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gTElORUFSIFNQQUNFXHJcblxyXG5cdGxpbmVhcl90b19nYW1tYV9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIEdBTU1BX09VVFBVVFwiLFxyXG5cclxuXHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gc3FydCggZ2xfRnJhZ0NvbG9yLnh5eiApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cclxufTtcclxuLyoqXHJcbiAqIFVuaWZvcm0gVXRpbGl0aWVzXHJcbiAqL1xyXG5cclxuVEhSRUUuVW5pZm9ybXNVdGlscyA9IHtcclxuXHJcblx0bWVyZ2U6IGZ1bmN0aW9uICggdW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0dmFyIHUsIHAsIHRtcCwgbWVyZ2VkID0ge307XHJcblxyXG5cdFx0Zm9yICggdSA9IDA7IHUgPCB1bmlmb3Jtcy5sZW5ndGg7IHUgKysgKSB7XHJcblxyXG5cdFx0XHR0bXAgPSB0aGlzLmNsb25lKCB1bmlmb3Jtc1sgdSBdICk7XHJcblxyXG5cdFx0XHRmb3IgKCBwIGluIHRtcCApIHtcclxuXHJcblx0XHRcdFx0bWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1lcmdlZDtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICggdW5pZm9ybXNfc3JjICkge1xyXG5cclxuXHRcdHZhciB1LCBwLCBwYXJhbWV0ZXIsIHBhcmFtZXRlcl9zcmMsIHVuaWZvcm1zX2RzdCA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHUgaW4gdW5pZm9ybXNfc3JjICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcclxuXHJcblx0XHRcdGZvciAoIHAgaW4gdW5pZm9ybXNfc3JjWyB1IF0gKSB7XHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcl9zcmMgPSB1bmlmb3Jtc19zcmNbIHUgXVsgcCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyIHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0IHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuaWZvcm1zX2RzdDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIFVuaWZvcm1zIGxpYnJhcnkgZm9yIHNoYXJlZCB3ZWJnbCBzaGFkZXJzXHJcbiAqL1xyXG5cclxuVEhSRUUuVW5pZm9ybXNMaWIgPSB7XHJcblxyXG5cdGNvbW1vbjoge1xyXG5cclxuXHRcdFwiZGlmZnVzZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxyXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblxyXG5cdFx0XCJtYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXHJcblx0XHRcImdhaW5CcmlnaHRuZXNzXCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAxLCAwLCAxICkgfSxcclxuXHJcblx0XHRcImxpZ2h0TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJlbWlzc2l2ZU1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcclxuXHRcdFwiZW52TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJmbGlwRW52TWFwXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLTEgfSxcclxuXHRcdFwidXNlUmVmcmFjdFwiIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcclxuXHRcdFwicmVmbGVjdGl2aXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcInJlZnJhY3Rpb25SYXRpb1wiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuOTggfSxcclxuXHRcdFwiY29tYmluZVwiIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcclxuXHJcblx0XHRcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRzcGVjdWxhcm1hcDoge1xyXG5cclxuXHRcdFwic3BlY3VsYXJNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcInNwZWN1bGFyT2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcclxuXHRcdFwic3BlY3VsYXJHYWluQnJpZ2h0bmVzc1wiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMSwgMCwgMSApIH0sXHJcblxyXG5cdH0sXHJcblxyXG5cdGJ1bXBtYXA6IHtcclxuXHJcblx0XHRcImJ1bXBNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImJ1bXBTY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSwgLy8gdXNlZCBpbnN0ZWFkIG9mICdidW1wR2FpbkJyaWdodG5lc3MnXHJcblx0XHRcImJ1bXBPZmZzZXRSZXBlYXRcIiA6IHsgdHlwZTogXCJ2NFwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIDEsIDEgKSB9XHRcdFxyXG5cclxuXHR9LFxyXG5cclxuXHRvcGFjaXR5bWFwOiB7XHJcblxyXG5cdFx0XCJvcGFjaXR5TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJvcGFjaXR5T2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcclxuXHRcdFwib3BhY2l0eUdhaW5CcmlnaHRuZXNzXCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAxLCAwLCAxICkgfSxcclxuXHJcblx0fSxcclxuXHRcclxuXHRub3JtYWxtYXA6IHtcclxuXHJcblx0XHRcIm5vcm1hbE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwibm9ybWFsU2NhbGVcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9LCAvLyB1c2VkIGluc3RlYWQgb2YgJ25vcm1hbEdhaW5CcmlnaHRuZXNzJ1xyXG5cdFx0XCJub3JtYWxPZmZzZXRSZXBlYXRcIiA6IHsgdHlwZTogXCJ2NFwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIDEsIDEgKSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGZvZyA6IHtcclxuXHJcblx0XHRcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXHJcblx0XHRcImZvZ05lYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblx0XHRcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcclxuXHRcdFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRsaWdodHM6IHtcclxuXHJcblx0XHRcImFtYmllbnRMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG5cdFx0XCJkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcImRpcmVjdGlvbmFsTGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwiaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcImhlbWlzcGhlcmVMaWdodFNreUNvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcImhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG5cdFx0XCJwb2ludExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwicG9pbnRMaWdodFBvc2l0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInBvaW50TGlnaHREaXN0YW5jZVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwicG9pbnRMaWdodERlY2F5RXhwb25lbnRcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG5cdFx0XCJzcG90TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJzcG90TGlnaHRQb3NpdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJzcG90TGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic3BvdExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNwb3RMaWdodERlY2F5RXhwb25lbnRcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNwb3RMaWdodEFuZ2xlQ29zXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJzcG90TGlnaHRFeHBvbmVudFwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcImFyZWFMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcImFyZWFMaWdodFBvc2l0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcImFyZWFMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJhcmVhTGlnaHREZWNheUV4cG9uZW50XCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJhcmVhTGlnaHRXaWR0aFwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJhcmVhTGlnaHRIZWlnaHRcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfVxyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJ0aWNsZToge1xyXG5cclxuXHRcdFwicHNDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxyXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcInNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwic2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cclxuXHRcdFwiZm9nRGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAwMjUgfSxcclxuXHRcdFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuXHRcdFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxyXG5cdFx0XCJmb2dDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdHNoYWRvd21hcDoge1xyXG5cclxuXHRcdFwic2hhZG93TWFwXCI6IHsgdHlwZTogXCJ0dlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic2hhZG93TWFwU2l6ZVwiOiB7IHR5cGU6IFwidjJ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwic2hhZG93Qmlhc1wiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic2hhZG93RGFya25lc3NcIjogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcInNoYWRvd01hdHJpeFwiIDogeyB0eXBlOiBcIm00dlwiLCB2YWx1ZTogW10gfVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogV2ViZ2wgU2hhZGVyIExpYnJhcnkgZm9yIHRocmVlLmpzXHJcbiAqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vIFxyXG4gKi9cclxuXHJcblxyXG5USFJFRS5TaGFkZXJMaWIgPSB7XHJcblxyXG5cclxuXHQncGh5c2ljYWwnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImJ1bXBtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJub3JtYWxtYXBcIiBdLFxyXG5cdFx0XHQvL1RIUkVFLlVuaWZvcm1zTGliWyBcInJvdWdobmVzc21hcFwiIF0sICBUT0RPOiBJbXBsZW1lbnQgbWUhXHJcblx0XHRcdC8vVEhSRUUuVW5pZm9ybXNMaWJbIFwibWV0YWxsaWNtYXBcIiBdLCAgVE9ETzogSW1wbGVtZW50IG1lIVxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJvcGFjaXR5bWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic3BlY3VsYXJtYXBcIiBdLFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdFwiYW1iaWVudFwiICA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfSxcclxuXHRcdFx0XHRcImVtaXNzaXZlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApIH0sXHJcblx0XHRcdFx0XCJzcGVjdWxhclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhGRkZGRkYgKSB9LFxyXG5cdFx0XHRcdFwiZmFsbG9mZkNvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweEZGRkZGRiApIH0sXHJcblx0XHRcdFx0XCJmYWxsb2ZmTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcdFwiZmFsbG9mZkJsZW5kUGFyYW1zXCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAxLCAwLCAwLCAxICkgfSxcclxuXHJcblx0XHRcdFx0XCJjbGVhckNvYXRcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMCB9LFxyXG5cdFx0XHRcdFwiY2xlYXJDb2F0Um91Z2huZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjI1IH0sXHJcblxyXG5cdFx0XHRcdFwicm91Z2huZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjUgfSxcclxuXHRcdFx0XHRcInJvdWdobmVzc01hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0XHRcInJvdWdobmVzc09mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXHJcblx0XHRcdFx0XCJyb3VnaG5lc3NHYWluQnJpZ2h0bmVzc1wiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMSwgMCwgMSApIH0sXHJcblxyXG5cdFx0XHRcdFwibWV0YWxsaWNcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuNSB9LFxyXG5cdFx0XHRcdFwibWV0YWxsaWNNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFx0XCJtZXRhbGxpY09mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXHJcblx0XHRcdFx0XCJtZXRhbGxpY0dhaW5CcmlnaHRuZXNzXCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAxLCAwLCAxICkgfSxcclxuXHJcblx0XHRcdFx0XCJhbmlzb3Ryb3B5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAgfSxcclxuXHRcdFx0XHRcImFuaXNvdHJvcHlNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFx0XCJhbmlzb3Ryb3B5T2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcclxuXHRcdFx0XHRcImFuaXNvdHJvcHlHYWluQnJpZ2h0bmVzc1wiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMSwgMCwgMSApIH0sXHJcblxyXG5cdFx0XHRcdFwiYW5pc290cm9weVJvdGF0aW9uXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAgfSxcclxuXHRcdFx0XHRcImFuaXNvdHJvcHlSb3RhdGlvbk1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0XHRcImFuaXNvdHJvcHlSb3RhdGlvbk9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXHJcblx0XHRcdFx0XCJhbmlzb3Ryb3B5Um90YXRpb25HYWluQnJpZ2h0bmVzc1wiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMSwgMCwgMSApIH0sXHJcblxyXG5cdFx0XHRcdFwidHJhbnNsdWNlbmN5XCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApIH0sXHJcblx0XHRcdFx0XCJ0cmFuc2x1Y2VuY3lNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFx0XCJ0cmFuc2x1Y2VuY3lOb3JtYWxBbHBoYVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC43NSB9LFxyXG5cdFx0XHRcdFwidHJhbnNsdWNlbmN5Tm9ybWFsUG93ZXJcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIuMCB9LFxyXG5cdFx0XHRcdFwidHJhbnNsdWNlbmN5Vmlld0FscGhhXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjc1IH0sXHJcblx0XHRcdFx0XCJ0cmFuc2x1Y2VuY3lWaWV3UG93ZXJcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIuMCB9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjNCB0YW5nZW50O1wiLFxyXG5cdFx0XHRcclxuXHRcdFx0XCIjZGVmaW5lIFBIT05HXCIsXHJcblx0XHRcdFwiI2RlZmluZSBQSFlTSUNBTFwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZCaW5vcm1hbDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHRcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibm9ybWFsbWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicm91Z2huZXNzbWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJvcGFjaXR5bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW5pc290cm9weW1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFuaXNvdHJvcHlyb3RhdGlvbm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1ldGFsbGljbWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidHJhbnNsdWNlbmN5bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnVtcG1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3BoeXNpY2FsX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJyb3VnaG5lc3NtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJvcGFjaXR5bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbmlzb3Ryb3B5bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW5pc290cm9weXJvdGF0aW9ubWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWV0YWxsaWNtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ0cmFuc2x1Y2VuY3ltYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJidW1wbWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0XCJ2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcInZWaWV3UG9zaXRpb24gPSAtbXZQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3BoeXNpY2FsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCIjZGVmaW5lIFBIWVNJQ0FMXCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGZhbGxvZmZDb2xvcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZmFsbG9mZkJsZW5kUGFyYW1zO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdWdobmVzcztcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1ldGFsbGljO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgY2xlYXJDb2F0O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgY2xlYXJDb2F0Um91Z2huZXNzO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgdHJhbnNsdWNlbmN5O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdHJhbnNsdWNlbmN5Tm9ybWFsQWxwaGE7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB0cmFuc2x1Y2VuY3lOb3JtYWxQb3dlcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHRyYW5zbHVjZW5jeVZpZXdQb3dlcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHRyYW5zbHVjZW5jeVZpZXdBbHBoYTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBhbmlzb3Ryb3B5O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgYW5pc290cm9weVJvdGF0aW9uO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZmFsbG9mZm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwib3BhY2l0eW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidHJhbnNsdWNlbmN5bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJidW1wbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbmlzb3Ryb3B5bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbmlzb3Ryb3B5cm90YXRpb25tYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1ldGFsbGljbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInJlZmxlY3Rpdml0eW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRhdHRlbnVhdGlvbl9mdW5jX2ZyYWdtZW50XCIgXSxcdFx0XHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzICggMC4wICksIG9wYWNpdHkgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgZGlmZnVzZUNvbG9yID0gZGlmZnVzZTtcIixcclxuXHRcdFx0XHRcInZlYzMgdHJhbnNsdWNlbmN5Q29sb3IgPSB0cmFuc2x1Y2VuY3k7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJvcGFjaXR5bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbmlzb3Ryb3B5bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbmlzb3Ryb3B5cm90YXRpb25tYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInJvdWdobmVzc21hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWV0YWxsaWNtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInRyYW5zbHVjZW5jeW1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicmVmbGVjdGl2aXR5bWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiAqPSBnbF9GcmFnQ29sb3IudztcIixcdFx0Ly8gcHJlbXVsdGlwbGVkLCBtdXN0IGJlIHVzZWQgd2l0aCBDdXN0b21CbGVuZGVyLCBPbmVGYWN0b3IsIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IsIEFkZEVxdWF0aW9uLlxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0J2Jhc2ljJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfRU5WTUFQXCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuXHRcdFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHR9LFxyXG5cclxuXHQnbGFtYmVydCc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRcImFtYmllbnRcIiAgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXHJcblx0XHRcdFx0XCJlbWlzc2l2ZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSB9LFxyXG5cdFx0XHRcdFwid3JhcFJHQlwiICA6IHsgdHlwZTogXCJ2M1wiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKSB9XHJcblx0XHRcdH1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgTEFNQkVSVFwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRhdHRlbnVhdGlvbl9mdW5jX2ZyYWdtZW50XCIgXSxcdFx0XHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMgKCAxLjAgKSwgb3BhY2l0eSApO1wiLFxyXG5cdFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdC8vXCJmbG9hdCBpc0Zyb250ID0gZmxvYXQoIGdsX0Zyb250RmFjaW5nICk7XCIsXHJcblx0XHRcdFx0XHQvL1wiZ2xfRnJhZ0NvbG9yLnh5eiAqPSBpc0Zyb250ICogdkxpZ2h0RnJvbnQgKyAoIDEuMCAtIGlzRnJvbnQgKSAqIHZMaWdodEJhY2s7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJpZiAoIGdsX0Zyb250RmFjaW5nIClcIixcclxuXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ICo9IHZMaWdodEZyb250O1wiLFxyXG5cdFx0XHRcdFx0XCJlbHNlXCIsXHJcblx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiAqPSB2TGlnaHRCYWNrO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ICo9IHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH0sXHJcblxyXG5cdCdwaG9uZyc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYnVtcG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcIm5vcm1hbG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNwZWN1bGFybWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwib3BhY2l0eW1hcFwiIF0sXHJcblxyXG5cdFx0XHR7XHJcblx0XHRcdFx0XCJhbWJpZW50XCIgIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9LFxyXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcclxuXHRcdFx0XHRcInNwZWN1bGFyXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXHJcblx0XHRcdFx0XCJzaGluaW5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDMwIH0sXHJcblx0XHRcdFx0XCJ3cmFwUkdCXCIgIDogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwiI2RlZmluZSBQSE9OR1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm9wYWNpdHltYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibm9ybWFsbWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnVtcG1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm9wYWNpdHltYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFwidk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0XCJ2Vmlld1Bvc2l0aW9uID0gLW12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwiI2RlZmluZSBQSE9OR1wiLFxyXG5cdFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnQ7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm9wYWNpdHltYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0YXR0ZW51YXRpb25fZnVuY19mcmFnbWVudFwiIF0sXHRcdFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyAoIDEuMCApLCBvcGFjaXR5ICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIGRpZmZ1c2VDb2xvciA9IGRpZmZ1c2U7XCIsXHJcblx0XHRcdFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwib3BhY2l0eW1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0J3BhcnRpY2xlX2Jhc2ljJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiAgVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwicGFydGljbGVcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNpemU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlwiLFxyXG5cdFx0XHRcdFx0XCJnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIGxlbmd0aCggbXZQb3NpdGlvbi54eXogKSApO1wiLFxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHRcdFx0XHRcdFwiZ2xfUG9pbnRTaXplID0gc2l6ZTtcIixcclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcHNDb2xvcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHBzQ29sb3IsIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnRpY2xlX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHR9LFxyXG5cclxuXHQnZGFzaGVkJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdFwic2NhbGVcIjogICAgIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblx0XHRcdFx0XCJkYXNoU2l6ZVwiOiAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuXHRcdFx0XHRcInRvdGFsU2l6ZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMiB9XHJcblx0XHRcdH1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXHJcblx0XHRcdFwiYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFwidkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcImRpc2NhcmQ7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHR9LFxyXG5cclxuXHQnZGVwdGgnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFwibU5lYXJcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG5cdFx0XHRcIm1GYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwLjAgfSxcclxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBtTmVhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1GYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgY29sb3IgPSAxLjAgLSBzbW9vdGhzdGVwKCBtTmVhciwgbUZhciwgZGVwdGggKTtcIixcclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGNvbG9yICksIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH0sXHJcblxyXG5cdCdub3JtYWwnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjUgKiBub3JtYWxpemUoIHZOb3JtYWwgKSArIDAuNSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdC8vXHROb3JtYWwgbWFwIHNoYWRlclxyXG5cdC8vXHRcdC0gQmxpbm4tUGhvbmdcclxuXHQvL1x0XHQtIG5vcm1hbCArIGRpZmZ1c2UgKyBzcGVjdWxhciArIEFPICsgZGlzcGxhY2VtZW50ICsgcmVmbGVjdGlvbiArIHNoYWRvdyBtYXBzXHJcblx0Ly9cdFx0LSBwb2ludCBhbmQgZGlyZWN0aW9uYWwgbGlnaHRzICh1c2Ugd2l0aCBcImxpZ2h0czogdHJ1ZVwiIG1hdGVyaWFsIG9wdGlvbilcclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHQnbm9ybWFsbWFwJyA6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcclxuXHJcblx0XHRcdHtcclxuXHJcblx0XHRcdFwiZW5hYmxlQU9cIlx0XHQgIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcclxuXHRcdFx0XCJlbmFibGVEaWZmdXNlXCJcdCAgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxyXG5cdFx0XHRcImVuYWJsZVNwZWN1bGFyXCIgIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcclxuXHRcdFx0XCJlbmFibGVSZWZsZWN0aW9uXCI6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXHJcblx0XHRcdFwiZW5hYmxlRGlzcGxhY2VtZW50XCI6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXHJcblxyXG5cdFx0XHRcInREaXNwbGFjZW1lbnRcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSwgLy8gbXVzdCBnbyBmaXJzdCBhcyB0aGlzIGlzIHZlcnRleCB0ZXh0dXJlXHJcblx0XHRcdFwidERpZmZ1c2VcIlx0ICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcInRDdWJlXCJcdFx0ICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcInROb3JtYWxcIlx0ICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcInRTcGVjdWxhclwiXHQgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFwidEFPXCJcdFx0ICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cclxuXHRcdFx0XCJ1Tm9ybWFsU2NhbGVcIjogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApIH0sXHJcblxyXG5cdFx0XHRcInVEaXNwbGFjZW1lbnRCaWFzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAgfSxcclxuXHRcdFx0XCJ1RGlzcGxhY2VtZW50U2NhbGVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG5cclxuXHRcdFx0XCJkaWZmdXNlXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfSxcclxuXHRcdFx0XCJzcGVjdWxhclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXHJcblx0XHRcdFwiYW1iaWVudFwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXHJcblx0XHRcdFwic2hpbmluZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAzMCB9LFxyXG5cdFx0XHRcIm9wYWNpdHlcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuXHJcblx0XHRcdFwidXNlUmVmcmFjdFwiOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxyXG5cdFx0XHRcInJlZnJhY3Rpb25SYXRpb1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC45OCB9LFxyXG5cdFx0XHRcInJlZmxlY3Rpdml0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXHJcblxyXG5cdFx0XHRcInVPZmZzZXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKSB9LFxyXG5cdFx0XHRcInVSZXBlYXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9LFxyXG5cclxuXHRcdFx0XCJ3cmFwUkdCXCIgIDogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApIH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnQ7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZURpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZVNwZWN1bGFyO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gYm9vbCBlbmFibGVBTztcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgZW5hYmxlUmVmbGVjdGlvbjtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdE5vcm1hbDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0U3BlY3VsYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdEFPO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdU5vcm1hbFNjYWxlO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgdXNlUmVmcmFjdDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZUYW5nZW50O1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Qmlub3JtYWw7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyB3cmFwUkdCO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCAxLjAgKSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgc3BlY3VsYXJUZXggPSB2ZWMzKCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIG5vcm1hbFRleCA9IHRleHR1cmUyRCggdE5vcm1hbCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1wiLFxyXG5cdFx0XHRcdFwibm9ybWFsVGV4Lnh5ICo9IHVOb3JtYWxTY2FsZTtcIixcclxuXHRcdFx0XHRcIm5vcm1hbFRleCA9IG5vcm1hbGl6ZSggbm9ybWFsVGV4ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYoIGVuYWJsZURpZmZ1c2UgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXHJcblx0XHRcdFx0XHRcdFwidGV4ZWxDb2xvci54eXogKj0gdGV4ZWxDb2xvci54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleGVsQ29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCJpZiggZW5hYmxlQU8gKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCBhb0NvbG9yID0gdGV4dHVyZTJEKCB0QU8sIHZVdiApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImFvQ29sb3IueHl6ICo9IGFvQ29sb3IueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqIGFvQ29sb3IueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiB0ZXh0dXJlMkQoIHRBTywgdlV2ICkueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcImlmKCBlbmFibGVTcGVjdWxhciApXCIsXHJcblx0XHRcdFx0XHRcInNwZWN1bGFyVGV4ID0gdGV4dHVyZTJEKCB0U3BlY3VsYXIsIHZVdiApLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJtYXQzIHRzYiA9IG1hdDMoIG5vcm1hbGl6ZSggdlRhbmdlbnQgKSwgbm9ybWFsaXplKCB2Qmlub3JtYWwgKSwgbm9ybWFsaXplKCB2Tm9ybWFsICkgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgZmluYWxOb3JtYWwgPSB0c2IgKiBub3JtYWxUZXg7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIEZMSVBfU0lERURcIixcclxuXHJcblx0XHRcdFx0XHRcImZpbmFsTm9ybWFsID0gLWZpbmFsTm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBmaW5hbE5vcm1hbCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gcG9pbnQgbGlnaHRzXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHBvaW50U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHBvaW50VmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBwb2ludERpc3RhbmNlID0gMS4wO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxyXG5cdFx0XHRcdFx0XHRcdFwicG9pbnREaXN0YW5jZSA9IDEuMCAtIG1pbiggKCBsZW5ndGgoIHBvaW50VmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwicG9pbnRWZWN0b3IgPSBub3JtYWxpemUoIHBvaW50VmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdCggbm9ybWFsLCBwb2ludFZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHBvaW50RGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdCggbm9ybWFsLCBwb2ludFZlY3RvciApICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHBvaW50RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyAoIHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRWZWN0b3IgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJwb2ludERpZmZ1c2UgKz0gcG9pbnREaXN0YW5jZSAqIHBvaW50TGlnaHRDb2xvclsgaSBdICogZGlmZnVzZSAqIHBvaW50RGlmZnVzZVdlaWdodDtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIHNwZWN1bGFyXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgcG9pbnRIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBwb2ludFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBwb2ludFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJUZXguciAqIG1heCggcG93KCBwb2ludERvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIDIuMCA9PiAyLjAwMDEgaXMgaGFjayB0byB3b3JrIGFyb3VuZCBBTkdMRSBidWdcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCBzaGluaW5lc3MgKyAyLjAwMDEgKSAvIDguMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCAxLjAgLSBkb3QoIHBvaW50VmVjdG9yLCBwb2ludEhhbGZWZWN0b3IgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFwicG9pbnRTcGVjdWxhciArPSBzY2hsaWNrICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogcG9pbnREaXN0YW5jZSAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0Ly8gc3BvdCBsaWdodHNcclxuXHJcblx0XHRcdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBzcG90RGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHNwb3RTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3RWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaXN0YW5jZSA9IDEuMDtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIHNwb3RMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxyXG5cdFx0XHRcdFx0XHRcdFwic3BvdERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggc3BvdFZlY3RvciApIC8gc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwic3BvdFZlY3RvciA9IG5vcm1hbGl6ZSggc3BvdFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBzcG90TGlnaHRQb3NpdGlvblsgaSBdIC0gdldvcmxkUG9zaXRpb24gKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInNwb3RFZmZlY3QgPSBtYXgoIHBvdyggc3BvdEVmZmVjdCwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gZGlmZnVzZVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcInZlYzMgc3BvdERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMgKCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggc3BvdERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdCggbm9ybWFsLCBzcG90VmVjdG9yICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInNwb3REaWZmdXNlICs9IHNwb3REaXN0YW5jZSAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiBkaWZmdXNlICogc3BvdERpZmZ1c2VXZWlnaHQgKiBzcG90RWZmZWN0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBzcGVjdWxhclxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzMgc3BvdEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIHNwb3RWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdEhhbGZWZWN0b3IgKSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBzcG90U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIHNwb3REb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIDIuMCA9PiAyLjAwMDEgaXMgaGFjayB0byB3b3JrIGFyb3VuZCBBTkdMRSBidWdcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggMS4wIC0gZG90KCBzcG90VmVjdG9yLCBzcG90SGFsZlZlY3RvciApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInNwb3RTcGVjdWxhciArPSBzY2hsaWNrICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RTcGVjdWxhcldlaWdodCAqIHNwb3REaWZmdXNlV2VpZ2h0ICogc3BvdERpc3RhbmNlICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogc3BvdEVmZmVjdDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvLyBkaXJlY3Rpb25hbCBsaWdodHNcclxuXHJcblx0XHRcdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGRpckRpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBkaXJTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHJcblx0XHRcdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0Z1bGwgPSBtYXgoIGRvdCggbm9ybWFsLCBkaXJWZWN0b3IgKSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZiA9IG1heCggMC41ICogZG90KCBub3JtYWwsIGRpclZlY3RvciApICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIGRpckRpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdGdWxsICksIHZlYzMoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmICksIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZGlyRGlmZnVzZSArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpZmZ1c2UgKiBkaXJEaWZmdXNlV2VpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXJcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBkaXJIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBkaXJWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggZGlyRG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIDEuMCAtIGRvdCggZGlyVmVjdG9yLCBkaXJIYWxmVmVjdG9yICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImRpclNwZWN1bGFyICs9IHNjaGxpY2sgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0Ly8gaGVtaXNwaGVyZSBsaWdodHNcclxuXHJcblx0XHRcdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBoZW1pRGlmZnVzZSAgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBoZW1pU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIiAsXHJcblxyXG5cdFx0XHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbFZlY3RvciApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBoZW1pQ29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImhlbWlEaWZmdXNlICs9IGRpZmZ1c2UgKiBoZW1pQ29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzcGVjdWxhciAoc2t5IGxpZ2h0KVxyXG5cclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBoZW1pSGFsZlZlY3RvclNreSA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGhlbWlEb3ROb3JtYWxIYWxmU2t5ID0gMC41ICogZG90KCBub3JtYWwsIGhlbWlIYWxmVmVjdG9yU2t5ICkgKyAwLjU7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ID0gc3BlY3VsYXJUZXguciAqIG1heCggcG93KCBoZW1pRG90Tm9ybWFsSGFsZlNreSwgc2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXIgKGdyb3VuZCBsaWdodClcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBsVmVjdG9yR3JvdW5kID0gLWxWZWN0b3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgaGVtaUhhbGZWZWN0b3JHcm91bmQgPSBub3JtYWxpemUoIGxWZWN0b3JHcm91bmQgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCA9IDAuNSAqIGRvdCggbm9ybWFsLCBoZW1pSGFsZlZlY3Rvckdyb3VuZCApICsgMC41O1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggaGVtaURvdE5vcm1hbEhhbGZHcm91bmQsIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdEdyb3VuZCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yR3JvdW5kICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyAyLjAgPT4gMi4wMDAxIGlzIGhhY2sgdG8gd29yayBhcm91bmQgQU5HTEUgYnVnXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgc2NobGlja1NreSA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yLCBoZW1pSGFsZlZlY3RvclNreSApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2tHcm91bmQgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIDEuMCAtIGRvdCggbFZlY3Rvckdyb3VuZCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaGVtaVNwZWN1bGFyICs9IGhlbWlDb2xvciAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqICggc2NobGlja1NreSAqIGhlbWlTcGVjdWxhcldlaWdodFNreSAqIG1heCggZG90UHJvZHVjdCwgMC4wICkgKyBzY2hsaWNrR3JvdW5kICogaGVtaVNwZWN1bGFyV2VpZ2h0R3JvdW5kICogbWF4KCBkb3RQcm9kdWN0R3JvdW5kLCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvLyBhbGwgbGlnaHRzIGNvbnRyaWJ1dGlvbiBzdW1tYXRpb25cclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHRvdGFsRGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyB0b3RhbFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidG90YWxEaWZmdXNlICs9IGRpckRpZmZ1c2U7XCIsXHJcblx0XHRcdFx0XHRcInRvdGFsU3BlY3VsYXIgKz0gZGlyU3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XHRcInRvdGFsRGlmZnVzZSArPSBoZW1pRGlmZnVzZTtcIixcclxuXHRcdFx0XHRcdFwidG90YWxTcGVjdWxhciArPSBoZW1pU3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gcG9pbnREaWZmdXNlO1wiLFxyXG5cdFx0XHRcdFx0XCJ0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XHRcInRvdGFsRGlmZnVzZSArPSBzcG90RGlmZnVzZTtcIixcclxuXHRcdFx0XHRcdFwidG90YWxTcGVjdWxhciArPSBzcG90U3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIE1FVEFMXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICsgdG90YWxTcGVjdWxhciApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICkgKyB0b3RhbFNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcImlmICggZW5hYmxlUmVmbGVjdGlvbiApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgdlJlZmxlY3Q7XCIsXHJcblx0XHRcdFx0XHRcInZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImlmICggdXNlUmVmcmFjdCApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgbm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIG5vcm1hbCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjNCBjdWJlQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIC12UmVmbGVjdC54LCB2UmVmbGVjdC55eiApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiY3ViZUNvbG9yLnh5eiAqPSBjdWJlQ29sb3IueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBjdWJlQ29sb3IueHl6LCBzcGVjdWxhclRleC5yICogcmVmbGVjdGl2aXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjNCB0YW5nZW50O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdU9mZnNldDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdVJlcGVhdDtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZURpc3BsYWNlbWVudDtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFZFUlRFWF9URVhUVVJFU1wiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaXNwbGFjZW1lbnQ7XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVEaXNwbGFjZW1lbnRTY2FsZTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudEJpYXM7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZCaW5vcm1hbDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdC8vIG5vcm1hbCwgdGFuZ2VudCBhbmQgYmlub3JtYWwgdmVjdG9yc1xyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFx0XHRcInZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWROb3JtYWwueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWM0IHNraW5uZWRUYW5nZW50ID0gc2tpbk1hdHJpeCAqIHZlYzQoIHRhbmdlbnQueHl6LCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwidlRhbmdlbnQgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWRUYW5nZW50Lnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcclxuXHRcdFx0XHRcdFwidlRhbmdlbnQgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHRhbmdlbnQueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwidkJpbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggdk5vcm1hbCwgdlRhbmdlbnQgKSAqIHRhbmdlbnQudyApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZVdiA9IHV2ICogdVJlcGVhdCArIHVPZmZzZXQ7XCIsXHJcblxyXG5cdFx0XHRcdC8vIGRpc3BsYWNlbWVudCBtYXBwaW5nXHJcblxyXG5cdFx0XHRcdFwidmVjMyBkaXNwbGFjZWRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgVkVSVEVYX1RFWFRVUkVTXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJpZiAoIGVuYWJsZURpc3BsYWNlbWVudCApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBkdiA9IHRleHR1cmUyRCggdERpc3BsYWNlbWVudCwgdXYgKS54eXo7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZGYgPSB1RGlzcGxhY2VtZW50U2NhbGUgKiBkdi54ICsgdURpc3BsYWNlbWVudEJpYXM7XCIsXHJcblx0XHRcdFx0XHRcdFwiZGlzcGxhY2VkUG9zaXRpb24gPSBwb3NpdGlvbiArIG5vcm1hbGl6ZSggbm9ybWFsICkgKiBkZjtcIixcclxuXHJcblx0XHRcdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHNraW5WZXJ0ZXggPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidmVjNCBza2lubmVkICA9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcIixcclxuXHRcdFx0XHRcdFx0XHRcInNraW5uZWQgXHQgICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJkaXNwbGFjZWRQb3NpdGlvbiAgPSBza2lubmVkLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJkaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IHNraW5WZXJ0ZXggPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzQgc2tpbm5lZCAgPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XCIsXHJcblx0XHRcdFx0XHRcdFwic2tpbm5lZCBcdCAgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkaXNwbGFjZWRQb3NpdGlvbiAgPSBza2lubmVkLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0XCJ2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBkaXNwbGFjZWRQb3NpdGlvbiwgMS4wICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIGRpc3BsYWNlZFBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHQvL1xyXG5cclxuXHRcdFx0XHRcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XCIsXHJcblx0XHRcdFx0XCJ2Vmlld1Bvc2l0aW9uID0gLW12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHQvLyBzaGFkb3dzXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcIixcclxuXHJcblx0XHRcdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdC8vXHRDdWJlIG1hcCBzaGFkZXJcclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHQnY3ViZSc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFx0XHRcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtMSB9IH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwidldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBEZXB0aCBlbmNvZGluZyBpbnRvIFJHQkEgdGV4dHVyZVxyXG5cdC8vIFx0YmFzZWQgb24gU3BpZGVyR0wgc2hhZG93IG1hcCBleGFtcGxlXHJcblx0Ly8gXHRcdGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxyXG5cdC8vIFx0b3JpZ2luYWxseSBmcm9tXHJcblx0Ly9cdFx0aHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy80NDIxMzgtcGFja2luZy1hLWZsb2F0LWludG8tYS1hOHI4ZzhiOC10ZXh0dXJlLXNoYWRlci9wYWdlX193aGljaHBhZ2VfXzElMjVFRiUyNUJGJTI1QkRcclxuXHQvLyBcdHNlZSBhbHNvIGhlcmU6XHJcblx0Ly9cdFx0aHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXHJcblxyXG5cdCdkZXB0aFJHQkEnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHt9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidmVjNCBwYWNrX2RlcHRoKCBjb25zdCBpbiBmbG9hdCBkZXB0aCApIHtcIixcclxuXHJcblx0XHRcdFx0XCJjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwiY29uc3QgdmVjNCBiaXRfbWFzayAgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzQgcmVzID0gZnJhY3QoIGRlcHRoICogYml0X3NoaWZ0ICk7XCIsXHJcblx0XHRcdFx0XCJyZXMgLT0gcmVzLnh4eXogKiBiaXRfbWFzaztcIixcclxuXHRcdFx0XHRcInJldHVybiByZXM7XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1wiLFxyXG5cclxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcclxuXHRcdFx0XHQvL1wiZmxvYXQgeiA9ICggKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICkgLSAzLjAgKSAvICggNDAwMC4wIC0gMy4wICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCB6ICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcicsIFRIUkVFLlJFVklTSU9OICk7XHJcblxyXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xyXG5cclxuXHR2YXIgX2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICksXHJcblx0X2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXHJcblxyXG5cdF9wcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnLFxyXG5cclxuXHRfYnVmZmVycyA9IHt9LFxyXG5cclxuXHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXHJcblx0X3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXHJcblx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxyXG5cdF9zdGVuY2lsID0gcGFyYW1ldGVycy5zdGVuY2lsICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0ZW5jaWwgOiB0cnVlLFxyXG5cdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcclxuXHJcblx0X2NsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICksXHJcblx0X2NsZWFyQWxwaGEgPSAwO1xyXG5cclxuXHQvLyBwdWJsaWMgcHJvcGVydGllc1xyXG5cclxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xyXG5cdHRoaXMuY29udGV4dCA9IG51bGw7XHJcblx0dGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gcGFyYW1ldGVycy5kZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHQ/IHBhcmFtZXRlcnMuZGV2aWNlUGl4ZWxSYXRpb1xyXG5cdFx0XHRcdDogc2VsZi5kZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHRcdD8gc2VsZi5kZXZpY2VQaXhlbFJhdGlvXHJcblx0XHRcdFx0XHQ6IDE7XHJcblxyXG5cdC8vIGNsZWFyaW5nXHJcblxyXG5cdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcclxuXHR0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcclxuXHR0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcclxuXHR0aGlzLmF1dG9DbGVhclN0ZW5jaWwgPSB0cnVlO1xyXG5cclxuXHQvLyBzY2VuZSBncmFwaFxyXG5cclxuXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcclxuXHR0aGlzLmF1dG9VcGRhdGVPYmplY3RzID0gdHJ1ZTtcclxuXHJcblx0Ly8gcGh5c2ljYWxseSBiYXNlZCBzaGFkaW5nXHJcblxyXG5cdHRoaXMuZ2FtbWFJbnB1dCA9IHRydWU7XHJcblx0dGhpcy5nYW1tYU91dHB1dCA9IHRydWU7XHJcblxyXG5cdC8vIHNoYWRvdyBtYXBcclxuXHJcblx0dGhpcy5zaGFkb3dNYXBFbmFibGVkID0gZmFsc2U7XHJcblx0dGhpcy5zaGFkb3dNYXBBdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHR0aGlzLnNoYWRvd01hcFR5cGUgPSBUSFJFRS5QQ0ZTaGFkb3dNYXA7XHJcblx0dGhpcy5zaGFkb3dNYXBDdWxsRmFjZSA9IFRIUkVFLkN1bGxGYWNlRnJvbnQ7XHJcblx0dGhpcy5zaGFkb3dNYXBEZWJ1ZyA9IGZhbHNlO1xyXG5cdHRoaXMuc2hhZG93TWFwQ2FzY2FkZSA9IGZhbHNlO1xyXG5cclxuXHQvLyBtb3JwaHNcclxuXHJcblx0dGhpcy5tYXhNb3JwaFRhcmdldHMgPSA4O1xyXG5cdHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcclxuXHJcblx0Ly8gZmxhZ3NcclxuXHJcblx0dGhpcy5hdXRvU2NhbGVDdWJlbWFwcyA9IHRydWU7XHJcblxyXG5cdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2luc1xyXG5cclxuXHR0aGlzLnJlbmRlclBsdWdpbnNQcmUgPSBbXTtcclxuXHR0aGlzLnJlbmRlclBsdWdpbnNQb3N0ID0gW107XHJcblxyXG5cdC8vIGluZm9cclxuXHJcblx0dGhpcy5pbmZvID0ge1xyXG5cclxuXHRcdG1lbW9yeToge1xyXG5cclxuXHRcdFx0cHJvZ3JhbXM6IDAsXHJcblx0XHRcdGdlb21ldHJpZXM6IDAsXHJcblx0XHRcdHRleHR1cmVzOiAwXHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyZW5kZXI6IHtcclxuXHJcblx0XHRcdGNhbGxzOiAwLFxyXG5cdFx0XHR2ZXJ0aWNlczogMCxcclxuXHRcdFx0ZmFjZXM6IDAsXHJcblx0XHRcdHBvaW50czogMFxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gaW50ZXJuYWwgcHJvcGVydGllc1xyXG5cclxuXHR2YXIgX3RoaXMgPSB0aGlzLFxyXG5cclxuXHRfcHJvZ3JhbXMgPSBbXSxcclxuXHRfcHJvZ3JhbXNfY291bnRlciA9IDAsXHJcblxyXG5cdC8vIGludGVybmFsIHN0YXRlIGNhY2hlXHJcblxyXG5cdF9jdXJyZW50UHJvZ3JhbSA9IG51bGwsXHJcblx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXHJcblx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTEsXHJcblx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IG51bGwsXHJcblx0X2N1cnJlbnRDYW1lcmEgPSBudWxsLFxyXG5cclxuXHRfdXNlZFRleHR1cmVVbml0cyA9IDAsXHJcblxyXG5cdC8vIEdMIHN0YXRlIGNhY2hlXHJcblxyXG5cdF9vbGREb3VibGVTaWRlZCA9IC0xLFxyXG5cdF9vbGRGbGlwU2lkZWQgPSAtMSxcclxuXHJcblx0X29sZEJsZW5kaW5nID0gLTEsXHJcblxyXG5cdF9vbGRCbGVuZEVxdWF0aW9uID0gLTEsXHJcblx0X29sZEJsZW5kU3JjID0gLTEsXHJcblx0X29sZEJsZW5kRHN0ID0gLTEsXHJcblxyXG5cdF9vbGREZXB0aFRlc3QgPSAtMSxcclxuXHRfb2xkRGVwdGhXcml0ZSA9IC0xLFxyXG5cclxuXHRfb2xkUG9seWdvbk9mZnNldCA9IG51bGwsXHJcblx0X29sZFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsLFxyXG5cdF9vbGRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsLFxyXG5cclxuXHRfb2xkTGluZVdpZHRoID0gbnVsbCxcclxuXHJcblx0X3ZpZXdwb3J0WCA9IDAsXHJcblx0X3ZpZXdwb3J0WSA9IDAsXHJcblx0X3ZpZXdwb3J0V2lkdGggPSBfY2FudmFzLndpZHRoLFxyXG5cdF92aWV3cG9ydEhlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxyXG5cdF9jdXJyZW50V2lkdGggPSAwLFxyXG5cdF9jdXJyZW50SGVpZ2h0ID0gMCxcclxuXHJcblx0X2VuYWJsZWRBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICksXHJcblxyXG5cdC8vIGZydXN0dW1cclxuXHJcblx0X2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxyXG5cclxuXHQgLy8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXHJcblxyXG5cdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHRfcHJvalNjcmVlbk1hdHJpeFBTID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcblx0X3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdF93aWR0aCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0X2hlaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxyXG5cclxuXHRfZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcblx0X2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlLFxyXG5cclxuXHRfbGlnaHRzID0ge1xyXG5cclxuXHRcdGFtYmllbnQ6IFsgMCwgMCwgMCBdLFxyXG5cdFx0ZGlyZWN0aW9uYWw6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IG5ldyBBcnJheSgpLCBwb3NpdGlvbnM6IG5ldyBBcnJheSgpIH0sXHJcblx0XHRwb2ludDogeyBsZW5ndGg6IDAsIGNvbG9yczogbmV3IEFycmF5KCksIHBvc2l0aW9uczogbmV3IEFycmF5KCksIGRpc3RhbmNlczogbmV3IEFycmF5KCksIGRlY2F5RXhwb25lbnRzOiBuZXcgQXJyYXkoKSB9LFxyXG5cdFx0c3BvdDogeyBsZW5ndGg6IDAsIGNvbG9yczogbmV3IEFycmF5KCksIHBvc2l0aW9uczogbmV3IEFycmF5KCksIGRpc3RhbmNlczogbmV3IEFycmF5KCksIGRlY2F5RXhwb25lbnRzOiBuZXcgQXJyYXkoKSwgZGlyZWN0aW9uczogbmV3IEFycmF5KCksIGFuZ2xlc0NvczogbmV3IEFycmF5KCksIGV4cG9uZW50czogbmV3IEFycmF5KCkgfSxcclxuXHRcdGhlbWk6IHsgbGVuZ3RoOiAwLCBza3lDb2xvcnM6IG5ldyBBcnJheSgpLCBncm91bmRDb2xvcnM6IG5ldyBBcnJheSgpLCBwb3NpdGlvbnM6IG5ldyBBcnJheSgpIH0sXHJcblx0XHRhcmVhOiB7IGxlbmd0aDogMCwgY29sb3JzOiBuZXcgQXJyYXkoKSwgcG9zaXRpb25zOiBuZXcgQXJyYXkoKSwgZGlzdGFuY2VzOiBuZXcgQXJyYXkoKSwgZGVjYXlFeHBvbmVudHM6IG5ldyBBcnJheSgpLCB3aWR0aHM6IG5ldyBBcnJheSgpLCBoZWlnaHRzOiBuZXcgQXJyYXkoKSB9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGluaXRpYWxpemVcclxuXHJcblx0dmFyIF9nbDtcclxuXHJcblx0dmFyIF9nbEV4dGVuc2lvblRleHR1cmVGbG9hdDtcclxuXHR2YXIgX2dsRXh0ZW5zaW9uVGV4dHVyZUZsb2F0TGluZWFyO1xyXG5cdHZhciBfZ2xFeHRlbnNpb25TdGFuZGFyZERlcml2YXRpdmVzO1xyXG5cdHZhciBfZ2xFeHRlbnNpb25UZXh0dXJlRmlsdGVyQW5pc290cm9waWM7XHJcblx0dmFyIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQztcclxuXHJcblx0aW5pdEdMKCk7XHJcblxyXG5cdHNldERlZmF1bHRHTFN0YXRlKCk7XHJcblxyXG5cdHRoaXMuY29udGV4dCA9IF9nbDtcclxuXHJcblx0Ly8gR1BVIGNhcGFiaWxpdGllc1xyXG5cclxuXHR2YXIgX21heFRleHR1cmVzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XHJcblx0dmFyIF9tYXhWZXJ0ZXhUZXh0dXJlcyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHR2YXIgX21heFRleHR1cmVTaXplID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9URVhUVVJFX1NJWkUgKTtcclxuXHR2YXIgX21heEN1YmVtYXBTaXplID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcclxuXHJcblx0dmFyIF9tYXhBbmlzb3Ryb3B5ID0gX2dsRXh0ZW5zaW9uVGV4dHVyZUZpbHRlckFuaXNvdHJvcGljID8gX2dsLmdldFBhcmFtZXRlciggX2dsRXh0ZW5zaW9uVGV4dHVyZUZpbHRlckFuaXNvdHJvcGljLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApIDogMDtcclxuXHJcblx0dmFyIF9zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gKCBfbWF4VmVydGV4VGV4dHVyZXMgPiAwICk7XHJcblx0dmFyIF9zdXBwb3J0c0JvbmVUZXh0dXJlcyA9IF9zdXBwb3J0c1ZlcnRleFRleHR1cmVzICYmIF9nbEV4dGVuc2lvblRleHR1cmVGbG9hdDtcclxuXHJcblx0dmFyIF9jb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEMgPyBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgKSA6IFtdO1xyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgX3ZlcnRleFNoYWRlclByZWNpc2lvbkhpZ2hwRmxvYXQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuVkVSVEVYX1NIQURFUiwgX2dsLkhJR0hfRkxPQVQgKTtcclxuXHR2YXIgX3ZlcnRleFNoYWRlclByZWNpc2lvbk1lZGl1bXBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuTUVESVVNX0ZMT0FUICk7XHJcblx0dmFyIF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25Mb3dwRmxvYXQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuVkVSVEVYX1NIQURFUiwgX2dsLkxPV19GTE9BVCApO1xyXG5cclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5ISUdIX0ZMT0FUICk7XHJcblx0dmFyIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbk1lZGl1bXBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5NRURJVU1fRkxPQVQgKTtcclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTG93cEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLkZSQUdNRU5UX1NIQURFUiwgX2dsLkxPV19GTE9BVCApO1xyXG5cclxuXHR2YXIgX3ZlcnRleFNoYWRlclByZWNpc2lvbkhpZ2hwSW50ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5ISUdIX0lOVCApO1xyXG5cdHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEludCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuTUVESVVNX0lOVCApO1xyXG5cdHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTG93cEludCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuTE9XX0lOVCApO1xyXG5cclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uSGlnaHBJbnQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuRlJBR01FTlRfU0hBREVSLCBfZ2wuSElHSF9JTlQgKTtcclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEludCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5NRURJVU1fSU5UICk7XHJcblx0dmFyIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbkxvd3BJbnQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuRlJBR01FTlRfU0hBREVSLCBfZ2wuTE9XX0lOVCApO1xyXG5cclxuXHQvLyBjbGFtcCBwcmVjaXNpb24gdG8gbWF4aW11bSBhdmFpbGFibGVcclxuXHJcblx0dmFyIGhpZ2hwQXZhaWxhYmxlID0gX3ZlcnRleFNoYWRlclByZWNpc2lvbkhpZ2hwRmxvYXQucHJlY2lzaW9uID4gMCAmJiBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25IaWdocEZsb2F0LnByZWNpc2lvbiA+IDA7XHJcblx0dmFyIG1lZGl1bXBBdmFpbGFibGUgPSBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDAgJiYgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDA7XHJcblxyXG5cdGlmICggX3ByZWNpc2lvbiA9PT0gXCJoaWdocFwiICYmICEgaGlnaHBBdmFpbGFibGUgKSB7XHJcblxyXG5cdFx0aWYgKCBtZWRpdW1wQXZhaWxhYmxlICkge1xyXG5cclxuXHRcdFx0X3ByZWNpc2lvbiA9IFwibWVkaXVtcFwiO1xyXG5cdFx0XHRUSFJFRS5vbndhcm5pbmcoIFwiV2ViR0xSZW5kZXJlcjogaGlnaHAgbm90IHN1cHBvcnRlZCwgdXNpbmcgbWVkaXVtcFwiICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9wcmVjaXNpb24gPSBcImxvd3BcIjtcclxuXHRcdFx0VEhSRUUub253YXJuaW5nKCBcIldlYkdMUmVuZGVyZXI6IGhpZ2hwIGFuZCBtZWRpdW1wIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIGxvd3BcIiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIF9wcmVjaXNpb24gPT09IFwibWVkaXVtcFwiICYmICEgbWVkaXVtcEF2YWlsYWJsZSApIHtcclxuXHJcblx0XHRfcHJlY2lzaW9uID0gXCJsb3dwXCI7XHJcblx0XHRUSFJFRS5vbndhcm5pbmcoIFwiV2ViR0xSZW5kZXJlcjogbWVkaXVtcCBub3Qgc3VwcG9ydGVkLCB1c2luZyBsb3dwXCIgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBBUElcclxuXHJcblx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2w7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX3N1cHBvcnRzVmVydGV4VGV4dHVyZXM7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VwcG9ydHNGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2xFeHRlbnNpb25UZXh0dXJlRmxvYXQ7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2xFeHRlbnNpb25TdGFuZGFyZERlcml2YXRpdmVzO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEM7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0TWF4QW5pc290cm9weSAgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9tYXhBbmlzb3Ryb3B5O1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX3ByZWNpc2lvbjtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApIHtcclxuXHJcblx0XHRfY2FudmFzLndpZHRoID0gd2lkdGggKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XHJcblx0XHRfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbztcclxuXHJcblx0XHRpZiAoIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gMSAmJiB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG5cdFx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHRfdmlld3BvcnRYID0geCAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbztcclxuXHRcdF92aWV3cG9ydFkgPSB5ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xyXG5cclxuXHRcdF92aWV3cG9ydFdpZHRoID0gd2lkdGggKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XHJcblx0XHRfdmlld3BvcnRIZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XHJcblxyXG5cdFx0X2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHRfZ2wuc2Npc3NvcihcclxuXHRcdFx0eCAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyxcclxuXHRcdFx0eSAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyxcclxuXHRcdFx0d2lkdGggKiB0aGlzLmRldmljZVBpeGVsUmF0aW8sXHJcblx0XHRcdGhlaWdodCAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpb1xyXG5cdFx0KTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5lbmFibGVTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggZW5hYmxlICkge1xyXG5cclxuXHRcdGVuYWJsZSA/IF9nbC5lbmFibGUoIF9nbC5TQ0lTU09SX1RFU1QgKSA6IF9nbC5kaXNhYmxlKCBfZ2wuU0NJU1NPUl9URVNUICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIENsZWFyaW5nXHJcblxyXG5cdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xyXG5cclxuXHRcdF9jbGVhckNvbG9yLnNldCggY29sb3IgKTtcclxuXHRcdF9jbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcclxuXHJcblx0XHRfZ2wuY2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRDbGVhckNvbG9ySGV4ID0gZnVuY3Rpb24gKCBoZXgsIGFscGhhICkge1xyXG5cclxuXHRcdFRIUkVFLm9ud2FybmluZyggJ0RFUFJFQ0FURUQ6IC5zZXRDbGVhckNvbG9ySGV4KCkgaXMgYmVpbmcgcmVtb3ZlZC4gVXNlIC5zZXRDbGVhckNvbG9yKCkgaW5zdGVhZC4nICk7XHJcblx0XHR0aGlzLnNldENsZWFyQ29sb3IoIGhleCwgYWxwaGEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfY2xlYXJDb2xvcjtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfY2xlYXJBbHBoYTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICggY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xyXG5cclxuXHRcdHZhciBiaXRzID0gMDtcclxuXHJcblx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xyXG5cdFx0aWYgKCBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcclxuXHRcdGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XHJcblxyXG5cdFx0X2dsLmNsZWFyKCBiaXRzICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRfZ2wuY2xlYXIoIF9nbC5DT0xPUl9CVUZGRVJfQklUICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRfZ2wuY2xlYXIoIF9nbC5ERVBUSF9CVUZGRVJfQklUICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdF9nbC5jbGVhciggX2dsLlNURU5DSUxfQlVGRkVSX0JJVCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcclxuXHJcblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblx0XHR0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gUGx1Z2luc1xyXG5cclxuXHR0aGlzLmFkZFBvc3RQbHVnaW4gPSBmdW5jdGlvbiAoIHBsdWdpbiApIHtcclxuXHJcblx0XHRwbHVnaW4uaW5pdCggdGhpcyApO1xyXG5cdFx0dGhpcy5yZW5kZXJQbHVnaW5zUG9zdC5wdXNoKCBwbHVnaW4gKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5hZGRQcmVQbHVnaW4gPSBmdW5jdGlvbiAoIHBsdWdpbiApIHtcclxuXHJcblx0XHRwbHVnaW4uaW5pdCggdGhpcyApO1xyXG5cdFx0dGhpcy5yZW5kZXJQbHVnaW5zUHJlLnB1c2goIHBsdWdpbiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBSZW5kZXJpbmdcclxuXHJcblx0dGhpcy51cGRhdGVTaGFkb3dNYXAgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcclxuXHRcdF9vbGRCbGVuZGluZyA9IC0xO1xyXG5cdFx0X29sZERlcHRoVGVzdCA9IC0xO1xyXG5cdFx0X29sZERlcHRoV3JpdGUgPSAtMTtcclxuXHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcclxuXHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xO1xyXG5cdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0X29sZERvdWJsZVNpZGVkID0gLTE7XHJcblx0XHRfb2xkRmxpcFNpZGVkID0gLTE7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3dNYXBQbHVnaW4udXBkYXRlKCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEludGVybmFsIGZ1bmN0aW9uc1xyXG5cclxuXHQvLyBCdWZmZXIgYWxsb2NhdGlvblxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVQYXJ0aWNsZUJ1ZmZlcnMgKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZUxpbmVCdWZmZXJzICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyArKztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlTWVzaEJ1ZmZlcnMgKCBnZW9tZXRyeUdyb3VwICkge1xyXG5cclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbE5vcm1hbEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFRhbmdlbnRCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDb2xvckJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsVVYyQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0dmFyIG0sIG1sO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0czsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzLnB1c2goIF9nbC5jcmVhdGVCdWZmZXIoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVycyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHM7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVycy5wdXNoKCBfZ2wuY3JlYXRlQnVmZmVyKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyArKztcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gRXZlbnRzXHJcblxyXG5cdHZhciBvbkdlb21ldHJ5RGlzcG9zZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcclxuXHJcblx0XHRkZWFsbG9jYXRlR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBvblRleHR1cmVEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xyXG5cclxuXHRcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgb25SZW5kZXJUYXJnZXREaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xyXG5cclxuXHRcdGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgb25NYXRlcmlhbERpc3Bvc2UgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHRtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XHJcblxyXG5cdFx0ZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXHJcblxyXG5cdHZhciBkZWxldGVCdWZmZXJzID0gZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgIT09IHVuZGVmaW5lZCApIF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbE5vcm1hbEJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbE5vcm1hbEJ1ZmZlciApO1xyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsVGFuZ2VudEJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbFRhbmdlbnRCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFVWQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsVVZCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFVWMkJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbFVWMkJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIgKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xGYWNlQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsRmFjZUJ1ZmZlciApO1xyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsTGluZUJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbExpbmVCdWZmZXIgKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgIT09IHVuZGVmaW5lZCApIF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgKTtcclxuXHRcdC8vIGN1c3RvbSBhdHRyaWJ1dGVzXHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpZCBpbiBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdFsgaWQgXS5idWZmZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGRlYWxsb2NhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbEluaXQgPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIGtleSBdLmJ1ZmZlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGF0dHJpYnV0ZXNbIGtleSBdLmJ1ZmZlciApO1xyXG5cdFx0XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5nZW9tZXRyeUdyb3VwcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgZyBpbiBnZW9tZXRyeS5nZW9tZXRyeUdyb3VwcyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBnIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzOyBtIDwgbWw7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbIG0gXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHM7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgbSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGRlbGV0ZUJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZGVsZXRlQnVmZmVycyggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBkZWFsbG9jYXRlVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKSB7XHJcblxyXG5cdFx0XHQvLyBjdWJlIHRleHR1cmVcclxuXHJcblx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyAyRCB0ZXh0dXJlXHJcblxyXG5cdFx0XHRpZiAoICEgdGV4dHVyZS5fX3dlYmdsSW5pdCApIHJldHVybjtcclxuXHJcblx0XHRcdHRleHR1cmUuX193ZWJnbEluaXQgPSBmYWxzZTtcclxuXHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0aWYgKCAhcmVuZGVyVGFyZ2V0IHx8ICEgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICkgcmV0dXJuO1xyXG5cclxuXHRcdF9nbC5kZWxldGVUZXh0dXJlKCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XHJcblx0XHRcdFx0X2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgKTtcclxuXHRcdFx0X2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBkZWFsbG9jYXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBvcHRpb25hbERpc2Nvbm5lY3RlZFByb2dyYW0gKSB7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBvcHRpb25hbERpc2Nvbm5lY3RlZFByb2dyYW0gfHwgbWF0ZXJpYWwucHJvZ3JhbTtcclxuXHJcblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRpZiggISBvcHRpb25hbERpc2Nvbm5lY3RlZFByb2dyYW0gKSB7XHJcblx0XHRcdG1hdGVyaWFsLnByb2dyYW0gPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb25seSBkZWFsbG9jYXRlIEdMIHByb2dyYW0gaWYgdGhpcyB3YXMgdGhlIGxhc3QgdXNlIG9mIHNoYXJlZCBwcm9ncmFtXHJcblx0XHQvLyBhc3N1bWVkIHRoZXJlIGlzIG9ubHkgc2luZ2xlIGNvcHkgb2YgYW55IHByb2dyYW0gaW4gdGhlIF9wcm9ncmFtcyBsaXN0XHJcblx0XHQvLyAodGhhdCdzIGhvdyBpdCdzIGNvbnN0cnVjdGVkKVxyXG5cclxuXHRcdHZhciBpLCBpbCwgcHJvZ3JhbUluZm87XHJcblx0XHR2YXIgZGVsZXRlUHJvZ3JhbSA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IF9wcm9ncmFtcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHByb2dyYW1JbmZvID0gX3Byb2dyYW1zWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHByb2dyYW1JbmZvLnByb2dyYW0gPT09IHByb2dyYW0gKSB7XHJcblxyXG5cdFx0XHRcdHByb2dyYW1JbmZvLnVzZWRUaW1lcyAtLTtcclxuXHJcblx0XHRcdFx0aWYgKCBwcm9ncmFtSW5mby51c2VkVGltZXMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZGVsZXRlUHJvZ3JhbSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGVsZXRlUHJvZ3JhbSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdC8vIGF2b2lkIHVzaW5nIGFycmF5LnNwbGljZSwgdGhpcyBpcyBjb3N0bGllciB0aGFuIGNyZWF0aW5nIG5ldyBhcnJheSBmcm9tIHNjcmF0Y2hcclxuXHJcblx0XHRcdHZhciBuZXdQcm9ncmFtcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gX3Byb2dyYW1zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHByb2dyYW1JbmZvLnByb2dyYW0gIT09IHByb2dyYW0gKSB7XHJcblxyXG5cdFx0XHRcdFx0bmV3UHJvZ3JhbXMucHVzaCggcHJvZ3JhbUluZm8gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHJcblx0XHRcdF9wcm9ncmFtcyA9IG5ld1Byb2dyYW1zO1xyXG5cdFx0XHRcclxuXHRcdFx0X2dsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnByb2dyYW1zIC0tO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQnVmZmVyIGluaXRpYWxpemF0aW9uXHJcblxyXG5cdGZ1bmN0aW9uIGluaXRDdXN0b21BdHRyaWJ1dGVzICggZ2VvbWV0cnksIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgbnZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgPSBbXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBhIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzWyBhIF07XHJcblxyXG5cdFx0XHRcdGlmICggIWF0dHJpYnV0ZS5fX3dlYmdsSW5pdGlhbGl6ZWQgfHwgYXR0cmlidXRlLmNyZWF0ZVVuaXF1ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLl9fd2ViZ2xJbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHNpemUgPSAxO1x0XHQvLyBcImZcIiBhbmQgXCJpXCJcclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS50eXBlID09PSBcInYyXCIgKSBzaXplID0gMjtcclxuXHRcdFx0XHRcdGVsc2UgaWYgKCBhdHRyaWJ1dGUudHlwZSA9PT0gXCJ2M1wiICkgc2l6ZSA9IDM7XHJcblx0XHRcdFx0XHRlbHNlIGlmICggYXR0cmlidXRlLnR5cGUgPT09IFwidjRcIiApIHNpemUgPSA0O1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSBcImNcIiAgKSBzaXplID0gMztcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuc2l6ZSA9IHNpemU7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogc2l6ZSApO1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyLmJlbG9uZ3NUb0F0dHJpYnV0ZSA9IGE7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QucHVzaCggYXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBpbml0UGFydGljbGVCdWZmZXJzICggZ2VvbWV0cnksIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgbnZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XHJcblx0XHRnZW9tZXRyeS5fX2NvbG9yQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX19zb3J0QXJyYXkgPSBbXTtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsUGFydGljbGVDb3VudCA9IG52ZXJ0aWNlcztcclxuXHJcblx0XHRpbml0Q3VzdG9tQXR0cmlidXRlcyAoIGdlb21ldHJ5LCBvYmplY3QgKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gaW5pdExpbmVCdWZmZXJzICggZ2VvbWV0cnksIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgbnZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XHJcblx0XHRnZW9tZXRyeS5fX2NvbG9yQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XHJcblx0XHRnZW9tZXRyeS5fX2xpbmVEaXN0YW5jZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMSApO1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xMaW5lQ291bnQgPSBudmVydGljZXM7XHJcblxyXG5cdFx0aW5pdEN1c3RvbUF0dHJpYnV0ZXMgKCBnZW9tZXRyeSwgb2JqZWN0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRNZXNoQnVmZmVycyAoIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnksXHJcblx0XHRcdGZhY2VzMyA9IGdlb21ldHJ5R3JvdXAuZmFjZXMzLFxyXG5cclxuXHRcdFx0bnZlcnRpY2VzID0gZmFjZXMzLmxlbmd0aCAqIDMsXHJcblx0XHRcdG50cmlzICAgICA9IGZhY2VzMy5sZW5ndGggKiAxLFxyXG5cdFx0XHRubGluZXMgICAgPSBmYWNlczMubGVuZ3RoICogMyxcclxuXHJcblx0XHRcdG1hdGVyaWFsID0gZ2V0QnVmZmVyTWF0ZXJpYWwoIG9iamVjdCwgZ2VvbWV0cnlHcm91cCApLFxyXG5cclxuXHRcdFx0dXZUeXBlID0gYnVmZmVyR3Vlc3NVVlR5cGUoIG1hdGVyaWFsICksXHJcblx0XHRcdG5vcm1hbFR5cGUgPSBidWZmZXJHdWVzc05vcm1hbFR5cGUoIG1hdGVyaWFsICksXHJcblx0XHRcdHZlcnRleENvbG9yVHlwZSA9IGJ1ZmZlckd1ZXNzVmVydGV4Q29sb3JUeXBlKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdGdlb21ldHJ5R3JvdXAuX192ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHJcblx0XHRpZiAoIG5vcm1hbFR5cGUgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fbm9ybWFsQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuaGFzVGFuZ2VudHMgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fdGFuZ2VudEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogNCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHZlcnRleENvbG9yVHlwZSApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5R3JvdXAuX19jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHV2VHlwZSApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuZmFjZVZlcnRleFV2cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fdXZBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuZmFjZVZlcnRleFV2cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fdXYyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAmJiBvYmplY3QuZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogNCApO1xyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fc2tpbldlaWdodEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogNCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fZmFjZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBudHJpcyAqIDMgKTtcclxuXHRcdGdlb21ldHJ5R3JvdXAuX19saW5lQXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIG5saW5lcyAqIDIgKTtcclxuXHJcblx0XHR2YXIgbSwgbWw7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5R3JvdXAuX19tb3JwaFRhcmdldHNBcnJheXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzOyBtIDwgbWw7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX19tb3JwaFRhcmdldHNBcnJheXMucHVzaCggbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhOb3JtYWxzQXJyYXlzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFsczsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhOb3JtYWxzQXJyYXlzLnB1c2goIG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQ291bnQgPSBudHJpcyAqIDM7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQ291bnQgPSBubGluZXMgKiAyO1xyXG5cclxuXHJcblx0XHQvLyBjdXN0b20gYXR0cmlidXRlc1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgPSBbXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBhIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIERvIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBhdHRyaWJ1dGUgb2JqZWN0IHNvIGRpZmZlcmVudCBnZW9tZXRyeUdyb3VwIGNodW5rcyB1c2UgZGlmZmVyZW50XHJcblx0XHRcdFx0Ly8gYXR0cmlidXRlIGJ1ZmZlcnMgd2hpY2ggYXJlIGNvcnJlY3RseSBpbmRleGVkIGluIHRoZSBzZXRNZXNoQnVmZmVycyBmdW5jdGlvblxyXG5cclxuXHRcdFx0XHR2YXIgb3JpZ2luYWxBdHRyaWJ1dGUgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzWyBhIF07XHJcblxyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSB7fTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIHByb3BlcnR5IGluIG9yaWdpbmFsQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZVsgcHJvcGVydHkgXSA9IG9yaWdpbmFsQXR0cmlidXRlWyBwcm9wZXJ0eSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggIWF0dHJpYnV0ZS5fX3dlYmdsSW5pdGlhbGl6ZWQgfHwgYXR0cmlidXRlLmNyZWF0ZVVuaXF1ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLl9fd2ViZ2xJbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHNpemUgPSAxO1x0XHQvLyBcImZcIiBhbmQgXCJpXCJcclxuXHJcblx0XHRcdFx0XHRpZiggYXR0cmlidXRlLnR5cGUgPT09IFwidjJcIiApIHNpemUgPSAyO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiggYXR0cmlidXRlLnR5cGUgPT09IFwidjNcIiApIHNpemUgPSAzO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiggYXR0cmlidXRlLnR5cGUgPT09IFwidjRcIiApIHNpemUgPSA0O1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiggYXR0cmlidXRlLnR5cGUgPT09IFwiY1wiICApIHNpemUgPSAzO1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5zaXplID0gc2l6ZTtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiBzaXplICk7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLmJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlID0gYTtcclxuXHJcblx0XHRcdFx0XHRvcmlnaW5hbEF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuX19vcmlnaW5hbCA9IG9yaWdpbmFsQXR0cmlidXRlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LnB1c2goIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9faW5pdHRlZEFycmF5cyA9IHRydWU7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5R3JvdXAgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdC5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWxcclxuXHRcdFx0PyBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzWyBnZW9tZXRyeUdyb3VwLm1hdGVyaWFsSW5kZXggXVxyXG5cdFx0XHQ6IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gbWF0ZXJpYWxOZWVkc1Ntb290aE5vcm1hbHMgKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRyZXR1cm4gbWF0ZXJpYWwgJiYgbWF0ZXJpYWwuc2hhZGluZyAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGJ1ZmZlckd1ZXNzTm9ybWFsVHlwZSAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdC8vIG9ubHkgTWVzaEJhc2ljTWF0ZXJpYWwgYW5kIE1lc2hEZXB0aE1hdGVyaWFsIGRvbid0IG5lZWQgbm9ybWFsc1xyXG5cclxuXHRcdGlmICggKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICYmICFtYXRlcmlhbC5lbnZNYXAgKSB8fCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsTmVlZHNTbW9vdGhOb3JtYWxzKCBtYXRlcmlhbCApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBUSFJFRS5GbGF0U2hhZGluZztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGJ1ZmZlckd1ZXNzVmVydGV4Q29sb3JUeXBlKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnZlcnRleENvbG9ycyApIHtcclxuXHJcblx0XHRcdHJldHVybiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gYnVmZmVyR3Vlc3NVVlR5cGUoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdC8vIG1hdGVyaWFsIG11c3QgdXNlIHNvbWUgdGV4dHVyZSB0byByZXF1aXJlIHV2c1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubWFwIHx8XHJcblx0XHQgICAgIG1hdGVyaWFsLm9wYWNpdHlNYXAgfHxcclxuXHRcdCAgICAgbWF0ZXJpYWwubGlnaHRNYXAgfHxcclxuXHRcdCAgICAgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgfHxcclxuXHRcdCAgICAgbWF0ZXJpYWwuYnVtcE1hcCB8fFxyXG5cdFx0ICAgICBtYXRlcmlhbC5ub3JtYWxNYXAgfHxcclxuXHRcdCAgICAgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgfHxcclxuXHRcdCAgICAgbWF0ZXJpYWwucmVmbGVjdGl2aXR5TWFwIHx8XHJcblx0XHQgICAgIG1hdGVyaWFsLnJvdWdobmVzc01hcCB8fFxyXG5cdFx0ICAgICBtYXRlcmlhbC5mYWxsb2ZmTWFwIHx8XHJcblx0XHQgICAgIG1hdGVyaWFsLmFuaXNvdHJvcHlNYXAgfHxcclxuXHRcdCAgICAgbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uTWFwIHx8XHJcblx0XHQgICAgIG1hdGVyaWFsLm1ldGFsbGljTWFwIHx8XHJcblx0XHQgICAgIG1hdGVyaWFsLnRyYW5zbHVjZW5jeU1hcCB8fFxyXG5cdFx0ICAgICAoIG1hdGVyaWFsLmFuaXNvdHJvcHkgJiYgbWF0ZXJpYWwuYW5pc290cm9weSAhPT0gMC4wICkgfHxcclxuXHRcdCAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIGluaXREaXJlY3RCdWZmZXJzKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgYSwgYXR0cmlidXRlLCB0eXBlO1xyXG5cclxuXHRcdGZvciAoIGEgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggYSA9PT0gXCJpbmRleFwiICkge1xyXG5cclxuXHRcdFx0XHR0eXBlID0gX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dHlwZSA9IF9nbC5BUlJBWV9CVUZGRVI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBhIF07XHJcblxyXG5cdFx0XHRhdHRyaWJ1dGUuYnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIHR5cGUsIGF0dHJpYnV0ZS5idWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIHR5cGUsIGF0dHJpYnV0ZS5hcnJheSwgX2dsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBCdWZmZXIgc2V0dGluZ1xyXG5cclxuXHRmdW5jdGlvbiBzZXRQYXJ0aWNsZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgaGludCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciB2LCBjLCB2ZXJ0ZXgsIG9mZnNldCwgaW5kZXgsIGNvbG9yLFxyXG5cclxuXHRcdHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHR2bCA9IHZlcnRpY2VzLmxlbmd0aCxcclxuXHJcblx0XHRjb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnMsXHJcblx0XHRjbCA9IGNvbG9ycy5sZW5ndGgsXHJcblxyXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeS5fX3ZlcnRleEFycmF5LFxyXG5cdFx0Y29sb3JBcnJheSA9IGdlb21ldHJ5Ll9fY29sb3JBcnJheSxcclxuXHJcblx0XHRzb3J0QXJyYXkgPSBnZW9tZXRyeS5fX3NvcnRBcnJheSxcclxuXHJcblx0XHRkaXJ0eVZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlFbGVtZW50cyA9IGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSxcclxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSxcclxuXHJcblx0XHRjdXN0b21BdHRyaWJ1dGVzID0gZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxyXG5cdFx0aSwgaWwsXHJcblx0XHRhLCBjYSwgY2FsLCB2YWx1ZSxcclxuXHRcdGN1c3RvbUF0dHJpYnV0ZTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5zb3J0UGFydGljbGVzICkge1xyXG5cclxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXhQUy5jb3B5KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeFBTLm11bHRpcGx5KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyB2IF07XHJcblxyXG5cdFx0XHRcdF92ZWN0b3IzLmNvcHkoIHZlcnRleCApO1xyXG5cdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXhQUyApO1xyXG5cclxuXHRcdFx0XHRzb3J0QXJyYXlbIHYgXSA9IFsgX3ZlY3RvcjMueiwgdiBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c29ydEFycmF5LnNvcnQoIG51bWVyaWNhbFNvcnQgKTtcclxuXHJcblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBzb3J0QXJyYXlbdl1bMV0gXTtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ID0gdiAqIDM7XHJcblxyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2ZXJ0ZXgueDtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdmVydGV4Lnk7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHZlcnRleC56O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ID0gYyAqIDM7XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzWyBzb3J0QXJyYXlbY11bMV0gXTtcclxuXHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3IucjtcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggISAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdFx0XHRjYWwgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWUubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBzb3J0QXJyYXlbIGNhIF1bIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBjYSBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDI7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSBcImNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSBzb3J0QXJyYXlbIGNhIF1bIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgICA9IHZhbHVlLnI7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMiBdID0gdmFsdWUuejtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSA0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgICAgPSB2YWx1ZS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSAgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyICBdID0gdmFsdWUuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDMgIF0gPSB2YWx1ZS53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBkaXJ0eVZlcnRpY2VzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyB2IF07XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gdiAqIDM7XHJcblxyXG5cdFx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xyXG5cdFx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHZlcnRleC55O1xyXG5cdFx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHZlcnRleC56O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRpcnR5Q29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBjID0gMDsgYyA8IGNsOyBjICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzWyBjIF07XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gYyAqIDM7XHJcblxyXG5cdFx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3IucjtcclxuXHRcdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmc7XHJcblx0XHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLm5lZWRzVXBkYXRlICYmXHJcblx0XHRcdFx0XHRcdCAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0XHRcdFx0ICAgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIikgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYWwgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWUubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSBcImNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUucjtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS56O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgICAgID0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSAgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgIF0gPSB2YWx1ZS56O1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAzICBdID0gdmFsdWUudztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5VmVydGljZXMgfHwgb2JqZWN0LnNvcnRQYXJ0aWNsZXMgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdmVydGV4QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0TGluZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgaGludCApIHtcclxuXHJcblx0XHR2YXIgdiwgYywgZCwgdmVydGV4LCBvZmZzZXQsIGNvbG9yLFxyXG5cclxuXHRcdHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHRjb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnMsXHJcblx0XHRsaW5lRGlzdGFuY2VzID0gZ2VvbWV0cnkubGluZURpc3RhbmNlcyxcclxuXHJcblx0XHR2bCA9IHZlcnRpY2VzLmxlbmd0aCxcclxuXHRcdGNsID0gY29sb3JzLmxlbmd0aCxcclxuXHRcdGRsID0gbGluZURpc3RhbmNlcy5sZW5ndGgsXHJcblxyXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeS5fX3ZlcnRleEFycmF5LFxyXG5cdFx0Y29sb3JBcnJheSA9IGdlb21ldHJ5Ll9fY29sb3JBcnJheSxcclxuXHRcdGxpbmVEaXN0YW5jZUFycmF5ID0gZ2VvbWV0cnkuX19saW5lRGlzdGFuY2VBcnJheSxcclxuXHJcblx0XHRkaXJ0eVZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlDb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlMaW5lRGlzdGFuY2VzID0gZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUsXHJcblxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCxcclxuXHJcblx0XHRpLCBpbCxcclxuXHRcdGEsIGNhLCBjYWwsIHZhbHVlLFxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlO1xyXG5cclxuXHRcdGlmICggZGlydHlWZXJ0aWNlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyB2IF07XHJcblxyXG5cdFx0XHRcdG9mZnNldCA9IHYgKiAzO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0IF0gICAgID0gdmVydGV4Lng7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHZlcnRleC55O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2ZXJ0ZXguejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5Q29sb3JzICkge1xyXG5cclxuXHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcclxuXHJcblx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbIGMgXTtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ID0gYyAqIDM7XHJcblxyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnI7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY29sb3JBcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5TGluZURpc3RhbmNlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGQgPSAwOyBkIDwgZGw7IGQgKysgKSB7XHJcblxyXG5cdFx0XHRcdGxpbmVEaXN0YW5jZUFycmF5WyBkIF0gPSBsaW5lRGlzdGFuY2VzWyBkIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbGluZURpc3RhbmNlQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSAmJlxyXG5cdFx0XHRcdFx0ICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fFxyXG5cdFx0XHRcdFx0ICAgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApICkge1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0Y2FsID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSAyO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gXCJjXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLnI7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdCA9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxICBdID0gdmFsdWUueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgIF0gPSB2YWx1ZS56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMyAgXSA9IHZhbHVlLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSA0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRNZXNoQnVmZmVycyggZ2VvbWV0cnlHcm91cCwgb2JqZWN0LCBoaW50LCBkaXNwb3NlLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRpZiAoICEgZ2VvbWV0cnlHcm91cC5fX2luaXR0ZWRBcnJheXMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBub3JtYWxUeXBlID0gYnVmZmVyR3Vlc3NOb3JtYWxUeXBlKCBtYXRlcmlhbCApLFxyXG5cdFx0dmVydGV4Q29sb3JUeXBlID0gYnVmZmVyR3Vlc3NWZXJ0ZXhDb2xvclR5cGUoIG1hdGVyaWFsICksXHJcblx0XHR1dlR5cGUgPSBidWZmZXJHdWVzc1VWVHlwZSggbWF0ZXJpYWwgKSxcclxuXHJcblx0XHRuZWVkc1Ntb290aE5vcm1hbHMgPSAoIG5vcm1hbFR5cGUgPT09IFRIUkVFLlNtb290aFNoYWRpbmcgKTtcclxuXHJcblx0XHR2YXIgZiwgZmwsIGZpLCBmYWNlLFxyXG5cdFx0dmVydGV4Tm9ybWFscywgZmFjZU5vcm1hbCwgbm9ybWFsLFxyXG5cdFx0dmVydGV4Q29sb3JzLCBmYWNlQ29sb3IsXHJcblx0XHR2ZXJ0ZXhUYW5nZW50cyxcclxuXHRcdHV2LCB1djIsIHYxLCB2MiwgdjMsIHY0LCB0MSwgdDIsIHQzLCB0NCwgbjEsIG4yLCBuMywgbjQsXHJcblx0XHRjMSwgYzIsIGMzLCBjNCxcclxuXHRcdHN3MSwgc3cyLCBzdzMsIHN3NCxcclxuXHRcdHNpMSwgc2kyLCBzaTMsIHNpNCxcclxuXHRcdHNhMSwgc2EyLCBzYTMsIHNhNCxcclxuXHRcdHNiMSwgc2IyLCBzYjMsIHNiNCxcclxuXHRcdG0sIG1sLCBpLCBpbCxcclxuXHRcdHZuLCB1dmksIHV2MmksXHJcblx0XHR2aywgdmtsLCB2a2EsXHJcblx0XHRua2EsIGNoZiwgZmFjZVZlcnRleE5vcm1hbHMsXHJcblx0XHRhLFxyXG5cclxuXHRcdHZlcnRleEluZGV4ID0gMCxcclxuXHJcblx0XHRvZmZzZXQgPSAwLFxyXG5cdFx0b2Zmc2V0X3V2ID0gMCxcclxuXHRcdG9mZnNldF91djIgPSAwLFxyXG5cdFx0b2Zmc2V0X2ZhY2UgPSAwLFxyXG5cdFx0b2Zmc2V0X25vcm1hbCA9IDAsXHJcblx0XHRvZmZzZXRfdGFuZ2VudCA9IDAsXHJcblx0XHRvZmZzZXRfbGluZSA9IDAsXHJcblx0XHRvZmZzZXRfY29sb3IgPSAwLFxyXG5cdFx0b2Zmc2V0X3NraW4gPSAwLFxyXG5cdFx0b2Zmc2V0X21vcnBoVGFyZ2V0ID0gMCxcclxuXHRcdG9mZnNldF9jdXN0b20gPSAwLFxyXG5cdFx0b2Zmc2V0X2N1c3RvbVNyYyA9IDAsXHJcblxyXG5cdFx0dmFsdWUsXHJcblxyXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fdmVydGV4QXJyYXksXHJcblx0XHR1dkFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3V2QXJyYXksXHJcblx0XHR1djJBcnJheSA9IGdlb21ldHJ5R3JvdXAuX191djJBcnJheSxcclxuXHRcdG5vcm1hbEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5LFxyXG5cdFx0dGFuZ2VudEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3RhbmdlbnRBcnJheSxcclxuXHRcdGNvbG9yQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fY29sb3JBcnJheSxcclxuXHJcblx0XHRza2luSW5kZXhBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19za2luSW5kZXhBcnJheSxcclxuXHRcdHNraW5XZWlnaHRBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19za2luV2VpZ2h0QXJyYXksXHJcblxyXG5cdFx0bW9ycGhUYXJnZXRzQXJyYXlzID0gZ2VvbWV0cnlHcm91cC5fX21vcnBoVGFyZ2V0c0FycmF5cyxcclxuXHRcdG1vcnBoTm9ybWFsc0FycmF5cyA9IGdlb21ldHJ5R3JvdXAuX19tb3JwaE5vcm1hbHNBcnJheXMsXHJcblxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlLFxyXG5cclxuXHRcdGZhY2VBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19mYWNlQXJyYXksXHJcblx0XHRsaW5lQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fbGluZUFycmF5LFxyXG5cclxuXHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LCAvLyB0aGlzIGlzIHNoYXJlZCBmb3IgYWxsIGNodW5rc1xyXG5cclxuXHRcdGRpcnR5VmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUsXHJcblx0XHRkaXJ0eUVsZW1lbnRzID0gZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlVdnMgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlOb3JtYWxzID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUsXHJcblx0XHRkaXJ0eVRhbmdlbnRzID0gZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlDb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlNb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlLFxyXG5cclxuXHRcdHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHRjaHVua19mYWNlczMgPSBnZW9tZXRyeUdyb3VwLmZhY2VzMyxcclxuXHRcdG9ial9mYWNlcyA9IGdlb21ldHJ5LmZhY2VzLFxyXG5cclxuXHRcdG9ial91dnMgID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdLFxyXG5cdFx0b2JqX3V2czIgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAxIF0sXHJcblxyXG5cdFx0b2JqX2NvbG9ycyA9IGdlb21ldHJ5LmNvbG9ycyxcclxuXHJcblx0XHRvYmpfc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcyxcclxuXHRcdG9ial9za2luV2VpZ2h0cyA9IGdlb21ldHJ5LnNraW5XZWlnaHRzLFxyXG5cclxuXHRcdG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyxcclxuXHRcdG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoTm9ybWFscztcclxuXHJcblx0XHRpZiAoIGRpcnR5VmVydGljZXMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdIF07XHJcblxyXG5cdFx0XHRcdHYxID0gdmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHYyID0gdmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdHYzID0gdmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0IF0gICAgID0gdjEueDtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdjEueTtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMiBdID0gdjEuejtcclxuXHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDMgXSA9IHYyLng7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDQgXSA9IHYyLnk7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDUgXSA9IHYyLno7XHJcblxyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA2IF0gPSB2My54O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA3IF0gPSB2My55O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA4IF0gPSB2My56O1xyXG5cclxuXHRcdFx0XHRvZmZzZXQgKz0gOTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHZlcnRleEFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlNb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2ayA9IDAsIHZrbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHZrIDwgdmtsOyB2ayArKyApIHtcclxuXHJcblx0XHRcdFx0b2Zmc2V0X21vcnBoVGFyZ2V0ID0gMDtcclxuXHJcblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNoZiA9IGNodW5rX2ZhY2VzM1sgZiBdO1xyXG5cdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2hmIF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gbW9ycGggcG9zaXRpb25zXHJcblxyXG5cdFx0XHRcdFx0djEgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0djIgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0djMgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRcdHZrYSA9IG1vcnBoVGFyZ2V0c0FycmF5c1sgdmsgXTtcclxuXHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCBdIFx0ICA9IHYxLng7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDEgXSA9IHYxLnk7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDIgXSA9IHYxLno7XHJcblxyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAzIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA0IF0gPSB2Mi55O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA1IF0gPSB2Mi56O1xyXG5cclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNiBdID0gdjMueDtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNyBdID0gdjMueTtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgOCBdID0gdjMuejtcclxuXHJcblx0XHRcdFx0XHQvLyBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG5lZWRzU21vb3RoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHNbIHZrIF0udmVydGV4Tm9ybWFsc1sgY2hmIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdG4xID0gZmFjZVZlcnRleE5vcm1hbHMuYTtcclxuXHRcdFx0XHRcdFx0XHRuMiA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmI7XHJcblx0XHRcdFx0XHRcdFx0bjMgPSBmYWNlVmVydGV4Tm9ybWFscy5jO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bjEgPSBtb3JwaE5vcm1hbHNbIHZrIF0uZmFjZU5vcm1hbHNbIGNoZiBdO1xyXG5cdFx0XHRcdFx0XHRcdG4yID0gbjE7XHJcblx0XHRcdFx0XHRcdFx0bjMgPSBuMTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG5rYSA9IG1vcnBoTm9ybWFsc0FycmF5c1sgdmsgXTtcclxuXHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0IF0gXHQgID0gbjEueDtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAxIF0gPSBuMS55O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDIgXSA9IG4xLno7XHJcblxyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDMgXSA9IG4yLng7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNCBdID0gbjIueTtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA1IF0gPSBuMi56O1xyXG5cclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA2IF0gPSBuMy54O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDcgXSA9IG4zLnk7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgOCBdID0gbjMuejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0XHRvZmZzZXRfbW9ycGhUYXJnZXQgKz0gOTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgdmsgXSApO1xyXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBtb3JwaFRhcmdldHNBcnJheXNbIHZrIF0sIGhpbnQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnNbIHZrIF0gKTtcclxuXHRcdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBtb3JwaE5vcm1hbHNBcnJheXNbIHZrIF0sIGhpbnQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9ial9za2luV2VpZ2h0cy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdXHRdO1xyXG5cclxuXHRcdFx0XHQvLyB3ZWlnaHRzXHJcblxyXG5cdFx0XHRcdHN3MSA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5hIF07XHJcblx0XHRcdFx0c3cyID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRzdzMgPSBvYmpfc2tpbldlaWdodHNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luIF0gICAgID0gc3cxLng7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDEgXSA9IHN3MS55O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAyIF0gPSBzdzEuejtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMyBdID0gc3cxLnc7XHJcblxyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA0IF0gPSBzdzIueDtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNSBdID0gc3cyLnk7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDYgXSA9IHN3Mi56O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA3IF0gPSBzdzIudztcclxuXHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDggXSAgPSBzdzMueDtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHN3My55O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxMCBdID0gc3czLno7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDExIF0gPSBzdzMudztcclxuXHJcblx0XHRcdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdFx0XHRzaTEgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHNpMiA9IG9ial9za2luSW5kaWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0c2kzID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luIF0gICAgID0gc2kxLng7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMSBdID0gc2kxLnk7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMiBdID0gc2kxLno7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMyBdID0gc2kxLnc7XHJcblxyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDQgXSA9IHNpMi54O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDUgXSA9IHNpMi55O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDYgXSA9IHNpMi56O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDcgXSA9IHNpMi53O1xyXG5cclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA4IF0gID0gc2kzLng7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHNpMy55O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDEwIF0gPSBzaTMuejtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxMSBdID0gc2kzLnc7XHJcblxyXG5cdFx0XHRcdG9mZnNldF9za2luICs9IDEyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvZmZzZXRfc2tpbiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlciApO1xyXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBza2luSW5kZXhBcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgc2tpbldlaWdodEFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlDb2xvcnMgJiYgdmVydGV4Q29sb3JUeXBlICkge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcclxuXHJcblx0XHRcdFx0dmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblx0XHRcdFx0ZmFjZUNvbG9yID0gZmFjZS5jb2xvcjtcclxuXHJcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICYmIHZlcnRleENvbG9yVHlwZSA9PT0gVEhSRUUuVmVydGV4Q29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRcdGMxID0gdmVydGV4Q29sb3JzWyAwIF07XHJcblx0XHRcdFx0XHRjMiA9IHZlcnRleENvbG9yc1sgMSBdO1xyXG5cdFx0XHRcdFx0YzMgPSB2ZXJ0ZXhDb2xvcnNbIDIgXTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjMSA9IGZhY2VDb2xvcjtcclxuXHRcdFx0XHRcdGMyID0gZmFjZUNvbG9yO1xyXG5cdFx0XHRcdFx0YzMgPSBmYWNlQ29sb3I7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yIF0gICAgID0gYzEucjtcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAxIF0gPSBjMS5nO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDIgXSA9IGMxLmI7XHJcblxyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDMgXSA9IGMyLnI7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNCBdID0gYzIuZztcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA1IF0gPSBjMi5iO1xyXG5cclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA2IF0gPSBjMy5yO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDcgXSA9IGMzLmc7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgOCBdID0gYzMuYjtcclxuXHJcblx0XHRcdFx0b2Zmc2V0X2NvbG9yICs9IDk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9mZnNldF9jb2xvciA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDb2xvckJ1ZmZlciApO1xyXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjb2xvckFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlUYW5nZW50cyAmJiBnZW9tZXRyeS5oYXNUYW5nZW50cyApIHtcclxuXHJcblx0XHRcdHZhciB0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcclxuXHJcblx0XHRcdFx0dmVydGV4VGFuZ2VudHMgPSBmYWNlLnZlcnRleFRhbmdlbnRzO1xyXG5cclxuXHRcdFx0XHR0MSA9IHZlcnRleFRhbmdlbnRzWyAwIF0gfHwgdG1wO1xyXG5cdFx0XHRcdHQyID0gdmVydGV4VGFuZ2VudHNbIDEgXSB8fCB0bXA7XHJcblx0XHRcdFx0dDMgPSB2ZXJ0ZXhUYW5nZW50c1sgMiBdIHx8IHRtcDtcclxuXHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCBdICAgICA9IHQxLng7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEgXSA9IHQxLnk7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDIgXSA9IHQxLno7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDMgXSA9IHQxLnc7XHJcblxyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA0IF0gPSB0Mi54O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA1IF0gPSB0Mi55O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA2IF0gPSB0Mi56O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA3IF0gPSB0Mi53O1xyXG5cclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgOCBdICA9IHQzLng7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDkgXSAgPSB0My55O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxMCBdID0gdDMuejtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMTEgXSA9IHQzLnc7XHJcblxyXG5cdFx0XHRcdG9mZnNldF90YW5nZW50ICs9IDEyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFRhbmdlbnRCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHRhbmdlbnRBcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5Tm9ybWFscyAmJiBub3JtYWxUeXBlICkge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcclxuXHJcblx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHRcdFx0XHRmYWNlTm9ybWFsID0gZmFjZS5ub3JtYWw7XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgJiYgbmVlZHNTbW9vdGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZuID0gdmVydGV4Tm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgXSAgICAgPSB2bi54O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDEgXSA9IHZuLnk7XHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMiBdID0gdm4uejtcclxuXHJcblx0XHRcdFx0XHRcdG9mZnNldF9ub3JtYWwgKz0gMztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgXSAgICAgPSBmYWNlTm9ybWFsLng7XHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMSBdID0gZmFjZU5vcm1hbC55O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDIgXSA9IGZhY2VOb3JtYWwuejtcclxuXHJcblx0XHRcdFx0XHRcdG9mZnNldF9ub3JtYWwgKz0gMztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG5vcm1hbEFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlVdnMgJiYgb2JqX3V2cyAmJiB1dlR5cGUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZpID0gY2h1bmtfZmFjZXMzWyBmIF07XHJcblxyXG5cdFx0XHRcdHV2ID0gb2JqX3V2c1sgZmkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCB1diA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1dmkgPSB1dlsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHV2QXJyYXlbIG9mZnNldF91diBdICAgICA9IHV2aS54O1xyXG5cdFx0XHRcdFx0dXZBcnJheVsgb2Zmc2V0X3V2ICsgMSBdID0gdXZpLnk7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0X3V2ICs9IDI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2Zmc2V0X3V2ID4gMCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWQnVmZmVyICk7XHJcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHV2QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eVV2cyAmJiBvYmpfdXZzMiAmJiB1dlR5cGUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZpID0gY2h1bmtfZmFjZXMzWyBmIF07XHJcblxyXG5cdFx0XHRcdHV2MiA9IG9ial91dnMyWyBmaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHV2MiA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1djJpID0gdXYyWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0dXYyQXJyYXlbIG9mZnNldF91djIgXSAgICAgPSB1djJpLng7XHJcblx0XHRcdFx0XHR1djJBcnJheVsgb2Zmc2V0X3V2MiArIDEgXSA9IHV2MmkueTtcclxuXHJcblx0XHRcdFx0XHRvZmZzZXRfdXYyICs9IDI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2Zmc2V0X3V2MiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVjJCdWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdXYyQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eUVsZW1lbnRzICkge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlIF0gXHQgPSB2ZXJ0ZXhJbmRleDtcclxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlICsgMSBdID0gdmVydGV4SW5kZXggKyAxO1xyXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAyIF0gPSB2ZXJ0ZXhJbmRleCArIDI7XHJcblxyXG5cdFx0XHRcdG9mZnNldF9mYWNlICs9IDM7XHJcblxyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgXSAgICAgPSB2ZXJ0ZXhJbmRleDtcclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMSBdID0gdmVydGV4SW5kZXggKyAxO1xyXG5cclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMiBdID0gdmVydGV4SW5kZXg7XHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDMgXSA9IHZlcnRleEluZGV4ICsgMjtcclxuXHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDQgXSA9IHZlcnRleEluZGV4ICsgMTtcclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgNSBdID0gdmVydGV4SW5kZXggKyAyO1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfbGluZSArPSA2O1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhJbmRleCArPSAzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbGluZUFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGN1c3RvbUF0dHJpYnV0ZS5fX29yaWdpbmFsLm5lZWRzVXBkYXRlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdG9mZnNldF9jdXN0b20gPSAwO1xyXG5cdFx0XHRcdG9mZnNldF9jdXN0b21TcmMgPSAwO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJ2ZXJ0aWNlc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwiZmFjZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAzO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcInZlcnRpY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdXHRdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IHYxLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjEueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdjIueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2Mi55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0IF0gPSB2My54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYzLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gNjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJmYWNlc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2MS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYyLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjIueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjMueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2My55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDY7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgcHA7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gXCJjXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwcCA9IFsgXCJyXCIsIFwiZ1wiLCBcImJcIiBdO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwcCA9IFsgXCJ4XCIsIFwieVwiLCBcInpcIiBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XHJcblx0XHRcdFx0XHRcdFx0djMgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjFbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MVsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYxWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjJbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2MlsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2M1sgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgXSA9IHYzWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCBdID0gdjNbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA5O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcImZhY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IHYxWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjFbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2MVsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2MlsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYyWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjJbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiBdID0gdjNbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2M1sgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggXSA9IHYzWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gOTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJmYWNlVmVydGljZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gdmFsdWVbIDAgXTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlWyAxIF07XHJcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZVsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjFbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MVsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYxWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjJbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2MlsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2M1sgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgXSA9IHYzWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCBdID0gdjNbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA5O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcInZlcnRpY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdXHRdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICBdIFx0PSB2MS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MS55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MS53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1ICBdID0gdjIueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjIuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHYzLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHYzLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTI7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwiZmFjZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gXHQ9IHYxLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiAgXSA9IHYxLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyAgXSA9IHYxLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2Mi55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgIF0gPSB2Mi53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA5ICBdID0gdjMueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMCBdID0gdjMuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAxMjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJmYWNlVmVydGljZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gdmFsdWVbIDAgXTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlWyAxIF07XHJcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZVsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gXHQ9IHYxLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiAgXSA9IHYxLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyAgXSA9IHYxLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2Mi55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgIF0gPSB2Mi53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA5ICBdID0gdjMueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMCBdID0gdjMuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAxMjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5idWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlzcG9zZSApIHtcclxuXHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9faW5pdHRlZEFycmF5cztcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19jb2xvckFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3RhbmdlbnRBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX191dkFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3V2MkFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX2ZhY2VBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX192ZXJ0ZXhBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19saW5lQXJyYXk7XHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9fc2tpbkluZGV4QXJyYXk7XHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9fc2tpbldlaWdodEFycmF5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gdXNlZCBieSByZW5kZXJCdWZmZXJEaXJlY3QgZm9yIFRIUkVFLkxpbmVcclxuXHRmdW5jdGlvbiBzZXR1cExpbmVzVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW1BdHRyaWJ1dGVzLCBnZW9tZXRyeUF0dHJpYnV0ZXMsIHN0YXJ0SW5kZXggKSB7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZUl0ZW0sIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVBvaW50ZXIsIGF0dHJpYnV0ZVNpemU7XHJcblxyXG5cdFx0Zm9yICggYXR0cmlidXRlTmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZVBvaW50ZXIgPSBwcm9ncmFtQXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdO1xyXG5cdFx0XHRhdHRyaWJ1dGVJdGVtID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBhdHRyaWJ1dGVOYW1lIF07XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZVBvaW50ZXIgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVJdGVtICkge1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZVNpemUgPSBhdHRyaWJ1dGVJdGVtLml0ZW1TaXplO1xyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZUl0ZW0uYnVmZmVyICk7XHJcblx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZVBvaW50ZXIgKTtcclxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVQb2ludGVyLCBhdHRyaWJ1dGVTaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogYXR0cmlidXRlU2l6ZSAqIDQgKTsgLy8gNCBieXRlcyBwZXIgRmxvYXQzMlxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgYXR0cmlidXRlTmFtZSBdLmxlbmd0aCA9PT0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIGF0dHJpYnV0ZVBvaW50ZXIsIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIGF0dHJpYnV0ZU5hbWUgXSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIGF0dHJpYnV0ZU5hbWUgXS5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliM2Z2KCBhdHRyaWJ1dGVQb2ludGVyLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBhdHRyaWJ1dGVOYW1lIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0RGlyZWN0QnVmZmVycyggZ2VvbWV0cnksIGhpbnQgKSB7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVJdGVtO1xyXG5cclxuXHRcdGZvciAoIGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZUl0ZW0gPSBhdHRyaWJ1dGVzWyBhdHRyaWJ1dGVOYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZUl0ZW0ubmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlTmFtZSA9PT0gJ2luZGV4JyApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGVJdGVtLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYXR0cmlidXRlSXRlbS5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGVJdGVtLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZUl0ZW0uYXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGVJdGVtLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIEJ1ZmZlciByZW5kZXJpbmdcclxuXHJcblx0dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICYmICEgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSBvYmplY3QuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgJiYgISBvYmplY3QuX193ZWJnbE5vcm1hbEJ1ZmZlciApIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgb2JqZWN0Ll9fd2ViZ2xVdkJ1ZmZlciApIG9iamVjdC5fX3dlYmdsVXZCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBvYmplY3QuX193ZWJnbENvbG9yQnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xDb2xvckJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblx0XHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggcHJvZ3JhbS5hdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtLmF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbE5vcm1hbEJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG54LCBueSwgbnosXHJcblx0XHRcdFx0XHRuYXgsIG5ieCwgbmN4LCBuYXksIG5ieSwgbmN5LCBuYXosIG5ieiwgbmN6LFxyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXksXHJcblx0XHRcdFx0XHRpLCBpbCA9IG9iamVjdC5jb3VudCAqIDM7XHJcblxyXG5cdFx0XHRcdGZvciggaSA9IDA7IGkgPCBpbDsgaSArPSA5ICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xyXG5cclxuXHRcdFx0XHRcdG5heCAgPSBub3JtYWxBcnJheVsgaSBdO1xyXG5cdFx0XHRcdFx0bmF5ICA9IG5vcm1hbEFycmF5WyBpICsgMSBdO1xyXG5cdFx0XHRcdFx0bmF6ICA9IG5vcm1hbEFycmF5WyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdG5ieCAgPSBub3JtYWxBcnJheVsgaSArIDMgXTtcclxuXHRcdFx0XHRcdG5ieSAgPSBub3JtYWxBcnJheVsgaSArIDQgXTtcclxuXHRcdFx0XHRcdG5ieiAgPSBub3JtYWxBcnJheVsgaSArIDUgXTtcclxuXHJcblx0XHRcdFx0XHRuY3ggID0gbm9ybWFsQXJyYXlbIGkgKyA2IF07XHJcblx0XHRcdFx0XHRuY3kgID0gbm9ybWFsQXJyYXlbIGkgKyA3IF07XHJcblx0XHRcdFx0XHRuY3ogID0gbm9ybWFsQXJyYXlbIGkgKyA4IF07XHJcblxyXG5cdFx0XHRcdFx0bnggPSAoIG5heCArIG5ieCArIG5jeCApIC8gMztcclxuXHRcdFx0XHRcdG55ID0gKCBuYXkgKyBuYnkgKyBuY3kgKSAvIDM7XHJcblx0XHRcdFx0XHRueiA9ICggbmF6ICsgbmJ6ICsgbmN6ICkgLyAzO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpIF0gXHQgPSBueDtcclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgMSBdID0gbnk7XHJcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDIgXSA9IG56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgMyBdID0gbng7XHJcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDQgXSA9IG55O1xyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyA1IF0gPSBuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDYgXSA9IG54O1xyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyA3IF0gPSBueTtcclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgOCBdID0gbno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBwcm9ncmFtLmF0dHJpYnV0ZXMubm9ybWFsICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtLmF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xVdkJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBwcm9ncmFtLmF0dHJpYnV0ZXMudXYgKTtcclxuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW0uYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbENvbG9yQnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIHByb2dyYW0uYXR0cmlidXRlcy5jb2xvciApO1xyXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbS5hdHRyaWJ1dGVzLmNvbG9yLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcclxuXHJcblx0XHRvYmplY3QuY291bnQgPSAwO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIGdlb21ldHJ5LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHR2YXIgbGluZXdpZHRoLCBhLCBhdHRyaWJ1dGU7XHJcblx0XHR2YXIgYXR0cmlidXRlSXRlbSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlUG9pbnRlciwgYXR0cmlidXRlU2l6ZTtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXM7XHJcblx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcblx0XHR2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlLFxyXG5cdFx0XHR3aXJlZnJhbWVCaXQgPSBtYXRlcmlhbC53aXJlZnJhbWUgPyAxIDogMCxcclxuXHRcdFx0Z2VvbWV0cnlIYXNoID0gKCBnZW9tZXRyeS5pZCAqIDB4ZmZmZmZmICkgKyAoIHByb2dyYW0uaWQgKiAyICkgKyB3aXJlZnJhbWVCaXQ7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeUhhc2ggIT09IF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggKSB7XHJcblxyXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gZ2VvbWV0cnlIYXNoO1xyXG5cdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0ZGlzYWJsZUF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVuZGVyIG1lc2hcclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIFwiaW5kZXhcIiBdO1xyXG5cclxuXHRcdFx0Ly8gaW5kZXhlZCB0cmlhbmdsZXNcclxuXHJcblx0XHRcdGlmICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcclxuXHJcblx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIDEgY2h1bmtcclxuXHRcdFx0XHQvLyBtdXN0IHNldCBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gdXNlIG5ldyBvZmZzZXRzIGZvciBlYWNoIGNodW5rXHJcblx0XHRcdFx0Ly8gZXZlbiBpZiBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzIGRpZG4ndCBjaGFuZ2VcclxuXHJcblx0XHRcdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA+IDEgKSB1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHN0YXJ0SW5kZXggPSBvZmZzZXRzWyBpIF0uaW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggYXR0cmlidXRlTmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0YXR0cmlidXRlUG9pbnRlciA9IHByb2dyYW1BdHRyaWJ1dGVzWyBhdHRyaWJ1dGVOYW1lIF07XHJcblx0XHRcdFx0XHRcdFx0YXR0cmlidXRlSXRlbSA9IGdlb21ldHJ5QXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZVBvaW50ZXIgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZUl0ZW0gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlSXRlbS5pdGVtU2l6ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZUl0ZW0uYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlUG9pbnRlciApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlUG9pbnRlciwgYXR0cmlidXRlU2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgc3RhcnRJbmRleCAqIGF0dHJpYnV0ZVNpemUgKiA0ICk7IC8vIDQgYnl0ZXMgcGVyIEZsb2F0MzJcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBhdHRyaWJ1dGVOYW1lIF0ubGVuZ3RoID09PSAyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliMmZ2KCBhdHRyaWJ1dGVQb2ludGVyLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBhdHRyaWJ1dGVOYW1lIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIGF0dHJpYnV0ZU5hbWUgXS5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIGF0dHJpYnV0ZVBvaW50ZXIsIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIGF0dHJpYnV0ZU5hbWUgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHJlbmRlciBpbmRleGVkIHRyaWFuZ2xlc1xyXG5cclxuXHRcdFx0XHRcdF9nbC5kcmF3RWxlbWVudHMoIF9nbC5UUklBTkdMRVMsIG9mZnNldHNbIGkgXS5jb3VudCwgX2dsLlVOU0lHTkVEX1NIT1JULCBvZmZzZXRzWyBpIF0uc3RhcnQgKiAyICk7IC8vIDIgYnl0ZXMgcGVyIFVpbnQxNlxyXG5cclxuXHRcdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gb2Zmc2V0c1sgaSBdLmNvdW50OyAvLyBub3QgcmVhbGx5IHRydWUsIGhlcmUgdmVydGljZXMgY2FuIGJlIHNoYXJlZFxyXG5cdFx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gb2Zmc2V0c1sgaSBdLmNvdW50IC8gMztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbm9uLWluZGV4ZWQgdHJpYW5nbGVzXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggYXR0cmlidXRlTmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggYXR0cmlidXRlTmFtZSA9PT0gJ2luZGV4JykgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVQb2ludGVyID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXTtcclxuXHRcdFx0XHRcdFx0YXR0cmlidXRlSXRlbSA9IGdlb21ldHJ5QXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdO1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVQb2ludGVyID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggYXR0cmlidXRlSXRlbSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlSXRlbS5pdGVtU2l6ZTtcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGVJdGVtLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVQb2ludGVyICk7XHJcblx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlUG9pbnRlciwgYXR0cmlidXRlU2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzICYmIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIGF0dHJpYnV0ZU5hbWUgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIGF0dHJpYnV0ZU5hbWUgXS5sZW5ndGggPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliMmZ2KCBhdHRyaWJ1dGVQb2ludGVyLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBhdHRyaWJ1dGVOYW1lIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBhdHRyaWJ1dGVOYW1lIF0ubGVuZ3RoID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjNmdiggYXR0cmlidXRlUG9pbnRlciwgbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgYXR0cmlidXRlTmFtZSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdO1xyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgbm9uLWluZGV4ZWQgdHJpYW5nbGVzXHJcblxyXG5cdFx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBwb3NpdGlvbi5hcnJheS5sZW5ndGggLyAzICk7XHJcblxyXG5cdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7XHJcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gMyAvIDM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0Ly8gcmVuZGVyIHBhcnRpY2xlc1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkge1xyXG5cclxuXHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBhdHRyaWJ1dGVOYW1lIGluIHByb2dyYW1BdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZVBvaW50ZXIgPSBwcm9ncmFtQXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdO1xyXG5cdFx0XHRcdFx0YXR0cmlidXRlSXRlbSA9IGdlb21ldHJ5QXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZVBvaW50ZXIgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggYXR0cmlidXRlSXRlbSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0YXR0cmlidXRlU2l6ZSA9IGF0dHJpYnV0ZUl0ZW0uaXRlbVNpemU7XHJcblx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZUl0ZW0uYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVQb2ludGVyICk7XHJcblx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZVBvaW50ZXIsIGF0dHJpYnV0ZVNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgJiYgbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgYXR0cmlidXRlTmFtZSBdICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIGF0dHJpYnV0ZU5hbWUgXS5sZW5ndGggPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjJmdiggYXR0cmlidXRlUG9pbnRlciwgbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgYXR0cmlidXRlTmFtZSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIGF0dHJpYnV0ZU5hbWUgXS5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjNmdiggYXR0cmlidXRlUG9pbnRlciwgbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgYXR0cmlidXRlTmFtZSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5QXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF07XHJcblxyXG5cdFx0XHQvLyByZW5kZXIgcGFydGljbGVzXHJcblxyXG5cdFx0XHRfZ2wuZHJhd0FycmF5cyggX2dsLlBPSU5UUywgMCwgcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gMyApO1xyXG5cclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnBvaW50cyArPSBwb3NpdGlvbi5hcnJheS5sZW5ndGggLyAzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG5cdFx0XHR2YXIgcHJpbWl0aXZlcyA9ICggb2JqZWN0LnR5cGUgPT09IFRIUkVFLkxpbmVTdHJpcCApID8gX2dsLkxJTkVfU1RSSVAgOiBfZ2wuTElORVM7XHJcblxyXG5cdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBcImluZGV4XCIgXTtcclxuXHJcblx0XHRcdC8vIGluZGV4ZWQgbGluZXNcclxuXHRcdFx0XHJcblx0XHRcdGlmICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcclxuXHJcblx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIDEgY2h1bmtcclxuXHRcdFx0XHQvLyBtdXN0IHNldCBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gdXNlIG5ldyBvZmZzZXRzIGZvciBlYWNoIGNodW5rXHJcblx0XHRcdFx0Ly8gZXZlbiBpZiBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzIGRpZG4ndCBjaGFuZ2VcclxuXHJcblx0XHRcdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA+IDEgKSB1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHN0YXJ0SW5kZXggPSBvZmZzZXRzWyBpIF0uaW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2V0dXBMaW5lc1ZlcnRleEF0dHJpYnV0ZXMobWF0ZXJpYWwsIHByb2dyYW1BdHRyaWJ1dGVzLCBnZW9tZXRyeUF0dHJpYnV0ZXMsIHN0YXJ0SW5kZXgpO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gaW5kaWNlc1xyXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleC5idWZmZXIgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIGluZGV4ZWQgbGluZXNcclxuXHJcblx0XHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuTElORVMsIG9mZnNldHNbIGkgXS5jb3VudCwgX2dsLlVOU0lHTkVEX1NIT1JULCBvZmZzZXRzWyBpIF0uc3RhcnQgKiAyICk7IC8vIDIgYnl0ZXMgcGVyIFVpbnQxNkFycmF5XHJcblxyXG5cdFx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBvZmZzZXRzWyBpIF0uY291bnQ7IC8vIG5vdCByZWFsbHkgdHJ1ZSwgaGVyZSB2ZXJ0aWNlcyBjYW4gYmUgc2hhcmVkXHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG5vbi1pbmRleGVkIGxpbmVzXHJcblxyXG5cdFx0XHRlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdHNldHVwTGluZXNWZXJ0ZXhBdHRyaWJ1dGVzKG1hdGVyaWFsLCBwcm9ncmFtQXR0cmlidXRlcywgZ2VvbWV0cnlBdHRyaWJ1dGVzLCAwKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5QXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF07XHJcblxyXG5cdFx0XHRcdF9nbC5kcmF3QXJyYXlzKCBwcmltaXRpdmVzLCAwLCBwb3NpdGlvbi5hcnJheS5sZW5ndGggLyAzICk7XHJcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cclxuXHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlbmRlckJ1ZmZlciA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciBsaW5ld2lkdGgsIGEsIGF0dHJpYnV0ZSwgaSwgaWw7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZSxcclxuXHRcdFx0d2lyZWZyYW1lQml0ID0gbWF0ZXJpYWwud2lyZWZyYW1lID8gMSA6IDAsXHJcblx0XHRcdGdlb21ldHJ5R3JvdXBIYXNoID0gKCBnZW9tZXRyeUdyb3VwLmlkICogMHhmZmZmZmYgKSArICggcHJvZ3JhbS5pZCAqIDIgKSArIHdpcmVmcmFtZUJpdDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5R3JvdXBIYXNoICE9PSBfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoICkge1xyXG5cclxuXHRcdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IGdlb21ldHJ5R3JvdXBIYXNoO1xyXG5cdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0ZGlzYWJsZUF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdmVydGljZXNcclxuXHJcblx0XHRpZiAoICFtYXRlcmlhbC5tb3JwaFRhcmdldHMgJiYgYXR0cmlidXRlcy5wb3NpdGlvbiA+PSAwICkge1xyXG5cclxuXHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QubW9ycGhUYXJnZXRCYXNlICkge1xyXG5cclxuXHRcdFx0XHRzZXR1cE1vcnBoVGFyZ2V0cyggbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0Ly8gY3VzdG9tIGF0dHJpYnV0ZXNcclxuXHJcblx0XHRcdC8vIFVzZSB0aGUgcGVyLWdlb21ldHJ5R3JvdXAgY3VzdG9tIGF0dHJpYnV0ZSBhcnJheXMgd2hpY2ggYXJlIHNldHVwIGluIGluaXRNZXNoQnVmZmVyc1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlID0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3RbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlIF0gPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGUuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgYXR0cmlidXRlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGUgXSApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgYXR0cmlidXRlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGUgXSwgYXR0cmlidXRlLnNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHQvLyBjb2xvcnNcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlcy5jb2xvciA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeS5jb2xvcnMubGVuZ3RoID4gMCB8fCBvYmplY3QuZ2VvbWV0cnkuZmFjZXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5jb2xvciApO1xyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyApIHtcclxuXHJcblxyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjNmdiggYXR0cmlidXRlcy5jb2xvciwgbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcy5jb2xvciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBub3JtYWxzXHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcclxuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0YW5nZW50c1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLnRhbmdlbnQgPj0gMCApIHtcclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVGFuZ2VudEJ1ZmZlciApO1xyXG5cdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy50YW5nZW50ICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudGFuZ2VudCwgNCwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdXZzXHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QuZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1swXSApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgKTtcclxuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyApIHtcclxuXHJcblxyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjJmdiggYXR0cmlidXRlcy51diwgbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcy51diApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYyID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbMV0gKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWMkJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2MiApO1xyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYyLCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgKSB7XHJcblxyXG5cclxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIGF0dHJpYnV0ZXMudXYyLCBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzLnV2MiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICYmXHJcblx0XHRcdFx0IGF0dHJpYnV0ZXMuc2tpbkluZGV4ID49IDAgJiYgYXR0cmlidXRlcy5za2luV2VpZ2h0ID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlciApO1xyXG5cdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5za2luSW5kZXggKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5za2luSW5kZXgsIDQsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnNraW5XZWlnaHQgKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5za2luV2VpZ2h0LCA0LCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBsaW5lIGRpc3RhbmNlc1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZURpc3RhbmNlQnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSApO1xyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSwgMSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZW5kZXIgbWVzaFxyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdC8vIHdpcmVmcmFtZVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgKSB7XHJcblxyXG5cdFx0XHRcdHNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICk7XHJcblxyXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVCdWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuTElORVMsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVDb3VudCwgX2dsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cdFx0XHQvLyB0cmlhbmdsZXNcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VCdWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuVFJJQU5HTEVTLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQ291bnQsIF9nbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VDb3VudDtcclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50IC8gMztcclxuXHJcblx0XHQvLyByZW5kZXIgbGluZXNcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0dmFyIHByaW1pdGl2ZXMgPSAoIG9iamVjdC50eXBlID09PSBUSFJFRS5MaW5lU3RyaXAgKSA/IF9nbC5MSU5FX1NUUklQIDogX2dsLkxJTkVTO1xyXG5cclxuXHRcdFx0c2V0TGluZVdpZHRoKCBtYXRlcmlhbC5saW5ld2lkdGggKTtcclxuXHJcblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBwcmltaXRpdmVzLCAwLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQ291bnQgKTtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xyXG5cclxuXHRcdC8vIHJlbmRlciBwYXJ0aWNsZXNcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuUE9JTlRTLCAwLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xQYXJ0aWNsZUNvdW50ICk7XHJcblxyXG5cdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IGdlb21ldHJ5R3JvdXAuX193ZWJnbFBhcnRpY2xlQ291bnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRpZiAoIF9lbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XHJcblxyXG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRfZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGRpc2FibGVBdHRyaWJ1dGVzKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBhdHRyaWJ1dGUgaW4gX2VuYWJsZWRBdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0aWYgKCBfZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcclxuXHRcdFx0XHRfZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldHVwTW9ycGhUYXJnZXRzICggbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApIHtcclxuXHJcblx0XHQvLyBzZXQgYmFzZVxyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gbWF0ZXJpYWwucHJvZ3JhbS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSAhPT0gLTEgJiYgYXR0cmlidXRlcy5wb3NpdGlvbiA+PSAwICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbIG9iamVjdC5tb3JwaFRhcmdldEJhc2UgXSApO1xyXG5cdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uID49IDAgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICk7XHJcblx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xyXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEZvcmNlZE9yZGVyLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdC8vIHNldCBmb3JjZWQgb3JkZXJcclxuXHJcblx0XHRcdHZhciBtID0gMDtcclxuXHRcdFx0dmFyIG9yZGVyID0gb2JqZWN0Lm1vcnBoVGFyZ2V0Rm9yY2VkT3JkZXI7XHJcblx0XHRcdHZhciBpbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuXHJcblx0XHRcdHdoaWxlICggbSA8IG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyAmJiBtIDwgb3JkZXIubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIFwibW9ycGhUYXJnZXRcIiArIG0gXSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyBvcmRlclsgbSBdIF0gKTtcclxuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdICk7XHJcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyBcIm1vcnBoTm9ybWFsXCIgKyBtIF0gPj0gMCAmJiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnNbIG9yZGVyWyBtIF0gXSApO1xyXG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBcIm1vcnBoTm9ybWFsXCIgKyBtIF0gKTtcclxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyBcIm1vcnBoTm9ybWFsXCIgKyBtIF0sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgbSBdID0gaW5mbHVlbmNlc1sgb3JkZXJbIG0gXSBdO1xyXG5cclxuXHRcdFx0XHRtICsrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGZpbmQgdGhlIG1vc3QgaW5mbHVlbmNpbmdcclxuXHJcblx0XHRcdHZhciBpbmZsdWVuY2UsIGFjdGl2ZUluZmx1ZW5jZUluZGljZXMgPSBbXTtcclxuXHRcdFx0dmFyIGluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xyXG5cdFx0XHR2YXIgaSwgaWwgPSBpbmZsdWVuY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGluZmx1ZW5jZSA9IGluZmx1ZW5jZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmZsdWVuY2UgPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMucHVzaCggWyBpbmZsdWVuY2UsIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGFjdGl2ZUluZmx1ZW5jZUluZGljZXMubGVuZ3RoID4gbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLnNvcnQoIG51bWVyaWNhbFNvcnQgKTtcclxuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLmxlbmd0aCA9IG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGFjdGl2ZUluZmx1ZW5jZUluZGljZXMubGVuZ3RoID4gbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLnNvcnQoIG51bWVyaWNhbFNvcnQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGFjdGl2ZUluZmx1ZW5jZUluZGljZXMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLnB1c2goIFsgMCwgMCBdICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dmFyIGluZmx1ZW5jZUluZGV4LCBtID0gMDtcclxuXHJcblx0XHRcdHdoaWxlICggbSA8IG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhY3RpdmVJbmZsdWVuY2VJbmRpY2VzWyBtIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0aW5mbHVlbmNlSW5kZXggPSBhY3RpdmVJbmZsdWVuY2VJbmRpY2VzWyBtIF1bIDEgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIFwibW9ycGhUYXJnZXRcIiArIG0gXSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbIGluZmx1ZW5jZUluZGV4IF0gKTtcclxuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBcIm1vcnBoVGFyZ2V0XCIgKyBtIF0gKTtcclxuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIFwibW9ycGhUYXJnZXRcIiArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIFwibW9ycGhOb3JtYWxcIiArIG0gXSA+PSAwICYmIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzWyBpbmZsdWVuY2VJbmRleCBdICk7XHJcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgXCJtb3JwaE5vcm1hbFwiICsgbSBdICk7XHJcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyBcIm1vcnBoTm9ybWFsXCIgKyBtIF0sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBtIF0gPSBpbmZsdWVuY2VzWyBpbmZsdWVuY2VJbmRleCBdO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8qXHJcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgXCJtb3JwaE5vcm1hbFwiICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgbSBdID0gMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtICsrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBsb2FkIHVwZGF0ZWQgaW5mbHVlbmNlcyB1bmlmb3JtXHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5wcm9ncmFtLnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdF9nbC51bmlmb3JtMWZ2KCBtYXRlcmlhbC5wcm9ncmFtLnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcywgb2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFNvcnRpbmdcclxuXHJcblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xyXG5cclxuXHRcdGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYi56IC0gYS56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBudW1lcmljYWxTb3J0ICggYSwgYiApIHtcclxuXHJcblx0XHRyZXR1cm4gYlsgMCBdIC0gYVsgMCBdO1xyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0Ly8gUmVuZGVyaW5nXHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XHJcblxyXG5cdFx0aWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0VEhSRUUub25lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGksIGlsLFxyXG5cclxuXHRcdHdlYmdsT2JqZWN0LCBvYmplY3QsXHJcblx0XHRyZW5kZXJMaXN0LFxyXG5cclxuXHRcdGxpZ2h0cyA9IHNjZW5lLl9fbGlnaHRzLFxyXG5cdFx0Zm9nID0gc2NlbmUuZm9nO1xyXG5cclxuXHRcdC8vIHJlc2V0IGNhY2hpbmcgZm9yIHRoaXMgZnJhbWVcclxuXHJcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtMTtcclxuXHRcdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcclxuXHJcblx0XHRpZiAoIHNjZW5lLmF1dG9VcGRhdGUgPT09IHRydWUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcblx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IHVuZGVmaW5lZCApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIFdlYkdMIG9iamVjdHNcclxuXHJcblx0XHRpZiAoIHRoaXMuYXV0b1VwZGF0ZU9iamVjdHMgKSB0aGlzLmluaXRXZWJHTE9iamVjdHMoIHNjZW5lICk7XHJcblxyXG5cdFx0Ly8gY3VzdG9tIHJlbmRlciBwbHVnaW5zIChwcmUgcGFzcylcclxuXHJcblx0XHRyZW5kZXJQbHVnaW5zKCB0aGlzLnJlbmRlclBsdWdpbnNQcmUsIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzID0gMDtcclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzID0gMDtcclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzID0gMDtcclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLnBvaW50cyA9IDA7XHJcblxyXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcclxuXHJcblx0XHRcdHRoaXMuY2xlYXIoIHRoaXMuYXV0b0NsZWFyQ29sb3IsIHRoaXMuYXV0b0NsZWFyRGVwdGgsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZXQgbWF0cmljZXMgZm9yIHJlZ3VsYXIgb2JqZWN0cyAoZnJ1c3R1bSBjdWxsZWQpXHJcblxyXG5cdFx0cmVuZGVyTGlzdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGkgXTtcclxuXHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QuaWQgPSBpO1xyXG5cdFx0XHR3ZWJnbE9iamVjdC5yZW5kZXIgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gKSB8fCAhICggb2JqZWN0LmZydXN0dW1DdWxsZWQgKSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApIHtcclxuXHJcblx0XHRcdFx0XHRzZXR1cE1hdHJpY2VzKCBvYmplY3QsIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0XHRcdHVucm9sbEJ1ZmZlck1hdGVyaWFsKCB3ZWJnbE9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdHdlYmdsT2JqZWN0LnJlbmRlciA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBvYmplY3QucmVuZGVyRGVwdGggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHdlYmdsT2JqZWN0LnogPSBvYmplY3QucmVuZGVyRGVwdGg7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0d2ViZ2xPYmplY3QueiA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5zb3J0T2JqZWN0cyApIHtcclxuXHJcblx0XHRcdHJlbmRlckxpc3Quc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IG1hdHJpY2VzIGZvciBpbW1lZGlhdGUgb2JqZWN0c1xyXG5cclxuXHRcdHJlbmRlckxpc3QgPSBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZTtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBpIF07XHJcblx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdHNldHVwTWF0cmljZXMoIG9iamVjdCwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHRcdHVucm9sbEltbWVkaWF0ZUJ1ZmZlck1hdGVyaWFsKCB3ZWJnbE9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xyXG5cdFx0XHR0aGlzLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XHJcblx0XHRcdHRoaXMuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cdFx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdHMoIHNjZW5lLl9fd2ViZ2xPYmplY3RzLCBmYWxzZSwgXCJcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgdHJ1ZSwgbWF0ZXJpYWwgKTtcclxuXHRcdFx0cmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsIFwiXCIsIGNhbWVyYSwgbGlnaHRzLCBmb2csIGZhbHNlLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHRcdFx0Ly8gb3BhcXVlIHBhc3MgKGZyb250LXRvLWJhY2sgb3JkZXIpXHJcblxyXG5cdFx0XHR0aGlzLnNldEJsZW5kaW5nKCBUSFJFRS5Ob0JsZW5kaW5nICk7XHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCBzY2VuZS5fX3dlYmdsT2JqZWN0cywgdHJ1ZSwgXCJvcGFxdWVcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgZmFsc2UsIG1hdGVyaWFsICk7XHJcblx0XHRcdHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCBcIm9wYXF1ZVwiLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBmYWxzZSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCBzY2VuZS5fX3dlYmdsT2JqZWN0cywgZmFsc2UsIFwidHJhbnNwYXJlbnRcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgdHJ1ZSwgbWF0ZXJpYWwgKTtcclxuXHRcdFx0cmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsIFwidHJhbnNwYXJlbnRcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgdHJ1ZSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY3VzdG9tIHJlbmRlciBwbHVnaW5zIChwb3N0IHBhc3MpXHJcblxyXG5cdFx0cmVuZGVyUGx1Z2lucyggdGhpcy5yZW5kZXJQbHVnaW5zUG9zdCwgc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHJcblx0XHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgJiYgcmVuZGVyVGFyZ2V0Lm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG5cdFx0XHR1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxyXG5cclxuXHRcdHRoaXMuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblx0XHR0aGlzLnNldERlcHRoV3JpdGUoIHRydWUgKTtcclxuXHJcblx0XHQvLyBfZ2wuZmluaXNoKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlclBsdWdpbnMoIHBsdWdpbnMsIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCAhIHBsdWdpbnMubGVuZ3RoICkgcmV0dXJuO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwbHVnaW5zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgc3RhdGUgZm9yIHBsdWdpbiAodG8gc3RhcnQgZnJvbSBjbGVhbiBzbGF0ZSlcclxuXHJcblx0XHRcdF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XHJcblx0XHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcblx0XHRcdF9vbGRCbGVuZGluZyA9IC0xO1xyXG5cdFx0XHRfb2xkRGVwdGhUZXN0ID0gLTE7XHJcblx0XHRcdF9vbGREZXB0aFdyaXRlID0gLTE7XHJcblx0XHRcdF9vbGREb3VibGVTaWRlZCA9IC0xO1xyXG5cdFx0XHRfb2xkRmxpcFNpZGVkID0gLTE7XHJcblx0XHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcclxuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XHJcblxyXG5cdFx0XHRfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRwbHVnaW5zWyBpIF0ucmVuZGVyKCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFdpZHRoLCBfY3VycmVudEhlaWdodCApO1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgc3RhdGUgYWZ0ZXIgcGx1Z2luIChhbnl0aGluZyBjb3VsZCBoYXZlIGNoYW5nZWQpXHJcblxyXG5cdFx0XHRfY3VycmVudFByb2dyYW0gPSBudWxsO1xyXG5cdFx0XHRfY3VycmVudENhbWVyYSA9IG51bGw7XHJcblxyXG5cdFx0XHRfb2xkQmxlbmRpbmcgPSAtMTtcclxuXHRcdFx0X29sZERlcHRoVGVzdCA9IC0xO1xyXG5cdFx0XHRfb2xkRGVwdGhXcml0ZSA9IC0xO1xyXG5cdFx0XHRfb2xkRG91YmxlU2lkZWQgPSAtMTtcclxuXHRcdFx0X29sZEZsaXBTaWRlZCA9IC0xO1xyXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gLTE7XHJcblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xO1xyXG5cclxuXHRcdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgcmV2ZXJzZSwgbWF0ZXJpYWxUeXBlLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB1c2VCbGVuZGluZywgb3ZlcnJpZGVNYXRlcmlhbCApIHtcclxuXHJcblx0XHR2YXIgd2ViZ2xPYmplY3QsIG9iamVjdCwgYnVmZmVyLCBtYXRlcmlhbCwgc3RhcnQsIGVuZCwgZGVsdGE7XHJcblxyXG5cdFx0aWYgKCByZXZlcnNlICkge1xyXG5cclxuXHRcdFx0c3RhcnQgPSByZW5kZXJMaXN0Lmxlbmd0aCAtIDE7XHJcblx0XHRcdGVuZCA9IC0xO1xyXG5cdFx0XHRkZWx0YSA9IC0xO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzdGFydCA9IDA7XHJcblx0XHRcdGVuZCA9IHJlbmRlckxpc3QubGVuZ3RoO1xyXG5cdFx0XHRkZWx0YSA9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSBzdGFydDsgaSAhPT0gZW5kOyBpICs9IGRlbHRhICkge1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHdlYmdsT2JqZWN0LnJlbmRlciApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cdFx0XHRcdGJ1ZmZlciA9IHdlYmdsT2JqZWN0LmJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0aWYgKCBvdmVycmlkZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbCA9IHdlYmdsT2JqZWN0WyBtYXRlcmlhbFR5cGUgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgbWF0ZXJpYWwgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVzZUJsZW5kaW5nICkgX3RoaXMuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xyXG5cdFx0XHRcdFx0X3RoaXMuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cdFx0XHRcdFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X3RoaXMuc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBidWZmZXIgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlciggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdHNJbW1lZGlhdGUgKCByZW5kZXJMaXN0LCBtYXRlcmlhbFR5cGUsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHVzZUJsZW5kaW5nLCBvdmVycmlkZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdHZhciB3ZWJnbE9iamVjdCwgb2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xyXG5cdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gd2ViZ2xPYmplY3RbIG1hdGVyaWFsVHlwZSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBtYXRlcmlhbCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdXNlQmxlbmRpbmcgKSBfdGhpcy5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xyXG5cclxuXHRcdFx0XHRcdF90aGlzLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XHJcblx0XHRcdFx0XHRfdGhpcy5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XHJcblx0XHRcdFx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfdGhpcy5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVySW1tZWRpYXRlT2JqZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuXHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcclxuXHJcblx0XHRfdGhpcy5zZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdGlmICggb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrKCBwcm9ncmFtLCBfZ2wsIF9mcnVzdHVtICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uKCBvYmplY3QgKSB7IF90aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApOyB9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiB1bnJvbGxJbW1lZGlhdGVCdWZmZXJNYXRlcmlhbCAoIGdsb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBvYmplY3QgPSBnbG9iamVjdC5vYmplY3QsXHJcblx0XHRcdG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XHJcblxyXG5cdFx0XHRnbG9iamVjdC50cmFuc3BhcmVudCA9IG1hdGVyaWFsO1xyXG5cdFx0XHRnbG9iamVjdC5vcGFxdWUgPSBudWxsO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRnbG9iamVjdC5vcGFxdWUgPSBtYXRlcmlhbDtcclxuXHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gdW5yb2xsQnVmZmVyTWF0ZXJpYWwgKCBnbG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgb2JqZWN0ID0gZ2xvYmplY3Qub2JqZWN0O1xyXG5cdFx0dmFyIGJ1ZmZlciA9IGdsb2JqZWN0LmJ1ZmZlcjtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWxJbmRleCA9IGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgPyAwIDogYnVmZmVyLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRtYXRlcmlhbCA9IG1hdGVyaWFsLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcclxuXHJcblx0XHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBtYXRlcmlhbDtcclxuXHRcdFx0XHRnbG9iamVjdC5vcGFxdWUgPSBudWxsO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbWF0ZXJpYWw7XHJcblx0XHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xyXG5cclxuXHRcdFx0XHRcdGdsb2JqZWN0LnRyYW5zcGFyZW50ID0gbWF0ZXJpYWw7XHJcblx0XHRcdFx0XHRnbG9iamVjdC5vcGFxdWUgPSBudWxsO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGdsb2JqZWN0Lm9wYXF1ZSA9IG1hdGVyaWFsO1xyXG5cdFx0XHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBPYmplY3RzIHJlZnJlc2hcclxuXHJcblx0dGhpcy5pbml0V2ViR0xPYmplY3RzID0gZnVuY3Rpb24gKCBzY2VuZSApIHtcclxuXHJcblx0XHRpZiAoICFzY2VuZS5fX3dlYmdsT2JqZWN0cyApIHtcclxuXHJcblx0XHRcdHNjZW5lLl9fd2ViZ2xPYmplY3RzID0gW107XHJcblx0XHRcdHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlID0gW107XHJcblx0XHRcdHNjZW5lLl9fd2ViZ2xTcHJpdGVzID0gW107XHJcblx0XHRcdHNjZW5lLl9fd2ViZ2xGbGFyZXMgPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKCBzY2VuZS5fX29iamVjdHNBZGRlZC5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRhZGRPYmplY3QoIHNjZW5lLl9fb2JqZWN0c0FkZGVkWyAwIF0sIHNjZW5lICk7XHJcblx0XHRcdHNjZW5lLl9fb2JqZWN0c0FkZGVkLnNwbGljZSggMCwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZSAoIHNjZW5lLl9fb2JqZWN0c1JlbW92ZWQubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0cmVtb3ZlT2JqZWN0KCBzY2VuZS5fX29iamVjdHNSZW1vdmVkWyAwIF0sIHNjZW5lICk7XHJcblx0XHRcdHNjZW5lLl9fb2JqZWN0c1JlbW92ZWQuc3BsaWNlKCAwLCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBvYmplY3RzIGFkZGluZyAvIHJlbW92YWxcclxuXHJcblx0XHRmb3IgKCB2YXIgbyA9IDAsIG9sID0gc2NlbmUuX193ZWJnbE9iamVjdHMubGVuZ3RoOyBvIDwgb2w7IG8gKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0ID0gc2NlbmUuX193ZWJnbE9iamVjdHNbIG8gXS5vYmplY3Q7XHJcblxyXG5cdFx0XHQvLyBUT0RPOiBSZW1vdmUgdGhpcyBoYWNrIChXZWJHTFJlbmRlcmVyIHJlZmFjdG9yaW5nKVxyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QuX193ZWJnbEFjdGl2ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHJlbW92ZU9iamVjdCggb2JqZWN0LCBzY2VuZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGFkZE9iamVjdCggb2JqZWN0LCBzY2VuZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dXBkYXRlT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIE9iamVjdHMgYWRkaW5nXHJcblxyXG5cdGZ1bmN0aW9uIGFkZE9iamVjdCggb2JqZWN0LCBzY2VuZSApIHtcclxuXHJcblx0XHR2YXIgZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBnZW9tZXRyeUdyb3VwO1xyXG5cclxuXHRcdGlmICggb2JqZWN0Ll9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QuX193ZWJnbEluaXQgPSB0cnVlO1xyXG5cclxuXHRcdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdFx0XHRvYmplY3QuX25vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5nZW9tZXRyeS5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuZ2VvbWV0cnkuX193ZWJnbEluaXQgPSB0cnVlO1xyXG5cdFx0XHRcdG9iamVjdC5nZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Ly8gZmFpbCBzaWxlbnRseSBmb3Igbm93XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRpbml0RGlyZWN0QnVmZmVycyggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkubWFrZUdyb3VwcyggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gY3JlYXRlIHNlcGFyYXRlIFZCT3MgcGVyIGdlb21ldHJ5IGNodW5rXHJcblxyXG5cdFx0XHRcdGZvciAoIGcgaW4gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBnIF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gaW5pdGlhbGlzZSBWQk8gb24gdGhlIGZpcnN0IGFjY2Vzc1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjcmVhdGVNZXNoQnVmZmVycyggZ2VvbWV0cnlHcm91cCApO1xyXG5cdFx0XHRcdFx0XHRpbml0TWVzaEJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5LnRhbmdlbnRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRcdGNyZWF0ZUxpbmVCdWZmZXJzKCBnZW9tZXRyeSApO1xyXG5cdFx0XHRcdFx0aW5pdExpbmVCdWZmZXJzKCBnZW9tZXRyeSwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3JlYXRlUGFydGljbGVCdWZmZXJzKCBnZW9tZXRyeSApO1xyXG5cdFx0XHRcdFx0aW5pdFBhcnRpY2xlQnVmZmVycyggZ2VvbWV0cnksIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5fX3dlYmdsQWN0aXZlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0YWRkQnVmZmVyKCBzY2VuZS5fX3dlYmdsT2JqZWN0cywgZ2VvbWV0cnksIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGcgaW4gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeUdyb3VwID0gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGcgXTtcclxuXHJcblx0XHRcdFx0XHRcdGFkZEJ1ZmZlciggc2NlbmUuX193ZWJnbE9iamVjdHMsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSB8fFxyXG5cdFx0XHRcdFx0XHRvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblx0XHRcdFx0YWRkQnVmZmVyKCBzY2VuZS5fX3dlYmdsT2JqZWN0cywgZ2VvbWV0cnksIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0IHx8IG9iamVjdC5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayApIHtcclxuXHJcblx0XHRcdFx0YWRkQnVmZmVySW1tZWRpYXRlKCBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgKSB7XHJcblxyXG5cdFx0XHRcdHNjZW5lLl9fd2ViZ2xTcHJpdGVzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGVuc0ZsYXJlICkge1xyXG5cclxuXHRcdFx0XHRzY2VuZS5fX3dlYmdsRmxhcmVzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2JqZWN0Ll9fd2ViZ2xBY3RpdmUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gYWRkQnVmZmVyKCBvYmpsaXN0LCBidWZmZXIsIG9iamVjdCApIHtcclxuXHJcblx0XHRvYmpsaXN0LnB1c2goXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZDogbnVsbCxcclxuXHRcdFx0XHRidWZmZXI6IGJ1ZmZlcixcclxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcclxuXHRcdFx0XHRvcGFxdWU6IG51bGwsXHJcblx0XHRcdFx0dHJhbnNwYXJlbnQ6IG51bGwsXHJcblx0XHRcdFx0ejogMFxyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhZGRCdWZmZXJJbW1lZGlhdGUoIG9iamxpc3QsIG9iamVjdCApIHtcclxuXHJcblx0XHRvYmpsaXN0LnB1c2goXHJcblx0XHRcdHtcclxuXHRcdFx0XHRpZDogbnVsbCxcclxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcclxuXHRcdFx0XHRvcGFxdWU6IG51bGwsXHJcblx0XHRcdFx0dHJhbnNwYXJlbnQ6IG51bGwsXHJcblx0XHRcdFx0ejogMFxyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBPYmplY3RzIHVwZGF0ZXNcclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlT2JqZWN0KCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LFxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLCBjdXN0b21BdHRyaWJ1dGVzRGlydHksIG1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdHNldERpcmVjdEJ1ZmZlcnMoIGdlb21ldHJ5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdC8vIGNoZWNrIGFsbCBnZW9tZXRyeSBncm91cHNcclxuXHJcblx0XHRcdGZvciggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzTGlzdFsgaSBdO1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5R3JvdXAgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5idWZmZXJzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRpbml0TWVzaEJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSB8fFxyXG5cdFx0XHRcdFx0IGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgfHxcclxuXHRcdFx0XHRcdCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LnRhbmdlbnRzTmVlZFVwZGF0ZSB8fCBjdXN0b21BdHRyaWJ1dGVzRGlydHkgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0TWVzaEJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAsIG9iamVjdCwgX2dsLkRZTkFNSUNfRFJBVywgIWdlb21ldHJ5LmR5bmFtaWMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Z2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5idWZmZXJzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsID0gZ2V0QnVmZmVyTWF0ZXJpYWwoIG9iamVjdCwgZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSB8fCBjdXN0b21BdHRyaWJ1dGVzRGlydHkgKSB7XHJcblxyXG5cdFx0XHRcdHNldExpbmVCdWZmZXJzKCBnZW9tZXRyeSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Z2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgY2xlYXJDdXN0b21BdHRyaWJ1dGVzKCBtYXRlcmlhbCApO1xyXG5cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsID0gZ2V0QnVmZmVyTWF0ZXJpYWwoIG9iamVjdCwgZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyB8fCBjdXN0b21BdHRyaWJ1dGVzRGlydHkgKSB7XHJcblxyXG5cdFx0XHRcdHNldFBhcnRpY2xlQnVmZmVycyggZ2VvbWV0cnksIF9nbC5EWU5BTUlDX0RSQVcsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgY2xlYXJDdXN0b21BdHRyaWJ1dGVzKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gT2JqZWN0cyB1cGRhdGVzIC0gY3VzdG9tIGF0dHJpYnV0ZXMgY2hlY2tcclxuXHJcblx0ZnVuY3Rpb24gYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgYSBpbiBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5hdHRyaWJ1dGVzWyBhIF0ubmVlZHNVcGRhdGUgKSByZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBhIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5hdHRyaWJ1dGVzWyBhIF0ubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIE9iamVjdHMgcmVtb3ZhbFxyXG5cclxuXHRmdW5jdGlvbiByZW1vdmVPYmplY3QoIG9iamVjdCwgc2NlbmUgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICB8fFxyXG5cdFx0XHQgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gfHxcclxuXHRcdFx0IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG5cdFx0XHRyZW1vdmVJbnN0YW5jZXMoIHNjZW5lLl9fd2ViZ2xPYmplY3RzLCBvYmplY3QgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgKSB7XHJcblxyXG5cdFx0XHRyZW1vdmVJbnN0YW5jZXNEaXJlY3QoIHNjZW5lLl9fd2ViZ2xTcHJpdGVzLCBvYmplY3QgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MZW5zRmxhcmUgKSB7XHJcblxyXG5cdFx0XHRyZW1vdmVJbnN0YW5jZXNEaXJlY3QoIHNjZW5lLl9fd2ViZ2xGbGFyZXMsIG9iamVjdCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCB8fCBvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHRyZW1vdmVJbnN0YW5jZXMoIHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIG9iamVjdC5fX3dlYmdsQWN0aXZlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZW1vdmVJbnN0YW5jZXMoIG9iamxpc3QsIG9iamVjdCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgbyA9IG9iamxpc3QubGVuZ3RoIC0gMTsgbyA+PSAwOyBvIC0tICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmpsaXN0WyBvIF0ub2JqZWN0ID09PSBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdG9iamxpc3Quc3BsaWNlKCBvLCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZW1vdmVJbnN0YW5jZXNEaXJlY3QoIG9iamxpc3QsIG9iamVjdCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgbyA9IG9iamxpc3QubGVuZ3RoIC0gMTsgbyA+PSAwOyBvIC0tICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmpsaXN0WyBvIF0gPT09IG9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0b2JqbGlzdC5zcGxpY2UoIG8sIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIE1hdGVyaWFsc1xyXG5cclxuXHR0aGlzLmluaXRNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0bWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xyXG5cclxuXHRcdHZhciB1LCBhLCBpZGVudGlmaWVycywgaSwgcGFyYW1ldGVycywgbWF4TGlnaHRDb3VudCwgbWF4Qm9uZXMsIG1heFNoYWRvd3MsIHNoYWRlcklEO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ2RlcHRoJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ25vcm1hbCc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ2Jhc2ljJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXJJRCA9ICdsYW1iZXJ0JztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2hhZGVySUQgPSAncGhvbmcnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBoeXNpY2FsTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXJJRCA9ICdwaHlzaWNhbCc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ2Jhc2ljJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ2Rhc2hlZCc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2hhZGVySUQgPSAncGFydGljbGVfYmFzaWMnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHNoYWRlcklEICkge1xyXG5cclxuXHRcdFx0c2V0TWF0ZXJpYWxTaGFkZXJzKCBtYXRlcmlhbCwgVEhSRUUuU2hhZGVyTGliWyBzaGFkZXJJRCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXHJcblx0XHQvLyAobm90IHRvIGJsb3cgb3ZlciBtYXhMaWdodHMgYnVkZ2V0KVxyXG5cclxuXHRcdG1heExpZ2h0Q291bnQgPSBhbGxvY2F0ZUxpZ2h0cyggbGlnaHRzICk7XHJcblxyXG5cdFx0bWF4U2hhZG93cyA9IGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICk7XHJcblxyXG5cdFx0bWF4Qm9uZXMgPSBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKTtcclxuXHJcblx0XHRwYXJhbWV0ZXJzID0ge1xyXG5cclxuXHRcdFx0bWFwOiAhIW1hdGVyaWFsLm1hcCxcclxuXHRcdFx0b3BhY2l0eU1hcDogISFtYXRlcmlhbC5vcGFjaXR5TWFwLFxyXG5cdFx0XHRlbnZNYXA6ICEhbWF0ZXJpYWwuZW52TWFwLFxyXG5cdFx0XHRsaWdodE1hcDogISFtYXRlcmlhbC5saWdodE1hcCxcclxuXHRcdFx0ZW1pc3NpdmVNYXA6ICEhbWF0ZXJpYWwuZW1pc3NpdmVNYXAsXHJcblx0XHRcdGJ1bXBNYXA6ICEhbWF0ZXJpYWwuYnVtcE1hcCxcclxuXHRcdFx0bm9ybWFsTWFwOiAhIW1hdGVyaWFsLm5vcm1hbE1hcCxcclxuXHRcdFx0c3BlY3VsYXJNYXA6ICEhbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXHJcblx0XHRcdHJlZmxlY3Rpdml0eU1hcDogISFtYXRlcmlhbC5yZWZsZWN0aXZpdHlNYXAsXHJcblx0XHRcdHJvdWdobmVzc01hcDogISFtYXRlcmlhbC5yb3VnaG5lc3NNYXAsXHJcblx0XHRcdHRyYW5zbHVjZW5jeU1hcDogISFtYXRlcmlhbC50cmFuc2x1Y2VuY3lNYXAsXHJcblx0XHRcdG1ldGFsbGljTWFwOiAhIW1hdGVyaWFsLm1ldGFsbGljTWFwLFxyXG5cdFx0XHRmYWxsb2ZmTWFwOiAhIW1hdGVyaWFsLmZhbGxvZmZNYXAsXHJcblxyXG5cdFx0XHRjbGVhckNvYXQ6ICgoIG1hdGVyaWFsLmNsZWFyQ29hdCAhPT0gdW5kZWZpbmVkICkmJiggbWF0ZXJpYWwuY2xlYXJDb2F0ICE9PSAwICkpLFxyXG5cclxuXHRcdFx0YW5pc290cm9weTogKCggbWF0ZXJpYWwuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkmJiggbWF0ZXJpYWwuYW5pc290cm9weSAhPT0gMCApKXx8KCAhISBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwICksXHJcblx0XHRcdGFuaXNvdHJvcHlNYXA6ICEhIG1hdGVyaWFsLmFuaXNvdHJvcHlNYXAsXHJcblx0XHRcdGFuaXNvdHJvcHlSb3RhdGlvbjogKCggbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSYmKCBtYXRlcmlhbC5hbmlzb3Ryb3B5Um90YXRpb24gIT09IDAgKSl8fCggISEgbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uTWFwICksXHJcblx0XHRcdGFuaXNvdHJvcHlSb3RhdGlvbk1hcDogISEgbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uTWFwLFxyXG5cclxuXHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXHJcblxyXG5cdFx0XHRmb2c6IGZvZyxcclxuXHRcdFx0dXNlRm9nOiBtYXRlcmlhbC5mb2csXHJcblx0XHRcdGZvZ0V4cDogZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMixcclxuXHJcblx0XHRcdHNpemVBdHRlbnVhdGlvbjogISEgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxyXG5cclxuXHRcdFx0c2tpbm5pbmc6IG1hdGVyaWFsLnNraW5uaW5nLFxyXG5cdFx0XHRtYXhCb25lczogbWF4Qm9uZXMsXHJcblx0XHRcdHVzZVZlcnRleFRleHR1cmU6IF9zdXBwb3J0c0JvbmVUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnVzZVZlcnRleFRleHR1cmUsXHJcblxyXG5cdFx0XHRtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcclxuXHRcdFx0bW9ycGhOb3JtYWxzOiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMsXHJcblx0XHRcdG1heE1vcnBoVGFyZ2V0czogdGhpcy5tYXhNb3JwaFRhcmdldHMsXHJcblx0XHRcdG1heE1vcnBoTm9ybWFsczogdGhpcy5tYXhNb3JwaE5vcm1hbHMsXHJcblxyXG5cdFx0XHRtYXhEaXJMaWdodHM6IG1heExpZ2h0Q291bnQuZGlyZWN0aW9uYWwsXHJcblx0XHRcdG1heFBvaW50TGlnaHRzOiBtYXhMaWdodENvdW50LnBvaW50LFxyXG5cdFx0XHRtYXhTcG90TGlnaHRzOiBtYXhMaWdodENvdW50LnNwb3QsXHJcblx0XHRcdG1heEhlbWlMaWdodHM6IG1heExpZ2h0Q291bnQuaGVtaSxcclxuXHRcdFx0bWF4QXJlYUxpZ2h0czogbWF4TGlnaHRDb3VudC5hcmVhLFxyXG5cclxuXHRcdFx0bWF4U2hhZG93czogbWF4U2hhZG93cyxcclxuXHRcdFx0c2hhZG93TWFwRW5hYmxlZDogdGhpcy5zaGFkb3dNYXBFbmFibGVkICYmIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmIG1heFNoYWRvd3MgPiAwLFxyXG5cdFx0XHRzaGFkb3dNYXBUeXBlOiB0aGlzLnNoYWRvd01hcFR5cGUsXHJcblx0XHRcdHNoYWRvd01hcERlYnVnOiB0aGlzLnNoYWRvd01hcERlYnVnLFxyXG5cdFx0XHRzaGFkb3dNYXBDYXNjYWRlOiB0aGlzLnNoYWRvd01hcENhc2NhZGUsXHJcblxyXG5cdFx0XHR0cmFuc2x1Y2VuY3k6IG1hdGVyaWFsLnRyYW5zbHVjZW5jeSAmJiAoIG1hdGVyaWFsLnRyYW5zbHVjZW5jeS5nZXRIZXgoKSA+IDAgKSxcclxuXHJcblx0XHRcdGFscGhhVGVzdDogbWF0ZXJpYWwuYWxwaGFUZXN0LFxyXG5cdFx0XHRmYWxsb2ZmOiAoIG1hdGVyaWFsLmZhbGxvZmYgfHwgZmFsc2UgKSxcclxuXHRcdFx0d3JhcEFyb3VuZDogbWF0ZXJpYWwud3JhcEFyb3VuZCxcclxuXHRcdFx0ZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUsXHJcblx0XHRcdGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGVcclxuXHJcblx0XHR9O1xyXG5cdFx0XHJcblx0XHRtYXRlcmlhbC5wcm9ncmFtID0gYnVpbGRQcm9ncmFtKCBzaGFkZXJJRCwgbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIsIG1hdGVyaWFsLnZlcnRleFNoYWRlciwgbWF0ZXJpYWwudW5pZm9ybXMsIG1hdGVyaWFsLmF0dHJpYnV0ZXMsIG1hdGVyaWFsLmRlZmluZXMsIHBhcmFtZXRlcnMsIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IG1hdGVyaWFsLnByb2dyYW0uYXR0cmlidXRlcztcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XHJcblxyXG5cdFx0XHR2YXIgaWQsIGJhc2UgPSBcIm1vcnBoVGFyZ2V0XCI7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHRoaXMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZCA9IGJhc2UgKyBpO1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIGlkIF0gPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgPSAwO1xyXG5cclxuXHRcdFx0dmFyIGlkLCBiYXNlID0gXCJtb3JwaE5vcm1hbFwiO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWQgPSBiYXNlICsgaTtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyBpZCBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG1hdGVyaWFsLnVuaWZvcm1zTGlzdCA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHUgaW4gbWF0ZXJpYWwudW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC51bmlmb3Jtc0xpc3QucHVzaCggWyBtYXRlcmlhbC51bmlmb3Jtc1sgdSBdLCB1IF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1hdGVyaWFsU2hhZGVycyggbWF0ZXJpYWwsIHNoYWRlcnMgKSB7XHJcblxyXG5cdFx0bWF0ZXJpYWwudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXJzLnVuaWZvcm1zICk7XHJcblx0XHRtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJzLnZlcnRleFNoYWRlcjtcclxuXHRcdG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0gc2hhZGVycy5mcmFnbWVudFNoYWRlcjtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcclxuXHJcblx0XHRfdXNlZFRleHR1cmVVbml0cyA9IDA7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSApIHtcclxuXHJcblx0XHRcdHZhciBvbGRQcm9ncmFtID0gbWF0ZXJpYWwucHJvZ3JhbTtcclxuXHJcblx0XHRcdF90aGlzLmluaXRNYXRlcmlhbCggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBvYmplY3QgKTtcclxuXHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmICggb2xkUHJvZ3JhbSApIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwsIG9sZFByb2dyYW0gKTtcclxuXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0aWYgKCAhIG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIF90aGlzLm1heE1vcnBoVGFyZ2V0cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbC5wcm9ncmFtLFxyXG5cdFx0XHRwX3VuaWZvcm1zID0gcHJvZ3JhbS51bmlmb3JtcyxcclxuXHRcdFx0bV91bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xyXG5cclxuXHRcdGlmICggcHJvZ3JhbSAhPT0gX2N1cnJlbnRQcm9ncmFtICkge1xyXG5cclxuXHRcdFx0X2dsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcclxuXHRcdFx0X2N1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbTtcclxuXHJcblx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcclxuXHJcblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xyXG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xyXG5cclxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRpZiAoIGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSBfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2tpbm5pbmcgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXHJcblx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcclxuXHRcdC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcclxuXHJcblx0XHRcdGlmICggX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdC51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggb2JqZWN0LmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVXaWR0aCwgb2JqZWN0LmJvbmVUZXh0dXJlV2lkdGggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZUhlaWdodCwgb2JqZWN0LmJvbmVUZXh0dXJlSGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYm9uZUdsb2JhbE1hdHJpY2VzLCBmYWxzZSwgb2JqZWN0LmJvbmVNYXRyaWNlcyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0Ly8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcclxuXHJcblx0XHRcdGlmICggZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGh5c2ljYWxNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbC5saWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggX2xpZ2h0c05lZWRVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0dXBMaWdodHMoIHByb2dyYW0sIGxpZ2h0cyApO1xyXG5cdFx0XHRcdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaWdodHMoIG1fdW5pZm9ybXMsIF9saWdodHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGh5c2ljYWxNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGFydGljbGUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcbiBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaHlzaWNhbE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGFtYmVydCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcclxuXHRcdFx0XHRtX3VuaWZvcm1zLm1GYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xyXG5cdFx0XHRcdG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgISBtYXRlcmlhbC5fc2hhZG93UGFzcyApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zU2hhZG93KCBtX3VuaWZvcm1zLCBsaWdodHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGxvYWQgY29tbW9uIHVuaWZvcm1zXHJcblxyXG5cdFx0XHRsb2FkVW5pZm9ybXNHZW5lcmljKCBwcm9ncmFtLCBtYXRlcmlhbC51bmlmb3Jtc0xpc3QgKTtcclxuXHJcblx0XHRcdC8vIGxvYWQgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcclxuXHRcdFx0Ly8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBoeXNpY2FsTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwuZW52TWFwICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24sIF92ZWN0b3IzLngsIF92ZWN0b3IzLnksIF92ZWN0b3IzLnogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaHlzaWNhbE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy52aWV3TWF0cml4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnZpZXdNYXRyaXgsIGZhbHNlLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bG9hZFVuaWZvcm1zTWF0cmljZXMoIHBfdW5pZm9ybXMsIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4LCBmYWxzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkLmVsZW1lbnRzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcm9ncmFtO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNDb21tb24gKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuY29sb3IgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XHJcblx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xyXG5cdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcclxuXHRcclxuXHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdHZhciBtYXAgPSBtYXRlcmlhbC5tYXA7XHJcblx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG1hcC5vZmZzZXQueCwgbWFwLm9mZnNldC55LCBtYXAucmVwZWF0LngsIG1hcC5yZXBlYXQueSApO1xyXG5cdFx0XHR1bmlmb3Jtcy5nYWluQnJpZ2h0bmVzcy52YWx1ZS5zZXQoIG1hcC5nYWluUGl2b3QsIG1hcC5nYWluLCBtYXAuYnJpZ2h0bmVzcywgMS4wICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XHJcblxyXG5cdFx0XHR2YXIgc3BlY3VsYXJNYXAgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcclxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBzcGVjdWxhck1hcDtcclxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJPZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBzcGVjdWxhck1hcC5vZmZzZXQueCwgc3BlY3VsYXJNYXAub2Zmc2V0LnksIHNwZWN1bGFyTWFwLnJlcGVhdC54LCBzcGVjdWxhck1hcC5yZXBlYXQueSApO1xyXG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhckdhaW5CcmlnaHRuZXNzLnZhbHVlLnNldCggc3BlY3VsYXJNYXAuZ2FpblBpdm90LCBzcGVjdWxhck1hcC5nYWluLCBzcGVjdWxhck1hcC5icmlnaHRuZXNzLCAxLjAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5vcGFjaXR5TWFwICkge1xyXG5cclxuXHRcdFx0dmFyIG9wYWNpdHlNYXAgPSBtYXRlcmlhbC5vcGFjaXR5TWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5vcGFjaXR5TWFwLnZhbHVlID0gb3BhY2l0eU1hcDtcclxuXHRcdFx0dW5pZm9ybXMub3BhY2l0eU9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9wYWNpdHlNYXAub2Zmc2V0LngsIG9wYWNpdHlNYXAub2Zmc2V0LnksIG9wYWNpdHlNYXAucmVwZWF0LngsIG9wYWNpdHlNYXAucmVwZWF0LnkgKTtcclxuXHRcdFx0dW5pZm9ybXMub3BhY2l0eUdhaW5CcmlnaHRuZXNzLnZhbHVlLnNldCggb3BhY2l0eU1hcC5nYWluUGl2b3QsIG9wYWNpdHlNYXAuZ2Fpbiwgb3BhY2l0eU1hcC5icmlnaHRuZXNzLCAxLjAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xyXG5cclxuXHRcdFx0dmFyIGJ1bXBNYXAgPSBtYXRlcmlhbC5idW1wTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5idW1wT2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggYnVtcE1hcC5vZmZzZXQueCwgYnVtcE1hcC5vZmZzZXQueSwgYnVtcE1hcC5yZXBlYXQueCwgYnVtcE1hcC5yZXBlYXQueSApO1xyXG5cdFx0XHQvL3VuaWZvcm1zLmJ1bXBHYWluQnJpZ2h0bmVzcy52YWx1ZS5zZXQoIGJ1bXBNYXAuZ2FpblBpdm90LCBidW1wTWFwLmdhaW4sIGJ1bXBNYXAuYnJpZ2h0bmVzcywgMS4wICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbE1hcCA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcclxuXHRcdFx0dW5pZm9ybXMubm9ybWFsT2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggbm9ybWFsTWFwLm9mZnNldC54LCBub3JtYWxNYXAub2Zmc2V0LnksIG5vcm1hbE1hcC5yZXBlYXQueCwgbm9ybWFsTWFwLnJlcGVhdC55ICk7XHJcblx0XHRcdC8vdW5pZm9ybXMubm9ybWFsR2FpbkJyaWdodG5lc3MudmFsdWUuc2V0KCBub3JtYWxNYXAuZ2FpblBpdm90LCBub3JtYWxNYXAuZ2Fpbiwgbm9ybWFsTWFwLmJyaWdodG5lc3MsIDEuMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmFuaXNvdHJvcHlNYXAgKSB7XHJcblxyXG5cdFx0XHR2YXIgYW5pc290cm9weU1hcCA9IG1hdGVyaWFsLmFuaXNvdHJvcHlNYXA7XHJcblx0XHRcdHVuaWZvcm1zLmFuaXNvdHJvcHlPZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBhbmlzb3Ryb3B5TWFwLm9mZnNldC54LCBhbmlzb3Ryb3B5TWFwLm9mZnNldC55LCBhbmlzb3Ryb3B5TWFwLnJlcGVhdC54LCBhbmlzb3Ryb3B5TWFwLnJlcGVhdC55ICk7XHJcblx0XHRcdHVuaWZvcm1zLmFuaXNvdHJvcHlHYWluQnJpZ2h0bmVzcy52YWx1ZS5zZXQoIGFuaXNvdHJvcHlNYXAuZ2FpblBpdm90LCBhbmlzb3Ryb3B5TWFwLmdhaW4sIGFuaXNvdHJvcHlNYXAuYnJpZ2h0bmVzcywgMS4wICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uTWFwICkge1xyXG5cclxuXHRcdFx0dmFyIGFuaXNvdHJvcHlSb3RhdGlvbk1hcCA9IG1hdGVyaWFsLmFuaXNvdHJvcHlSb3RhdGlvbk1hcDtcclxuXHRcdFx0dW5pZm9ybXMuYW5pc290cm9weVJvdGF0aW9uT2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggYW5pc290cm9weVJvdGF0aW9uTWFwLm9mZnNldC54LCBhbmlzb3Ryb3B5Um90YXRpb25NYXAub2Zmc2V0LnksIGFuaXNvdHJvcHlSb3RhdGlvbk1hcC5yZXBlYXQueCwgYW5pc290cm9weVJvdGF0aW9uTWFwLnJlcGVhdC55ICk7XHJcblx0XHRcdHVuaWZvcm1zLmFuaXNvdHJvcHlSb3RhdGlvbkdhaW5CcmlnaHRuZXNzLnZhbHVlLnNldCggYW5pc290cm9weVJvdGF0aW9uTWFwLmdhaW5QaXZvdCwgYW5pc290cm9weVJvdGF0aW9uTWFwLmdhaW4sIGFuaXNvdHJvcHlSb3RhdGlvbk1hcC5icmlnaHRuZXNzLCAxLjAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHR2YXIgcm91Z2huZXNzTWFwID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5yb3VnaG5lc3NPZmZzZXRSZXBlYXQudmFsdWUuc2V0KCByb3VnaG5lc3NNYXAub2Zmc2V0LngsIHJvdWdobmVzc01hcC5vZmZzZXQueSwgcm91Z2huZXNzTWFwLnJlcGVhdC54LCByb3VnaG5lc3NNYXAucmVwZWF0LnkgKTtcclxuXHRcdFx0dW5pZm9ybXMucm91Z2huZXNzR2FpbkJyaWdodG5lc3MudmFsdWUuc2V0KCByb3VnaG5lc3NNYXAuZ2FpblBpdm90LCByb3VnaG5lc3NNYXAuZ2Fpbiwgcm91Z2huZXNzTWFwLmJyaWdodG5lc3MsIDEuMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1ldGFsbGljTWFwICkge1xyXG5cclxuXHRcdFx0dmFyIG1ldGFsbGljTWFwID0gbWF0ZXJpYWwubWV0YWxsaWNNYXA7XHJcblx0XHRcdHVuaWZvcm1zLm1ldGFsbGljT2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggbWV0YWxsaWNNYXAub2Zmc2V0LngsIG1ldGFsbGljTWFwLm9mZnNldC55LCBtZXRhbGxpY01hcC5yZXBlYXQueCwgbWV0YWxsaWNNYXAucmVwZWF0LnkgKTtcclxuXHRcdFx0dW5pZm9ybXMubWV0YWxsaWNHYWluQnJpZ2h0bmVzcy52YWx1ZS5zZXQoIG1ldGFsbGljTWFwLmdhaW5QaXZvdCwgbWV0YWxsaWNNYXAuZ2FpbiwgbWV0YWxsaWNNYXAuYnJpZ2h0bmVzcywgMS4wICk7XHJcblxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zbHVjZW5jeU1hcCApIHtcclxuXHJcblx0XHRcdHZhciB0cmFuc2x1Y2VuY3lNYXAgPSBtYXRlcmlhbC50cmFuc2x1Y2VuY3lNYXA7XHJcblx0XHRcdHVuaWZvcm1zLnRyYW5zbHVjZW5jeU1hcC52YWx1ZSA9IHRyYW5zbHVjZW5jeU1hcDtcclxuXHRcdFx0Ly91bmlmb3Jtcy50cmFuc2x1Y2VuY3lPZmZzZXRSZXBlYXQudmFsdWUuc2V0KCB0cmFuc2x1Y2VuY3lNYXAub2Zmc2V0LngsIHRyYW5zbHVjZW5jeU1hcC5vZmZzZXQueSwgdHJhbnNsdWNlbmN5TWFwLnJlcGVhdC54LCB0cmFuc2x1Y2VuY3lNYXAucmVwZWF0LnkgKTtcclxuXHRcdFx0Ly91bmlmb3Jtcy50cmFuc2x1Y2VuY3lHYWluQnJpZ2h0bmVzcy52YWx1ZS5zZXQoIHRyYW5zbHVjZW5jeU1hcC5nYWluUGl2b3QsIHRyYW5zbHVjZW5jeU1hcC5nYWluLCB0cmFuc2x1Y2VuY3lNYXAuYnJpZ2h0bmVzcywgMS4wICk7XHJcblxyXG5cdFx0fVxyXG5cdFx0dW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwO1xyXG5cdFx0dW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggbWF0ZXJpYWwuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkgPyAxIDogLTE7XHJcblxyXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0Ly91bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgKiBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XHJcblx0XHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XHJcblx0XHR1bmlmb3Jtcy5jb21iaW5lLnZhbHVlID0gbWF0ZXJpYWwuY29tYmluZTtcclxuXHRcdHVuaWZvcm1zLnVzZVJlZnJhY3QudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgaW5zdGFuY2VvZiBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2ggKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcclxuXHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcclxuXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BhcnRpY2xlICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLnBzQ29sb3IudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcclxuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cdFx0dW5pZm9ybXMuc2l6ZS52YWx1ZSA9IG1hdGVyaWFsLnNpemU7XHJcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuaGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxyXG5cclxuXHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRm9nICggdW5pZm9ybXMsIGZvZyApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSA9IGZvZy5jb2xvcjtcclxuXHJcblx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcclxuXHRcdFx0dW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMub3BhY2l0eU1hcC52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHlNYXA7XHJcblxyXG5cdFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gbWF0ZXJpYWwuc2hpbmluZXNzO1xyXG5cclxuXHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmFtYmllbnQudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLmFtYmllbnQgKTtcclxuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLmVtaXNzaXZlICk7XHJcblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5zcGVjdWxhciApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50LnZhbHVlID0gbWF0ZXJpYWwuYW1iaWVudDtcclxuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZTtcclxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC53cmFwQXJvdW5kICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMud3JhcFJHQi52YWx1ZS5jb3B5KCBtYXRlcmlhbC53cmFwUkdCICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5TWFwLnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eU1hcDtcclxuXHJcblx0XHR1bmlmb3Jtcy5mYWxsb2ZmQmxlbmRQYXJhbXMudmFsdWUgPSBtYXRlcmlhbC5mYWxsb2ZmQmxlbmRQYXJhbXM7XHJcblx0XHR1bmlmb3Jtcy5mYWxsb2ZmTWFwLnZhbHVlID0gbWF0ZXJpYWwuZmFsbG9mZk1hcDtcclxuXHJcblx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XHJcblx0XHR1bmlmb3Jtcy5tZXRhbGxpYy52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbGljO1xyXG5cclxuXHRcdHVuaWZvcm1zLmNsZWFyQ29hdC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyQ29hdDtcclxuXHRcdHVuaWZvcm1zLmNsZWFyQ29hdFJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcztcclxuXHJcblx0XHR1bmlmb3Jtcy5yb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XHJcblx0XHR1bmlmb3Jtcy5tZXRhbGxpY01hcC52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbGljTWFwO1xyXG5cclxuXHRcdHVuaWZvcm1zLnRyYW5zbHVjZW5jeU1hcC52YWx1ZSA9IG1hdGVyaWFsLnRyYW5zbHVjZW5jeU1hcDtcclxuXHRcdHVuaWZvcm1zLnRyYW5zbHVjZW5jeU5vcm1hbEFscGhhLnZhbHVlID0gbWF0ZXJpYWwudHJhbnNsdWNlbmN5Tm9ybWFsQWxwaGE7XHJcblx0XHR1bmlmb3Jtcy50cmFuc2x1Y2VuY3lOb3JtYWxQb3dlci52YWx1ZSA9IG1hdGVyaWFsLnRyYW5zbHVjZW5jeU5vcm1hbFBvd2VyO1xyXG5cdFx0dW5pZm9ybXMudHJhbnNsdWNlbmN5Vmlld0FscGhhLnZhbHVlID0gbWF0ZXJpYWwudHJhbnNsdWNlbmN5Vmlld0FscGhhO1xyXG5cdFx0dW5pZm9ybXMudHJhbnNsdWNlbmN5Vmlld1Bvd2VyLnZhbHVlID0gbWF0ZXJpYWwudHJhbnNsdWNlbmN5Vmlld1Bvd2VyO1xyXG5cclxuXHRcdHVuaWZvcm1zLmFuaXNvdHJvcHlNYXAudmFsdWUgPSBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwO1xyXG5cdFx0dW5pZm9ybXMuYW5pc290cm9weS52YWx1ZSA9IG1hdGVyaWFsLmFuaXNvdHJvcHk7XHJcblx0XHR1bmlmb3Jtcy5hbmlzb3Ryb3B5Um90YXRpb24udmFsdWUgPSBtYXRlcmlhbC5hbmlzb3Ryb3B5Um90YXRpb247XHJcblx0XHR1bmlmb3Jtcy5hbmlzb3Ryb3B5Um90YXRpb25NYXAudmFsdWUgPSBtYXRlcmlhbC5hbmlzb3Ryb3B5Um90YXRpb25NYXA7XHJcblxyXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudC52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuYW1iaWVudCApO1xyXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuZW1pc3NpdmUgKTtcclxuXHRcdFx0dW5pZm9ybXMuZmFsbG9mZkNvbG9yLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5mYWxsb2ZmQ29sb3IgKTtcclxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLnNwZWN1bGFyICk7XHJcblx0XHRcdHVuaWZvcm1zLnRyYW5zbHVjZW5jeS52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwudHJhbnNsdWNlbmN5ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmFtYmllbnQudmFsdWUgPSBtYXRlcmlhbC5hbWJpZW50O1xyXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlO1xyXG5cdFx0XHR1bmlmb3Jtcy5mYWxsb2ZmQ29sb3IudmFsdWUgPSBtYXRlcmlhbC5mYWxsb2ZmQ29sb3I7XHJcblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XHJcblx0XHRcdHVuaWZvcm1zLnRyYW5zbHVjZW5jeS52YWx1ZSA9IG1hdGVyaWFsLnRyYW5zbHVjZW5jeTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudC52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuYW1iaWVudCApO1xyXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuZW1pc3NpdmUgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudC52YWx1ZSA9IG1hdGVyaWFsLmFtYmllbnQ7XHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwud3JhcEFyb3VuZCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLndyYXBSR0IudmFsdWUuY29weSggbWF0ZXJpYWwud3JhcFJHQiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGlnaHRzICggdW5pZm9ybXMsIGxpZ2h0cyApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5hbWJpZW50O1xyXG5cclxuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnM7XHJcblx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucztcclxuXHJcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMucG9pbnQuY29sb3JzO1xyXG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnBvaW50LnBvc2l0aW9ucztcclxuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kaXN0YW5jZXM7XHJcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0RGVjYXlFeHBvbmVudC52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kZWNheUV4cG9uZW50cztcclxuXHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zcG90LmNvbG9ycztcclxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QucG9zaXRpb25zO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RGlzdGFuY2UudmFsdWUgPSBsaWdodHMuc3BvdC5kaXN0YW5jZXM7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHREZWNheUV4cG9uZW50LnZhbHVlID0gbGlnaHRzLnNwb3QuZGVjYXlFeHBvbmVudHM7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuc3BvdC5kaXJlY3Rpb25zO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MudmFsdWUgPSBsaWdodHMuc3BvdC5hbmdsZXNDb3M7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRFeHBvbmVudC52YWx1ZSA9IGxpZ2h0cy5zcG90LmV4cG9uZW50cztcclxuXHJcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLnNreUNvbG9ycztcclxuXHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLnZhbHVlID0gbGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzO1xyXG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmhlbWkucG9zaXRpb25zO1xyXG5cclxuXHRcdHVuaWZvcm1zLmFyZWFMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmFyZWEuY29sb3JzO1xyXG5cdFx0dW5pZm9ybXMuYXJlYUxpZ2h0UG9zaXRpb24udmFsdWUgPSBsaWdodHMuYXJlYS5wb3NpdGlvbnM7XHJcblx0XHR1bmlmb3Jtcy5hcmVhTGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5hcmVhLmRpc3RhbmNlcztcclxuXHRcdHVuaWZvcm1zLmFyZWFMaWdodERlY2F5RXhwb25lbnQudmFsdWUgPSBsaWdodHMuYXJlYS5kZWNheUV4cG9uZW50cztcclxuXHRcdHVuaWZvcm1zLmFyZWFMaWdodFdpZHRoLnZhbHVlID0gbGlnaHRzLmFyZWEud2lkdGhzO1xyXG5cdFx0dW5pZm9ybXMuYXJlYUxpZ2h0SGVpZ2h0LnZhbHVlID0gbGlnaHRzLmFyZWEuaGVpZ2h0cztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU2hhZG93ICggdW5pZm9ybXMsIGxpZ2h0cyApIHtcclxuXHJcblx0XHRpZiAoIHVuaWZvcm1zLnNoYWRvd01hdHJpeCApIHtcclxuXHJcblx0XHRcdHZhciBqID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsaWdodCA9IGxpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0IHx8ICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICYmICEgbGlnaHQuc2hhZG93Q2FzY2FkZSApICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcC52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWFwO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZS52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWFwU2l6ZTtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXRyaXgudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hdHJpeDtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dEYXJrbmVzcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93RGFya25lc3M7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dCaWFzLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dCaWFzO1xyXG5cclxuXHRcdFx0XHRcdGogKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcclxuXHJcblx0ZnVuY3Rpb24gbG9hZFVuaWZvcm1zTWF0cmljZXMgKCB1bmlmb3Jtcywgb2JqZWN0ICkge1xyXG5cclxuXHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBvYmplY3QuX21vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdGlmICggdW5pZm9ybXMubm9ybWFsTWF0cml4ICkge1xyXG5cclxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXgzZnYoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5fbm9ybWFsTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZXRUZXh0dXJlVW5pdCgpIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZVVuaXQgPSBfdXNlZFRleHR1cmVVbml0cztcclxuXHJcblx0XHRpZiAoIHRleHR1cmVVbml0ID49IF9tYXhUZXh0dXJlcyApIHtcclxuXHJcblx0XHRcdFRIUkVFLm9ud2FybmluZyggXCJXZWJHTFJlbmRlcmVyOiB0cnlpbmcgdG8gdXNlIFwiICsgdGV4dHVyZVVuaXQgKyBcIiB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgXCIgKyBfbWF4VGV4dHVyZXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X3VzZWRUZXh0dXJlVW5pdHMgKz0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZVVuaXQ7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGxvYWRVbmlmb3Jtc0dlbmVyaWMgKCBwcm9ncmFtLCB1bmlmb3JtcyApIHtcclxuXHJcblx0XHR2YXIgdW5pZm9ybSwgdmFsdWUsIHR5cGUsIGxvY2F0aW9uLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCwgaSwgaWwsIGosIGpsLCBvZmZzZXQ7XHJcblxyXG5cdFx0Zm9yICggaiA9IDAsIGpsID0gdW5pZm9ybXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRsb2NhdGlvbiA9IHByb2dyYW0udW5pZm9ybXNbIHVuaWZvcm1zWyBqIF1bIDEgXSBdO1xyXG5cdFx0XHRpZiAoICFsb2NhdGlvbiApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0dW5pZm9ybSA9IHVuaWZvcm1zWyBqIF1bIDAgXTtcclxuXHJcblx0XHRcdHR5cGUgPSB1bmlmb3JtLnR5cGU7XHJcblx0XHRcdHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcclxuXHJcblx0XHRcdGlmICggdHlwZSA9PT0gXCJpXCIgKSB7IC8vIHNpbmdsZSBpbnRlZ2VyXHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJmXCIgKSB7IC8vIHNpbmdsZSBmbG9hdFxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidjJcIiApIHsgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjJcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidjNcIiApIHsgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnogKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidjRcIiApIHsgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjRcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiY1wiICkgeyAvLyBzaW5nbGUgVEhSRUUuQ29sb3JcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLnIsIHZhbHVlLmcsIHZhbHVlLmIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiaXYxXCIgKSB7IC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcIml2XCIgKSB7IC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJmdjFcIiApIHsgLy8gZmxhdCBhcnJheSBvZiBmbG9hdHMgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImZ2XCIgKSB7IC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidjJ2XCIgKSB7IC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjJcclxuXHJcblx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMiAqIHZhbHVlLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCA9IGkgKiAyO1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgXSBcdCA9IHZhbHVlWyBpIF0ueDtcclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2M3ZcIiApIHsgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yM1xyXG5cclxuXHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAzICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gaSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCBdIFx0ID0gdmFsdWVbIGkgXS54O1xyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2NHZcIiApIHsgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yNFxyXG5cclxuXHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA0ICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gaSAqIDQ7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCBdIFx0ID0gdmFsdWVbIGkgXS54O1xyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMyBdID0gdmFsdWVbIGkgXS53O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwibTRcIikgeyAvLyBzaW5nbGUgVEhSRUUuTWF0cml4NFxyXG5cclxuXHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhbHVlLmZsYXR0ZW5Ub0FycmF5KCB1bmlmb3JtLl9hcnJheSApO1xyXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcIm00dlwiICkgeyAvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXg0XHJcblxyXG5cdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiAxNiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcInRcIiApIHsgLy8gc2luZ2xlIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXHJcblxyXG5cdFx0XHRcdHRleHR1cmUgPSB2YWx1ZTtcclxuXHRcdFx0XHR0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRpZiAoICF0ZXh0dXJlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5pbWFnZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xyXG5cclxuXHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcInR2XCIgKSB7IC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkKVxyXG5cclxuXHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBbXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IoIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkgXSA9IGdldFRleHR1cmVVbml0KCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRmb3IoIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZSA9IHVuaWZvcm0udmFsdWVbIGkgXTtcclxuXHRcdFx0XHRcdHRleHR1cmVVbml0ID0gdW5pZm9ybS5fYXJyYXlbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICF0ZXh0dXJlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0VEhSRUUub253YXJuaW5nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5rbm93biB1bmlmb3JtIHR5cGU6ICcgKyB0eXBlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXR1cE1hdHJpY2VzICggb2JqZWN0LCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRvYmplY3QuX25vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIHNldENvbG9yR2FtbWEoIGFycmF5LCBvZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHlTcSApIHtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3IuciAqIGNvbG9yLnIgKiBpbnRlbnNpdHlTcTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nICogY29sb3IuZyAqIGludGVuc2l0eVNxO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmIgKiBjb2xvci5iICogaW50ZW5zaXR5U3E7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldENvbG9yTGluZWFyKCBhcnJheSwgb2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICkge1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSAgICAgPSBjb2xvci5yICogaW50ZW5zaXR5O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYiAqIGludGVuc2l0eTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBMaWdodHMgKCBwcm9ncmFtLCBsaWdodHMgKSB7XHJcblxyXG5cdFx0dmFyIGwsIGxsLCBsaWdodCwgbixcclxuXHRcdHIgPSAwLCBnID0gMCwgYiA9IDAsXHJcblx0XHRjb2xvciwgc2t5Q29sb3IsIGdyb3VuZENvbG9yLFxyXG5cdFx0aW50ZW5zaXR5LCAgaW50ZW5zaXR5U3EsXHJcblx0XHRwb3NpdGlvbixcclxuXHRcdGRpc3RhbmNlLFxyXG5cclxuXHRcdHpsaWdodHMgPSBfbGlnaHRzLFxyXG5cclxuXHRcdGRpckNvbG9ycyA9IHpsaWdodHMuZGlyZWN0aW9uYWwuY29sb3JzLFxyXG5cdFx0ZGlyUG9zaXRpb25zID0gemxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnMsXHJcblxyXG5cdFx0cG9pbnRDb2xvcnMgPSB6bGlnaHRzLnBvaW50LmNvbG9ycyxcclxuXHRcdHBvaW50UG9zaXRpb25zID0gemxpZ2h0cy5wb2ludC5wb3NpdGlvbnMsXHJcblx0XHRwb2ludERpc3RhbmNlcyA9IHpsaWdodHMucG9pbnQuZGlzdGFuY2VzLFxyXG5cdFx0cG9pbnREZWNheUV4cG9uZW50cyA9IHpsaWdodHMucG9pbnQuZGVjYXlFeHBvbmVudHMsXHJcblxyXG5cdFx0c3BvdENvbG9ycyA9IHpsaWdodHMuc3BvdC5jb2xvcnMsXHJcblx0XHRzcG90UG9zaXRpb25zID0gemxpZ2h0cy5zcG90LnBvc2l0aW9ucyxcclxuXHRcdHNwb3REaXN0YW5jZXMgPSB6bGlnaHRzLnNwb3QuZGlzdGFuY2VzLFxyXG5cdFx0c3BvdERlY2F5RXhwb25lbnRzID0gemxpZ2h0cy5zcG90LmRlY2F5RXhwb25lbnRzLFxyXG5cdFx0c3BvdERpcmVjdGlvbnMgPSB6bGlnaHRzLnNwb3QuZGlyZWN0aW9ucyxcclxuXHRcdHNwb3RBbmdsZXNDb3MgPSB6bGlnaHRzLnNwb3QuYW5nbGVzQ29zLFxyXG5cdFx0c3BvdEV4cG9uZW50cyA9IHpsaWdodHMuc3BvdC5leHBvbmVudHMsXHJcblxyXG5cdFx0aGVtaVNreUNvbG9ycyA9IHpsaWdodHMuaGVtaS5za3lDb2xvcnMsXHJcblx0XHRoZW1pR3JvdW5kQ29sb3JzID0gemxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycyxcclxuXHRcdGhlbWlQb3NpdGlvbnMgPSB6bGlnaHRzLmhlbWkucG9zaXRpb25zLFxyXG5cclxuXHRcdGFyZWFDb2xvcnMgPSB6bGlnaHRzLmFyZWEuY29sb3JzLFxyXG5cdFx0YXJlYVBvc2l0aW9ucyA9IHpsaWdodHMuYXJlYS5wb3NpdGlvbnMsXHJcblx0XHRhcmVhRGlzdGFuY2VzID0gemxpZ2h0cy5hcmVhLmRpc3RhbmNlcyxcclxuXHRcdGFyZWFEZWNheUV4cG9uZW50cyA9IHpsaWdodHMuYXJlYS5kZWNheUV4cG9uZW50cyxcclxuXHRcdGFyZWFXaWR0aHMgPSB6bGlnaHRzLmFyZWEud2lkdGhzLFxyXG5cdFx0YXJlYUhlaWdodHMgPSB6bGlnaHRzLmFyZWEuaGVpZ2h0cyxcclxuXHJcblx0XHRkaXJMZW5ndGggPSAwLFxyXG5cdFx0cG9pbnRMZW5ndGggPSAwLFxyXG5cdFx0c3BvdExlbmd0aCA9IDAsXHJcblx0XHRoZW1pTGVuZ3RoID0gMCxcclxuXHRcdGFyZWFMZW5ndGggPSAwLFxyXG5cclxuXHRcdGRpckNvdW50ID0gMCxcclxuXHRcdHBvaW50Q291bnQgPSAwLFxyXG5cdFx0c3BvdENvdW50ID0gMCxcclxuXHRcdGhlbWlDb3VudCA9IDAsXHJcblx0XHRhcmVhQ291bnQgPSAwLFxyXG5cclxuXHRcdGRpck9mZnNldCA9IDAsXHJcblx0XHRwb2ludE9mZnNldCA9IDAsXHJcblx0XHRzcG90T2Zmc2V0ID0gMCxcclxuXHRcdGhlbWlPZmZzZXQgPSAwLFxyXG5cdFx0YXJlYU9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xyXG5cclxuXHRcdFx0bGlnaHQgPSBsaWdodHNbIGwgXTtcclxuXHJcblx0XHRcdGlmICggbGlnaHQub25seVNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Y29sb3IgPSBsaWdodC5jb2xvcjtcclxuXHRcdFx0aW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xyXG5cdFx0XHRkaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkFtYmllbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0XHRcdHIgKz0gY29sb3IuciAqIGNvbG9yLnI7XHJcblx0XHRcdFx0XHRnICs9IGNvbG9yLmcgKiBjb2xvci5nO1xyXG5cdFx0XHRcdFx0YiArPSBjb2xvci5iICogY29sb3IuYjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRyICs9IGNvbG9yLnI7XHJcblx0XHRcdFx0XHRnICs9IGNvbG9yLmc7XHJcblx0XHRcdFx0XHRiICs9IGNvbG9yLmI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0ZGlyQ291bnQgKz0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0X2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBza2lwIGxpZ2h0cyB3aXRoIHVuZGVmaW5lZCBkaXJlY3Rpb25cclxuXHRcdFx0XHQvLyB0aGVzZSBjcmVhdGUgdHJvdWJsZXMgaW4gT3BlbkdMIChtYWtpbmcgcGl4ZWwgYmxhY2spXHJcblxyXG5cdFx0XHRcdGlmICggX2RpcmVjdGlvbi54ID09PSAwICYmIF9kaXJlY3Rpb24ueSA9PT0gMCAmJiBfZGlyZWN0aW9uLnogPT09IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0ZGlyT2Zmc2V0ID0gZGlyTGVuZ3RoICogMztcclxuXHJcblx0XHRcdFx0ZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgXSAgICAgPSBfZGlyZWN0aW9uLng7XHJcblx0XHRcdFx0ZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XHJcblx0XHRcdFx0ZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XHJcblxyXG5cdFx0XHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcclxuXHJcblx0XHRcdFx0XHRzZXRDb2xvckdhbW1hKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSAqIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRpckxlbmd0aCArPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRwb2ludENvdW50ICs9IDE7XHJcblxyXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdHBvaW50T2Zmc2V0ID0gcG9pbnRMZW5ndGggKiAzO1xyXG5cclxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q29sb3JHYW1tYSggcG9pbnRDb2xvcnMsIHBvaW50T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICogaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIHBvaW50Q29sb3JzLCBwb2ludE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0IF0gICAgID0gX3ZlY3RvcjMueDtcclxuXHRcdFx0XHRwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xyXG5cdFx0XHRcdHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdHBvaW50RGlzdGFuY2VzWyBwb2ludExlbmd0aCBdID0gZGlzdGFuY2U7XHJcblx0XHRcdFx0cG9pbnREZWNheUV4cG9uZW50c1sgcG9pbnRMZW5ndGggXSA9IGxpZ2h0LmRlY2F5RXhwb25lbnQ7XHJcblxyXG5cdFx0XHRcdHBvaW50TGVuZ3RoICs9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcclxuXHJcblx0XHRcdFx0c3BvdENvdW50ICs9IDE7XHJcblxyXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdHNwb3RPZmZzZXQgPSBzcG90TGVuZ3RoICogMztcclxuXHJcblx0XHRcdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKiBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggc3BvdENvbG9ycywgc3BvdE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCBdICAgICA9IF92ZWN0b3IzLng7XHJcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF92ZWN0b3IzLnk7XHJcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdHNwb3REaXN0YW5jZXNbIHNwb3RMZW5ndGggXSA9IGRpc3RhbmNlO1xyXG5cdFx0XHRcdHNwb3REZWNheUV4cG9uZW50c1sgc3BvdExlbmd0aCBdID0gbGlnaHQuZGVjYXlFeHBvbmVudDtcclxuXHJcblx0XHRcdFx0X2RpcmVjdGlvbi5jb3B5KCBfdmVjdG9yMyApO1xyXG5cdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0X2RpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XHJcblx0XHRcdFx0X2RpcmVjdGlvbi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0c3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgXSAgICAgPSBfZGlyZWN0aW9uLng7XHJcblx0XHRcdFx0c3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XHJcblx0XHRcdFx0c3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XHJcblxyXG5cdFx0XHRcdHNwb3RBbmdsZXNDb3NbIHNwb3RMZW5ndGggXSA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xyXG5cdFx0XHRcdHNwb3RFeHBvbmVudHNbIHNwb3RMZW5ndGggXSA9IGxpZ2h0LmV4cG9uZW50O1xyXG5cclxuXHRcdFx0XHRzcG90TGVuZ3RoICs9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIHtcclxuXHJcblx0XHRcdFx0aGVtaUNvdW50ICs9IDE7XHJcblxyXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdF9kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdC8vIHNraXAgbGlnaHRzIHdpdGggdW5kZWZpbmVkIGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIHRoZXNlIGNyZWF0ZSB0cm91YmxlcyBpbiBPcGVuR0wgKG1ha2luZyBwaXhlbCBibGFjaylcclxuXHJcblx0XHRcdFx0aWYgKCBfZGlyZWN0aW9uLnggPT09IDAgJiYgX2RpcmVjdGlvbi55ID09PSAwICYmIF9kaXJlY3Rpb24ueiA9PT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRoZW1pT2Zmc2V0ID0gaGVtaUxlbmd0aCAqIDM7XHJcblxyXG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgXSAgICAgPSBfZGlyZWN0aW9uLng7XHJcblx0XHRcdFx0aGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcclxuXHRcdFx0XHRoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xyXG5cclxuXHRcdFx0XHRza3lDb2xvciA9IGxpZ2h0LmNvbG9yO1xyXG5cdFx0XHRcdGdyb3VuZENvbG9yID0gbGlnaHQuZ3JvdW5kQ29sb3I7XHJcblxyXG5cdFx0XHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcclxuXHJcblx0XHRcdFx0XHRpbnRlbnNpdHlTcSA9IGludGVuc2l0eSAqIGludGVuc2l0eTtcclxuXHJcblx0XHRcdFx0XHRzZXRDb2xvckdhbW1hKCBoZW1pU2t5Q29sb3JzLCBoZW1pT2Zmc2V0LCBza3lDb2xvciwgaW50ZW5zaXR5U3EgKTtcclxuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIGhlbWlHcm91bmRDb2xvcnMsIGhlbWlPZmZzZXQsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHlTcSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBoZW1pU2t5Q29sb3JzLCBoZW1pT2Zmc2V0LCBza3lDb2xvciwgaW50ZW5zaXR5ICk7XHJcblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggaGVtaUdyb3VuZENvbG9ycywgaGVtaU9mZnNldCwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGhlbWlMZW5ndGggKz0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQXJlYUxpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRhcmVhQ291bnQgKz0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0YXJlYU9mZnNldCA9IGFyZWFMZW5ndGggKiAzO1xyXG5cclxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q29sb3JHYW1tYSggYXJlYUNvbG9ycywgYXJlYU9mZnNldCwgY29sb3IsIGludGVuc2l0eSAqIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBhcmVhQ29sb3JzLCBhcmVhT2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRhcmVhUG9zaXRpb25zWyBhcmVhT2Zmc2V0IF0gICAgID0gX3ZlY3RvcjMueDtcclxuXHRcdFx0XHRhcmVhUG9zaXRpb25zWyBhcmVhT2Zmc2V0ICsgMSBdID0gX3ZlY3RvcjMueTtcclxuXHRcdFx0XHRhcmVhUG9zaXRpb25zWyBhcmVhT2Zmc2V0ICsgMiBdID0gX3ZlY3RvcjMuejtcclxuXHJcblx0XHRcdFx0YXJlYURpc3RhbmNlc1sgYXJlYUxlbmd0aCBdID0gZGlzdGFuY2U7XHJcblx0XHRcdFx0YXJlYURlY2F5RXhwb25lbnRzWyBhcmVhTGVuZ3RoIF0gPSBsaWdodC5kZWNheUV4cG9uZW50O1xyXG5cclxuXHRcdFx0XHRsaWdodC5tYXRyaXhXb3JsZC5leHRyYWN0QmFzaXMoIF93aWR0aCwgX2hlaWdodCwgX3ZlY3RvcjMgKTtcclxuXHRcdFx0XHRfd2lkdGgubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LndpZHRoICk7XHJcblx0XHRcdFx0X2hlaWdodC5tdWx0aXBseVNjYWxhciggbGlnaHQuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdGFyZWFXaWR0aHNbIGFyZWFPZmZzZXQgXSAgICAgPSBfd2lkdGgueDtcclxuXHRcdFx0XHRhcmVhV2lkdGhzWyBhcmVhT2Zmc2V0ICsgMSBdID0gX3dpZHRoLnk7XHJcblx0XHRcdFx0YXJlYVdpZHRoc1sgYXJlYU9mZnNldCArIDIgXSA9IF93aWR0aC56O1xyXG5cclxuXHRcdFx0XHRhcmVhSGVpZ2h0c1sgYXJlYU9mZnNldCBdICAgICA9IF9oZWlnaHQueDtcclxuXHRcdFx0XHRhcmVhSGVpZ2h0c1sgYXJlYU9mZnNldCArIDEgXSA9IF9oZWlnaHQueTtcclxuXHRcdFx0XHRhcmVhSGVpZ2h0c1sgYXJlYU9mZnNldCArIDIgXSA9IF9oZWlnaHQuejtcclxuXHJcblx0XHRcdFx0YXJlYUxlbmd0aCArPSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBudWxsIGV2ZW50dWFsIHJlbWFpbnMgZnJvbSByZW1vdmVkIGxpZ2h0c1xyXG5cdFx0Ly8gKHRoaXMgaXMgdG8gYXZvaWQgaWYgaW4gc2hhZGVyKVxyXG5cclxuXHRcdGZvciAoIGwgPSBkaXJMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBkaXJDb2xvcnMubGVuZ3RoLCBkaXJDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgZGlyQ29sb3JzWyBsIF0gPSAwLjA7XHJcblx0XHRmb3IgKCBsID0gcG9pbnRMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBwb2ludENvbG9ycy5sZW5ndGgsIHBvaW50Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHBvaW50Q29sb3JzWyBsIF0gPSAwLjA7XHJcblx0XHRmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcclxuXHRcdGZvciAoIGwgPSBoZW1pTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggaGVtaVNreUNvbG9ycy5sZW5ndGgsIGhlbWlDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgaGVtaVNreUNvbG9yc1sgbCBdID0gMC4wO1xyXG5cdFx0Zm9yICggbCA9IGhlbWlMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBoZW1pR3JvdW5kQ29sb3JzLmxlbmd0aCwgaGVtaUNvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBoZW1pR3JvdW5kQ29sb3JzWyBsIF0gPSAwLjA7XHJcblx0XHRmb3IgKCBsID0gYXJlYUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGFyZWFDb2xvcnMubGVuZ3RoLCBhcmVhQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGFyZWFDb2xvcnNbIGwgXSA9IDAuMDtcclxuXHJcblx0XHR6bGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCA9IGRpckxlbmd0aDtcclxuXHRcdHpsaWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XHJcblx0XHR6bGlnaHRzLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcclxuXHRcdHpsaWdodHMuaGVtaS5sZW5ndGggPSBoZW1pTGVuZ3RoO1xyXG5cdFx0emxpZ2h0cy5hcmVhLmxlbmd0aCA9IGFyZWFMZW5ndGg7XHJcblxyXG5cdFx0emxpZ2h0cy5hbWJpZW50WyAwIF0gPSByO1xyXG5cdFx0emxpZ2h0cy5hbWJpZW50WyAxIF0gPSBnO1xyXG5cdFx0emxpZ2h0cy5hbWJpZW50WyAyIF0gPSBiO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBHTCBzdGF0ZSBzZXR0aW5nXHJcblxyXG5cdHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0aWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VOb25lICkge1xyXG5cclxuXHRcdFx0X2dsLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBmcm9udEZhY2VEaXJlY3Rpb24gPT09IFRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ1cgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlQmFjayApIHtcclxuXHJcblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVF9BTkRfQkFDSyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRNYXRlcmlhbEZhY2VzID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR2YXIgZG91YmxlU2lkZWQgPSBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5Eb3VibGVTaWRlO1xyXG5cdFx0dmFyIGZsaXBTaWRlZCA9IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlO1xyXG5cclxuXHRcdGlmICggX29sZERvdWJsZVNpZGVkICE9PSBkb3VibGVTaWRlZCApIHtcclxuXHJcblx0XHRcdGlmICggZG91YmxlU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfb2xkRG91YmxlU2lkZWQgPSBkb3VibGVTaWRlZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBfb2xkRmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNXICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfb2xkRmxpcFNpZGVkID0gZmxpcFNpZGVkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXREZXB0aFRlc3QgPSBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcclxuXHJcblx0XHRpZiAoIF9vbGREZXB0aFRlc3QgIT09IGRlcHRoVGVzdCApIHtcclxuXHJcblx0XHRcdGlmICggZGVwdGhUZXN0ICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfb2xkRGVwdGhUZXN0ID0gZGVwdGhUZXN0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXREZXB0aFdyaXRlID0gZnVuY3Rpb24gKCBkZXB0aFdyaXRlICkge1xyXG5cclxuXHRcdGlmICggX29sZERlcHRoV3JpdGUgIT09IGRlcHRoV3JpdGUgKSB7XHJcblxyXG5cdFx0XHRfZ2wuZGVwdGhNYXNrKCBkZXB0aFdyaXRlICk7XHJcblx0XHRcdF9vbGREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldExpbmVXaWR0aCAoIHdpZHRoICkge1xyXG5cclxuXHRcdGlmICggd2lkdGggIT09IF9vbGRMaW5lV2lkdGggKSB7XHJcblxyXG5cdFx0XHRfZ2wubGluZVdpZHRoKCB3aWR0aCApO1xyXG5cclxuXHRcdFx0X29sZExpbmVXaWR0aCA9IHdpZHRoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0UG9seWdvbk9mZnNldCAoIHBvbHlnb25vZmZzZXQsIGZhY3RvciwgdW5pdHMgKSB7XHJcblxyXG5cdFx0aWYgKCBfb2xkUG9seWdvbk9mZnNldCAhPT0gcG9seWdvbm9mZnNldCApIHtcclxuXHJcblx0XHRcdGlmICggcG9seWdvbm9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X29sZFBvbHlnb25PZmZzZXQgPSBwb2x5Z29ub2Zmc2V0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHBvbHlnb25vZmZzZXQgJiYgKCBfb2xkUG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IF9vbGRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkgKSB7XHJcblxyXG5cdFx0XHRfZ2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xyXG5cclxuXHRcdFx0X29sZFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XHJcblx0XHRcdF9vbGRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0QmxlbmRpbmcgPSBmdW5jdGlvbiAoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QgKSB7XHJcblxyXG5cdFx0aWYgKCBibGVuZGluZyAhPT0gX29sZEJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0aWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTm9CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5CTEVORCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cdFx0XHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcclxuXHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0Ly8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb24oIF9nbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdF9nbC5ibGVuZEZ1bmMoIF9nbC5aRVJPLCBfZ2wuT05FX01JTlVTX1NSQ19DT0xPUiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cdFx0XHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcclxuXHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuWkVSTywgX2dsLlNSQ19DT0xPUiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cdFx0XHRcdF9nbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIF9nbC5GVU5DX0FERCwgX2dsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0X2dsLmJsZW5kRnVuY1NlcGFyYXRlKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgX2dsLk9ORSwgX2dsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9vbGRCbGVuZGluZyA9IGJsZW5kaW5nO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdGlmICggYmxlbmRFcXVhdGlvbiAhPT0gX29sZEJsZW5kRXF1YXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBwYXJhbVRocmVlVG9HTCggYmxlbmRFcXVhdGlvbiApICk7XHJcblxyXG5cdFx0XHRcdF9vbGRCbGVuZEVxdWF0aW9uID0gYmxlbmRFcXVhdGlvbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYmxlbmRTcmMgIT09IF9vbGRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gX29sZEJsZW5kRHN0ICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmMgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0ICkgKTtcclxuXHJcblx0XHRcdFx0X29sZEJsZW5kU3JjID0gYmxlbmRTcmM7XHJcblx0XHRcdFx0X29sZEJsZW5kRHN0ID0gYmxlbmREc3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9vbGRCbGVuZEVxdWF0aW9uID0gbnVsbDtcclxuXHRcdFx0X29sZEJsZW5kU3JjID0gbnVsbDtcclxuXHRcdFx0X29sZEJsZW5kRHN0ID0gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIERlZmluZXNcclxuXHJcblx0ZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbmVzICggZGVmaW5lcyApIHtcclxuXHJcblx0XHR2YXIgdmFsdWUsIGNodW5rLCBjaHVua3MgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZCBpbiBkZWZpbmVzICkge1xyXG5cclxuXHRcdFx0dmFsdWUgPSBkZWZpbmVzWyBkIF07XHJcblx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRjaHVuayA9IFwiI2RlZmluZSBcIiArIGQgKyBcIiBcIiArIHZhbHVlO1xyXG5cdFx0XHRjaHVua3MucHVzaCggY2h1bmsgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCBcIlxcblwiICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFNoYWRlcnNcclxuXHJcblx0ZnVuY3Rpb24gYnVpbGRQcm9ncmFtKCBzaGFkZXJJRCwgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlciwgdW5pZm9ybXMsIGF0dHJpYnV0ZXMsIGRlZmluZXMsIHBhcmFtZXRlcnMsIGluZGV4MEF0dHJpYnV0ZU5hbWUgKSB7XHJcblxyXG5cdFx0dmFyIHAsIHBsLCBkLCBwcm9ncmFtLCBjb2RlO1xyXG5cdFx0dmFyIGNodW5rcyA9IFtdO1xyXG5cclxuXHRcdC8vIEdlbmVyYXRlIGNvZGVcclxuXHJcblx0XHRpZiAoIHNoYWRlcklEICkge1xyXG5cclxuXHRcdFx0Y2h1bmtzLnB1c2goIHNoYWRlcklEICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNodW5rcy5wdXNoKCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0XHRjaHVua3MucHVzaCggdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGQgaW4gZGVmaW5lcyApIHtcclxuXHJcblx0XHRcdGNodW5rcy5wdXNoKCBkICk7XHJcblx0XHRcdGNodW5rcy5wdXNoKCBkZWZpbmVzWyBkIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggcCBpbiBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0Y2h1bmtzLnB1c2goIHAgKTtcclxuXHRcdFx0Y2h1bmtzLnB1c2goIHBhcmFtZXRlcnNbIHAgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb2RlID0gY2h1bmtzLmpvaW4oKTtcclxuXHJcblx0XHQvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcclxuXHJcblx0XHRmb3IgKCBwID0gMCwgcGwgPSBfcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcHJvZ3JhbUluZm8gPSBfcHJvZ3JhbXNbIHAgXTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUluZm8uY29kZS5sZW5ndGggPT09IGNvZGUubGVuZ3RoICYmIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XHJcblxyXG5cdFx0XHRcdHByb2dyYW1JbmZvLnVzZWRUaW1lcyArKztcclxuXHJcblx0XHRcdFx0cmV0dXJuIHByb2dyYW1JbmZvLnByb2dyYW07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaGFkb3dNYXBUeXBlRGVmaW5lID0gXCJTSEFET1dNQVBfVFlQRV9CQVNJQ1wiO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTaGFkb3dNYXAgKSB7XHJcblxyXG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gXCJTSEFET1dNQVBfVFlQRV9QQ0ZcIjtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XHJcblxyXG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gXCJTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVFwiO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xyXG5cclxuXHRcdHByb2dyYW0gPSBfZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdHZhciBwcmVmaXhfdmVydGV4ID0gW1xyXG5cclxuXHRcdFx0XCJwcmVjaXNpb24gXCIgKyBfcHJlY2lzaW9uICsgXCIgZmxvYXQ7XCIsXHJcblx0XHRcdFwicHJlY2lzaW9uIFwiICsgX3ByZWNpc2lvbiArIFwiIGludDtcIixcclxuXHJcblx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/IFwiI2RlZmluZSBWRVJURVhfVEVYVFVSRVNcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRfdGhpcy5nYW1tYUlucHV0ID8gXCIjZGVmaW5lIEdBTU1BX0lOUFVUXCIgOiBcIlwiLFxyXG5cdFx0XHRfdGhpcy5nYW1tYU91dHB1dCA/IFwiI2RlZmluZSBHQU1NQV9PVVRQVVRcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0FSRUFfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhBcmVhTGlnaHRzLFxyXG5cclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9TSEFET1dTIFwiICsgcGFyYW1ldGVycy5tYXhTaGFkb3dzLFxyXG5cclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9CT05FUyBcIiArIHBhcmFtZXRlcnMubWF4Qm9uZXMsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm9wYWNpdHlNYXAgPyBcIiNkZWZpbmUgVVNFX09QQUNJVFlNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuZmFsbG9mZk1hcCA/IFwiI2RlZmluZSBVU0VfRkFMTE9GRk1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy50cmFuc2x1Y2VuY3lNYXAgPyBcIiNkZWZpbmUgVVNFX1RSQU5TTFVDRU5DWU1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyBcIiNkZWZpbmUgVVNFX0VOVk1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/IFwiI2RlZmluZSBVU0VfTElHSFRNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyBcIiNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyBcIiNkZWZpbmUgVVNFX0JVTVBNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMucmVmbGVjdGl2aXR5TWFwID8gXCIjZGVmaW5lIFVTRV9SRUZMRUNUSVZJVFlNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMucm91Z2huZXNzTWFwID8gXCIjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMubWV0YWxsaWNNYXAgPyBcIiNkZWZpbmUgVVNFX01FVEFMTElDTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfTk9STUFMTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyBcIiNkZWZpbmUgVVNFX0NPTE9SXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmNsZWFyQ29hdCA/IFwiI2RlZmluZSBDTEVBUkNPQVRcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLmFuaXNvdHJvcHkgPyBcIiNkZWZpbmUgQU5JU09UUk9QWVwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5hbmlzb3Ryb3B5TWFwID8gXCIjZGVmaW5lIFVTRV9BTklTT1RST1BZTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHQoIHBhcmFtZXRlcnMuYW5pc290cm9weSAmJiBwYXJhbWV0ZXJzLmFuaXNvdHJvcHlSb3RhdGlvbiApID8gXCIjZGVmaW5lIEFOSVNPVFJPUFlST1RBVElPTlwiIDogXCJcIixcclxuXHRcdFx0KCBwYXJhbWV0ZXJzLmFuaXNvdHJvcHkgJiYgcGFyYW1ldGVycy5hbmlzb3Ryb3B5Um90YXRpb25NYXAgKSA/IFwiI2RlZmluZSBVU0VfQU5JU09UUk9QWVJPVEFUSU9OTUFQXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5za2lubmluZyA/IFwiI2RlZmluZSBVU0VfU0tJTk5JTkdcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/IFwiI2RlZmluZSBCT05FX1RFWFRVUkVcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/IFwiI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyA/IFwiI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLndyYXBBcm91bmQgPyBcIiNkZWZpbmUgV1JBUF9BUk9VTkRcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyBcIiNkZWZpbmUgRE9VQkxFX1NJREVEXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/IFwiI2RlZmluZSBGTElQX1NJREVEXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gXCIjZGVmaW5lIFVTRV9TSEFET1dNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBcIiArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcERlYnVnID8gXCIjZGVmaW5lIFNIQURPV01BUF9ERUJVR1wiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBDYXNjYWRlID8gXCIjZGVmaW5lIFNIQURPV01BUF9DQVNDQURFXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gPyBcIiNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTlwiIDogXCJcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIixcclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djI7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBVU0VfQ09MT1JcIixcclxuXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXHJcblxyXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwO1wiLFxyXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxO1wiLFxyXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyO1wiLFxyXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7XCIsXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTtcIixcclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyO1wiLFxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NDtcIixcclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1O1wiLFxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDY7XCIsXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NztcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7XCIsXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiXCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIik7XHJcblxyXG5cdFxyXG5cdFx0dmFyIHByZWZpeF9mcmFnbWVudCA9IFtcclxuXHJcblx0XHRcdFwicHJlY2lzaW9uIFwiICsgX3ByZWNpc2lvbiArIFwiIGZsb2F0O1wiLFxyXG5cdFx0XHRcInByZWNpc2lvbiBcIiArIF9wcmVjaXNpb24gKyBcIiBpbnQ7XCIsXHJcblxyXG5cdFx0XHQoIHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCApID8gXCIjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVwiIDogXCJcIixcclxuXHJcblx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0FSRUFfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhBcmVhTGlnaHRzLFxyXG5cclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9TSEFET1dTIFwiICsgcGFyYW1ldGVycy5tYXhTaGFkb3dzLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYVRlc3QgPyBcIiNkZWZpbmUgQUxQSEFURVNUIFwiICsgcGFyYW1ldGVycy5hbHBoYVRlc3Q6IFwiXCIsXHJcblxyXG5cdFx0XHRfdGhpcy5nYW1tYUlucHV0ID8gXCIjZGVmaW5lIEdBTU1BX0lOUFVUXCIgOiBcIlwiLFxyXG5cdFx0XHRfdGhpcy5nYW1tYU91dHB1dCA/IFwiI2RlZmluZSBHQU1NQV9PVVRQVVRcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nICkgPyBcIiNkZWZpbmUgVVNFX0ZPR1wiIDogXCJcIixcclxuXHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gXCIjZGVmaW5lIEZPR19FWFAyXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5tYXAgPyBcIiNkZWZpbmUgVVNFX01BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5vcGFjaXR5TWFwID8gXCIjZGVmaW5lIFVTRV9PUEFDSVRZTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmZhbGxvZmZNYXAgPyBcIiNkZWZpbmUgVVNFX0ZBTExPRkZNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMudHJhbnNsdWNlbmN5TWFwID8gXCIjZGVmaW5lIFVTRV9UUkFOU0xVQ0VOQ1lNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gXCIjZGVmaW5lIFVTRV9FTlZNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMubGlnaHRNYXAgPyBcIiNkZWZpbmUgVVNFX0xJR0hUTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gXCIjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gXCIjZGVmaW5lIFVTRV9CVU1QTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnJlZmxlY3Rpdml0eU1hcCA/IFwiI2RlZmluZSBVU0VfUkVGTEVDVElWSVRZTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/IFwiI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm1ldGFsbGljTWFwID8gXCIjZGVmaW5lIFVTRV9NRVRBTExJQ01BUFwiIDogXCJcIixcdFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfTk9STUFMTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyBcIiNkZWZpbmUgVVNFX0NPTE9SXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmNsZWFyQ29hdCA/IFwiI2RlZmluZSBDTEVBUkNPQVRcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLnRyYW5zbHVjZW5jeSA/IFwiI2RlZmluZSBUUkFOU0xVQ0VOQ1lcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLmFuaXNvdHJvcHkgPyBcIiNkZWZpbmUgQU5JU09UUk9QWVwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5hbmlzb3Ryb3B5TWFwID8gXCIjZGVmaW5lIFVTRV9BTklTT1RST1BZTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHQoIHBhcmFtZXRlcnMuYW5pc290cm9weSAmJiBwYXJhbWV0ZXJzLmFuaXNvdHJvcHlSb3RhdGlvbiApID8gXCIjZGVmaW5lIEFOSVNPVFJPUFlST1RBVElPTlwiIDogXCJcIixcclxuXHRcdFx0KCBwYXJhbWV0ZXJzLmFuaXNvdHJvcHkgJiYgcGFyYW1ldGVycy5hbmlzb3Ryb3B5Um90YXRpb25NYXAgKSA/IFwiI2RlZmluZSBVU0VfQU5JU09UUk9QWVJPVEFUSU9OTUFQXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5mYWxsb2ZmID8gXCIjZGVmaW5lIEZBTExPRkZcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLndyYXBBcm91bmQgPyBcIiNkZWZpbmUgV1JBUF9BUk9VTkRcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyBcIiNkZWZpbmUgRE9VQkxFX1NJREVEXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/IFwiI2RlZmluZSBGTElQX1NJREVEXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gXCIjZGVmaW5lIFVTRV9TSEFET1dNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBcIiArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcERlYnVnID8gXCIjZGVmaW5lIFNIQURPV01BUF9ERUJVR1wiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBDYXNjYWRlID8gXCIjZGVmaW5lIFNIQURPV01BUF9DQVNDQURFXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XCIsXHJcblx0XHRcdFwiXCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIik7XHJcblxyXG5cdFx0dmFyIGdsVmVydGV4U2hhZGVyID0gZ2V0U2hhZGVyKCBcInZlcnRleFwiLCBwcmVmaXhfdmVydGV4ICsgdmVydGV4U2hhZGVyICk7XHJcblx0XHR2YXIgZ2xGcmFnbWVudFNoYWRlciA9IGdldFNoYWRlciggXCJmcmFnbWVudFwiLCBwcmVmaXhfZnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdF9nbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XHJcblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XHJcblxyXG5cdFx0Ly8gRm9yY2UgYSBwYXJ0aWN1bGFyIGF0dHJpYnV0ZSB0byBpbmRleCAwLlxyXG5cdFx0Ly8gYmVjYXVzZSBwb3RlbnRpYWxseSBleHBlbnNpdmUgZW11bGF0aW9uIGlzIGRvbmUgYnkgYnJvd3NlciBpZiBhdHRyaWJ1dGUgMCBpcyBkaXNhYmxlZC5cclxuXHRcdC8vIEFuZCwgY29sb3IsIGZvciBleGFtcGxlIGlzIG9mdGVuIGF1dG9tYXRpY2FsbHkgYm91bmQgdG8gaW5kZXggMCBzbyBkaXNhYmxpbmcgaXRcclxuXHRcdGlmICggaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgaW5kZXgwQXR0cmlidXRlTmFtZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbUxvZ0luZm8gPSBfZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKTtcclxuXHJcblx0XHRpZiAoIF9nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBfZ2wuTElOS19TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5vbmVycm9yKCBzaGFkZXJJRCArICcgc2hhZGVyIHByb2dyYW0gZXJyb3I6ICcgKyBfZ2wuZ2V0RXJyb3IoKSArICdcXG4nICsgcHJvZ3JhbUxvZ0luZm8sIHsgdmFsaWRhdGlvblN0YXR1czogX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIF9nbC5WQUxJREFURV9TVEFUVVMgKSB9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNsZWFuIHVwXHJcblxyXG5cdFx0X2dsLmRlbGV0ZVNoYWRlciggZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cdFx0X2dsLmRlbGV0ZVNoYWRlciggZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRwcm9ncmFtLnVuaWZvcm1zID0ge307XHJcblx0XHRwcm9ncmFtLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHJcblx0XHR2YXIgaWRlbnRpZmllcnMsIHUsIGEsIGk7XHJcblxyXG5cdFx0Ly8gY2FjaGUgdW5pZm9ybSBsb2NhdGlvbnNcclxuXHJcblx0XHRpZGVudGlmaWVycyA9IFtcclxuXHJcblx0XHRcdCd2aWV3TWF0cml4JywgJ21vZGVsVmlld01hdHJpeCcsICdwcm9qZWN0aW9uTWF0cml4JywgJ25vcm1hbE1hdHJpeCcsICdtb2RlbE1hdHJpeCcsICdjYW1lcmFQb3NpdGlvbicsXHJcblx0XHRcdCdtb3JwaFRhcmdldEluZmx1ZW5jZXMnXHJcblxyXG5cdFx0XTtcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGlkZW50aWZpZXJzLnB1c2goICdib25lVGV4dHVyZScgKTtcclxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggJ2JvbmVUZXh0dXJlV2lkdGgnICk7XHJcblx0XHRcdGlkZW50aWZpZXJzLnB1c2goICdib25lVGV4dHVyZUhlaWdodCcgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggJ2JvbmVHbG9iYWxNYXRyaWNlcycgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdSBpbiB1bmlmb3JtcyApIHtcclxuXHJcblx0XHRcdGlkZW50aWZpZXJzLnB1c2goIHUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y2FjaGVVbmlmb3JtTG9jYXRpb25zKCBwcm9ncmFtLCBpZGVudGlmaWVycyApO1xyXG5cclxuXHRcdC8vIGNhY2hlIGF0dHJpYnV0ZXMgbG9jYXRpb25zXHJcblxyXG5cdFx0aWRlbnRpZmllcnMgPSBbXHJcblxyXG5cdFx0XHRcInBvc2l0aW9uXCIsIFwibm9ybWFsXCIsIFwidXZcIiwgXCJ1djJcIiwgXCJ0YW5nZW50XCIsIFwiY29sb3JcIixcclxuXHRcdFx0XCJza2luSW5kZXhcIiwgXCJza2luV2VpZ2h0XCIsIFwibGluZURpc3RhbmNlXCJcclxuXHJcblx0XHRdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5tYXhNb3JwaFRhcmdldHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCBcIm1vcnBoVGFyZ2V0XCIgKyBpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5tYXhNb3JwaE5vcm1hbHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCBcIm1vcnBoTm9ybWFsXCIgKyBpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGEgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlkZW50aWZpZXJzLnB1c2goIGEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y2FjaGVBdHRyaWJ1dGVMb2NhdGlvbnMoIHByb2dyYW0sIGlkZW50aWZpZXJzICk7XHJcblxyXG5cdFx0cHJvZ3JhbS5pZCA9IF9wcm9ncmFtc19jb3VudGVyICsrO1xyXG5cclxuXHRcdF9wcm9ncmFtcy5wdXNoKCB7IHByb2dyYW06IHByb2dyYW0sIGNvZGU6IGNvZGUsIHVzZWRUaW1lczogMSB9ICk7XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkucHJvZ3JhbXMgPSBfcHJvZ3JhbXMubGVuZ3RoO1xyXG5cclxuXHRcdHJldHVybiBwcm9ncmFtO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBTaGFkZXIgcGFyYW1ldGVycyBjYWNoZVxyXG5cclxuXHRmdW5jdGlvbiBjYWNoZVVuaWZvcm1Mb2NhdGlvbnMgKCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcclxuXHJcblx0XHR2YXIgaSwgbCwgaWQ7XHJcblxyXG5cdFx0Zm9yKCBpID0gMCwgbCA9IGlkZW50aWZpZXJzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZCA9IGlkZW50aWZpZXJzWyBpIF07XHJcblx0XHRcdHByb2dyYW0udW5pZm9ybXNbIGlkIF0gPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBpZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY2FjaGVBdHRyaWJ1dGVMb2NhdGlvbnMgKCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcclxuXHJcblx0XHR2YXIgaSwgbCwgaWQ7XHJcblxyXG5cdFx0Zm9yKCBpID0gMCwgbCA9IGlkZW50aWZpZXJzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZCA9IGlkZW50aWZpZXJzWyBpIF07XHJcblx0XHRcdHByb2dyYW0uYXR0cmlidXRlc1sgaWQgXSA9IF9nbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgaWQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzICggc3RyaW5nICkge1xyXG5cclxuXHRcdHZhciBjaHVua3MgPSBzdHJpbmcuc3BsaXQoIFwiXFxuXCIgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly8gQ2hyb21lIHJlcG9ydHMgc2hhZGVyIGVycm9ycyBvbiBsaW5lc1xyXG5cdFx0XHQvLyBzdGFydGluZyBjb3VudGluZyBmcm9tIDFcclxuXHJcblx0XHRcdGNodW5rc1sgaSBdID0gKCBpICsgMSApICsgXCI6IFwiICsgY2h1bmtzWyBpIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjaHVua3Muam9pbiggXCJcXG5cIiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZXRTaGFkZXIgKCB0eXBlLCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0dmFyIHNoYWRlcjtcclxuXHJcblx0XHRpZiAoIHR5cGUgPT09IFwiZnJhZ21lbnRcIiApIHtcclxuXHJcblx0XHRcdHNoYWRlciA9IF9nbC5jcmVhdGVTaGFkZXIoIF9nbC5GUkFHTUVOVF9TSEFERVIgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcInZlcnRleFwiICkge1xyXG5cclxuXHRcdFx0c2hhZGVyID0gX2dsLmNyZWF0ZVNoYWRlciggX2dsLlZFUlRFWF9TSEFERVIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2dsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcclxuXHRcdF9nbC5jb21waWxlU2hhZGVyKCBzaGFkZXIgKTtcclxuXHJcblx0XHRpZiAoICFfZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIF9nbC5DT01QSUxFX1NUQVRVUyApICkge1xyXG5cclxuXHRcdFx0VEhSRUUub25lcnJvciggXCJzaGFkZXIgZXJyb3JcIiwgeyBzaGFkZXJJbmZvTG9nOiBfZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIHNoYWRlckNvZGU6IGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSB9ICk7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBUZXh0dXJlc1xyXG5cclxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyAoIHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcblx0XHRpZiAoIGlzSW1hZ2VQb3dlck9mVHdvICkge1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBTICkgKTtcclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBUICkgKTtcclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWFnRmlsdGVyICkgKTtcclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblxyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWluRmlsdGVyICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBfZ2xFeHRlbnNpb25UZXh0dXJlRmlsdGVyQW5pc290cm9waWMgJiYgdGV4dHVyZS50eXBlICE9PSBUSFJFRS5GbG9hdFR5cGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgdGV4dHVyZS5fX29sZEFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgX2dsRXh0ZW5zaW9uVGV4dHVyZUZpbHRlckFuaXNvdHJvcGljLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBfbWF4QW5pc290cm9weSApICk7XHJcblx0XHRcdFx0dGV4dHVyZS5fX29sZEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLm5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdFx0aWYgKCAhIHRleHR1cmUuX193ZWJnbEluaXQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuX193ZWJnbEluaXQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRcdFx0X3RoaXMuaW5mby5tZW1vcnkudGV4dHVyZXMgKys7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XHJcblxyXG5cdFx0XHR2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlLFxyXG5cdFx0XHRpc0ltYWdlUG93ZXJPZlR3byA9IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSxcclxuXHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcclxuXHRcdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xyXG5cclxuXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xyXG5cclxuXHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxyXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xyXG5cdFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xyXG5cclxuXHRcdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHRcdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRmb3IoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQhPT1USFJFRS5SR0JBRm9ybWF0ICkge1xyXG5cdFx0XHRcdFx0XHRfZ2wuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgeyAvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxyXG5cclxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxyXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xyXG5cdFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xyXG5cclxuXHRcdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHRcdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5pbWFnZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSgpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjbGFtcFRvTWF4U2l6ZSAoIGltYWdlLCBtYXhTaXplICkge1xyXG5cclxuXHRcdGlmICggaW1hZ2Uud2lkdGggPD0gbWF4U2l6ZSAmJiBpbWFnZS5oZWlnaHQgPD0gbWF4U2l6ZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcclxuXHRcdC8vIHByZW11bHRpcGxpZWQgYWxwaGEuXHJcblxyXG5cdFx0dmFyIG1heERpbWVuc2lvbiA9IE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblx0XHR2YXIgbmV3V2lkdGggPSBNYXRoLmZsb29yKCBpbWFnZS53aWR0aCAqIG1heFNpemUgLyBtYXhEaW1lbnNpb24gKTtcclxuXHRcdHZhciBuZXdIZWlnaHQgPSBNYXRoLmZsb29yKCBpbWFnZS5oZWlnaHQgKiBtYXhTaXplIC8gbWF4RGltZW5zaW9uICk7XHJcblxyXG5cdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRjYW52YXMud2lkdGggPSBuZXdXaWR0aDtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcblxyXG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcclxuXHRcdGN0eC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGNhbnZhcztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZSAoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApIHtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5uZWVkc1VwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcclxuXHJcblx0XHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xyXG5cclxuXHRcdFx0XHR2YXIgaXNDb21wcmVzc2VkID0gdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1xyXG5cclxuXHRcdFx0XHR2YXIgY3ViZUltYWdlID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBfdGhpcy5hdXRvU2NhbGVDdWJlbWFwcyAmJiAhIGlzQ29tcHJlc3NlZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGN1YmVJbWFnZVsgaSBdID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2VbIGkgXSwgX21heEN1YmVtYXBTaXplICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGN1YmVJbWFnZVsgaSBdID0gdGV4dHVyZS5pbWFnZVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcclxuXHRcdFx0XHRpc0ltYWdlUG93ZXJPZlR3byA9IFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSxcclxuXHRcdFx0XHRnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxyXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcclxuXHJcblx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmKCAhaXNDb21wcmVzc2VkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBqIF07XHJcblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCE9PVRIUkVFLlJHQkFGb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0X2dsLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlRHluYW1pYyAoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gUmVuZGVyIHRhcmdldHNcclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBGcmFtZUJ1ZmZlciAoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIHRleHR1cmVUYXJnZXQgKSB7XHJcblxyXG5cdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xyXG5cdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGV4dHVyZVRhcmdldCwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlLCAwICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyICggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgICkge1xyXG5cclxuXHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9DT01QT05FTlQxNiwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0LyogRm9yIHNvbWUgcmVhc29uIHRoaXMgaXMgbm90IHdvcmtpbmcuIERlZmF1bHRpbmcgdG8gUkdCQTQuXHJcblx0XHR9IGVsc2UgaWYoICEgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5TVEVOQ0lMX0lOREVYOCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHRcdCovXHJcblx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuUkdCQTQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCAmJiAhIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdHJ1ZTtcclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9PT0gdW5kZWZpbmVkICkgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPSB0cnVlO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XHJcblxyXG5cdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0X3RoaXMuaW5mby5tZW1vcnkudGV4dHVyZXMgKys7XHJcblxyXG5cdFx0XHQvLyBTZXR1cCB0ZXh0dXJlLCBjcmVhdGUgcmVuZGVyIGFuZCBmcmFtZSBidWZmZXJzXHJcblxyXG5cdFx0XHR2YXIgaXNUYXJnZXRQb3dlck9mVHdvID0gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQuaGVpZ2h0ICksXHJcblx0XHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LmZvcm1hdCApLFxyXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudHlwZSApO1xyXG5cclxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcclxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IFtdO1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xyXG5cclxuXHRcdFx0XHRcdHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xyXG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbS5fX3dlYmdsUmVuZGVyYnVmZmVyO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xyXG5cdFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0LCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcclxuXHJcblx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XHJcblxyXG5cdFx0XHRcdHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFJlbGVhc2UgZXZlcnl0aGluZ1xyXG5cclxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XHJcblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZnJhbWVidWZmZXIsIHdpZHRoLCBoZWlnaHQsIHZ4LCB2eTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSBdO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XHJcblx0XHRcdGhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XHJcblxyXG5cdFx0XHR2eCA9IDA7XHJcblx0XHRcdHZ5ID0gMDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZnJhbWVidWZmZXIgPSBudWxsO1xyXG5cclxuXHRcdFx0d2lkdGggPSBfdmlld3BvcnRXaWR0aDtcclxuXHRcdFx0aGVpZ2h0ID0gX3ZpZXdwb3J0SGVpZ2h0O1xyXG5cclxuXHRcdFx0dnggPSBfdmlld3BvcnRYO1xyXG5cdFx0XHR2eSA9IF92aWV3cG9ydFk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblx0XHRcdF9nbC52aWV3cG9ydCggdngsIHZ5LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRfY3VycmVudEZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9jdXJyZW50V2lkdGggPSB3aWR0aDtcclxuXHRcdF9jdXJyZW50SGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xyXG5cdFx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XHJcblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXHJcblxyXG5cdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrICggZiApIHtcclxuXHJcblx0XHRpZiAoIGYgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcclxuXHJcblx0XHRcdHJldHVybiBfZ2wuTkVBUkVTVDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIF9nbC5MSU5FQVI7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIE1hcCB0aHJlZS5qcyBjb25zdGFudHMgdG8gV2ViR0wgY29uc3RhbnRzXHJcblxyXG5cdGZ1bmN0aW9uIHBhcmFtVGhyZWVUb0dMICggcCApIHtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5SRVBFQVQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSByZXR1cm4gX2dsLkNMQU1QX1RPX0VER0U7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLk1JUlJPUkVEX1JFUEVBVDtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1Q7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfQllURTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzZfNTtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkJ5dGVUeXBlICkgcmV0dXJuIF9nbC5CWVRFO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5TaG9ydFR5cGUgKSByZXR1cm4gX2dsLlNIT1JUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkludFR5cGUgKSByZXR1cm4gX2dsLklOVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9JTlQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkZsb2F0VHlwZSApIHJldHVybiBfZ2wuRkxPQVQ7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5BbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuQUxQSEE7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkZvcm1hdCApIHJldHVybiBfZ2wuUkdCO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0JBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRV9BTFBIQTtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkFkZEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX0FERDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19TVUJUUkFDVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlplcm9GYWN0b3IgKSByZXR1cm4gX2dsLlpFUk87XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZUZhY3RvciApIHJldHVybiBfZ2wuT05FO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5TcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuU1JDX0NPTE9SO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5Ec3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuRFNUX0FMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0FMUEhBO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBX1NBVFVSQVRFO1xyXG5cclxuXHRcdGlmICggX2dsRXh0ZW5zaW9uQ29tcHJlc3NlZFRleHR1cmVTM1RDICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQy5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gX2dsRXh0ZW5zaW9uQ29tcHJlc3NlZFRleHR1cmVTM1RDLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQWxsb2NhdGlvbnNcclxuXHJcblx0ZnVuY3Rpb24gYWxsb2NhdGVCb25lcyAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIF9zdXBwb3J0c0JvbmVUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gMTAyNDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxyXG5cdFx0XHQvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyXHJcblx0XHRcdC8vICAgdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxlIG9iamVjdHMgKVxyXG5cdFx0XHQvL1xyXG5cdFx0XHQvLyBcdC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcclxuXHRcdFx0Ly8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXHJcblx0XHRcdC8vICAgICh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcclxuXHJcblx0XHRcdHZhciBuVmVydGV4VW5pZm9ybXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcclxuXHRcdFx0dmFyIG5WZXJ0ZXhNYXRyaWNlcyA9IE1hdGguZmxvb3IoICggblZlcnRleFVuaWZvcm1zIC0gMjAgKSAvIDQgKTtcclxuXHJcblx0XHRcdHZhciBtYXhCb25lcyA9IG5WZXJ0ZXhNYXRyaWNlcztcclxuXHJcblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdG1heEJvbmVzID0gTWF0aC5taW4oIG9iamVjdC5ib25lcy5sZW5ndGgsIG1heEJvbmVzICk7XHJcblxyXG5cdFx0XHRcdGlmICggbWF4Qm9uZXMgPCBvYmplY3QuYm9uZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRcdFRIUkVFLm9ud2FybmluZyggXCJXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtIFwiICsgb2JqZWN0LmJvbmVzLmxlbmd0aCArIFwiLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0IFwiICsgbWF4Qm9uZXMgKyBcIiAodHJ5IE9wZW5HTCBpbnN0ZWFkIG9mIEFOR0xFKVwiICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYXhCb25lcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKSB7XHJcblxyXG5cdFx0dmFyIGRpckxpZ2h0cyA9IDA7XHJcblx0XHR2YXIgcG9pbnRMaWdodHMgPSAwO1xyXG5cdFx0dmFyIHNwb3RMaWdodHMgPSAwO1xyXG5cdFx0dmFyIGhlbWlMaWdodHMgPSAwO1xyXG5cdFx0dmFyIGFyZWFMaWdodHMgPSAwO1xyXG5cclxuXHRcdGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgbGlnaHQgPSBsaWdodHNbIGwgXTtcclxuXHJcblx0XHRcdGlmICggbGlnaHQub25seVNoYWRvdyB8fCBsaWdodC52aXNpYmxlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBkaXJMaWdodHMgKys7XHJcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkgcG9pbnRMaWdodHMgKys7XHJcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBzcG90TGlnaHRzICsrO1xyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkgaGVtaUxpZ2h0cyArKztcclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkFyZWFMaWdodCApIGFyZWFMaWdodHMgKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7ICdkaXJlY3Rpb25hbCcgOiBkaXJMaWdodHMsICdwb2ludCcgOiBwb2ludExpZ2h0cywgJ3Nwb3QnOiBzcG90TGlnaHRzLCAnaGVtaSc6IGhlbWlMaWdodHMsICdhcmVhJzogYXJlYUxpZ2h0cyB9O1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhbGxvY2F0ZVNoYWRvd3MoIGxpZ2h0cyApIHtcclxuXHJcblx0XHR2YXIgbWF4U2hhZG93cyA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCsrICkge1xyXG5cclxuXHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBsIF07XHJcblxyXG5cdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIG1heFNoYWRvd3MgKys7XHJcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICYmICEgbGlnaHQuc2hhZG93Q2FzY2FkZSApIG1heFNoYWRvd3MgKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXhTaGFkb3dzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBJbml0aWFsaXphdGlvblxyXG5cclxuXHRmdW5jdGlvbiBpbml0R0woKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0ge1xyXG5cdFx0XHRcdGFscGhhOiBfYWxwaGEsXHJcblx0XHRcdFx0cHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxyXG5cdFx0XHRcdGFudGlhbGlhczogX2FudGlhbGlhcyxcclxuXHRcdFx0XHRzdGVuY2lsOiBfc3RlbmNpbCxcclxuXHRcdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdF9nbCA9IF9jb250ZXh0IHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJywgYXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHRcdGlmICggX2dsID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRUSFJFRS5vbmVycm9yKCAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0VEhSRUUub25lcnJvciggZXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2dsRXh0ZW5zaW9uVGV4dHVyZUZsb2F0ID0gX2dsLmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cdFx0X2dsRXh0ZW5zaW9uVGV4dHVyZUZsb2F0TGluZWFyID0gX2dsLmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcclxuXHRcdF9nbEV4dGVuc2lvblN0YW5kYXJkRGVyaXZhdGl2ZXMgPSBfZ2wuZ2V0RXh0ZW5zaW9uKCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xyXG5cclxuXHRcdF9nbEV4dGVuc2lvblRleHR1cmVGaWx0ZXJBbmlzb3Ryb3BpYyA9IF9nbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgX2dsLmdldEV4dGVuc2lvbiggJ01PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgX2dsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XHJcblxyXG5cdFx0X2dsRXh0ZW5zaW9uQ29tcHJlc3NlZFRleHR1cmVTM1RDID0gX2dsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IF9nbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgX2dsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHJcblx0XHRpZiAoICEgX2dsRXh0ZW5zaW9uVGV4dHVyZUZsb2F0ICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBGbG9hdCB0ZXh0dXJlcyBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIF9nbEV4dGVuc2lvblN0YW5kYXJkRGVyaXZhdGl2ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFN0YW5kYXJkIGRlcml2YXRpdmVzIG5vdCBzdXBwb3J0ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICEgX2dsRXh0ZW5zaW9uVGV4dHVyZUZpbHRlckFuaXNvdHJvcGljICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBbmlzb3Ryb3BpYyB0ZXh0dXJlIGZpbHRlcmluZyBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogUzNUQyBjb21wcmVzc2VkIHRleHR1cmVzIG5vdCBzdXBwb3J0ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFwicmFuZ2VNaW5cIiAgOiAxLFxyXG5cdFx0XHRcdFx0XCJyYW5nZU1heFwiICA6IDEsXHJcblx0XHRcdFx0XHRcInByZWNpc2lvblwiIDogMVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldERlZmF1bHRHTFN0YXRlICgpIHtcclxuXHJcblx0XHRfZ2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xyXG5cdFx0X2dsLmNsZWFyRGVwdGgoIDEgKTtcclxuXHRcdF9nbC5jbGVhclN0ZW5jaWwoIDAgKTtcclxuXHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0X2dsLmRlcHRoRnVuYyggX2dsLkxFUVVBTCApO1xyXG5cclxuXHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcclxuXHRcdF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcclxuXHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcclxuXHRcdF9nbC5ibGVuZEZ1bmMoIF9nbC5TUkNfQUxQSEEsIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdFx0X2dsLnZpZXdwb3J0KCBfdmlld3BvcnRYLCBfdmlld3BvcnRZLCBfdmlld3BvcnRXaWR0aCwgX3ZpZXdwb3J0SGVpZ2h0ICk7XHJcblx0XHRcclxuXHRcdF9nbC5jbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBkZWZhdWx0IHBsdWdpbnMgKG9yZGVyIGlzIGltcG9ydGFudClcclxuXHJcblx0dGhpcy5zaGFkb3dNYXBQbHVnaW4gPSBuZXcgVEhSRUUuU2hhZG93TWFwUGx1Z2luKCk7XHJcblx0dGhpcy5hZGRQcmVQbHVnaW4oIHRoaXMuc2hhZG93TWFwUGx1Z2luICk7XHJcblxyXG5cdHRoaXMuYWRkUG9zdFBsdWdpbiggbmV3IFRIUkVFLlNwcml0ZVBsdWdpbigpICk7XHJcblx0dGhpcy5hZGRQb3N0UGx1Z2luKCBuZXcgVEhSRUUuTGVuc0ZsYXJlUGx1Z2luKCkgKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xyXG5cclxuXHR0aGlzLndpZHRoID0gd2lkdGg7XHJcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHR0aGlzLndyYXBTID0gb3B0aW9ucy53cmFwUyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblx0dGhpcy53cmFwVCA9IG9wdGlvbnMud3JhcFQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cclxuXHR0aGlzLm1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHR0aGlzLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcclxuXHJcblx0dGhpcy5hbmlzb3Ryb3B5ID0gb3B0aW9ucy5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaXNvdHJvcHkgOiAxO1xyXG5cclxuXHR0aGlzLm9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XHJcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHR0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6IFRIUkVFLlJHQkFGb3JtYXQ7XHJcblx0dGhpcy50eXBlID0gb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xyXG5cclxuXHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XHJcblx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xyXG5cclxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2hhcmVEZXB0aEZyb20gPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0bXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0ICk7XHJcblxyXG5cdFx0dG1wLndyYXBTID0gdGhpcy53cmFwUztcclxuXHRcdHRtcC53cmFwVCA9IHRoaXMud3JhcFQ7XHJcblxyXG5cdFx0dG1wLm1hZ0ZpbHRlciA9IHRoaXMubWFnRmlsdGVyO1xyXG5cdFx0dG1wLm1pbkZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xyXG5cclxuXHRcdHRtcC5hbmlzb3Ryb3B5ID0gdGhpcy5hbmlzb3Ryb3B5O1xyXG5cclxuXHRcdHRtcC5vZmZzZXQuY29weSggdGhpcy5vZmZzZXQgKTtcclxuXHRcdHRtcC5yZXBlYXQuY29weSggdGhpcy5yZXBlYXQgKTtcclxuXHJcblx0XHR0bXAuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XHJcblx0XHR0bXAudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcblx0XHR0bXAuZGVwdGhCdWZmZXIgPSB0aGlzLmRlcHRoQnVmZmVyO1xyXG5cdFx0dG1wLnN0ZW5jaWxCdWZmZXIgPSB0aGlzLnN0ZW5jaWxCdWZmZXI7XHJcblxyXG5cdFx0dG1wLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdHRtcC5zaGFyZURlcHRoRnJvbSA9IHRoaXMuc2hhcmVEZXB0aEZyb207XHJcblxyXG5cdFx0cmV0dXJuIHRtcDtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcclxuXHJcblx0VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xyXG5cclxuXHR0aGlzLmFjdGl2ZUN1YmVGYWNlID0gMDsgLy8gUFggMCwgTlggMSwgUFkgMiwgTlkgMywgUFogNCwgTlogNVxyXG5cclxufTtcclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlJlbmRlcmFibGVWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMucG9zaXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblxyXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUmVuZGVyYWJsZVZlcnRleC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggdmVydGV4ICkge1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uV29ybGQuY29weSggdmVydGV4LnBvc2l0aW9uV29ybGQgKTtcclxuXHR0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHZlcnRleC5wb3NpdGlvblNjcmVlbiApO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlJlbmRlcmFibGVGYWNlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmlkID0gMDtcclxuXHJcblx0dGhpcy52MSA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblx0dGhpcy52MiA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblx0dGhpcy52MyA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblxyXG5cdHRoaXMuY2VudHJvaWRNb2RlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHRoaXMubm9ybWFsTW9kZWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR0aGlzLnZlcnRleE5vcm1hbHNNb2RlbCA9IFsgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xyXG5cdHRoaXMudmVydGV4Tm9ybWFsc0xlbmd0aCA9IDA7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBudWxsO1xyXG5cdHRoaXMubWF0ZXJpYWwgPSBudWxsO1xyXG5cdHRoaXMudXZzID0gW1tdXTtcclxuXHJcblx0dGhpcy56ID0gMDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SZW5kZXJhYmxlT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmlkID0gMDtcclxuXHJcblx0dGhpcy5vYmplY3QgPSBudWxsO1xyXG5cdHRoaXMueiA9IDA7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUmVuZGVyYWJsZVNwcml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5pZCA9IDA7XHJcblxyXG5cdHRoaXMub2JqZWN0ID0gbnVsbDtcclxuXHJcblx0dGhpcy54ID0gMDtcclxuXHR0aGlzLnkgPSAwO1xyXG5cdHRoaXMueiA9IDA7XHJcblxyXG5cdHRoaXMucm90YXRpb24gPSAwO1xyXG5cdHRoaXMuc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFsID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SZW5kZXJhYmxlTGluZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5pZCA9IDA7XHJcblxyXG5cdHRoaXMudjEgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xyXG5cdHRoaXMudjIgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFsgbmV3IFRIUkVFLkNvbG9yKCksIG5ldyBUSFJFRS5Db2xvcigpIF07XHJcblx0dGhpcy5tYXRlcmlhbCA9IG51bGw7XHJcblxyXG5cdHRoaXMueiA9IDA7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuR2VvbWV0cnlVdGlscyA9IHtcclxuXHJcblx0Ly8gTWVyZ2UgdHdvIGdlb21ldHJpZXMgb3IgZ2VvbWV0cnkgYW5kIGdlb21ldHJ5IGZyb20gb2JqZWN0ICh1c2luZyBvYmplY3QncyB0cmFuc2Zvcm0pXHJcblxyXG5cdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgb2JqZWN0MiAvKiBtZXNoIHwgZ2VvbWV0cnkgKi8sIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeCwgbm9ybWFsTWF0cml4LFxyXG5cdFx0dmVydGV4T2Zmc2V0ID0gZ2VvbWV0cnkxLnZlcnRpY2VzLmxlbmd0aCxcclxuXHRcdHV2UG9zaXRpb24gPSBnZW9tZXRyeTEuZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aCxcclxuXHRcdGdlb21ldHJ5MiA9IG9iamVjdDIgaW5zdGFuY2VvZiBUSFJFRS5NZXNoID8gb2JqZWN0Mi5nZW9tZXRyeSA6IG9iamVjdDIsXHJcblx0XHR2ZXJ0aWNlczEgPSBnZW9tZXRyeTEudmVydGljZXMsXHJcblx0XHR2ZXJ0aWNlczIgPSBnZW9tZXRyeTIudmVydGljZXMsXHJcblx0XHRmYWNlczEgPSBnZW9tZXRyeTEuZmFjZXMsXHJcblx0XHRmYWNlczIgPSBnZW9tZXRyeTIuZmFjZXMsXHJcblx0XHR1dnMxID0gZ2VvbWV0cnkxLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcclxuXHRcdHV2czIgPSBnZW9tZXRyeTIuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWxJbmRleE9mZnNldCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxJbmRleE9mZnNldCA9IDA7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QyIGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdG9iamVjdDIubWF0cml4QXV0b1VwZGF0ZSAmJiBvYmplY3QyLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdFx0bWF0cml4ID0gb2JqZWN0Mi5tYXRyaXg7XHJcblxyXG5cdFx0XHRub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlczJbIGkgXTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCApIHZlcnRleENvcHkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlczJbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXHJcblx0XHRcdGZhY2VWZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLFxyXG5cdFx0XHRmYWNlVmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xyXG5cdFx0XHRmYWNlQ29weS5ub3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdGlmICggbm9ybWFsTWF0cml4ICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0bm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xyXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcclxuXHJcblx0XHRcdGZhY2VDb3B5LmNlbnRyb2lkLmNvcHkoIGZhY2UuY2VudHJvaWQgKTtcclxuXHJcblx0XHRcdGlmICggbWF0cml4ICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQ29weS5jZW50cm9pZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHV2c1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHV2Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR1dkNvcHkucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2WyBqIF0ueCwgdXZbIGogXS55ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHV2czEucHVzaCggdXZDb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgcmFuZG9tIHBvaW50IGluIHRyaWFuZ2xlICh2aWEgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMpXHJcblx0Ly8gXHQodW5pZm9ybSBkaXN0cmlidXRpb24pXHJcblx0Ly8gXHRodHRwOi8vd3d3LmNnYWZhcS5pbmZvL3dpa2kvUmFuZG9tX1BvaW50X0luX1RyaWFuZ2xlXHJcblxyXG5cdHJhbmRvbVBvaW50SW5UcmlhbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvckEsIHZlY3RvckIsIHZlY3RvckMgKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dmFyIGEgPSBUSFJFRS5NYXRoLnJhbmRvbTE2KCk7XHJcblx0XHRcdHZhciBiID0gVEhSRUUuTWF0aC5yYW5kb20xNigpO1xyXG5cclxuXHRcdFx0aWYgKCAoIGEgKyBiICkgPiAxICkge1xyXG5cclxuXHRcdFx0XHRhID0gMSAtIGE7XHJcblx0XHRcdFx0YiA9IDEgLSBiO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGMgPSAxIC0gYSAtIGI7XHJcblxyXG5cdFx0XHRwb2ludC5jb3B5KCB2ZWN0b3JBICk7XHJcblx0XHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCBhICk7XHJcblxyXG5cdFx0XHR2ZWN0b3IuY29weSggdmVjdG9yQiApO1xyXG5cdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIGIgKTtcclxuXHJcblx0XHRcdHBvaW50LmFkZCggdmVjdG9yICk7XHJcblxyXG5cdFx0XHR2ZWN0b3IuY29weSggdmVjdG9yQyApO1xyXG5cdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIGMgKTtcclxuXHJcblx0XHRcdHBvaW50LmFkZCggdmVjdG9yICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHQvLyBHZXQgcmFuZG9tIHBvaW50IGluIGZhY2UgKHRyaWFuZ2xlIC8gcXVhZClcclxuXHQvLyAodW5pZm9ybSBkaXN0cmlidXRpb24pXHJcblxyXG5cdHJhbmRvbVBvaW50SW5GYWNlOiBmdW5jdGlvbiAoIGZhY2UsIGdlb21ldHJ5LCB1c2VDYWNoZWRBcmVhcyApIHtcclxuXHJcblx0XHR2YXIgdkEsIHZCLCB2QywgdkQ7XHJcblxyXG5cdFx0dkEgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHR2QiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdHZDID0gZ2VvbWV0cnkudmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbVBvaW50SW5UcmlhbmdsZSggdkEsIHZCLCB2QyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIHJhbmRvbSBwb2ludHMgaW4gbWVzaFxyXG5cdC8vIFx0LSBjcmVhdGUgYXJyYXkgd2l0aCBjdW11bGF0aXZlIHN1bXMgb2YgZmFjZSBhcmVhc1xyXG5cdC8vICAtIHBpY2sgcmFuZG9tIG51bWJlciBmcm9tIDAgdG8gdG90YWwgYXJlYVxyXG5cdC8vICAtIGZpbmQgY29ycmVzcG9uZGluZyBwbGFjZSBpbiBhcmVhIGFycmF5IGJ5IGJpbmFyeSBzZWFyY2hcclxuXHQvL1x0LSBnZXQgcmFuZG9tIHBvaW50IGluIGZhY2VcclxuXHJcblx0cmFuZG9tUG9pbnRzSW5HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbiApIHtcclxuXHJcblx0XHR2YXIgZmFjZSwgaSxcclxuXHRcdFx0ZmFjZXMgPSBnZW9tZXRyeS5mYWNlcyxcclxuXHRcdFx0dmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcclxuXHRcdFx0aWwgPSBmYWNlcy5sZW5ndGgsXHJcblx0XHRcdHRvdGFsQXJlYSA9IDAsXHJcblx0XHRcdGN1bXVsYXRpdmVBcmVhcyA9IFtdLFxyXG5cdFx0XHR2QSwgdkIsIHZDLCB2RDtcclxuXHJcblx0XHQvLyBwcmVjb21wdXRlIGZhY2UgYXJlYXNcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHR2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0dkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdHZDID0gdmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0ZmFjZS5fYXJlYSA9IFRIUkVFLkdlb21ldHJ5VXRpbHMudHJpYW5nbGVBcmVhKCB2QSwgdkIsIHZDICk7XHJcblxyXG5cdFx0XHR0b3RhbEFyZWEgKz0gZmFjZS5fYXJlYTtcclxuXHJcblx0XHRcdGN1bXVsYXRpdmVBcmVhc1sgaSBdID0gdG90YWxBcmVhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBiaW5hcnkgc2VhcmNoIGN1bXVsYXRpdmUgYXJlYXMgYXJyYXlcclxuXHJcblx0XHRmdW5jdGlvbiBiaW5hcnlTZWFyY2hJbmRpY2VzKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGJpbmFyeVNlYXJjaCggc3RhcnQsIGVuZCApIHtcclxuXHJcblx0XHRcdFx0Ly8gcmV0dXJuIGNsb3Nlc3QgbGFyZ2VyIGluZGV4XHJcblx0XHRcdFx0Ly8gaWYgZXhhY3QgbnVtYmVyIGlzIG5vdCBmb3VuZFxyXG5cclxuXHRcdFx0XHRpZiAoIGVuZCA8IHN0YXJ0IClcclxuXHRcdFx0XHRcdHJldHVybiBzdGFydDtcclxuXHJcblx0XHRcdFx0dmFyIG1pZCA9IHN0YXJ0ICsgTWF0aC5mbG9vciggKCBlbmQgLSBzdGFydCApIC8gMiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1bXVsYXRpdmVBcmVhc1sgbWlkIF0gPiB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gYmluYXJ5U2VhcmNoKCBzdGFydCwgbWlkIC0gMSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdW11bGF0aXZlQXJlYXNbIG1pZCBdIDwgdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGJpbmFyeVNlYXJjaCggbWlkICsgMSwgZW5kICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG1pZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IGJpbmFyeVNlYXJjaCggMCwgY3VtdWxhdGl2ZUFyZWFzLmxlbmd0aCAtIDEgKVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBwaWNrIHJhbmRvbSBmYWNlIHdlaWdodGVkIGJ5IGZhY2UgYXJlYVxyXG5cclxuXHRcdHZhciByLCBpbmRleCxcclxuXHRcdFx0cmVzdWx0ID0gW107XHJcblxyXG5cdFx0dmFyIHN0YXRzID0ge307XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBuOyBpICsrICkge1xyXG5cclxuXHRcdFx0ciA9IFRIUkVFLk1hdGgucmFuZG9tMTYoKSAqIHRvdGFsQXJlYTtcclxuXHJcblx0XHRcdGluZGV4ID0gYmluYXJ5U2VhcmNoSW5kaWNlcyggciApO1xyXG5cclxuXHRcdFx0cmVzdWx0WyBpIF0gPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbVBvaW50SW5GYWNlKCBmYWNlc1sgaW5kZXggXSwgZ2VvbWV0cnksIHRydWUgKTtcclxuXHJcblx0XHRcdGlmICggISBzdGF0c1sgaW5kZXggXSApIHtcclxuXHJcblx0XHRcdFx0c3RhdHNbIGluZGV4IF0gPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c3RhdHNbIGluZGV4IF0gKz0gMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHRyaWFuZ2xlIGFyZWEgKGhhbGYgb2YgcGFyYWxsZWxvZ3JhbSlcclxuXHQvL1x0aHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9UcmlhbmdsZUFyZWEuaHRtbFxyXG5cclxuXHR0cmlhbmdsZUFyZWE6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdmVjdG9yMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgdmVjdG9yMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yQSwgdmVjdG9yQiwgdmVjdG9yQyApIHtcclxuXHJcblx0XHRcdHZlY3RvcjEuc3ViVmVjdG9ycyggdmVjdG9yQiwgdmVjdG9yQSApO1xyXG5cdFx0XHR2ZWN0b3IyLnN1YlZlY3RvcnMoIHZlY3RvckMsIHZlY3RvckEgKTtcclxuXHRcdFx0dmVjdG9yMS5jcm9zcyggdmVjdG9yMiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIDAuNSAqIHZlY3RvcjEubGVuZ3RoKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHQvLyBDZW50ZXIgZ2VvbWV0cnkgc28gdGhhdCAwLDAsMCBpcyBpbiBjZW50ZXIgb2YgYm91bmRpbmcgYm94XHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHR2YXIgYmIgPSBnZW9tZXRyeS5ib3VuZGluZ0JveDtcclxuXHJcblx0XHR2YXIgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRvZmZzZXQuYWRkVmVjdG9ycyggYmIubWluLCBiYi5tYXggKTtcclxuXHRcdG9mZnNldC5tdWx0aXBseVNjYWxhciggLTAuNSApO1xyXG5cclxuXHRcdGdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbiggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApICk7XHJcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmlhbmd1bGF0ZVF1YWRzOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciBpLCBpbCwgaiwgamw7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gW107XHJcblx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGdlb21ldHJ5LmZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRmYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMCwgamwgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlVmVydGV4VXZzWyBqIF0ucHVzaCggZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaiBdWyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuZmFjZXMgPSBmYWNlcztcclxuXHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzO1xyXG5cclxuXHRcdGdlb21ldHJ5LmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHRcdGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Lmhhc1RhbmdlbnRzICkgZ2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5JbWFnZVV0aWxzID0ge1xyXG5cclxuXHRjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxyXG5cclxuXHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XHJcblx0XHRsb2FkZXIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIHVuZGVmaW5lZCwgbWFwcGluZyApO1xyXG5cclxuXHRcdHZhciBpbWFnZSA9IGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xyXG5cdFx0dGV4dHVyZS5zb3VyY2VGaWxlID0gdXJsO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb2FkQ29tcHJlc3NlZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUoKTtcclxuXHRcdHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG5cdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0XHRyZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBidWZmZXIgPSByZXF1ZXN0LnJlc3BvbnNlO1xyXG5cdFx0XHR2YXIgZGRzID0gVEhSRUUuSW1hZ2VVdGlscy5wYXJzZUREUyggYnVmZmVyLCB0cnVlICk7XHJcblxyXG5cdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IGRkcy5mb3JtYXQ7XHJcblxyXG5cdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSBkZHMubWlwbWFwcztcclxuXHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IGRkcy53aWR0aDtcclxuXHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSBkZHMuaGVpZ2h0O1xyXG5cclxuXHRcdFx0Ly8gZ2wuZ2VuZXJhdGVNaXBtYXAgZmFpbHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcclxuXHRcdFx0Ly8gbWlwbWFwcyBtdXN0IGJlIGVtYmVkZGVkIGluIHRoZSBERFMgZmlsZVxyXG5cdFx0XHQvLyBvciB0ZXh0dXJlIGZpbHRlcnMgbXVzdCBub3QgdXNlIG1pcG1hcHBpbmdcclxuXHJcblx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlcXVlc3Qub25lcnJvciA9IG9uRXJyb3I7XHJcblxyXG5cdFx0cmVxdWVzdC5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XHJcblx0XHRyZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuXHRcdHJlcXVlc3Quc2VuZCggbnVsbCApO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb2FkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICggYXJyYXksIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgaW1hZ2VzID0gW107XHJcblx0XHRpbWFnZXMubG9hZENvdW50ID0gMDtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XHJcblx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xyXG5cdFx0aWYgKCBtYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuXHRcdC8vIG5vIGZsaXBwaW5nIG5lZWRlZCBmb3IgY3ViZSB0ZXh0dXJlc1xyXG5cclxuXHRcdHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHR2YXIgY3ViZUltYWdlID0gbmV3IEltYWdlKCk7XHJcblx0XHRcdGltYWdlc1sgaSBdID0gY3ViZUltYWdlO1xyXG5cclxuXHRcdFx0Y3ViZUltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0aW1hZ2VzLmxvYWRDb3VudCArPSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoIGltYWdlcy5sb2FkQ291bnQgPT09IDYgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Y3ViZUltYWdlLm9uZXJyb3IgPSBvbkVycm9yO1xyXG5cclxuXHRcdFx0Y3ViZUltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHRcdFx0Y3ViZUltYWdlLnNyYyA9IGFycmF5WyBpIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIGFycmF5LCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIGltYWdlcyA9IFtdO1xyXG5cdFx0aW1hZ2VzLmxvYWRDb3VudCA9IDA7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUoKTtcclxuXHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XHJcblx0XHRpZiAoIG1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG5cdFx0Ly8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcclxuXHRcdC8vIChhbHNvIGZsaXBwaW5nIGRvZXNuJ3Qgd29yayBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyApXHJcblxyXG5cdFx0dGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGNhbid0IGdlbmVyYXRlIG1pcG1hcHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcclxuXHRcdC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcclxuXHJcblx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdHZhciBnZW5lcmF0ZUN1YmVGYWNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoIHJxLCBpbWcgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHR2YXIgYnVmZmVyID0gcnEucmVzcG9uc2U7XHJcblx0XHRcdFx0dmFyIGRkcyA9IFRIUkVFLkltYWdlVXRpbHMucGFyc2VERFMoIGJ1ZmZlciwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0XHRpbWcuZm9ybWF0ID0gZGRzLmZvcm1hdDtcclxuXHJcblx0XHRcdFx0aW1nLm1pcG1hcHMgPSBkZHMubWlwbWFwcztcclxuXHRcdFx0XHRpbWcud2lkdGggPSBkZHMud2lkdGg7XHJcblx0XHRcdFx0aW1nLmhlaWdodCA9IGRkcy5oZWlnaHQ7XHJcblxyXG5cdFx0XHRcdGltYWdlcy5sb2FkQ291bnQgKz0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbWFnZXMubG9hZENvdW50ID09PSA2ICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gZGRzLmZvcm1hdDtcclxuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjb21wcmVzc2VkIGN1YmVtYXAgdGV4dHVyZXMgYXMgNiBzZXBhcmF0ZSBERFMgZmlsZXNcclxuXHJcblx0XHRpZiAoIGFycmF5IGluc3RhbmNlb2YgQXJyYXkgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjdWJlSW1hZ2UgPSB7fTtcclxuXHRcdFx0XHRpbWFnZXNbIGkgXSA9IGN1YmVJbWFnZTtcclxuXHJcblx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0XHRcdFx0cmVxdWVzdC5vbmxvYWQgPSBnZW5lcmF0ZUN1YmVGYWNlQ2FsbGJhY2soIHJlcXVlc3QsIGN1YmVJbWFnZSApO1xyXG5cdFx0XHRcdHJlcXVlc3Qub25lcnJvciA9IG9uRXJyb3I7XHJcblxyXG5cdFx0XHRcdHZhciB1cmwgPSBhcnJheVsgaSBdO1xyXG5cclxuXHRcdFx0XHRyZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcclxuXHRcdFx0XHRyZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuXHRcdFx0XHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHQvLyBjb21wcmVzc2VkIGN1YmVtYXAgdGV4dHVyZSBzdG9yZWQgaW4gYSBzaW5nbGUgRERTIGZpbGVcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIHVybCA9IGFycmF5O1xyXG5cdFx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuXHRcdFx0cmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBidWZmZXIgPSByZXF1ZXN0LnJlc3BvbnNlO1xyXG5cdFx0XHRcdHZhciBkZHMgPSBUSFJFRS5JbWFnZVV0aWxzLnBhcnNlRERTKCBidWZmZXIsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkZHMuaXNDdWJlbWFwICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBmYWNlcyA9IGRkcy5taXBtYXBzLmxlbmd0aCAvIGRkcy5taXBtYXBDb3VudDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgZiA9IDA7IGYgPCBmYWNlczsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGltYWdlc1sgZiBdID0geyBtaXBtYXBzIDogW10gfTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRkcy5taXBtYXBDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ubWlwbWFwcy5wdXNoKCBkZHMubWlwbWFwc1sgZiAqIGRkcy5taXBtYXBDb3VudCArIGkgXSApO1xyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmZvcm1hdCA9IGRkcy5mb3JtYXQ7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ud2lkdGggPSBkZHMud2lkdGg7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gZGRzLmhlaWdodDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSBkZHMuZm9ybWF0O1xyXG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xyXG5cclxuXHRcdFx0cmVxdWVzdC5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XHJcblx0XHRcdHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG5cdFx0XHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWRERFNUZXh0dXJlOiBmdW5jdGlvbiAoIHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBpbWFnZXMgPSBbXTtcclxuXHRcdGltYWdlcy5sb2FkQ291bnQgPSAwO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlKCk7XHJcblx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xyXG5cdFx0aWYgKCBtYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuXHRcdC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXHJcblx0XHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxyXG5cclxuXHRcdHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXHJcblx0XHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXHJcblxyXG5cdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHR7XHJcblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG5cdFx0XHRyZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGJ1ZmZlciA9IHJlcXVlc3QucmVzcG9uc2U7XHJcblx0XHRcdFx0dmFyIGRkcyA9IFRIUkVFLkltYWdlVXRpbHMucGFyc2VERFMoIGJ1ZmZlciwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRkcy5pc0N1YmVtYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGZhY2VzID0gZGRzLm1pcG1hcHMubGVuZ3RoIC8gZGRzLm1pcG1hcENvdW50O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHMgOiBbXSB9O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGRzLm1pcG1hcENvdW50OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIGRkcy5taXBtYXBzWyBmICogZGRzLm1pcG1hcENvdW50ICsgaSBdICk7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gZGRzLmZvcm1hdDtcclxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS53aWR0aCA9IGRkcy53aWR0aDtcclxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5oZWlnaHQgPSBkZHMuaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gZGRzLndpZHRoO1xyXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSBkZHMuaGVpZ2h0O1xyXG5cdFx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gZGRzLm1pcG1hcHM7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IGRkcy5mb3JtYXQ7XHJcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJlcXVlc3Qub25lcnJvciA9IG9uRXJyb3I7XHJcblxyXG5cdFx0XHRyZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcclxuXHRcdFx0cmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblx0XHRcdHJlcXVlc3Quc2VuZCggbnVsbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VERFM6IGZ1bmN0aW9uICggYnVmZmVyLCBsb2FkTWlwbWFwcyApIHtcclxuXHJcblx0XHR2YXIgZGRzID0geyBtaXBtYXBzOiBbXSwgd2lkdGg6IDAsIGhlaWdodDogMCwgZm9ybWF0OiBudWxsLCBtaXBtYXBDb3VudDogMSB9O1xyXG5cclxuXHRcdC8vIEFkYXB0ZWQgZnJvbSBAdG9qaSdzIEREUyB1dGlsc1xyXG5cdFx0Ly9cdGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL3dlYmdsLXRleHR1cmUtdXRpbHMvYmxvYi9tYXN0ZXIvdGV4dHVyZS11dGlsL2Rkcy5qc1xyXG5cclxuXHRcdC8vIEFsbCB2YWx1ZXMgYW5kIHN0cnVjdHVyZXMgcmVmZXJlbmNlZCBmcm9tOlxyXG5cdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2JiOTQzOTkxLmFzcHgvXHJcblxyXG5cdFx0dmFyIEREU19NQUdJQyA9IDB4MjA1MzQ0NDQ7XHJcblxyXG5cdFx0dmFyIEREU0RfQ0FQUyA9IDB4MSxcclxuXHRcdFx0RERTRF9IRUlHSFQgPSAweDIsXHJcblx0XHRcdEREU0RfV0lEVEggPSAweDQsXHJcblx0XHRcdEREU0RfUElUQ0ggPSAweDgsXHJcblx0XHRcdEREU0RfUElYRUxGT1JNQVQgPSAweDEwMDAsXHJcblx0XHRcdEREU0RfTUlQTUFQQ09VTlQgPSAweDIwMDAwLFxyXG5cdFx0XHRERFNEX0xJTkVBUlNJWkUgPSAweDgwMDAwLFxyXG5cdFx0XHRERFNEX0RFUFRIID0gMHg4MDAwMDA7XHJcblxyXG5cdFx0dmFyIEREU0NBUFNfQ09NUExFWCA9IDB4OCxcclxuXHRcdFx0RERTQ0FQU19NSVBNQVAgPSAweDQwMDAwMCxcclxuXHRcdFx0RERTQ0FQU19URVhUVVJFID0gMHgxMDAwO1xyXG5cclxuXHRcdHZhciBERFNDQVBTMl9DVUJFTUFQID0gMHgyMDAsXHJcblx0XHRcdEREU0NBUFMyX0NVQkVNQVBfUE9TSVRJVkVYID0gMHg0MDAsXHJcblx0XHRcdEREU0NBUFMyX0NVQkVNQVBfTkVHQVRJVkVYID0gMHg4MDAsXHJcblx0XHRcdEREU0NBUFMyX0NVQkVNQVBfUE9TSVRJVkVZID0gMHgxMDAwLFxyXG5cdFx0XHRERFNDQVBTMl9DVUJFTUFQX05FR0FUSVZFWSA9IDB4MjAwMCxcclxuXHRcdFx0RERTQ0FQUzJfQ1VCRU1BUF9QT1NJVElWRVogPSAweDQwMDAsXHJcblx0XHRcdEREU0NBUFMyX0NVQkVNQVBfTkVHQVRJVkVaID0gMHg4MDAwLFxyXG5cdFx0XHRERFNDQVBTMl9WT0xVTUUgPSAweDIwMDAwMDtcclxuXHJcblx0XHR2YXIgRERQRl9BTFBIQVBJWEVMUyA9IDB4MSxcclxuXHRcdFx0RERQRl9BTFBIQSA9IDB4MixcclxuXHRcdFx0RERQRl9GT1VSQ0MgPSAweDQsXHJcblx0XHRcdEREUEZfUkdCID0gMHg0MCxcclxuXHRcdFx0RERQRl9ZVVYgPSAweDIwMCxcclxuXHRcdFx0RERQRl9MVU1JTkFOQ0UgPSAweDIwMDAwO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZvdXJDQ1RvSW50MzIoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCkgK1xyXG5cdFx0XHRcdCh2YWx1ZS5jaGFyQ29kZUF0KDEpIDw8IDgpICtcclxuXHRcdFx0XHQodmFsdWUuY2hhckNvZGVBdCgyKSA8PCAxNikgK1xyXG5cdFx0XHRcdCh2YWx1ZS5jaGFyQ29kZUF0KDMpIDw8IDI0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gaW50MzJUb0ZvdXJDQyggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcclxuXHRcdFx0XHR2YWx1ZSAmIDB4ZmYsXHJcblx0XHRcdFx0KHZhbHVlID4+IDgpICYgMHhmZixcclxuXHRcdFx0XHQodmFsdWUgPj4gMTYpICYgMHhmZixcclxuXHRcdFx0XHQodmFsdWUgPj4gMjQpICYgMHhmZlxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGxvYWRBUkdCTWlwKCBidWZmZXIsIGRhdGFPZmZzZXQsIHdpZHRoLCBoZWlnaHQgKSB7XHJcblx0XHRcdHZhciBkYXRhTGVuZ3RoID0gd2lkdGgqaGVpZ2h0KjQ7XHJcblx0XHRcdHZhciBzcmNCdWZmZXIgPSBuZXcgVWludDhBcnJheSggYnVmZmVyLCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoICk7XHJcblx0XHRcdHZhciBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSggZGF0YUxlbmd0aCApO1xyXG5cdFx0XHR2YXIgZHN0ID0gMDtcclxuXHRcdFx0dmFyIHNyYyA9IDA7XHJcblx0XHRcdGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrICkge1xyXG5cdFx0XHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKSB7XHJcblx0XHRcdFx0XHR2YXIgYiA9IHNyY0J1ZmZlcltzcmNdOyBzcmMrKztcclxuXHRcdFx0XHRcdHZhciBnID0gc3JjQnVmZmVyW3NyY107IHNyYysrO1xyXG5cdFx0XHRcdFx0dmFyIHIgPSBzcmNCdWZmZXJbc3JjXTsgc3JjKys7XHJcblx0XHRcdFx0XHR2YXIgYSA9IHNyY0J1ZmZlcltzcmNdOyBzcmMrKztcclxuXHRcdFx0XHRcdGJ5dGVBcnJheVtkc3RdID0gcjsgZHN0Kys7XHQvL3JcclxuXHRcdFx0XHRcdGJ5dGVBcnJheVtkc3RdID0gZzsgZHN0Kys7XHQvL2dcclxuXHRcdFx0XHRcdGJ5dGVBcnJheVtkc3RdID0gYjsgZHN0Kys7XHQvL2JcclxuXHRcdFx0XHRcdGJ5dGVBcnJheVtkc3RdID0gYTsgZHN0Kys7XHQvL2FcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGJ5dGVBcnJheTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgRk9VUkNDX0RYVDEgPSBmb3VyQ0NUb0ludDMyKFwiRFhUMVwiKTtcclxuXHRcdHZhciBGT1VSQ0NfRFhUMyA9IGZvdXJDQ1RvSW50MzIoXCJEWFQzXCIpO1xyXG5cdFx0dmFyIEZPVVJDQ19EWFQ1ID0gZm91ckNDVG9JbnQzMihcIkRYVDVcIik7XHJcblxyXG5cdFx0dmFyIGhlYWRlckxlbmd0aEludCA9IDMxOyAvLyBUaGUgaGVhZGVyIGxlbmd0aCBpbiAzMiBiaXQgaW50c1xyXG5cclxuXHRcdC8vIE9mZnNldHMgaW50byB0aGUgaGVhZGVyIGFycmF5XHJcblxyXG5cdFx0dmFyIG9mZl9tYWdpYyA9IDA7XHJcblxyXG5cdFx0dmFyIG9mZl9zaXplID0gMTtcclxuXHRcdHZhciBvZmZfZmxhZ3MgPSAyO1xyXG5cdFx0dmFyIG9mZl9oZWlnaHQgPSAzO1xyXG5cdFx0dmFyIG9mZl93aWR0aCA9IDQ7XHJcblxyXG5cdFx0dmFyIG9mZl9taXBtYXBDb3VudCA9IDc7XHJcblxyXG5cdFx0dmFyIG9mZl9wZkZsYWdzID0gMjA7XHJcblx0XHR2YXIgb2ZmX3BmRm91ckNDID0gMjE7XHJcblx0XHR2YXIgb2ZmX1JHQkJpdENvdW50ID0gMjI7XHJcblx0XHR2YXIgb2ZmX1JCaXRNYXNrID0gMjM7XHJcblx0XHR2YXIgb2ZmX0dCaXRNYXNrID0gMjQ7XHJcblx0XHR2YXIgb2ZmX0JCaXRNYXNrID0gMjU7XHJcblx0XHR2YXIgb2ZmX0FCaXRNYXNrID0gMjY7XHJcblxyXG5cdFx0dmFyIG9mZl9jYXBzID0gMjc7XHJcblx0XHR2YXIgb2ZmX2NhcHMyID0gMjg7XHJcblx0XHR2YXIgb2ZmX2NhcHMzID0gMjk7XHJcblx0XHR2YXIgb2ZmX2NhcHM0ID0gMzA7XHJcblxyXG5cdFx0Ly8gUGFyc2UgaGVhZGVyXHJcblxyXG5cdFx0dmFyIGhlYWRlciA9IG5ldyBJbnQzMkFycmF5KCBidWZmZXIsIDAsIGhlYWRlckxlbmd0aEludCApO1xyXG5cclxuXHRcdGlmICggaGVhZGVyWyBvZmZfbWFnaWMgXSAhPT0gRERTX01BR0lDICkge1xyXG5cclxuXHRcdFx0VEhSRUUub25lcnJvciggXCJJbWFnZVV0aWxzLnBhcnNlRERTKCk6IEludmFsaWQgbWFnaWMgbnVtYmVyIGluIEREUyBoZWFkZXJcIiApO1xyXG5cdFx0XHRyZXR1cm4gZGRzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICEgaGVhZGVyWyBvZmZfcGZGbGFncyBdICYgRERQRl9GT1VSQ0MgKSB7XHJcblxyXG5cdFx0XHRUSFJFRS5vbmVycm9yKCBcIkltYWdlVXRpbHMucGFyc2VERFMoKTogVW5zdXBwb3J0ZWQgZm9ybWF0LCBtdXN0IGNvbnRhaW4gYSBGb3VyQ0MgY29kZVwiICk7XHJcblx0XHRcdHJldHVybiBkZHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBibG9ja0J5dGVzO1xyXG5cclxuXHRcdHZhciBmb3VyQ0MgPSBoZWFkZXJbIG9mZl9wZkZvdXJDQyBdO1xyXG5cclxuXHRcdHZhciBpc1JHQkFVbmNvbXByZXNzZWQgPSBmYWxzZTtcclxuXHJcblx0XHRzd2l0Y2ggKCBmb3VyQ0MgKSB7XHJcblxyXG5cdFx0XHRjYXNlIEZPVVJDQ19EWFQxOlxyXG5cclxuXHRcdFx0XHRibG9ja0J5dGVzID0gODtcclxuXHRcdFx0XHRkZHMuZm9ybWF0ID0gVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQ7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIEZPVVJDQ19EWFQzOlxyXG5cclxuXHRcdFx0XHRibG9ja0J5dGVzID0gMTY7XHJcblx0XHRcdFx0ZGRzLmZvcm1hdCA9IFRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgRk9VUkNDX0RYVDU6XHJcblxyXG5cdFx0XHRcdGJsb2NrQnl0ZXMgPSAxNjtcclxuXHRcdFx0XHRkZHMuZm9ybWF0ID0gVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0aWYoIGhlYWRlcltvZmZfUkdCQml0Q291bnRdID09MzIgXHJcblx0XHRcdFx0XHQmJiBoZWFkZXJbb2ZmX1JCaXRNYXNrXSYweGZmMDAwMFxyXG5cdFx0XHRcdFx0JiYgaGVhZGVyW29mZl9HQml0TWFza10mMHhmZjAwIFxyXG5cdFx0XHRcdFx0JiYgaGVhZGVyW29mZl9CQml0TWFza10mMHhmZlxyXG5cdFx0XHRcdFx0JiYgaGVhZGVyW29mZl9BQml0TWFza10mMHhmZjAwMDAwMCAgKSB7XHJcblx0XHRcdFx0XHRpc1JHQkFVbmNvbXByZXNzZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0YmxvY2tCeXRlcyA9IDY0O1xyXG5cdFx0XHRcdFx0ZGRzLmZvcm1hdCA9IFRIUkVFLlJHQkFGb3JtYXQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFRIUkVFLm9uZXJyb3IoIFwiSW1hZ2VVdGlscy5wYXJzZUREUygpOiBVbnN1cHBvcnRlZCBGb3VyQ0MgY29kZTogXCIsIGludDMyVG9Gb3VyQ0MoIGZvdXJDQyApICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gZGRzO1xyXG5cdFx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRkZHMubWlwbWFwQ291bnQgPSAxO1xyXG5cclxuXHRcdGlmICggaGVhZGVyWyBvZmZfZmxhZ3MgXSAmIEREU0RfTUlQTUFQQ09VTlQgJiYgbG9hZE1pcG1hcHMgIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0ZGRzLm1pcG1hcENvdW50ID0gTWF0aC5tYXgoIDEsIGhlYWRlclsgb2ZmX21pcG1hcENvdW50IF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9UT0RPOiBWZXJpZnkgdGhhdCBhbGwgZmFjZXMgb2YgdGhlIGN1YmVtYXAgYXJlIHByZXNlbnQgd2l0aCBERFNDQVBTMl9DVUJFTUFQX1BPU0lUSVZFWCwgZXRjLlxyXG5cclxuXHRcdGRkcy5pc0N1YmVtYXAgPSBoZWFkZXJbIG9mZl9jYXBzMiBdICYgRERTQ0FQUzJfQ1VCRU1BUCA/IHRydWUgOiBmYWxzZTtcclxuXHJcblx0XHRkZHMud2lkdGggPSBoZWFkZXJbIG9mZl93aWR0aCBdO1xyXG5cdFx0ZGRzLmhlaWdodCA9IGhlYWRlclsgb2ZmX2hlaWdodCBdO1xyXG5cclxuXHRcdHZhciBkYXRhT2Zmc2V0ID0gaGVhZGVyWyBvZmZfc2l6ZSBdICsgNDtcclxuXHJcblx0XHQvLyBFeHRyYWN0IG1pcG1hcHMgYnVmZmVyc1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGRkcy53aWR0aDtcclxuXHRcdHZhciBoZWlnaHQgPSBkZHMuaGVpZ2h0O1xyXG5cclxuXHRcdHZhciBmYWNlcyA9IGRkcy5pc0N1YmVtYXAgPyA2IDogMTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZmFjZSA9IDA7IGZhY2UgPCBmYWNlczsgZmFjZSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRkcy5taXBtYXBDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYoIGlzUkdCQVVuY29tcHJlc3NlZCApIHtcclxuXHRcdFx0XHRcdHZhciBieXRlQXJyYXkgPSBsb2FkQVJHQk1pcCggYnVmZmVyLCBkYXRhT2Zmc2V0LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblx0XHRcdFx0XHR2YXIgZGF0YUxlbmd0aCA9IGJ5dGVBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBkYXRhTGVuZ3RoID0gTWF0aC5tYXgoIDQsIHdpZHRoICkgLyA0ICogTWF0aC5tYXgoIDQsIGhlaWdodCApIC8gNCAqIGJsb2NrQnl0ZXM7XHJcblx0XHRcdFx0XHR2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHR2YXIgbWlwbWFwID0geyBcImRhdGFcIjogYnl0ZUFycmF5LCBcIndpZHRoXCI6IHdpZHRoLCBcImhlaWdodFwiOiBoZWlnaHQgfTtcclxuXHRcdFx0XHRkZHMubWlwbWFwcy5wdXNoKCBtaXBtYXAgKTtcclxuXHJcblx0XHRcdFx0ZGF0YU9mZnNldCArPSBkYXRhTGVuZ3RoO1xyXG5cclxuXHRcdFx0XHR3aWR0aCA9IE1hdGgubWF4KCB3aWR0aCAqIDAuNSwgMSApO1xyXG5cdFx0XHRcdGhlaWdodCA9IE1hdGgubWF4KCBoZWlnaHQgKiAwLjUsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHdpZHRoID0gZGRzLndpZHRoO1xyXG5cdFx0XHRoZWlnaHQgPSBkZHMuaGVpZ2h0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXROb3JtYWxNYXA6IGZ1bmN0aW9uICggaW1hZ2UsIGRlcHRoICkge1xyXG5cclxuXHRcdC8vIEFkYXB0ZWQgZnJvbSBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9sYWIvaGVpZ2h0bm9ybWFsL1xyXG5cclxuXHRcdHZhciBjcm9zcyA9IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHRcdHJldHVybiBbIGFbIDEgXSAqIGJbIDIgXSAtIGFbIDIgXSAqIGJbIDEgXSwgYVsgMiBdICogYlsgMCBdIC0gYVsgMCBdICogYlsgMiBdLCBhWyAwIF0gKiBiWyAxIF0gLSBhWyAxIF0gKiBiWyAwIF0gXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN1YnRyYWN0ID0gZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFsgYVsgMCBdIC0gYlsgMCBdLCBhWyAxIF0gLSBiWyAxIF0sIGFbIDIgXSAtIGJbIDIgXSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gKCBhICkge1xyXG5cclxuXHRcdFx0dmFyIGwgPSBNYXRoLnNxcnQoIGFbIDAgXSAqIGFbIDAgXSArIGFbIDEgXSAqIGFbIDEgXSArIGFbIDIgXSAqIGFbIDIgXSApO1xyXG5cdFx0XHRyZXR1cm4gWyBhWyAwIF0gLyBsLCBhWyAxIF0gLyBsLCBhWyAyIF0gLyBsIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRlcHRoID0gZGVwdGggfCAxO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGltYWdlLndpZHRoO1xyXG5cdFx0dmFyIGhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHJcblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAgKTtcclxuXHJcblx0XHR2YXIgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICkuZGF0YTtcclxuXHRcdHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSggd2lkdGgsIGhlaWdodCApO1xyXG5cdFx0dmFyIG91dHB1dCA9IGltYWdlRGF0YS5kYXRhO1xyXG5cclxuXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbHkgPSB5IC0gMSA8IDAgPyAwIDogeSAtIDE7XHJcblx0XHRcdFx0dmFyIHV5ID0geSArIDEgPiBoZWlnaHQgLSAxID8gaGVpZ2h0IC0gMSA6IHkgKyAxO1xyXG5cdFx0XHRcdHZhciBseCA9IHggLSAxIDwgMCA/IDAgOiB4IC0gMTtcclxuXHRcdFx0XHR2YXIgdXggPSB4ICsgMSA+IHdpZHRoIC0gMSA/IHdpZHRoIC0gMSA6IHggKyAxO1xyXG5cclxuXHRcdFx0XHR2YXIgcG9pbnRzID0gW107XHJcblx0XHRcdFx0dmFyIG9yaWdpbiA9IFsgMCwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIDAsIC0gMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbICAxLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgMSwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIDEsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgMCwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcclxuXHJcblx0XHRcdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdFx0XHR2YXIgbnVtX3BvaW50cyA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bV9wb2ludHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHYxID0gcG9pbnRzWyBpIF07XHJcblx0XHRcdFx0XHR2YXIgdjIgPSBwb2ludHNbICggaSArIDEgKSAlIG51bV9wb2ludHMgXTtcclxuXHRcdFx0XHRcdHYxID0gc3VidHJhY3QoIHYxLCBvcmlnaW4gKTtcclxuXHRcdFx0XHRcdHYyID0gc3VidHJhY3QoIHYyLCBvcmlnaW4gKTtcclxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsaXplKCBjcm9zcyggdjEsIHYyICkgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBub3JtYWwgPSBbIDAsIDAsIDAgXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsWyAwIF0gKz0gbm9ybWFsc1sgaSBdWyAwIF07XHJcblx0XHRcdFx0XHRub3JtYWxbIDEgXSArPSBub3JtYWxzWyBpIF1bIDEgXTtcclxuXHRcdFx0XHRcdG5vcm1hbFsgMiBdICs9IG5vcm1hbHNbIGkgXVsgMiBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG5vcm1hbFsgMCBdIC89IG5vcm1hbHMubGVuZ3RoO1xyXG5cdFx0XHRcdG5vcm1hbFsgMSBdIC89IG5vcm1hbHMubGVuZ3RoO1xyXG5cdFx0XHRcdG5vcm1hbFsgMiBdIC89IG5vcm1hbHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHR2YXIgaWR4ID0gKCB5ICogd2lkdGggKyB4ICkgKiA0O1xyXG5cclxuXHRcdFx0XHRvdXRwdXRbIGlkeCBdID0gKCAoIG5vcm1hbFsgMCBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XHJcblx0XHRcdFx0b3V0cHV0WyBpZHggKyAxIF0gPSAoICggbm9ybWFsWyAxIF0gKyAxLjAgKSAvIDIuMCAqIDI1NSApIHwgMDtcclxuXHRcdFx0XHRvdXRwdXRbIGlkeCArIDIgXSA9ICggbm9ybWFsWyAyIF0gKiAyNTUgKSB8IDA7XHJcblx0XHRcdFx0b3V0cHV0WyBpZHggKyAzIF0gPSAyNTU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcclxuXHJcblx0XHRyZXR1cm4gY2FudmFzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZURhdGFUZXh0dXJlOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGNvbG9yICkge1xyXG5cclxuXHRcdHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQ7XHJcblx0XHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KCAzICogc2l6ZSApO1xyXG5cclxuXHRcdHZhciByID0gTWF0aC5mbG9vciggY29sb3IuciAqIDI1NSApO1xyXG5cdFx0dmFyIGcgPSBNYXRoLmZsb29yKCBjb2xvci5nICogMjU1ICk7XHJcblx0XHR2YXIgYiA9IE1hdGguZmxvb3IoIGNvbG9yLmIgKiAyNTUgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZGF0YVsgaSAqIDMgXSBcdCAgPSByO1xyXG5cdFx0XHRkYXRhWyBpICogMyArIDEgXSA9IGc7XHJcblx0XHRcdGRhdGFbIGkgKiAzICsgMiBdID0gYjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIFRIUkVFLlJHQkZvcm1hdCApO1xyXG5cdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TY2VuZVV0aWxzID0ge1xyXG5cclxuXHRjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0dmFyIGdyb3VwID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRncm91cC5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ3JvdXA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRldGFjaCA6IGZ1bmN0aW9uICggY2hpbGQsIHBhcmVudCwgc2NlbmUgKSB7XHJcblxyXG5cdFx0Y2hpbGQuYXBwbHlNYXRyaXgoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0cGFyZW50LnJlbW92ZSggY2hpbGQgKTtcclxuXHRcdHNjZW5lLmFkZCggY2hpbGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXR0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xyXG5cclxuXHRcdHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdFx0bWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0Y2hpbGQuYXBwbHlNYXRyaXgoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdHNjZW5lLnJlbW92ZSggY2hpbGQgKTtcclxuXHRcdHBhcmVudC5hZGQoIGNoaWxkICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBGb3IgVGV4dCBvcGVyYXRpb25zIGluIHRocmVlLmpzIChTZWUgVGV4dEdlb21ldHJ5KVxyXG4gKlxyXG4gKiBJdCB1c2VzIHRlY2huaXF1ZXMgdXNlZCBpbjpcclxuICpcclxuICogXHR0eXBlZmFjZS5qcyBhbmQgY2FudmFzdGV4dFxyXG4gKiBcdFx0Rm9yIGNvbnZlcnRpbmcgZm9udHMgYW5kIHJlbmRlcmluZyB3aXRoIGphdmFzY3JpcHRcclxuICpcdFx0aHR0cDovL3R5cGVmYWNlLm5lb2NyYWN5Lm9yZ1xyXG4gKlxyXG4gKlx0VHJpYW5ndWxhdGlvbiBwb3J0ZWQgZnJvbSBBUzNcclxuICpcdFx0U2ltcGxlIFBvbHlnb24gVHJpYW5ndWxhdGlvblxyXG4gKlx0XHRodHRwOi8vYWN0aW9uc25pcHBldC5jb20vP3A9MTQ2MlxyXG4gKlxyXG4gKiBcdEEgTWV0aG9kIHRvIHRyaWFuZ3VsYXRlIHNoYXBlcyB3aXRoIGhvbGVzXHJcbiAqXHRcdGh0dHA6Ly93d3cuc2FrcmkubmV0L2Jsb2cvMjAwOS8wNi8xMi9hbi1hcHByb2FjaC10by10cmlhbmd1bGF0aW5nLXBvbHlnb25zLXdpdGgtaG9sZXMvXHJcbiAqXHJcbiAqL1xyXG5cclxuVEhSRUUuRm9udFV0aWxzID0ge1xyXG5cclxuXHRmYWNlcyA6IHt9LFxyXG5cclxuXHQvLyBKdXN0IGZvciBub3cuIGZhY2Vbd2VpZ2h0XVtzdHlsZV1cclxuXHJcblx0ZmFjZSA6IFwiaGVsdmV0aWtlclwiLFxyXG5cdHdlaWdodDogXCJub3JtYWxcIixcclxuXHRzdHlsZSA6IFwibm9ybWFsXCIsXHJcblx0c2l6ZSA6IDE1MCxcclxuXHRkaXZpc2lvbnMgOiAxMCxcclxuXHJcblx0Z2V0RmFjZSA6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZhY2VzWyB0aGlzLmZhY2UgXVsgdGhpcy53ZWlnaHQgXVsgdGhpcy5zdHlsZSBdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb2FkRmFjZSA6IGZ1bmN0aW9uKCBkYXRhICkge1xyXG5cclxuXHRcdHZhciBmYW1pbHkgPSBkYXRhLmZhbWlseU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcblx0XHR2YXIgVGhyZWVGb250ID0gdGhpcztcclxuXHJcblx0XHRUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdID0gVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXSB8fCB7fTtcclxuXHJcblx0XHRUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdIHx8IHt9O1xyXG5cdFx0VGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF1bIGRhdGEuY3NzRm9udFN0eWxlIF0gPSBkYXRhO1xyXG5cclxuXHRcdHZhciBmYWNlID0gVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF1bIGRhdGEuY3NzRm9udFN0eWxlIF0gPSBkYXRhO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkcmF3VGV4dCA6IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG5cclxuXHRcdHZhciBjaGFyYWN0ZXJQdHMgPSBbXSwgYWxsUHRzID0gW107XHJcblxyXG5cdFx0Ly8gUmVuZGVyVGV4dFxyXG5cclxuXHRcdHZhciBpLCBwLFxyXG5cdFx0XHRmYWNlID0gdGhpcy5nZXRGYWNlKCksXHJcblx0XHRcdHNjYWxlID0gdGhpcy5zaXplIC8gZmFjZS5yZXNvbHV0aW9uLFxyXG5cdFx0XHRvZmZzZXQgPSAwLFxyXG5cdFx0XHRjaGFycyA9IFN0cmluZyggdGV4dCApLnNwbGl0KCAnJyApLFxyXG5cdFx0XHRsZW5ndGggPSBjaGFycy5sZW5ndGg7XHJcblxyXG5cdFx0dmFyIGZvbnRQYXRocyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xyXG5cclxuXHRcdFx0dmFyIHJldCA9IHRoaXMuZXh0cmFjdEdseXBoUG9pbnRzKCBjaGFyc1sgaSBdLCBmYWNlLCBzY2FsZSwgb2Zmc2V0LCBwYXRoICk7XHJcblx0XHRcdG9mZnNldCArPSByZXQub2Zmc2V0O1xyXG5cclxuXHRcdFx0Zm9udFBhdGhzLnB1c2goIHJldC5wYXRoICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGdldCB0aGUgd2lkdGhcclxuXHJcblx0XHR2YXIgd2lkdGggPSBvZmZzZXQgLyAyO1xyXG5cdFx0Ly9cclxuXHRcdC8vIGZvciAoIHAgPSAwOyBwIDwgYWxsUHRzLmxlbmd0aDsgcCsrICkge1xyXG5cdFx0Ly9cclxuXHRcdC8vIFx0YWxsUHRzWyBwIF0ueCAtPSB3aWR0aDtcclxuXHRcdC8vXHJcblx0XHQvLyB9XHJcblxyXG5cdFx0Ly92YXIgZXh0cmFjdCA9IHRoaXMuZXh0cmFjdFBvaW50cyggYWxsUHRzLCBjaGFyYWN0ZXJQdHMgKTtcclxuXHRcdC8vZXh0cmFjdC5jb250b3VyID0gYWxsUHRzO1xyXG5cclxuXHRcdC8vZXh0cmFjdC5wYXRocyA9IGZvbnRQYXRocztcclxuXHRcdC8vZXh0cmFjdC5vZmZzZXQgPSB3aWR0aDtcclxuXHJcblx0XHRyZXR1cm4geyBwYXRocyA6IGZvbnRQYXRocywgb2Zmc2V0IDogd2lkdGggfTtcclxuXHJcblx0fSxcclxuXHJcblxyXG5cclxuXHJcblx0ZXh0cmFjdEdseXBoUG9pbnRzIDogZnVuY3Rpb24oIGMsIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKSB7XHJcblxyXG5cdFx0dmFyIHB0cyA9IFtdO1xyXG5cclxuXHRcdHZhciBpLCBpMiwgZGl2aXNpb25zLFxyXG5cdFx0XHRvdXRsaW5lLCBhY3Rpb24sIGxlbmd0aCxcclxuXHRcdFx0c2NhbGVYLCBzY2FsZVksXHJcblx0XHRcdHgsIHksIGNweCwgY3B5LCBjcHgwLCBjcHkwLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLFxyXG5cdFx0XHRsYXN0ZSxcclxuXHRcdFx0Z2x5cGggPSBmYWNlLmdseXBoc1sgYyBdIHx8IGZhY2UuZ2x5cGhzWyAnPycgXTtcclxuXHJcblx0XHRpZiAoICFnbHlwaCApIHJldHVybjtcclxuXHJcblx0XHRpZiAoIGdseXBoLm8gKSB7XHJcblxyXG5cdFx0XHRvdXRsaW5lID0gZ2x5cGguX2NhY2hlZE91dGxpbmUgfHwgKCBnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoICcgJyApICk7XHJcblx0XHRcdGxlbmd0aCA9IG91dGxpbmUubGVuZ3RoO1xyXG5cclxuXHRcdFx0c2NhbGVYID0gc2NhbGU7XHJcblx0XHRcdHNjYWxlWSA9IHNjYWxlO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW5ndGg7ICkge1xyXG5cclxuXHRcdFx0XHRhY3Rpb24gPSBvdXRsaW5lWyBpICsrIF07XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coIGFjdGlvbiApO1xyXG5cclxuXHRcdFx0XHRzd2l0Y2goIGFjdGlvbiApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnbSc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gTW92ZSBUb1xyXG5cclxuXHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcclxuXHRcdFx0XHRcdHkgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcclxuXHJcblx0XHRcdFx0XHRwYXRoLm1vdmVUbyggeCwgeSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2wnOlxyXG5cclxuXHRcdFx0XHRcdC8vIExpbmUgVG9cclxuXHJcblx0XHRcdFx0XHR4ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XHJcblx0XHRcdFx0XHRwYXRoLmxpbmVUbyh4LHkpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3EnOlxyXG5cclxuXHRcdFx0XHRcdC8vIFF1YWRyYXRpY0N1cnZlVG9cclxuXHJcblx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHRjcHkgID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XHJcblx0XHRcdFx0XHRjcHgxID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XHJcblxyXG5cdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKGNweDEsIGNweTEsIGNweCwgY3B5KTtcclxuXHJcblx0XHRcdFx0XHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XHJcblx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaTIgPSAxLCBkaXZpc2lvbnMgPSB0aGlzLmRpdmlzaW9uczsgaTIgPD0gZGl2aXNpb25zOyBpMiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcclxuXHRcdFx0XHRcdFx0XHR2YXIgdHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xyXG5cdFx0XHRcdFx0ICB9XHJcblxyXG5cdFx0XHRcdCAgfVxyXG5cclxuXHRcdFx0XHQgIGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdiJzpcclxuXHJcblx0XHRcdFx0XHQvLyBDdWJpYyBCZXppZXIgQ3VydmVcclxuXHJcblx0XHRcdFx0XHRjcHggID0gb3V0bGluZVsgaSsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0Y3B5ICA9IG91dGxpbmVbIGkrKyBdICogIHNjYWxlWTtcclxuXHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lWyBpKysgXSAqICBzY2FsZVggKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSsrIF0gKiAtc2NhbGVZO1xyXG5cdFx0XHRcdFx0Y3B4MiA9IG91dGxpbmVbIGkrKyBdICogIHNjYWxlWCArIG9mZnNldDtcclxuXHRcdFx0XHRcdGNweTIgPSBvdXRsaW5lWyBpKysgXSAqIC1zY2FsZVk7XHJcblxyXG5cdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgsIGNweSwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiApO1xyXG5cclxuXHRcdFx0XHRcdGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbGFzdGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cclxuXHJcblx0XHRyZXR1cm4geyBvZmZzZXQ6IGdseXBoLmhhKnNjYWxlLCBwYXRoOnBhdGh9O1xyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzID0gZnVuY3Rpb24oIHRleHQsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdC8vIFBhcmFtZXRlcnMgXHJcblxyXG5cdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xyXG5cclxuXHR2YXIgc2l6ZSA9IHBhcmFtZXRlcnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zaXplIDogMTAwO1xyXG5cdHZhciBjdXJ2ZVNlZ21lbnRzID0gcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHM6IDQ7XHJcblxyXG5cdHZhciBmb250ID0gcGFyYW1ldGVycy5mb250ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmZvbnQgOiBcImhlbHZldGlrZXJcIjtcclxuXHR2YXIgd2VpZ2h0ID0gcGFyYW1ldGVycy53ZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMud2VpZ2h0IDogXCJub3JtYWxcIjtcclxuXHR2YXIgc3R5bGUgPSBwYXJhbWV0ZXJzLnN0eWxlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0eWxlIDogXCJub3JtYWxcIjtcclxuXHJcblx0VEhSRUUuRm9udFV0aWxzLnNpemUgPSBzaXplO1xyXG5cdFRIUkVFLkZvbnRVdGlscy5kaXZpc2lvbnMgPSBjdXJ2ZVNlZ21lbnRzO1xyXG5cclxuXHRUSFJFRS5Gb250VXRpbHMuZmFjZSA9IGZvbnQ7XHJcblx0VEhSRUUuRm9udFV0aWxzLndlaWdodCA9IHdlaWdodDtcclxuXHRUSFJFRS5Gb250VXRpbHMuc3R5bGUgPSBzdHlsZTtcclxuXHJcblx0Ly8gR2V0IGEgRm9udCBkYXRhIGpzb24gb2JqZWN0XHJcblxyXG5cdHZhciBkYXRhID0gVEhSRUUuRm9udFV0aWxzLmRyYXdUZXh0KCB0ZXh0ICk7XHJcblxyXG5cdHZhciBwYXRocyA9IGRhdGEucGF0aHM7XHJcblx0dmFyIHNoYXBlcyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XHJcblxyXG5cdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIHNoYXBlcywgcGF0aHNbIHAgXS50b1NoYXBlcygpICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHNoYXBlcztcclxuXHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoaXMgY29kZSBpcyBhIHF1aWNrIHBvcnQgb2YgY29kZSB3cml0dGVuIGluIEMrKyB3aGljaCB3YXMgc3VibWl0dGVkIHRvXHJcbiAqIGZsaXBjb2RlLmNvbSBieSBKb2huIFcuIFJhdGNsaWZmICAvLyBKdWx5IDIyLCAyMDAwXHJcbiAqIFNlZSBvcmlnaW5hbCBjb2RlIGFuZCBtb3JlIGluZm9ybWF0aW9uIGhlcmU6XHJcbiAqIGh0dHA6Ly93d3cuZmxpcGNvZGUuY29tL2FyY2hpdmVzL0VmZmljaWVudF9Qb2x5Z29uX1RyaWFuZ3VsYXRpb24uc2h0bWxcclxuICpcclxuICogcG9ydGVkIHRvIGFjdGlvbnNjcmlwdCBieSBaZXZhbiBSb3NzZXJcclxuICogd3d3LmFjdGlvbnNuaXBwZXQuY29tXHJcbiAqXHJcbiAqIHBvcnRlZCB0byBqYXZhc2NyaXB0IGJ5IEpvc2h1YSBLb29cclxuICogaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4oIGZ1bmN0aW9uKCBuYW1lc3BhY2UgKSB7XHJcblxyXG5cdHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xyXG5cclxuXHQvLyB0YWtlcyBpbiBhbiBjb250b3VyIGFycmF5IGFuZCByZXR1cm5zXHJcblxyXG5cdHZhciBwcm9jZXNzID0gZnVuY3Rpb24oIGNvbnRvdXIsIGluZGljZXMgKSB7XHJcblxyXG5cdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoIG4gPCAzICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxyXG5cdFx0XHR2ZXJ0cyA9IFtdLFxyXG5cdFx0XHR2ZXJ0SW5kaWNlcyA9IFtdO1xyXG5cclxuXHRcdC8qIHdlIHdhbnQgYSBjb3VudGVyLWNsb2Nrd2lzZSBwb2x5Z29uIGluIHZlcnRzICovXHJcblxyXG5cdFx0dmFyIHUsIHYsIHc7XHJcblxyXG5cdFx0aWYgKCBhcmVhKCBjb250b3VyICkgPiAwLjAgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IG47IHYrKyApIHZlcnRzWyB2IF0gPSB2O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IG47IHYrKyApIHZlcnRzWyB2IF0gPSAoIG4gLSAxICkgLSB2O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbnYgPSBuO1xyXG5cclxuXHRcdC8qICByZW1vdmUgbnYgLSAyIHZlcnRpY2VzLCBjcmVhdGluZyAxIHRyaWFuZ2xlIGV2ZXJ5IHRpbWUgKi9cclxuXHJcblx0XHR2YXIgY291bnQgPSAyICogbnY7ICAgLyogZXJyb3IgZGV0ZWN0aW9uICovXHJcblxyXG5cdFx0Zm9yKCB2ID0gbnYgLSAxOyBudiA+IDI7ICkge1xyXG5cclxuXHRcdFx0LyogaWYgd2UgbG9vcCwgaXQgaXMgcHJvYmFibHkgYSBub24tc2ltcGxlIHBvbHlnb24gKi9cclxuXHJcblx0XHRcdGlmICggKCBjb3VudC0tICkgPD0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8qKiBUcmlhbmd1bGF0ZTogRVJST1IgLSBwcm9iYWJsZSBiYWQgcG9seWdvbiFcclxuXHJcblx0XHRcdFx0Ly8gU29tZXRpbWVzIHdhcm5pbmcgaXMgZmluZSwgZXNwZWNpYWxseSBwb2x5Z29ucyBhcmUgdHJpYW5ndWxhdGVkIGluIHJldmVyc2UuXHJcblx0XHRcdFx0VEhSRUUub253YXJuaW5nKCBcIldhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIVwiICk7XHJcblxyXG5cdFx0XHRcdGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXHJcblxyXG5cdFx0XHR1ID0gdjsgXHQgXHRpZiAoIG52IDw9IHUgKSB1ID0gMDsgICAgIC8qIHByZXZpb3VzICovXHJcblx0XHRcdHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cclxuXHRcdFx0dyA9IHYgKyAxOyAgaWYgKCBudiA8PSB3ICkgdyA9IDA7ICAgICAvKiBuZXh0ICAgICAqL1xyXG5cclxuXHRcdFx0aWYgKCBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBudiwgdmVydHMgKSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGEsIGIsIGMsIHMsIHQ7XHJcblxyXG5cdFx0XHRcdC8qIHRydWUgbmFtZXMgb2YgdGhlIHZlcnRpY2VzICovXHJcblxyXG5cdFx0XHRcdGEgPSB2ZXJ0c1sgdSBdO1xyXG5cdFx0XHRcdGIgPSB2ZXJ0c1sgdiBdO1xyXG5cdFx0XHRcdGMgPSB2ZXJ0c1sgdyBdO1xyXG5cclxuXHRcdFx0XHQvKiBvdXRwdXQgVHJpYW5nbGUgKi9cclxuXHJcblx0XHRcdFx0cmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxyXG5cdFx0XHRcdFx0Y29udG91clsgYiBdLFxyXG5cdFx0XHRcdFx0Y29udG91clsgYyBdIF0gKTtcclxuXHJcblxyXG5cdFx0XHRcdHZlcnRJbmRpY2VzLnB1c2goIFsgdmVydHNbIHUgXSwgdmVydHNbIHYgXSwgdmVydHNbIHcgXSBdICk7XHJcblxyXG5cdFx0XHRcdC8qIHJlbW92ZSB2IGZyb20gdGhlIHJlbWFpbmluZyBwb2x5Z29uICovXHJcblxyXG5cdFx0XHRcdGZvciggcyA9IHYsIHQgPSB2ICsgMTsgdCA8IG52OyBzKyssIHQrKyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0c1sgcyBdID0gdmVydHNbIHQgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRudi0tO1xyXG5cclxuXHRcdFx0XHQvKiByZXNldCBlcnJvciBkZXRlY3Rpb24gY291bnRlciAqL1xyXG5cclxuXHRcdFx0XHRjb3VudCA9IDIgKiBudjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gY2FsY3VsYXRlIGFyZWEgb2YgdGhlIGNvbnRvdXIgcG9seWdvblxyXG5cclxuXHR2YXIgYXJlYSA9IGZ1bmN0aW9uICggY29udG91ciApIHtcclxuXHJcblx0XHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cdFx0dmFyIGEgPSAwLjA7XHJcblxyXG5cdFx0Zm9yKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxKysgKSB7XHJcblxyXG5cdFx0XHRhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYSAqIDAuNTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHNuaXAgPSBmdW5jdGlvbiAoIGNvbnRvdXIsIHUsIHYsIHcsIG4sIHZlcnRzICkge1xyXG5cclxuXHRcdHZhciBwO1xyXG5cdFx0dmFyIGF4LCBheSwgYngsIGJ5O1xyXG5cdFx0dmFyIGN4LCBjeSwgcHgsIHB5O1xyXG5cclxuXHRcdGF4ID0gY29udG91clsgdmVydHNbIHUgXSBdLng7XHJcblx0XHRheSA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS55O1xyXG5cclxuXHRcdGJ4ID0gY29udG91clsgdmVydHNbIHYgXSBdLng7XHJcblx0XHRieSA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS55O1xyXG5cclxuXHRcdGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XHJcblx0XHRjeSA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS55O1xyXG5cclxuXHRcdGlmICggRVBTSUxPTiA+ICgoKGJ4LWF4KSooY3ktYXkpKSAtICgoYnktYXkpKihjeC1heCkpKSApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR2YXIgYVgsIGFZLCBiWCwgYlksIGNYLCBjWTtcclxuXHRcdHZhciBhcHgsIGFweSwgYnB4LCBicHksIGNweCwgY3B5O1xyXG5cdFx0dmFyIGNDUk9TU2FwLCBiQ1JPU1NjcCwgYUNST1NTYnA7XHJcblxyXG5cdFx0YVggPSBjeCAtIGJ4OyAgYVkgPSBjeSAtIGJ5O1xyXG5cdFx0YlggPSBheCAtIGN4OyAgYlkgPSBheSAtIGN5O1xyXG5cdFx0Y1ggPSBieCAtIGF4OyAgY1kgPSBieSAtIGF5O1xyXG5cclxuXHRcdGZvciAoIHAgPSAwOyBwIDwgbjsgcCsrICkge1xyXG5cclxuXHRcdFx0cHggPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueFxyXG5cdFx0XHRweSA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS55XHJcblxyXG5cdFx0XHRpZiAoICggKHB4ID09PSBheCkgJiYgKHB5ID09PSBheSkgKSB8fFxyXG5cdFx0XHRcdCAoIChweCA9PT0gYngpICYmIChweSA9PT0gYnkpICkgfHxcclxuXHRcdFx0XHQgKCAocHggPT09IGN4KSAmJiAocHkgPT09IGN5KSApIClcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0YXB4ID0gcHggLSBheDsgIGFweSA9IHB5IC0gYXk7XHJcblx0XHRcdGJweCA9IHB4IC0gYng7ICBicHkgPSBweSAtIGJ5O1xyXG5cdFx0XHRjcHggPSBweCAtIGN4OyAgY3B5ID0gcHkgLSBjeTtcclxuXHJcblx0XHRcdC8vIHNlZSBpZiBwIGlzIGluc2lkZSB0cmlhbmdsZSBhYmNcclxuXHJcblx0XHRcdGFDUk9TU2JwID0gYVgqYnB5IC0gYVkqYnB4O1xyXG5cdFx0XHRjQ1JPU1NhcCA9IGNYKmFweSAtIGNZKmFweDtcclxuXHRcdFx0YkNST1NTY3AgPSBiWCpjcHkgLSBiWSpjcHg7XHJcblxyXG5cdFx0XHRpZiAoIChhQ1JPU1NicCA+PSAtRVBTSUxPTikgJiYgKGJDUk9TU2NwID49IC1FUFNJTE9OKSAmJiAoY0NST1NTYXAgPj0gLUVQU0lMT04pICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdG5hbWVzcGFjZS5Ucmlhbmd1bGF0ZSA9IHByb2Nlc3M7XHJcblx0bmFtZXNwYWNlLlRyaWFuZ3VsYXRlLmFyZWEgPSBhcmVhO1xyXG5cclxuXHRyZXR1cm4gbmFtZXNwYWNlO1xyXG5cclxufSkoVEhSRUUuRm9udFV0aWxzKTtcclxuXHJcbi8vIFRvIHVzZSB0aGUgdHlwZWZhY2UuanMgZmFjZSBmaWxlcywgaG9vayB1cCB0aGUgQVBJXHJcbnNlbGYuX3R5cGVmYWNlX2pzID0geyBmYWNlczogVEhSRUUuRm9udFV0aWxzLmZhY2VzLCBsb2FkRmFjZTogVEhSRUUuRm9udFV0aWxzLmxvYWRGYWNlIH07XHJcblRIUkVFLnR5cGVmYWNlX2pzID0gc2VsZi5fdHlwZWZhY2VfanM7XHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxyXG4gKlxyXG4gKiBTb21lIGNvbW1vbiBvZiBDdXJ2ZSBtZXRob2RzXHJcbiAqIC5nZXRQb2ludCh0KSwgZ2V0VGFuZ2VudCh0KVxyXG4gKiAuZ2V0UG9pbnRBdCh1KSwgZ2V0VGFnZW50QXQodSlcclxuICogLmdldFBvaW50cygpLCAuZ2V0U3BhY2VkUG9pbnRzKClcclxuICogLmdldExlbmd0aCgpXHJcbiAqIC51cGRhdGVBcmNMZW5ndGhzKClcclxuICpcclxuICogVGhpcyBmb2xsb3dpbmcgY2xhc3NlcyBzdWJjbGFzc2VzIFRIUkVFLkN1cnZlOlxyXG4gKlxyXG4gKiAtLSAyZCBjbGFzc2VzIC0tXHJcbiAqIFRIUkVFLkxpbmVDdXJ2ZVxyXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZVxyXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXHJcbiAqIFRIUkVFLlNwbGluZUN1cnZlXHJcbiAqIFRIUkVFLkFyY0N1cnZlXHJcbiAqIFRIUkVFLkVsbGlwc2VDdXJ2ZVxyXG4gKlxyXG4gKiAtLSAzZCBjbGFzc2VzIC0tXHJcbiAqIFRIUkVFLkxpbmVDdXJ2ZTNcclxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXHJcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXHJcbiAqIFRIUkVFLlNwbGluZUN1cnZlM1xyXG4gKiBUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTNcclxuICpcclxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aFxyXG4gKlxyXG4gKiovXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3NcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3VydmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG59O1xyXG5cclxuLy8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXHJcbi8vXHQtIHQgWzAgLi4gMV1cclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0VEhSRUUub253YXJuaW5nKCBcIldhcm5pbmcsIGdldFBvaW50KCkgbm90IGltcGxlbWVudGVkIVwiICk7XHJcblx0cmV0dXJuIG51bGw7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXHJcbi8vIC0gdSBbMCAuLiAxXVxyXG5cclxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xyXG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB0ICk7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XHJcblxyXG5cdHZhciBkLCBwdHMgPSBbXTtcclxuXHJcblx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdHB0cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcHRzO1xyXG5cclxufTtcclxuXHJcbi8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XHJcblxyXG5cdHZhciBkLCBwdHMgPSBbXTtcclxuXHJcblx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdHB0cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBwdHM7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblx0cmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xyXG5cclxufTtcclxuXHJcbi8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3RocyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRpZiAoICFkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucykgPyAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyk6IDIwMDtcclxuXHJcblx0aWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Roc1xyXG5cdFx0JiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT0gZGl2aXNpb25zICsgMSApXHJcblx0XHQmJiAhdGhpcy5uZWVkc1VwZGF0ZSkge1xyXG5cclxuXHRcdC8vY29uc29sZS5sb2coIFwiY2FjaGVkXCIsIHRoaXMuY2FjaGVBcmNMZW5ndGhzICk7XHJcblx0XHRyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR2YXIgY2FjaGUgPSBbXTtcclxuXHR2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcclxuXHR2YXIgcCwgc3VtID0gMDtcclxuXHJcblx0Y2FjaGUucHVzaCggMCApO1xyXG5cclxuXHRmb3IgKCBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHAgKysgKSB7XHJcblxyXG5cdFx0Y3VycmVudCA9IHRoaXMuZ2V0UG9pbnQgKCBwIC8gZGl2aXNpb25zICk7XHJcblx0XHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XHJcblx0XHRjYWNoZS5wdXNoKCBzdW0gKTtcclxuXHRcdGxhc3QgPSBjdXJyZW50O1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XHJcblxyXG5cdHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOnN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuQ3VydmUucHJvdG90eXBlLnVwZGF0ZUFyY0xlbmd0aHMgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHR0aGlzLmdldExlbmd0aHMoKTtcclxufTtcclxuXHJcbi8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aSBkaXN0YW5jZVxyXG5cclxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFV0b1RtYXBwaW5nID0gZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcclxuXHJcblx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcblx0dmFyIGkgPSAwLCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xyXG5cclxuXHR2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcclxuXHJcblx0aWYgKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XHJcblxyXG5cdH1cclxuXHJcblx0Ly92YXIgdGltZSA9IERhdGUubm93KCk7XHJcblxyXG5cdC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXHJcblxyXG5cdHZhciBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xyXG5cclxuXHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xyXG5cclxuXHRcdGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xyXG5cclxuXHRcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XHJcblxyXG5cdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcclxuXHJcblx0XHRcdGxvdyA9IGkgKyAxO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcclxuXHJcblx0XHRcdGhpZ2ggPSBpIC0gMTtcclxuXHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGhpZ2ggPSBpO1xyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRcdC8vIERPTkVcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0aSA9IGhpZ2g7XHJcblxyXG5cdC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcclxuXHJcblx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xyXG5cclxuXHRcdHZhciB0ID0gaSAvICggaWwgLSAxICk7XHJcblx0XHRyZXR1cm4gdDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0YXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXHJcblxyXG5cdHZhciBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XHJcbiAgICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xyXG5cclxuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XHJcblxyXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcclxuXHJcbiAgICB2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgLy8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxyXG5cclxuICAgIHZhciB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0xICk7XHJcblxyXG5cdHJldHVybiB0O1xyXG5cclxufTtcclxuXHJcbi8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcclxuLy8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxyXG4vLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxyXG4vLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHR2YXIgZGVsdGEgPSAwLjAwMDE7XHJcblx0dmFyIHQxID0gdCAtIGRlbHRhO1xyXG5cdHZhciB0MiA9IHQgKyBkZWx0YTtcclxuXHJcblx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxyXG5cclxuXHRpZiAoIHQxIDwgMCApIHQxID0gMDtcclxuXHRpZiAoIHQyID4gMSApIHQyID0gMTtcclxuXHJcblx0dmFyIHB0MSA9IHRoaXMuZ2V0UG9pbnQoIHQxICk7XHJcblx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XHJcblxyXG5cdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIocHQxKTtcclxuXHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudEF0ID0gZnVuY3Rpb24gKCB1ICkge1xyXG5cclxuXHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcclxuXHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0VXRpbHNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3VydmUuVXRpbHMgPSB7XHJcblxyXG5cdHRhbmdlbnRRdWFkcmF0aWNCZXppZXI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcclxuXHJcblx0XHRyZXR1cm4gMiAqICggMSAtIHQgKSAqICggcDEgLSBwMCApICsgMiAqIHQgKiAoIHAyIC0gcDEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUHVheSBCaW5nLCB0aGFua3MgZm9yIGhlbHBpbmcgd2l0aCB0aGlzIGRlcml2YXRpdmUhXHJcblxyXG5cdHRhbmdlbnRDdWJpY0JlemllcjogZnVuY3Rpb24gKHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdHJldHVybiAtMyAqIHAwICogKDEgLSB0KSAqICgxIC0gdCkgICtcclxuXHRcdFx0MyAqIHAxICogKDEgLSB0KSAqICgxLXQpIC0gNiAqdCAqcDEgKiAoMS10KSArXHJcblx0XHRcdDYgKiB0ICogIHAyICogKDEtdCkgLSAzICogdCAqIHQgKiBwMiArXHJcblx0XHRcdDMgKiB0ICogdCAqIHAzO1xyXG5cdH0sXHJcblxyXG5cclxuXHR0YW5nZW50U3BsaW5lOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XHJcblxyXG5cdFx0dmFyIGgwMCA9IDYgKiB0ICogdCAtIDYgKiB0OyBcdC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxyXG5cdFx0dmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zIOKIkiAydF4yICsgdFxyXG5cdFx0dmFyIGgwMSA9IC02ICogdCAqIHQgKyA2ICogdDsgXHQvLyDiiJIgMnQzICsgM3QyXHJcblx0XHR2YXIgaDExID0gMyAqIHQgKiB0IC0gMiAqIHQ7XHQvLyB0MyDiiJIgdDJcclxuXHJcblx0XHRyZXR1cm4gaDAwICsgaDEwICsgaDAxICsgaDExO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBDYXRtdWxsLVJvbVxyXG5cclxuXHRpbnRlcnBvbGF0ZTogZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCB0ICkge1xyXG5cclxuXHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xyXG5cdFx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblx0XHR2YXIgdDIgPSB0ICogdDtcclxuXHRcdHZhciB0MyA9IHQgKiB0MjtcclxuXHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIFRPRE86IFRyYW5zZm9ybWF0aW9uIGZvciBDdXJ2ZXM/XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdDNEIEN1cnZlc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xyXG5cclxuVEhSRUUuQ3VydmUuY3JlYXRlID0gZnVuY3Rpb24gKCBjb25zdHJ1Y3RvciwgZ2V0UG9pbnRGdW5jICkge1xyXG5cclxuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0UG9pbnQgPSBnZXRQb2ludEZ1bmM7XHJcblxyXG5cdHJldHVybiBjb25zdHJ1Y3RvcjtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKiovXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxyXG4gKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmN1cnZlcyA9IFtdO1xyXG5cdHRoaXMuYmVuZHMgPSBbXTtcclxuXHRcclxuXHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxyXG59O1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoIGN1cnZlICkge1xyXG5cclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2hlY2tDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0Ly8gVE9ET1xyXG5cdC8vIElmIHRoZSBlbmRpbmcgb2YgY3VydmUgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgc3RhcnRpbmdcclxuXHQvLyBvciB0aGUgbmV4dCBjdXJ2ZSwgdGhlbiwgdGhpcyBpcyBub3QgYSByZWFsIHBhdGhcclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XHJcblx0Ly8gVE9ETyBUZXN0XHJcblx0Ly8gYW5kIHZlcmlmeSBmb3IgdmVjdG9yMyAobmVlZHMgdG8gaW1wbGVtZW50IGVxdWFscylcclxuXHQvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcclxuXHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWzBdLmdldFBvaW50KDApO1xyXG5cdHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzW3RoaXMuY3VydmVzLmxlbmd0aC0xXS5nZXRQb2ludCgxKTtcclxuXHRcclxuXHRpZiAoIXN0YXJ0UG9pbnQuZXF1YWxzKGVuZFBvaW50KSkge1xyXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggbmV3IFRIUkVFLkxpbmVDdXJ2ZShlbmRQb2ludCwgc3RhcnRQb2ludCkgKTtcclxuXHR9XHJcblx0XHJcbn07XHJcblxyXG4vLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cclxuLy8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxyXG4vLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XHJcblxyXG4vLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXHJcbi8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxyXG4vLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXHJcbi8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHR2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xyXG5cdHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cdHZhciBpID0gMCwgZGlmZiwgY3VydmU7XHJcblxyXG5cdC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxyXG5cclxuXHR3aGlsZSAoIGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoICkge1xyXG5cclxuXHRcdGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcclxuXHJcblx0XHRcdGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XHJcblx0XHRcdGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcclxuXHJcblx0XHRcdHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcclxuXHJcblx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHJcblx0XHRpICsrO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG5cclxuXHQvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcclxuXHJcbn07XHJcblxyXG4vKlxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcclxufTsqL1xyXG5cclxuXHJcbi8vIFdlIGNhbm5vdCB1c2UgdGhlIGRlZmF1bHQgVEhSRUUuQ3VydmUgZ2V0UG9pbnQoKSB3aXRoIGdldExlbmd0aCgpIGJlY2F1c2UgaW5cclxuLy8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXHJcbi8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBsZW5zID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuXHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XHJcblxyXG59O1xyXG5cclxuLy8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXHJcbi8vIFdlIGNhbm5vdCBvdmVyd3JpdGUgZ2V0TGVuZ3RocygpIGJlY2F1c2UgVXRvVCBtYXBwaW5nIHVzZXMgaXQuXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEN1cnZlTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXHJcblxyXG5cdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEdldCBsZW5ndGggb2Ygc3Vic3VydmVcclxuXHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcclxuXHJcblx0dmFyIGxlbmd0aHMgPSBbXSwgc3VtcyA9IDA7XHJcblx0dmFyIGksIGlsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcclxuXHRcdGxlbmd0aHMucHVzaCggc3VtcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcclxuXHJcblx0cmV0dXJuIGxlbmd0aHM7XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBSZXR1cm5zIG1pbiBhbmQgbWF4IGNvb3JkaW5hdGVzLCBhcyB3ZWxsIGFzIGNlbnRyb2lkXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcclxuXHJcblx0dmFyIG1heFgsIG1heFksIG1heFo7XHJcblx0dmFyIG1pblgsIG1pblksIG1pblo7XHJcblxyXG5cdG1heFggPSBtYXhZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG5cdG1pblggPSBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cclxuXHR2YXIgcCwgaSwgaWwsIHN1bTtcclxuXHJcblx0dmFyIHYzID0gcG9pbnRzWzBdIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMztcclxuXHJcblx0c3VtID0gdjMgPyBuZXcgVEhSRUUuVmVjdG9yMygpIDogbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0Zm9yICggaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHAgPSBwb2ludHNbIGkgXTtcclxuXHJcblx0XHRpZiAoIHAueCA+IG1heFggKSBtYXhYID0gcC54O1xyXG5cdFx0ZWxzZSBpZiAoIHAueCA8IG1pblggKSBtaW5YID0gcC54O1xyXG5cclxuXHRcdGlmICggcC55ID4gbWF4WSApIG1heFkgPSBwLnk7XHJcblx0XHRlbHNlIGlmICggcC55IDwgbWluWSApIG1pblkgPSBwLnk7XHJcblxyXG5cdFx0aWYgKCB2MyApIHtcclxuXHJcblx0XHRcdGlmICggcC56ID4gbWF4WiApIG1heFogPSBwLno7XHJcblx0XHRcdGVsc2UgaWYgKCBwLnogPCBtaW5aICkgbWluWiA9IHAuejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3VtLmFkZCggcCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciByZXQgPSB7XHJcblxyXG5cdFx0bWluWDogbWluWCxcclxuXHRcdG1pblk6IG1pblksXHJcblx0XHRtYXhYOiBtYXhYLFxyXG5cdFx0bWF4WTogbWF4WSxcclxuXHRcdGNlbnRyb2lkOiBzdW0uZGl2aWRlU2NhbGFyKCBpbCApXHJcblxyXG5cdH07XHJcblxyXG5cdGlmICggdjMgKSB7XHJcblxyXG5cdFx0cmV0Lm1heFogPSBtYXhaO1xyXG5cdFx0cmV0Lm1pblogPSBtaW5aO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiByZXQ7XHJcblxyXG59O1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDcmVhdGUgR2VvbWV0cmllcyBIZWxwZXJzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQYXJ0aWNsZVN5c3RlbSBvYmplY3RzKVxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBwdHMgPSB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XHJcblx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xyXG5cclxufTtcclxuXHJcbi8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gZXF1aWRpc3RhbmNlIHNhbXBsaW5nIGFsb25nIHRoZSBwYXRoXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcclxuXHJcblx0dmFyIHB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcclxuXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBwb2ludHMgKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBwb2ludHNbIGkgXS54LCBwb2ludHNbIGkgXS55LCBwb2ludHNbIGkgXS56IHx8IDApICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxufTtcclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEJlbmQgLyBXcmFwIEhlbHBlciBNZXRob2RzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8vIFdyYXAgcGF0aCAvIEJlbmQgbW9kaWZpZXJzP1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5hZGRXcmFwUGF0aCA9IGZ1bmN0aW9uICggYmVuZHBhdGggKSB7XHJcblxyXG5cdHRoaXMuYmVuZHMucHVzaCggYmVuZHBhdGggKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnRzID0gZnVuY3Rpb24oIHNlZ21lbnRzLCBiZW5kcyApIHtcclxuXHJcblx0dmFyIG9sZFB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBzZWdtZW50cyApOyAvLyBnZXRQb2ludHMgZ2V0U3BhY2VkUG9pbnRzXHJcblx0dmFyIGksIGlsO1xyXG5cclxuXHRpZiAoICFiZW5kcyApIHtcclxuXHJcblx0XHRiZW5kcyA9IHRoaXMuYmVuZHM7XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggaSA9IDAsIGlsID0gYmVuZHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0b2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gb2xkUHRzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiggc2VnbWVudHMsIGJlbmRzICkge1xyXG5cclxuXHR2YXIgb2xkUHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIHNlZ21lbnRzICk7XHJcblxyXG5cdHZhciBpLCBpbDtcclxuXHJcblx0aWYgKCAhYmVuZHMgKSB7XHJcblxyXG5cdFx0YmVuZHMgPSB0aGlzLmJlbmRzO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdG9sZFB0cyA9IHRoaXMuZ2V0V3JhcFBvaW50cyggb2xkUHRzLCBiZW5kc1sgaSBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG9sZFB0cztcclxuXHJcbn07XHJcblxyXG4vLyBUaGlzIHJldHVybnMgZ2V0UG9pbnRzKCkgYmVuZC93cmFwcGVkIGFyb3VuZCB0aGUgY29udG91ciBvZiBhIHBhdGguXHJcbi8vIFJlYWQgaHR0cDovL3d3dy5wbGFuZXRjbGVnZy5jb20vcHJvamVjdHMvV2FycGluZ1RleHRUb1NwbGluZXMuaHRtbFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRXcmFwUG9pbnRzID0gZnVuY3Rpb24gKCBvbGRQdHMsIHBhdGggKSB7XHJcblxyXG5cdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XHJcblxyXG5cdHZhciBpLCBpbCwgcCwgb2xkWCwgb2xkWSwgeE5vcm07XHJcblxyXG5cdGZvciAoIGkgPSAwLCBpbCA9IG9sZFB0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRwID0gb2xkUHRzWyBpIF07XHJcblxyXG5cdFx0b2xkWCA9IHAueDtcclxuXHRcdG9sZFkgPSBwLnk7XHJcblxyXG5cdFx0eE5vcm0gPSBvbGRYIC8gYm91bmRzLm1heFg7XHJcblxyXG5cdFx0Ly8gSWYgdXNpbmcgYWN0dWFsIGRpc3RhbmNlLCBmb3IgbGVuZ3RoID4gcGF0aCwgcmVxdWlyZXMgbGluZSBleHRydXNpb25zXHJcblx0XHQvL3hOb3JtID0gcGF0aC5nZXRVdG9UbWFwcGluZyh4Tm9ybSwgb2xkWCk7IC8vIDMgc3R5bGVzLiAxKSB3cmFwIHN0cmV0Y2hlZC4gMikgd3JhcCBzdHJldGNoIGJ5IGFyYyBsZW5ndGggMykgd2FycCBieSBhY3R1YWwgZGlzdGFuY2VcclxuXHJcblx0XHR4Tm9ybSA9IHBhdGguZ2V0VXRvVG1hcHBpbmcoIHhOb3JtLCBvbGRYICk7XHJcblxyXG5cdFx0Ly8gY2hlY2sgZm9yIG91dCBvZiBib3VuZHM/XHJcblxyXG5cdFx0dmFyIHBhdGhQdCA9IHBhdGguZ2V0UG9pbnQoIHhOb3JtICk7XHJcblx0XHR2YXIgbm9ybWFsID0gcGF0aC5nZXRUYW5nZW50KCB4Tm9ybSApO1xyXG5cdFx0bm9ybWFsLnNldCggLW5vcm1hbC55LCBub3JtYWwueCApLm11bHRpcGx5U2NhbGFyKCBvbGRZICk7XHJcblxyXG5cdFx0cC54ID0gcGF0aFB0LnggKyBub3JtYWwueDtcclxuXHRcdHAueSA9IHBhdGhQdC55ICsgbm9ybWFsLnk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG9sZFB0cztcclxuXHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuR3lyb3Njb3BlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uICggZm9yY2UgKSB7XHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSAmJiB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHQvLyB1cGRhdGUgbWF0cml4V29ybGRcclxuXHJcblx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnBhcmVudCApIHtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggdGhpcy50cmFuc2xhdGlvbldvcmxkLCB0aGlzLnF1YXRlcm5pb25Xb3JsZCwgdGhpcy5zY2FsZVdvcmxkICk7XHJcblx0XHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy50cmFuc2xhdGlvbk9iamVjdCwgdGhpcy5xdWF0ZXJuaW9uT2JqZWN0LCB0aGlzLnNjYWxlT2JqZWN0ICk7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvbXBvc2UoIHRoaXMudHJhbnNsYXRpb25Xb3JsZCwgdGhpcy5xdWF0ZXJuaW9uT2JqZWN0LCB0aGlzLnNjYWxlV29ybGQgKTtcclxuXHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGZvcmNlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUudHJhbnNsYXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUudHJhbnNsYXRpb25PYmplY3QgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnF1YXRlcm5pb25Xb3JsZCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUucXVhdGVybmlvbk9iamVjdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUuc2NhbGVXb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUuc2NhbGVPYmplY3QgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxyXG4gKlxyXG4gKiovXHJcblxyXG5USFJFRS5QYXRoID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFRIUkVFLkN1cnZlUGF0aC5jYWxsKHRoaXMpO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMgPSBbXTtcclxuXHJcblx0aWYgKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0dGhpcy5mcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuUGF0aEFjdGlvbnMgPSB7XHJcblxyXG5cdE1PVkVfVE86ICdtb3ZlVG8nLFxyXG5cdExJTkVfVE86ICdsaW5lVG8nLFxyXG5cdFFVQURSQVRJQ19DVVJWRV9UTzogJ3F1YWRyYXRpY0N1cnZlVG8nLCAvLyBCZXppZXIgcXVhZHJhdGljIGN1cnZlXHJcblx0QkVaSUVSX0NVUlZFX1RPOiAnYmV6aWVyQ3VydmVUbycsIFx0XHQvLyBCZXppZXIgY3ViaWMgY3VydmVcclxuXHRDU1BMSU5FX1RIUlU6ICdzcGxpbmVUaHJ1JyxcdFx0XHRcdC8vIENhdG11bGwtcm9tIHNwbGluZVxyXG5cdEFSQzogJ2FyYycsXHRcdFx0XHRcdFx0XHRcdC8vIENpcmNsZVxyXG5cdEVMTElQU0U6ICdlbGxpcHNlJ1xyXG59O1xyXG5cclxuLy8gVE9ETyBDbGVhbiB1cCBQQVRIIEFQSVxyXG5cclxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXHJcbi8vIC0gdmVjdG9yczogYXJyYXkgb2YgVmVjdG9yMlxyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcblx0dGhpcy5tb3ZlVG8oIHZlY3RvcnNbIDAgXS54LCB2ZWN0b3JzWyAwIF0ueSApO1xyXG5cclxuXHRmb3IgKCB2YXIgdiA9IDEsIHZsZW4gPSB2ZWN0b3JzLmxlbmd0aDsgdiA8IHZsZW47IHYgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5saW5lVG8oIHZlY3RvcnNbIHYgXS54LCB2ZWN0b3JzWyB2IF0ueSApO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vIHN0YXJ0UGF0aCgpIGVuZFBhdGgoKT9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuTGluZUN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICkgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkxJTkVfVE8sIGFyZ3M6IGFyZ3MgfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xyXG5cclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcclxuXHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKSApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuUVVBRFJBVElDX0NVUlZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgIGFDUDJ4LCBhQ1AyeSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgIGFYLCBhWSApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5DdWJpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQMngsIGFDUDJ5ICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZICkgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkJFWklFUl9DVVJWRV9UTywgYXJnczogYXJncyB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuLy8tLS1cclxuXHR2YXIgbnB0cyA9IFsgbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApIF07XHJcblx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIG5wdHMsIHB0cyApO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIG5wdHMgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVSwgYXJnczogYXJncyB9ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRlVUVVJFOiBDaGFuZ2UgdGhlIEFQSSBvciBmb2xsb3cgY2FudmFzIEFQST9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDFdLmFyZ3M7XHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR0aGlzLmFic2FyYyhhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxyXG5cdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxuIH07XHJcblxyXG4gVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHR0aGlzLmFic2VsbGlwc2UoYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlKTtcclxuIH07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5lbGxpcHNlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMV0uYXJncztcclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHRoaXMuYWJzZWxsaXBzZShhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLFxyXG5cdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxuIH07XHJcblxyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRcdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCgxKTtcclxuXHRhcmdzLnB1c2gobGFzdFBvaW50LngpO1xyXG5cdGFyZ3MucHVzaChsYXN0UG9pbnQueSk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuRUxMSVBTRSwgYXJnczogYXJncyB9ICk7XHJcblxyXG4gfTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xyXG5cclxuXHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNDA7XHJcblxyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGl2aXNpb25zOyBpICsrICkge1xyXG5cclxuXHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0XHQvL2lmKCAhdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICkgdGhyb3cgXCJESUVcIjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBpZiAoIGNsb3NlZFBhdGggKSB7XHJcblx0Ly9cclxuXHQvLyBcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xyXG5cdC8vXHJcblx0Ly8gfVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG5cclxufTtcclxuXHJcbi8qIFJldHVybiBhbiBhcnJheSBvZiB2ZWN0b3JzIGJhc2VkIG9uIGNvbnRvdXIgb2YgdGhlIHBhdGggKi9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKSB7XHJcblxyXG5cdGlmICh0aGlzLnVzZVNwYWNlZFBvaW50cykge1xyXG5cdFx0Y29uc29sZS5sb2coJ3RhdGEnKTtcclxuXHRcdHJldHVybiB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCBjbG9zZWRQYXRoICk7XHJcblx0fVxyXG5cclxuXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XHJcblxyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0dmFyIGksIGlsLCBpdGVtLCBhY3Rpb24sIGFyZ3M7XHJcblx0dmFyIGNweCwgY3B5LCBjcHgyLCBjcHkyLCBjcHgxLCBjcHkxLCBjcHgwLCBjcHkwLFxyXG5cdFx0bGFzdGUsIGosXHJcblx0XHR0LCB0eCwgdHk7XHJcblxyXG5cdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRpdGVtID0gdGhpcy5hY3Rpb25zWyBpIF07XHJcblxyXG5cdFx0YWN0aW9uID0gaXRlbS5hY3Rpb247XHJcblx0XHRhcmdzID0gaXRlbS5hcmdzO1xyXG5cclxuXHRcdHN3aXRjaCggYWN0aW9uICkge1xyXG5cclxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpcclxuXHJcblx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOlxyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpcclxuXHJcblx0XHRcdGNweCAgPSBhcmdzWyAyIF07XHJcblx0XHRcdGNweSAgPSBhcmdzWyAzIF07XHJcblxyXG5cdFx0XHRjcHgxID0gYXJnc1sgMCBdO1xyXG5cdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xyXG5cclxuXHRcdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0bGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xyXG5cdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcclxuXHJcblx0XHRcdFx0Y3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XHJcblx0XHRcdFx0Y3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHQgPSBqIC8gZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcclxuXHRcdFx0XHR0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5CRVpJRVJfQ1VSVkVfVE86XHJcblxyXG5cdFx0XHRjcHggID0gYXJnc1sgNCBdO1xyXG5cdFx0XHRjcHkgID0gYXJnc1sgNSBdO1xyXG5cclxuXHRcdFx0Y3B4MSA9IGFyZ3NbIDAgXTtcclxuXHRcdFx0Y3B5MSA9IGFyZ3NbIDEgXTtcclxuXHJcblx0XHRcdGNweDIgPSBhcmdzWyAyIF07XHJcblx0XHRcdGNweTIgPSBhcmdzWyAzIF07XHJcblxyXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XHJcblx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xyXG5cclxuXHRcdFx0XHRjcHgwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXTtcclxuXHRcdFx0XHRjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHQgPSBqIC8gZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcclxuXHRcdFx0XHR0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlU6XHJcblxyXG5cdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xyXG5cclxuXHRcdFx0dmFyIGxhc3QgPSBuZXcgVEhSRUUuVmVjdG9yMiggbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXSwgbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXSApO1xyXG5cdFx0XHR2YXIgc3B0cyA9IFsgbGFzdCBdO1xyXG5cclxuXHRcdFx0dmFyIG4gPSBkaXZpc2lvbnMgKiBhcmdzWyAwIF0ubGVuZ3RoO1xyXG5cclxuXHRcdFx0c3B0cyA9IHNwdHMuY29uY2F0KCBhcmdzWyAwIF0gKTtcclxuXHJcblx0XHRcdHZhciBzcGxpbmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIHNwdHMgKTtcclxuXHJcblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IG47IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBzcGxpbmUuZ2V0UG9pbnRBdCggaiAvIG4gKSApIDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQVJDOlxyXG5cclxuXHRcdFx0dmFyIGFYID0gYXJnc1sgMCBdLCBhWSA9IGFyZ3NbIDEgXSxcclxuXHRcdFx0XHRhUmFkaXVzID0gYXJnc1sgMiBdLFxyXG5cdFx0XHRcdGFTdGFydEFuZ2xlID0gYXJnc1sgMyBdLCBhRW5kQW5nbGUgPSBhcmdzWyA0IF0sXHJcblx0XHRcdFx0YUNsb2Nrd2lzZSA9ICEhYXJnc1sgNSBdO1xyXG5cclxuXHRcdFx0dmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcclxuXHRcdFx0dmFyIGFuZ2xlO1xyXG5cdFx0XHR2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR0ID0gaiAvIHRkaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRcdGlmICggISBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHRcdFx0XHRcdHQgPSAxIC0gdDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcblxyXG5cdFx0XHRcdHR4ID0gYVggKyBhUmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHRcdFx0dHkgPSBhWSArIGFSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBvaW50cyk7XHJcblxyXG5cdFx0ICBicmVhaztcclxuXHRcdCAgXHJcblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkVMTElQU0U6XHJcblxyXG5cdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxyXG5cdFx0XHRcdHhSYWRpdXMgPSBhcmdzWyAyIF0sXHJcblx0XHRcdFx0eVJhZGl1cyA9IGFyZ3NbIDMgXSxcclxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDQgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNSBdLFxyXG5cdFx0XHRcdGFDbG9ja3dpc2UgPSAhIWFyZ3NbIDYgXTtcclxuXHJcblxyXG5cdFx0XHR2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xyXG5cdFx0XHR2YXIgYW5nbGU7XHJcblx0XHRcdHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcclxuXHJcblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHQgPSBqIC8gdGRpdmlzaW9ucztcclxuXHJcblx0XHRcdFx0aWYgKCAhIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0dCA9IDEgLSB0O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHJcblx0XHRcdFx0dHggPSBhWCArIHhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcclxuXHRcdFx0XHR0eSA9IGFZICsgeVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2cocG9pbnRzKTtcclxuXHJcblx0XHQgIGJyZWFrO1xyXG5cclxuXHRcdH0gLy8gZW5kIHN3aXRjaFxyXG5cclxuXHR9XHJcblxyXG5cclxuXHJcblx0Ly8gTm9ybWFsaXplIHRvIHJlbW92ZSB0aGUgY2xvc2luZyBwb2ludCBieSBkZWZhdWx0LlxyXG5cdHZhciBsYXN0UG9pbnQgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxXTtcclxuXHR2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcclxuXHRpZiAoIE1hdGguYWJzKGxhc3RQb2ludC54IC0gcG9pbnRzWyAwIF0ueCkgPCBFUFNJTE9OICYmXHJcblx0XHRcdCBNYXRoLmFicyhsYXN0UG9pbnQueSAtIHBvaW50c1sgMCBdLnkpIDwgRVBTSUxPTilcclxuXHRcdHBvaW50cy5zcGxpY2UoIHBvaW50cy5sZW5ndGggLSAxLCAxKTtcclxuXHRpZiAoIGNsb3NlZFBhdGggKSB7XHJcblxyXG5cdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxuXHJcbn07XHJcblxyXG4vLyBCcmVha3MgcGF0aCBpbnRvIHNoYXBlc1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUudG9TaGFwZXMgPSBmdW5jdGlvbiggaXNDQ1cgKSB7XHJcblxyXG5cdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XHJcblx0XHR2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcclxuXHJcblx0XHR2YXIgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7XHJcblxyXG5cdFx0Ly8gaW5QdCBvbiBwb2x5Z29uIGNvbnRvdXIgPT4gaW1tZWRpYXRlIHN1Y2Nlc3MgICAgb3JcclxuXHRcdC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2VcclxuXHRcdC8vICB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBpblB0LCBsZWZ0IG9mIGluUHRcclxuXHRcdC8vICBub3QgY291bnRpbmcgbG93ZXJZIGVuZHBvaW50cyBvZiBlZGdlcyBhbmQgd2hvbGUgZWRnZXMgb24gdGhhdCBsaW5lXHJcblx0XHR2YXIgaW5zaWRlID0gZmFsc2U7XHJcblx0XHRmb3IoIHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHErKyApIHtcclxuXHRcdFx0dmFyIGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHAgXTtcclxuXHRcdFx0dmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcclxuXHJcblx0XHRcdHZhciBlZGdlRHggPSBlZGdlSGlnaFB0LnggLSBlZGdlTG93UHQueDtcclxuXHRcdFx0dmFyIGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyhlZGdlRHkpID4gRVBTSUxPTiApIHtcdFx0XHQvLyBub3QgcGFyYWxsZWxcclxuXHRcdFx0XHRpZiAoIGVkZ2VEeSA8IDAgKSB7XHJcblx0XHRcdFx0XHRlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC1lZGdlRHg7XHJcblx0XHRcdFx0XHRlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBwIF07IGVkZ2VEeSA9IC1lZGdlRHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSBcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmICggaW5QdC55ID09IGVkZ2VMb3dQdC55ICkge1xyXG5cdFx0XHRcdFx0aWYgKCBpblB0LnggPT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XHJcblx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIHBlcnBFZGdlID0gZWRnZUR5ICogKGluUHQueCAtIGVkZ2VMb3dQdC54KSAtIGVkZ2VEeCAqIChpblB0LnkgLSBlZGdlTG93UHQueSk7XHJcblx0XHRcdFx0XHRpZiAoIHBlcnBFZGdlID09IDAgKVx0XHRcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xyXG5cdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA8IDAgKSBcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcdFx0Ly8gdHJ1ZSBpbnRlcnNlY3Rpb24gbGVmdCBvZiBpblB0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1x0XHQvLyBwYXJhbGxlbCBvciBjb2xpbmVhclxyXG5cdFx0XHRcdGlmICggaW5QdC55ICE9IGVkZ2VMb3dQdC55ICkgXHRcdGNvbnRpbnVlO1x0XHRcdC8vIHBhcmFsbGVsXHJcblx0XHRcdFx0Ly8gZWdkZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XHJcblx0XHRcdFx0aWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxyXG5cdFx0XHRcdFx0ICggKCBlZGdlTG93UHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlSGlnaFB0LnggKSApIClcdFx0cmV0dXJuXHR0cnVlO1x0Ly8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXHJcblx0XHRcdFx0Ly8gY29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm5cdGluc2lkZTtcclxuXHR9XHJcblxyXG5cdHZhciBpLCBpbCwgaXRlbSwgYWN0aW9uLCBhcmdzO1xyXG5cclxuXHR2YXIgc3ViUGF0aHMgPSBbXSwgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xyXG5cclxuXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0aXRlbSA9IHRoaXMuYWN0aW9uc1sgaSBdO1xyXG5cclxuXHRcdGFyZ3MgPSBpdGVtLmFyZ3M7XHJcblx0XHRhY3Rpb24gPSBpdGVtLmFjdGlvbjtcclxuXHJcblx0XHRpZiAoIGFjdGlvbiA9PSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPICkge1xyXG5cclxuXHRcdFx0aWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPSAwICkge1xyXG5cclxuXHRcdFx0XHRzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xyXG5cdFx0XHRcdGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGFzdFBhdGhbIGFjdGlvbiBdLmFwcGx5KCBsYXN0UGF0aCwgYXJncyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT0gMCApIHtcclxuXHJcblx0XHRzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNvbnNvbGUubG9nKHN1YlBhdGhzKTtcclxuXHJcblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT0gMCApIHJldHVybiBbXTtcclxuXHJcblx0dmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XHJcblxyXG5cdGlmICggc3ViUGF0aHMubGVuZ3RoID09IDEpIHtcclxuXHJcblx0XHR0bXBQYXRoID0gc3ViUGF0aHNbMF07XHJcblx0XHR0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xyXG5cdFx0dG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcclxuXHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xyXG5cdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XHJcblx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBob2xlc0ZpcnN0ID0gIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XHJcblx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gIWhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0O1xyXG5cclxuXHQvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xyXG5cdFxyXG5cdHZhciBiZXR0ZXJTaGFwZUhvbGVzID0gW107XHJcblx0dmFyIG5ld1NoYXBlcyA9IFtdO1xyXG5cdHZhciBuZXdTaGFwZUhvbGVzID0gW107XHJcblx0dmFyIG1haW5JZHggPSAwO1xyXG5cdHZhciB0bXBQb2ludHM7XHJcblxyXG5cdG5ld1NoYXBlc1ttYWluSWR4XSA9IHVuZGVmaW5lZDtcclxuXHRuZXdTaGFwZUhvbGVzW21haW5JZHhdID0gW107XHJcblxyXG5cdGZvciAoIGkgPSAwLCBpbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xyXG5cdFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcclxuXHRcdHNvbGlkID0gVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHRtcFBvaW50cyApO1xyXG5cdFx0c29saWQgPSBpc0NDVyA/ICFzb2xpZCA6IHNvbGlkO1xyXG5cclxuXHRcdGlmICggc29saWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoICghIGhvbGVzRmlyc3QgKSAmJiAoIG5ld1NoYXBlc1ttYWluSWR4XSApIClcdG1haW5JZHgrKztcclxuXHJcblx0XHRcdG5ld1NoYXBlc1ttYWluSWR4XSA9IHsgczogbmV3IFRIUkVFLlNoYXBlKCksIHA6IHRtcFBvaW50cyB9O1xyXG5cdFx0XHRuZXdTaGFwZXNbbWFpbklkeF0ucy5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG5cdFx0XHRuZXdTaGFwZXNbbWFpbklkeF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuXHRcdFx0XHJcblx0XHRcdGlmICggaG9sZXNGaXJzdCApXHRtYWluSWR4Kys7XHJcblx0XHRcdG5ld1NoYXBlSG9sZXNbbWFpbklkeF0gPSBbXTtcclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2N3JywgaSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG5ld1NoYXBlSG9sZXNbbWFpbklkeF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbMF0gfSApO1xyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGlmICggbmV3U2hhcGVzLmxlbmd0aCA+IDEgKSB7XHJcblx0XHR2YXIgYW1iaWdpb3VzID0gZmFsc2U7XHJcblx0XHR2YXIgdG9DaGFuZ2UgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4KysgKSB7XHJcblx0XHRcdGJldHRlclNoYXBlSG9sZXNbc0lkeF0gPSBbXTtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHgrKyApIHtcclxuXHRcdFx0dmFyIHNoID0gbmV3U2hhcGVzW3NJZHhdO1xyXG5cdFx0XHR2YXIgc2hvID0gbmV3U2hhcGVIb2xlc1tzSWR4XTtcclxuXHRcdFx0Zm9yICh2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4KysgKSB7XHJcblx0XHRcdFx0dmFyIGhvID0gc2hvW2hJZHhdO1xyXG5cdFx0XHRcdHZhciBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xyXG5cdFx0XHRcdGZvciAodmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCsrICkge1xyXG5cdFx0XHRcdFx0aWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzW3MySWR4XS5wICkgKSB7XHJcblx0XHRcdFx0XHRcdGlmICggc0lkeCAhPSBzMklkeCApXHRcdHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xyXG5cdFx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcclxuXHRcdFx0XHRcdFx0XHRob2xlX3VuYXNzaWduZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzW3MySWR4XS5wdXNoKCBobyApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGFtYmlnaW91cyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7IGJldHRlclNoYXBlSG9sZXNbc0lkeF0ucHVzaCggaG8gKTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlnaW91czogXCIsIGFtYmlnaW91cyk7XHJcblx0XHRpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwidG8gY2hhbmdlOiBcIiwgdG9DaGFuZ2UpO1xyXG5cdFx0XHRpZiAoISBhbWJpZ2lvdXMpXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZhciB0bXBIb2xlcywgaiwgamw7XHJcblx0Zm9yICggaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cdFx0dG1wU2hhcGUgPSBuZXdTaGFwZXNbaV0ucztcclxuXHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzW2ldO1xyXG5cdFx0Zm9yICggaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblx0XHRcdHRtcFNoYXBlLmhvbGVzLnB1c2goIHRtcEhvbGVzW2pdLmggKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xyXG5cclxuXHRyZXR1cm4gc2hhcGVzO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIERlZmluZXMgYSAyZCBzaGFwZSBwbGFuZSB1c2luZyBwYXRocy5cclxuICoqL1xyXG5cclxuLy8gU1RFUCAxIENyZWF0ZSBhIHBhdGguXHJcbi8vIFNURVAgMiBUdXJuIHBhdGggaW50byBzaGFwZS5cclxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcclxuLy8gU1RFUCAzYSAtIEV4dHJhY3QgcG9pbnRzIGZyb20gZWFjaCBzaGFwZSwgdHVybiB0byB2ZXJ0aWNlc1xyXG4vLyBTVEVQIDNiIC0gVHJpYW5ndWxhdGUgZWFjaCBzaGFwZSwgYWRkIGZhY2VzLlxyXG5cclxuVEhSRUUuU2hhcGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLlBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG5cdHRoaXMuaG9sZXMgPSBbXTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5QYXRoLnByb3RvdHlwZSApO1xyXG5cclxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBFeHRydWRlR2VvbWV0cnlcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xyXG5cclxuXHR2YXIgZXh0cnVkZWQgPSBuZXcgVEhSRUUuRXh0cnVkZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XHJcblx0cmV0dXJuIGV4dHJ1ZGVkO1xyXG5cclxufTtcclxuXHJcbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gU2hhcGVHZW9tZXRyeVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNoYXBlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcclxuXHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBob2xlc1xyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBpLCBpbCA9IHRoaXMuaG9sZXMubGVuZ3RoLCBob2xlc1B0cyA9IFtdO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0VHJhbnNmb3JtZWRQb2ludHMoIGRpdmlzaW9ucywgdGhpcy5iZW5kcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBob2xlc1B0cztcclxuXHJcbn07XHJcblxyXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzIChzcGFjZWQgYnkgcmVndWxhciBkaXN0YW5jZSlcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHR2YXIgaSwgaWwgPSB0aGlzLmhvbGVzLmxlbmd0aCwgaG9sZXNQdHMgPSBbXTtcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIHRoaXMuYmVuZHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaG9sZXNQdHM7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0cmV0dXJuIHtcclxuXHJcblx0XHRzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cyggZGl2aXNpb25zICksXHJcblx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRpZiAodGhpcy51c2VTcGFjZWRQb2ludHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmV4dHJhY3RBbGxTcGFjZWRQb2ludHMoZGl2aXNpb25zKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLmV4dHJhY3RBbGxQb2ludHMoZGl2aXNpb25zKTtcclxuXHJcbn07XHJcblxyXG4vL1xyXG4vLyBUSFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50c1dpdGhCZW5kID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMsIGJlbmQgKSB7XHJcbi8vXHJcbi8vIFx0cmV0dXJuIHtcclxuLy9cclxuLy8gXHRcdHNoYXBlOiB0aGlzLnRyYW5zZm9ybSggYmVuZCwgZGl2aXNpb25zICksXHJcbi8vIFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zLCBiZW5kIClcclxuLy9cclxuLy8gXHR9O1xyXG4vL1xyXG4vLyB9O1xyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0cmV0dXJuIHtcclxuXHJcblx0XHRzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zICksXHJcblx0XHRob2xlczogdGhpcy5nZXRTcGFjZWRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFV0aWxzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLlNoYXBlLlV0aWxzID0ge1xyXG5cclxuXHR0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnUHQxLCBpblNlZ1B0MiwgaW5PdGhlclB0ICkge1xyXG5cdFx0XHQvLyBpbk90aGVyUHQgbmVlZHMgdG8gYmUgY29saW5lYXIgdG8gdGhlIGluU2VnbWVudFxyXG5cdFx0XHRpZiAoIGluU2VnUHQxLnggIT0gaW5TZWdQdDIueCApIHtcclxuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnggPCBpblNlZ1B0Mi54ICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuXHQoICggaW5TZWdQdDEueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDIueCApICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnggPD0gaW5PdGhlclB0LnggKSAmJiAoIGluT3RoZXJQdC54IDw9IGluU2VnUHQxLnggKSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoIGluU2VnUHQxLnkgPCBpblNlZ1B0Mi55ICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuXHQoICggaW5TZWdQdDEueSA8PSBpbk90aGVyUHQueSApICYmICggaW5PdGhlclB0LnkgPD0gaW5TZWdQdDIueSApICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGluU2VnUHQyLnkgPD0gaW5PdGhlclB0LnkgKSAmJiAoIGluT3RoZXJQdC55IDw9IGluU2VnUHQxLnkgKSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSB7XHJcblx0XHRcdHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xyXG5cclxuXHRcdFx0dmFyIHNlZzFkeCA9IGluU2VnMVB0Mi54IC0gaW5TZWcxUHQxLngsICAgc2VnMWR5ID0gaW5TZWcxUHQyLnkgLSBpblNlZzFQdDEueTtcclxuXHRcdFx0dmFyIHNlZzJkeCA9IGluU2VnMlB0Mi54IC0gaW5TZWcyUHQxLngsICAgc2VnMmR5ID0gaW5TZWcyUHQyLnkgLSBpblNlZzJQdDEueTtcclxuXHJcblx0XHRcdHZhciBzZWcxc2VnMmR4ID0gaW5TZWcxUHQxLnggLSBpblNlZzJQdDEueDtcclxuXHRcdFx0dmFyIHNlZzFzZWcyZHkgPSBpblNlZzFQdDEueSAtIGluU2VnMlB0MS55O1xyXG5cclxuXHRcdFx0dmFyIGxpbWl0XHRcdD0gc2VnMWR5ICogc2VnMmR4IC0gc2VnMWR4ICogc2VnMmR5O1xyXG5cdFx0XHR2YXIgcGVycFNlZzFcdD0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKGxpbWl0KSA+IEVQU0lMT04gKSB7XHRcdFx0Ly8gbm90IHBhcmFsbGVsXHJcblxyXG5cdFx0XHRcdHZhciBwZXJwU2VnMjtcclxuXHRcdFx0XHRpZiAoIGxpbWl0ID4gMCApIHtcclxuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA8IDAgKSB8fCAoIHBlcnBTZWcxID4gbGltaXQgKSApIFx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xyXG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcyIDwgMCApIHx8ICggcGVycFNlZzIgPiBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxID4gMCApIHx8ICggcGVycFNlZzEgPCBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XHJcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gaS5lLiB0byByZWR1Y2Ugcm91bmRpbmcgZXJyb3JzXHJcblx0XHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGF0IGVuZHBvaW50IG9mIHNlZ21lbnQjMT9cclxuXHRcdFx0XHRpZiAoIHBlcnBTZWcyID09IDAgKSB7XHJcblx0XHRcdFx0XHRpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcclxuXHRcdFx0XHRcdFx0ICggKCBwZXJwU2VnMSA9PSAwICkgfHwgKCBwZXJwU2VnMSA9PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRyZXR1cm4gIFsgaW5TZWcxUHQxIF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICggcGVycFNlZzIgPT0gbGltaXQgKSB7XHJcblx0XHRcdFx0XHRpZiAoICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkgJiZcclxuXHRcdFx0XHRcdFx0ICggKCBwZXJwU2VnMSA9PSAwICkgfHwgKCBwZXJwU2VnMSA9PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRyZXR1cm4gIFsgaW5TZWcxUHQyIF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzI/XHJcblx0XHRcdFx0aWYgKCBwZXJwU2VnMSA9PSAwIClcdFx0cmV0dXJuICBbIGluU2VnMlB0MSBdO1xyXG5cdFx0XHRcdGlmICggcGVycFNlZzEgPT0gbGltaXQgKVx0cmV0dXJuICBbIGluU2VnMlB0MiBdO1xyXG5cclxuXHRcdFx0XHQvLyByZXR1cm4gcmVhbCBpbnRlcnNlY3Rpb24gcG9pbnRcclxuXHRcdFx0XHR2YXIgZmFjdG9yU2VnMSA9IHBlcnBTZWcyIC8gbGltaXQ7XHJcblx0XHRcdFx0cmV0dXJuXHRbIHsgeDogaW5TZWcxUHQxLnggKyBmYWN0b3JTZWcxICogc2VnMWR4LFxyXG5cdFx0XHRcdFx0XHRcdHk6IGluU2VnMVB0MS55ICsgZmFjdG9yU2VnMSAqIHNlZzFkeSB9IF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1x0XHQvLyBwYXJhbGxlbCBvciBjb2xpbmVhclxyXG5cdFx0XHRcdGlmICggKCBwZXJwU2VnMSAhPSAwICkgfHxcclxuXHRcdFx0XHRcdCAoIHNlZzJkeSAqIHNlZzFzZWcyZHggIT0gc2VnMmR4ICogc2VnMXNlZzJkeSApICkgXHRcdFx0cmV0dXJuIFtdO1xyXG5cclxuXHRcdFx0XHQvLyB0aGV5IGFyZSBjb2xsaW5lYXIgb3IgZGVnZW5lcmF0ZVxyXG5cdFx0XHRcdHZhciBzZWcxUHQgPSAoIChzZWcxZHggPT0gMCkgJiYgKHNlZzFkeSA9PSAwKSApO1x0Ly8gc2VnbWVudDEgaXN0IGp1c3QgYSBwb2ludD9cclxuXHRcdFx0XHR2YXIgc2VnMlB0ID0gKCAoc2VnMmR4ID09IDApICYmIChzZWcyZHkgPT0gMCkgKTtcdC8vIHNlZ21lbnQyIGlzdCBqdXN0IGEgcG9pbnQ/XHJcblx0XHRcdFx0Ly8gYm90aCBzZWdtZW50cyBhcmUgcG9pbnRzXHJcblx0XHRcdFx0aWYgKCBzZWcxUHQgJiYgc2VnMlB0ICkge1xyXG5cdFx0XHRcdFx0aWYgKCAoaW5TZWcxUHQxLnggIT0gaW5TZWcyUHQxLngpIHx8XHJcblx0XHRcdFx0XHRcdCAoaW5TZWcxUHQxLnkgIT0gaW5TZWcyUHQxLnkpIClcdFx0cmV0dXJuIFtdOyAgIFx0Ly8gdGhleSBhcmUgZGlzdGluY3QgIHBvaW50c1xyXG5cdFx0XHRcdFx0cmV0dXJuICBbIGluU2VnMVB0MSBdOyAgICAgICAgICAgICAgICAgXHRcdFx0XHRcdC8vIHRoZXkgYXJlIHRoZSBzYW1lIHBvaW50XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHNlZ21lbnQjMSAgaXMgYSBzaW5nbGUgcG9pbnRcclxuXHRcdFx0XHRpZiAoIHNlZzFQdCApIHtcclxuXHRcdFx0XHRcdGlmICghIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzJcclxuXHRcdFx0XHRcdHJldHVybiAgWyBpblNlZzFQdDEgXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gc2VnbWVudCMyICBpcyBhIHNpbmdsZSBwb2ludFxyXG5cdFx0XHRcdGlmICggc2VnMlB0ICkge1xyXG5cdFx0XHRcdFx0aWYgKCEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSApIClcdFx0cmV0dXJuIFtdO1x0XHQvLyBidXQgbm90IGluIHNlZ21lbnQjMVxyXG5cdFx0XHRcdFx0cmV0dXJuICBbIGluU2VnMlB0MSBdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gdGhleSBhcmUgY29sbGluZWFyIHNlZ21lbnRzLCB3aGljaCBtaWdodCBvdmVybGFwXHJcblx0XHRcdFx0dmFyIHNlZzFtaW4sIHNlZzFtYXgsIHNlZzFtaW5WYWwsIHNlZzFtYXhWYWw7XHJcblx0XHRcdFx0dmFyIHNlZzJtaW4sIHNlZzJtYXgsIHNlZzJtaW5WYWwsIHNlZzJtYXhWYWw7XHJcblx0XHRcdFx0aWYgKHNlZzFkeCAhPSAwKSB7XHRcdC8vIHRoZSBzZWdtZW50cyBhcmUgTk9UIG9uIGEgdmVydGljYWwgbGluZVxyXG5cdFx0XHRcdFx0aWYgKCBpblNlZzFQdDEueCA8IGluU2VnMVB0Mi54ICkge1xyXG5cdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLng7XHJcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDI7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueDtcclxuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS54O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBpblNlZzJQdDEueCA8IGluU2VnMlB0Mi54ICkge1xyXG5cdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLng7XHJcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueDtcclxuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS54O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHQvLyB0aGUgc2VnbWVudHMgYXJlIG9uIGEgdmVydGljYWwgbGluZVxyXG5cdFx0XHRcdFx0aWYgKCBpblNlZzFQdDEueSA8IGluU2VnMVB0Mi55ICkge1xyXG5cdFx0XHRcdFx0XHRzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLnk7XHJcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDI7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueTtcclxuXHRcdFx0XHRcdFx0c2VnMW1heCA9IGluU2VnMVB0MTsgc2VnMW1heFZhbCA9IGluU2VnMVB0MS55O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBpblNlZzJQdDEueSA8IGluU2VnMlB0Mi55ICkge1xyXG5cdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLnk7XHJcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcclxuXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS55O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIHNlZzFtaW5WYWwgPD0gc2VnMm1pblZhbCApIHtcclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8ICBzZWcybWluVmFsIClcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA9PSBzZWcybWluVmFsIClcdHtcclxuXHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRcdHJldHVybiBbIHNlZzJtaW4gXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzJtaW4sIHNlZzFtYXggXTtcclxuXHRcdFx0XHRcdHJldHVyblx0WyBzZWcybWluLCBzZWcybWF4IF07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICggc2VnMW1pblZhbCA+ICBzZWcybWF4VmFsIClcdHJldHVybiBbXTtcclxuXHRcdFx0XHRcdGlmICggc2VnMW1pblZhbCA9PSBzZWcybWF4VmFsIClcdHtcclxuXHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XHJcblx0XHRcdFx0XHRcdHJldHVybiBbIHNlZzFtaW4gXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzFtaW4sIHNlZzFtYXggXTtcclxuXHRcdFx0XHRcdHJldHVyblx0WyBzZWcxbWluLCBzZWcybWF4IF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZUFuZ2xlKCBpblZlcnRleCwgaW5MZWdGcm9tUHQsIGluTGVnVG9QdCwgaW5PdGhlclB0ICkge1xyXG5cdFx0XHQvLyBUaGUgb3JkZXIgb2YgbGVncyBpcyBpbXBvcnRhbnRcclxuXHJcblx0XHRcdHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xyXG5cclxuXHRcdFx0Ly8gdHJhbnNsYXRpb24gb2YgYWxsIHBvaW50cywgc28gdGhhdCBWZXJ0ZXggaXMgYXQgKDAsMClcclxuXHRcdFx0dmFyIGxlZ0Zyb21QdFhcdD0gaW5MZWdGcm9tUHQueCAtIGluVmVydGV4LngsICBsZWdGcm9tUHRZXHQ9IGluTGVnRnJvbVB0LnkgLSBpblZlcnRleC55O1xyXG5cdFx0XHR2YXIgbGVnVG9QdFhcdD0gaW5MZWdUb1B0LnhcdC0gaW5WZXJ0ZXgueCwgIGxlZ1RvUHRZXHRcdD0gaW5MZWdUb1B0LnlcdC0gaW5WZXJ0ZXgueTtcclxuXHRcdFx0dmFyIG90aGVyUHRYXHQ9IGluT3RoZXJQdC54XHQtIGluVmVydGV4LngsICBvdGhlclB0WVx0XHQ9IGluT3RoZXJQdC55XHQtIGluVmVydGV4Lnk7XHJcblxyXG5cdFx0XHQvLyBtYWluIGFuZ2xlID4wOiA8IDE4MCBkZWcuOyAwOiAxODAgZGVnLjsgPDA6ID4gMTgwIGRlZy5cclxuXHRcdFx0dmFyIGZyb20ydG9BbmdsZVx0PSBsZWdGcm9tUHRYICogbGVnVG9QdFkgLSBsZWdGcm9tUHRZICogbGVnVG9QdFg7XHJcblx0XHRcdHZhciBmcm9tMm90aGVyQW5nbGVcdD0gbGVnRnJvbVB0WCAqIG90aGVyUHRZIC0gbGVnRnJvbVB0WSAqIG90aGVyUHRYO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyhmcm9tMnRvQW5nbGUpID4gRVBTSUxPTiApIHtcdFx0XHQvLyBhbmdsZSAhPSAxODAgZGVnLlxyXG5cclxuXHRcdFx0XHR2YXIgb3RoZXIydG9BbmdsZVx0XHQ9IG90aGVyUHRYICogbGVnVG9QdFkgLSBvdGhlclB0WSAqIGxlZ1RvUHRYO1xyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IFwiICsgZnJvbTJ0b0FuZ2xlICsgXCIsIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICsgXCIsIG90aGVyMnRvOiBcIiArIG90aGVyMnRvQW5nbGUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBmcm9tMnRvQW5nbGUgPiAwICkge1x0XHRcdFx0Ly8gbWFpbiBhbmdsZSA8IDE4MCBkZWcuXHJcblx0XHRcdFx0XHRyZXR1cm5cdCggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApICYmICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1x0XHRcdFx0XHRcdFx0XHQvLyBtYWluIGFuZ2xlID4gMTgwIGRlZy5cclxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgfHwgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZ2xlID09IDE4MCBkZWcuXHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogMTgwIGRlZy4sIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICApO1xyXG5cdFx0XHRcdHJldHVyblx0KCBmcm9tMm90aGVyQW5nbGUgPiAwICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuXHRcdFx0dmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXHJcblx0XHRcdHZhciBob2xlO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgaG9sZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgc2hhcGUgcG9pbnRcclxuXHRcdFx0XHR2YXIgbGFzdFNoYXBlSWR4ID0gc2hhcGUubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdFx0dmFyIHByZXZTaGFwZUlkeCA9IGluU2hhcGVJZHggLSAxO1xyXG5cdFx0XHRcdGlmICggcHJldlNoYXBlSWR4IDwgMCApXHRcdFx0cHJldlNoYXBlSWR4ID0gbGFzdFNoYXBlSWR4O1xyXG5cclxuXHRcdFx0XHR2YXIgbmV4dFNoYXBlSWR4ID0gaW5TaGFwZUlkeCArIDE7XHJcblx0XHRcdFx0aWYgKCBuZXh0U2hhcGVJZHggPiBsYXN0U2hhcGVJZHggKVx0bmV4dFNoYXBlSWR4ID0gMDtcclxuXHJcblx0XHRcdFx0dmFyIGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBzaGFwZVtpblNoYXBlSWR4XSwgc2hhcGVbIHByZXZTaGFwZUlkeCBdLCBzaGFwZVsgbmV4dFNoYXBlSWR4IF0sIGhvbGVbaW5Ib2xlSWR4XSApO1xyXG5cdFx0XHRcdGlmICghIGluc2lkZUFuZ2xlICkge1xyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChTaGFwZSk6IFwiICsgaW5TaGFwZUlkeCArIFwiLCBQb2ludDogXCIgKyBob2xlW2luSG9sZUlkeF0ueCArIFwiL1wiICsgaG9sZVtpbkhvbGVJZHhdLnkgKTtcclxuXHRcdFx0XHRcdHJldHVyblx0ZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBDaGVjayBpZiBzaGFwZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgaG9sZSBwb2ludFxyXG5cdFx0XHRcdHZhciBsYXN0SG9sZUlkeCA9IGhvbGUubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdFx0dmFyIHByZXZIb2xlSWR4ID0gaW5Ib2xlSWR4IC0gMTtcclxuXHRcdFx0XHRpZiAoIHByZXZIb2xlSWR4IDwgMCApXHRcdFx0cHJldkhvbGVJZHggPSBsYXN0SG9sZUlkeDtcclxuXHJcblx0XHRcdFx0dmFyIG5leHRIb2xlSWR4ID0gaW5Ib2xlSWR4ICsgMTtcclxuXHRcdFx0XHRpZiAoIG5leHRIb2xlSWR4ID4gbGFzdEhvbGVJZHggKVx0bmV4dEhvbGVJZHggPSAwO1xyXG5cclxuXHRcdFx0XHRpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggaG9sZVtpbkhvbGVJZHhdLCBob2xlWyBwcmV2SG9sZUlkeCBdLCBob2xlWyBuZXh0SG9sZUlkeCBdLCBzaGFwZVtpblNoYXBlSWR4XSApO1xyXG5cdFx0XHRcdGlmICghIGluc2lkZUFuZ2xlICkge1xyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChIb2xlKTogXCIgKyBpbkhvbGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgc2hhcGVbaW5TaGFwZUlkeF0ueCArIFwiL1wiICsgc2hhcGVbaW5TaGFwZUlkeF0ueSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVyblx0dHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaW50ZXJzZWN0c1NoYXBlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcclxuXHRcdFx0XHQvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBzaGFwZSBlZGdlc1xyXG5cdFx0XHRcdHZhciBzSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XHJcblx0XHRcdFx0Zm9yICggc0lkeCA9IDA7IHNJZHggPCBzaGFwZS5sZW5ndGg7IHNJZHgrKyApIHtcclxuXHRcdFx0XHRcdG5leHRJZHggPSBzSWR4KzE7IG5leHRJZHggJT0gc2hhcGUubGVuZ3RoO1xyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBzaGFwZVtzSWR4XSwgc2hhcGVbbmV4dElkeF0sIHRydWUgKTtcclxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKVx0XHRyZXR1cm5cdHRydWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaW5kZXBIb2xlcyA9IFtdO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaW50ZXJzZWN0c0hvbGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xyXG5cdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGhvbGUgZWRnZXNcclxuXHRcdFx0XHR2YXIgaWhJZHgsIGNoa0hvbGUsXHJcblx0XHRcdFx0XHRoSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XHJcblx0XHRcdFx0Zm9yICggaWhJZHggPSAwOyBpaElkeCA8IGluZGVwSG9sZXMubGVuZ3RoOyBpaElkeCsrICkge1xyXG5cdFx0XHRcdFx0Y2hrSG9sZSA9IGhvbGVzW2luZGVwSG9sZXNbaWhJZHhdXTtcclxuXHRcdFx0XHRcdGZvciAoIGhJZHggPSAwOyBoSWR4IDwgY2hrSG9sZS5sZW5ndGg7IGhJZHgrKyApIHtcclxuXHRcdFx0XHRcdFx0bmV4dElkeCA9IGhJZHgrMTsgbmV4dElkeCAlPSBjaGtIb2xlLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNoYXBlUHQsIGluSG9sZVB0LCBjaGtIb2xlW2hJZHhdLCBjaGtIb2xlW25leHRJZHhdLCB0cnVlICk7XHJcblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKVx0XHRyZXR1cm5cdHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVyblx0ZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXHJcblx0XHRcdFx0c2hhcGVQdCwgaG9sZVB0LFxyXG5cdFx0XHRcdGhvbGVJZHgsIGN1dEtleSwgZmFpbGVkQ3V0cyA9IFtdLFxyXG5cdFx0XHRcdHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxyXG5cdFx0XHRcdHRtcEhvbGUxLCB0bXBIb2xlMjtcclxuXHJcblx0XHRcdGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0aW5kZXBIb2xlcy5wdXNoKCBoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgY291bnRlciA9IGluZGVwSG9sZXMubGVuZ3RoICogMjtcclxuXHRcdFx0d2hpbGUgKCBpbmRlcEhvbGVzLmxlbmd0aCA+IDAgKSB7XHJcblx0XHRcdFx0Y291bnRlciAtLTtcclxuXHRcdFx0XHRpZiAoIGNvdW50ZXIgPCAwICkge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIFwiSW5maW5pdGUgTG9vcCEgSG9sZXMgbGVmdDpcIiArIGluZGVwSG9sZXMubGVuZ3RoICsgXCIsIFByb2JhYmx5IEhvbGUgb3V0c2lkZSBTaGFwZSFcIiApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBzZWFyY2ggZm9yIHNoYXBlLXZlcnRleCBhbmQgaG9sZS12ZXJ0ZXgsXHJcblx0XHRcdFx0Ly8gd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcclxuXHRcdFx0XHRmb3IgKCBzaGFwZUluZGV4ID0gMDsgc2hhcGVJbmRleCA8IHNoYXBlLmxlbmd0aDsgc2hhcGVJbmRleCsrICkge1xyXG5cclxuXHRcdFx0XHRcdHNoYXBlUHQgPSBzaGFwZVsgc2hhcGVJbmRleCBdO1xyXG5cdFx0XHRcdFx0aG9sZUluZGV4XHQ9IC0xO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNlYXJjaCBmb3IgaG9sZSB3aGljaCBjYW4gYmUgcmVhY2hlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcclxuXHRcdFx0XHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGluZGVwSG9sZXMubGVuZ3RoOyBoICsrICkge1xyXG5cdFx0XHRcdFx0XHRob2xlSWR4ID0gaW5kZXBIb2xlc1toXTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgbXVsdGlwbGUgY2hlY2tzXHJcblx0XHRcdFx0XHRcdGN1dEtleSA9IHNoYXBlUHQueCArIFwiOlwiICsgc2hhcGVQdC55ICsgXCI6XCIgKyBob2xlSWR4O1xyXG5cdFx0XHRcdFx0XHRpZiAoIGZhaWxlZEN1dHNbY3V0S2V5XSAhPT0gdW5kZWZpbmVkIClcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdGhvbGUgPSBob2xlc1tob2xlSWR4XTtcclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGgyID0gMDsgaDIgPCBob2xlLmxlbmd0aDsgaDIgKysgKSB7XHJcblx0XHRcdFx0XHRcdFx0aG9sZVB0ID0gaG9sZVsgaDIgXTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoISBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIHNoYXBlSW5kZXgsIGgyICkgKVx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdHNTaGFwZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzSG9sZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhvbGVJbmRleCA9IGgyO1xyXG5cdFx0XHRcdFx0XHRcdGluZGVwSG9sZXMuc3BsaWNlKGgsMSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRtcFNoYXBlMSA9IHNoYXBlLnNsaWNlKCAwLCBzaGFwZUluZGV4KzEgKTtcclxuXHRcdFx0XHRcdFx0XHR0bXBTaGFwZTIgPSBzaGFwZS5zbGljZSggc2hhcGVJbmRleCApO1xyXG5cdFx0XHRcdFx0XHRcdHRtcEhvbGUxID0gaG9sZS5zbGljZSggaG9sZUluZGV4ICk7XHJcblx0XHRcdFx0XHRcdFx0dG1wSG9sZTIgPSBob2xlLnNsaWNlKCAwLCBob2xlSW5kZXgrMSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzaGFwZSA9IHRtcFNoYXBlMS5jb25jYXQoIHRtcEhvbGUxICkuY29uY2F0KCB0bXBIb2xlMiApLmNvbmNhdCggdG1wU2hhcGUyICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIERlYnVnIG9ubHksIHRvIHNob3cgdGhlIHNlbGVjdGVkIGN1dHNcclxuXHRcdFx0XHRcdFx0XHQvLyBnbG9iX0N1dExpbmVzLnB1c2goIFsgc2hhcGVQdCwgaG9sZVB0IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcclxuXHJcblx0XHRcdFx0XHRcdGZhaWxlZEN1dHNbY3V0S2V5XSA9IHRydWU7XHRcdFx0Ly8gcmVtZW1iZXIgZmFpbHVyZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBzaGFwZTsgXHRcdFx0Lyogc2hhcGUgd2l0aCBubyBob2xlcyAqL1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR2YXIgaSwgaWwsIGYsIGZhY2UsXHJcblx0XHRcdGtleSwgaW5kZXgsXHJcblx0XHRcdGFsbFBvaW50c01hcCA9IHt9O1xyXG5cclxuXHRcdC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cclxuXHJcblx0XHR2YXIgYWxscG9pbnRzID0gY29udG91ci5jb25jYXQoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlc1toXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCBcImFsbHBvaW50c1wiLGFsbHBvaW50cywgYWxscG9pbnRzLmxlbmd0aCApO1xyXG5cclxuXHRcdC8vIHByZXBhcmUgYWxsIHBvaW50cyBtYXBcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBhbGxwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRrZXkgPSBhbGxwb2ludHNbIGkgXS54ICsgXCI6XCIgKyBhbGxwb2ludHNbIGkgXS55O1xyXG5cclxuXHRcdFx0aWYgKCBhbGxQb2ludHNNYXBbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCBcIkR1cGxpY2F0ZSBwb2ludFwiLCBrZXkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFsbFBvaW50c01hcFsga2V5IF0gPSBpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZW1vdmUgaG9sZXMgYnkgY3V0dGluZyBwYXRocyB0byBob2xlcyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlIHNoYXBlXHJcblx0XHR2YXIgc2hhcGVXaXRob3V0SG9sZXMgPSByZW1vdmVIb2xlcyggY29udG91ciwgaG9sZXMgKTtcclxuXHJcblx0XHR2YXIgdHJpYW5nbGVzID0gVEhSRUUuRm9udFV0aWxzLlRyaWFuZ3VsYXRlKCBzaGFwZVdpdGhvdXRIb2xlcywgZmFsc2UgKTsgLy8gVHJ1ZSByZXR1cm5zIGluZGljZXMgZm9yIHBvaW50cyBvZiBzcG9vbGVkIHNoYXBlXHJcblx0XHQvL2NvbnNvbGUubG9nKCBcInRyaWFuZ2xlc1wiLHRyaWFuZ2xlcywgdHJpYW5nbGVzLmxlbmd0aCApO1xyXG5cclxuXHRcdC8vIGNoZWNrIGFsbCBmYWNlIHZlcnRpY2VzIGFnYWluc3QgYWxsIHBvaW50cyBtYXBcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdHJpYW5nbGVzWyBpIF07XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMDsgZiA8IDM7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcclxuXHJcblx0XHRcdFx0aW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZVsgZiBdID0gaW5kZXg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRyaWFuZ2xlcy5jb25jYXQoKTtcclxuXHJcblx0fSxcclxuXHJcblx0aXNDbG9ja1dpc2U6IGZ1bmN0aW9uICggcHRzICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggcHRzICkgPCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cclxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXHJcblxyXG5cdC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xyXG5cclxuXHRiMnAwOiBmdW5jdGlvbiAoIHQsIHAgKSB7XHJcblxyXG5cdFx0dmFyIGsgPSAxIC0gdDtcclxuXHRcdHJldHVybiBrICogayAqIHA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGIycDE6IGZ1bmN0aW9uICggdCwgcCApIHtcclxuXHJcblx0XHRyZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiMnAyOiBmdW5jdGlvbiAoIHQsIHAgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHQgKiB0ICogcDtcclxuXHJcblx0fSxcclxuXHJcblx0YjI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5iMnAwKCB0LCBwMCApICsgdGhpcy5iMnAxKCB0LCBwMSApICsgdGhpcy5iMnAyKCB0LCBwMiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXHJcblxyXG5cdGIzcDA6IGZ1bmN0aW9uICggdCwgcCApIHtcclxuXHJcblx0XHR2YXIgayA9IDEgLSB0O1xyXG5cdFx0cmV0dXJuIGsgKiBrICogayAqIHA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGIzcDE6IGZ1bmN0aW9uICggdCwgcCApIHtcclxuXHJcblx0XHR2YXIgayA9IDEgLSB0O1xyXG5cdFx0cmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiM3AyOiBmdW5jdGlvbiAoIHQsIHAgKSB7XHJcblxyXG5cdFx0dmFyIGsgPSAxIC0gdDtcclxuXHRcdHJldHVybiAzICogayAqIHQgKiB0ICogcDtcclxuXHJcblx0fSxcclxuXHJcblx0YjNwMzogZnVuY3Rpb24gKCB0LCBwICkge1xyXG5cclxuXHRcdHJldHVybiB0ICogdCAqIHQgKiBwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiMzogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5iM3AwKCB0LCBwMCApICsgdGhpcy5iM3AxKCB0LCBwMSApICsgdGhpcy5iM3AyKCB0LCBwMiApICsgIHRoaXMuYjNwMyggdCwgcDMgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdExpbmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuTGluZUN1cnZlID0gZnVuY3Rpb24gKCB2MSwgdjIgKSB7XHJcblxyXG5cdHRoaXMudjEgPSB2MTtcclxuXHR0aGlzLnYyID0gdjI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIHBvaW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1Yih0aGlzLnYxKTtcclxuXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRyZXR1cm4gcG9pbnQ7XHJcblxyXG59O1xyXG5cclxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XHJcblxyXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1Yih0aGlzLnYxKTtcclxuXHJcblx0cmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFF1YWRyYXRpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHR0aGlzLnYwID0gdjA7XHJcblx0dGhpcy52MSA9IHYxO1xyXG5cdHRoaXMudjIgPSB2MjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuXHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciB0eCwgdHk7XHJcblxyXG5cdHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcclxuXHR0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICk7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0eCwgdHk7XHJcblxyXG5cdHR4ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xyXG5cdHR5ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xyXG5cclxuXHQvLyByZXR1cm5zIHVuaXQgdmVjdG9yXHJcblxyXG5cdHZhciB0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xyXG5cdHRhbmdlbnQubm9ybWFsaXplKCk7XHJcblxyXG5cdHJldHVybiB0YW5nZW50O1xyXG5cclxufTtcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdWJpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XHJcblxyXG5cdHRoaXMudjAgPSB2MDtcclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cdHRoaXMudjMgPSB2MztcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciB0eCwgdHk7XHJcblxyXG5cdHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xyXG5cdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcclxuXHJcblx0dmFyIHR4LCB0eTtcclxuXHJcblx0dHggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xyXG5cdHR5ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcclxuXHJcblx0dmFyIHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XHJcblx0dGFuZ2VudC5ub3JtYWxpemUoKTtcclxuXHJcblx0cmV0dXJuIHRhbmdlbnQ7XHJcblxyXG59O1xyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFNwbGluZSBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjIgKi8gKSB7XHJcblxyXG5cdHRoaXMucG9pbnRzID0gKHBvaW50cyA9PSB1bmRlZmluZWQpID8gW10gOiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgYyA9IFtdO1xyXG5cdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cywgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQ7XHJcblx0cG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xyXG5cclxuXHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcblx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0Y1sgMCBdID0gaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xyXG5cdGNbIDEgXSA9IGludFBvaW50O1xyXG5cdGNbIDIgXSA9IGludFBvaW50ICA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtMSA6IGludFBvaW50ICsgMTtcclxuXHRjWyAzIF0gPSBpbnRQb2ludCAgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLTEgOiBpbnRQb2ludCArIDI7XHJcblxyXG5cdHYueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludHNbIGNbIDAgXSBdLngsIHBvaW50c1sgY1sgMSBdIF0ueCwgcG9pbnRzWyBjWyAyIF0gXS54LCBwb2ludHNbIGNbIDMgXSBdLngsIHdlaWdodCApO1xyXG5cdHYueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludHNbIGNbIDAgXSBdLnksIHBvaW50c1sgY1sgMSBdIF0ueSwgcG9pbnRzWyBjWyAyIF0gXS55LCBwb2ludHNbIGNbIDMgXSBdLnksIHdlaWdodCApO1xyXG5cclxuXHRyZXR1cm4gdjtcclxuXHJcbn07XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0RWxsaXBzZSBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5FbGxpcHNlQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0dGhpcy5hWCA9IGFYO1xyXG5cdHRoaXMuYVkgPSBhWTtcclxuXHJcblx0dGhpcy54UmFkaXVzID0geFJhZGl1cztcclxuXHR0aGlzLnlSYWRpdXMgPSB5UmFkaXVzO1xyXG5cclxuXHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XHJcblx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XHJcblxyXG5cdHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIGFuZ2xlO1xyXG5cdHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xyXG5cclxuXHRpZiAoIGRlbHRhQW5nbGUgPCAwICkgZGVsdGFBbmdsZSArPSBNYXRoLlBJICogMjtcclxuXHRpZiAoIGRlbHRhQW5nbGUgPiBNYXRoLlBJICogMiApIGRlbHRhQW5nbGUgLT0gTWF0aC5QSSAqIDI7XHJcblxyXG5cdGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICkge1xyXG5cclxuXHRcdGFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgKyAoIDEgLSB0ICkgKiAoIE1hdGguUEkgKiAyIC0gZGVsdGFBbmdsZSApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciB0eCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcclxuXHR2YXIgdHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XHJcblxyXG59O1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRBcmMgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQXJjQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0VEhSRUUuRWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG59O1xyXG5cclxuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSApO1xyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdExpbmUzRFxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5MaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRmdW5jdGlvbiAoIHYxLCB2MiApIHtcclxuXHJcblx0XHR0aGlzLnYxID0gdjE7XHJcblx0XHR0aGlzLnYyID0gdjI7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHR2YXIgciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cclxuXHRcdHIuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApOyAvLyBkaWZmXHJcblx0XHRyLm11bHRpcGx5U2NhbGFyKCB0ICk7XHJcblx0XHRyLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRcdHJldHVybiByO1xyXG5cclxuXHR9XHJcblxyXG4pO1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcblx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciB0eCwgdHksIHR6O1xyXG5cclxuXHRcdHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcclxuXHRcdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcclxuXHRcdHR6ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnogKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdWJpYyBCZXppZXIgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XHJcblxyXG5cdFx0dGhpcy52MCA9IHYwO1xyXG5cdFx0dGhpcy52MSA9IHYxO1xyXG5cdFx0dGhpcy52MiA9IHYyO1xyXG5cdFx0dGhpcy52MyA9IHYzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0dmFyIHR4LCB0eSwgdHo7XHJcblxyXG5cdFx0dHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XHJcblx0XHR0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcclxuXHRcdHR6ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnosIHRoaXMudjMueiApO1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdHgsIHR5LCB0eiApO1xyXG5cclxuXHR9XHJcblxyXG4pO1xyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFNwbGluZSAzRCBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IzICovKSB7XHJcblxyXG5cdFx0dGhpcy5wb2ludHMgPSAocG9pbnRzID09IHVuZGVmaW5lZCkgPyBbXSA6IHBvaW50cztcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBjID0gW107XHJcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsIHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0O1xyXG5cdFx0cG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xyXG5cclxuXHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0Y1sgMCBdID0gaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xyXG5cdFx0Y1sgMSBdID0gaW50UG9pbnQ7XHJcblx0XHRjWyAyIF0gPSBpbnRQb2ludCAgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxO1xyXG5cdFx0Y1sgMyBdID0gaW50UG9pbnQgID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcclxuXHJcblx0XHR2YXIgcHQwID0gcG9pbnRzWyBjWzBdIF0sXHJcblx0XHRcdHB0MSA9IHBvaW50c1sgY1sxXSBdLFxyXG5cdFx0XHRwdDIgPSBwb2ludHNbIGNbMl0gXSxcclxuXHRcdFx0cHQzID0gcG9pbnRzWyBjWzNdIF07XHJcblxyXG5cdFx0di54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUocHQwLngsIHB0MS54LCBwdDIueCwgcHQzLngsIHdlaWdodCk7XHJcblx0XHR2LnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZShwdDAueSwgcHQxLnksIHB0Mi55LCBwdDMueSwgd2VpZ2h0KTtcclxuXHRcdHYueiA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKHB0MC56LCBwdDEueiwgcHQyLnosIHB0My56LCB3ZWlnaHQpO1xyXG5cclxuXHRcdHJldHVybiB2O1xyXG5cclxuXHR9XHJcblxyXG4pO1xyXG5cclxuXHJcbi8vIFRIUkVFLlNwbGluZUN1cnZlMy5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKHQpIHtcclxuLy8gXHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuLy8gXHRcdHZhciBjID0gW107XHJcbi8vIFx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsIHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0O1xyXG4vLyBcdFx0cG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xyXG5cclxuLy8gXHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuLy8gXHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG4vLyBcdFx0Y1sgMCBdID0gaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xyXG4vLyBcdFx0Y1sgMSBdID0gaW50UG9pbnQ7XHJcbi8vIFx0XHRjWyAyIF0gPSBpbnRQb2ludCAgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxO1xyXG4vLyBcdFx0Y1sgMyBdID0gaW50UG9pbnQgID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcclxuXHJcbi8vIFx0XHR2YXIgcHQwID0gcG9pbnRzWyBjWzBdIF0sXHJcbi8vIFx0XHRcdHB0MSA9IHBvaW50c1sgY1sxXSBdLFxyXG4vLyBcdFx0XHRwdDIgPSBwb2ludHNbIGNbMl0gXSxcclxuLy8gXHRcdFx0cHQzID0gcG9pbnRzWyBjWzNdIF07XHJcblxyXG4vLyBcdC8vIHQgPSB3ZWlnaHQ7XHJcbi8vIFx0di54ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFNwbGluZSggdCwgcHQwLngsIHB0MS54LCBwdDIueCwgcHQzLnggKTtcclxuLy8gXHR2LnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50U3BsaW5lKCB0LCBwdDAueSwgcHQxLnksIHB0Mi55LCBwdDMueSApO1xyXG4vLyBcdHYueiA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRTcGxpbmUoIHQsIHB0MC56LCBwdDEueiwgcHQyLnosIHB0My56ICk7XHJcblxyXG4vLyBcdHJldHVybiB2O1xyXG5cclxuLy8gfVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcblx0ZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLykge1xyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gKHBvaW50cyA9PSB1bmRlZmluZWQpID8gW10gOiBwb2ludHM7XHJcblxyXG5cdH0sXHJcblxyXG4gICAgZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIGMgPSBbXTtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsIHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0O1xyXG4gICAgICAgIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMCApICogdDtcclxuICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBmcm9tIDAtbGVuZ3RoICsxXHJcblxyXG4gICAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuICAgICAgICB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuICAgICAgICBpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKCBNYXRoLmZsb29yKCBNYXRoLmFicyggaW50UG9pbnQgKSAvIHBvaW50cy5sZW5ndGggKSArIDEgKSAqIHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgY1sgMCBdID0gKCBpbnRQb2ludCAtIDEgKSAlIHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgY1sgMSBdID0gKCBpbnRQb2ludCApICUgcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBjWyAyIF0gPSAoIGludFBvaW50ICsgMSApICUgcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBjWyAzIF0gPSAoIGludFBvaW50ICsgMiApICUgcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgdi54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50c1sgY1sgMCBdIF0ueCwgcG9pbnRzWyBjWyAxIF0gXS54LCBwb2ludHNbIGNbIDIgXSBdLngsIHBvaW50c1sgY1sgMyBdIF0ueCwgd2VpZ2h0ICk7XHJcbiAgICAgICAgdi55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50c1sgY1sgMCBdIF0ueSwgcG9pbnRzWyBjWyAxIF0gXS55LCBwb2ludHNbIGNbIDIgXSBdLnksIHBvaW50c1sgY1sgMyBdIF0ueSwgd2VpZ2h0ICk7XHJcbiAgICAgICAgdi56ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50c1sgY1sgMCBdIF0ueiwgcG9pbnRzWyBjWyAxIF0gXS56LCBwb2ludHNbIGNbIDIgXSBdLnosIHBvaW50c1sgY1sgMyBdIF0ueiwgd2VpZ2h0ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB2O1xyXG5cclxuICAgIH1cclxuXHJcbik7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKi9cclxuXHJcblRIUkVFLkFuaW1hdGlvbkhhbmRsZXIgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBwbGF5aW5nID0gW107XHJcblx0dmFyIGxpYnJhcnkgPSB7fTtcclxuXHR2YXIgdGhhdCAgICA9IHt9O1xyXG5cclxuXHJcblx0Ly8tLS0gdXBkYXRlIC0tLVxyXG5cclxuXHR0aGF0LnVwZGF0ZSA9IGZ1bmN0aW9uKCBkZWx0YVRpbWVNUyApIHtcclxuXHJcblx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHBsYXlpbmcubGVuZ3RoOyBpICsrIClcclxuXHRcdFx0cGxheWluZ1sgaSBdLnVwZGF0ZSggZGVsdGFUaW1lTVMgKTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8vLS0tIGFkZCAtLS1cclxuXHJcblx0dGhhdC5hZGRUb1VwZGF0ZSA9IGZ1bmN0aW9uKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0aWYgKCBwbGF5aW5nLmluZGV4T2YoIGFuaW1hdGlvbiApID09PSAtMSApXHJcblx0XHRcdHBsYXlpbmcucHVzaCggYW5pbWF0aW9uICk7XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvLy0tLSByZW1vdmUgLS0tXHJcblxyXG5cdHRoYXQucmVtb3ZlRnJvbVVwZGF0ZSA9IGZ1bmN0aW9uKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gcGxheWluZy5pbmRleE9mKCBhbmltYXRpb24gKTtcclxuXHJcblx0XHRpZiggaW5kZXggIT09IC0xIClcclxuXHRcdFx0cGxheWluZy5zcGxpY2UoIGluZGV4LCAxICk7XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvLy0tLSBhZGQgLS0tXHJcblxyXG5cdHRoYXQuYWRkID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcblxyXG5cdFx0aWYgKCBsaWJyYXJ5WyBkYXRhLm5hbWUgXSAhPT0gdW5kZWZpbmVkIClcclxuXHRcdFx0VEhSRUUub253YXJuaW5nKCBcIlRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkOiBXYXJuaW5nISBcIiArIGRhdGEubmFtZSArIFwiIGFscmVhZHkgZXhpc3RzIGluIGxpYnJhcnkuIE92ZXJ3cml0aW5nLlwiICk7XHJcblxyXG5cdFx0bGlicmFyeVsgZGF0YS5uYW1lIF0gPSBkYXRhO1xyXG5cdFx0aW5pdERhdGEoIGRhdGEgKTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8vLS0tIGdldCAtLS1cclxuXHJcblx0dGhhdC5nZXQgPSBmdW5jdGlvbiggbmFtZSApIHtcclxuXHJcblx0XHRpZiAoIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICkge1xyXG5cclxuXHRcdFx0aWYgKCBsaWJyYXJ5WyBuYW1lIF0gKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBsaWJyYXJ5WyBuYW1lIF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRUSFJFRS5vbndhcm5pbmcoIFwiVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQ6IENvdWxkbid0IGZpbmQgYW5pbWF0aW9uIFwiICsgbmFtZSApO1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyB0b2RvOiBhZGQgc2ltcGxlIHR3ZWVuIGxpYnJhcnlcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vLS0tIHBhcnNlIC0tLVxyXG5cclxuXHR0aGF0LnBhcnNlID0gZnVuY3Rpb24oIHJvb3QgKSB7XHJcblxyXG5cdFx0Ly8gc2V0dXAgaGllcmFyY2h5XHJcblxyXG5cdFx0dmFyIGhpZXJhcmNoeSA9IFtdO1xyXG5cclxuXHRcdGlmICggcm9vdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xyXG5cclxuXHRcdFx0Zm9yKCB2YXIgYiA9IDA7IGIgPCByb290LmJvbmVzLmxlbmd0aDsgYisrICkge1xyXG5cclxuXHRcdFx0XHRoaWVyYXJjaHkucHVzaCggcm9vdC5ib25lc1sgYiBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHBhcnNlUmVjdXJzZUhpZXJhcmNoeSggcm9vdCwgaGllcmFyY2h5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoaWVyYXJjaHk7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkgPSBmdW5jdGlvbiggcm9vdCwgaGllcmFyY2h5ICkge1xyXG5cclxuXHRcdGhpZXJhcmNoeS5wdXNoKCByb290ICk7XHJcblxyXG5cdFx0Zm9yKCB2YXIgYyA9IDA7IGMgPCByb290LmNoaWxkcmVuLmxlbmd0aDsgYysrIClcclxuXHRcdFx0cGFyc2VSZWN1cnNlSGllcmFyY2h5KCByb290LmNoaWxkcmVuWyBjIF0sIGhpZXJhcmNoeSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLy0tLSBpbml0IGRhdGEgLS0tXHJcblxyXG5cdHZhciBpbml0RGF0YSA9IGZ1bmN0aW9uKCBkYXRhICkge1xyXG5cclxuXHRcdGlmKCBkYXRhLmluaXRpYWxpemVkID09PSB0cnVlIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHJcblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIGtleXNcclxuXHJcblx0XHRmb3IoIHZhciBoID0gMDsgaCA8IGRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCArKyApIHtcclxuXHJcblx0XHRcdGZvciggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gcmVtb3ZlIG1pbnVzIHRpbWVzXHJcblxyXG5cdFx0XHRcdGlmKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lIDwgMCApXHJcblx0XHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID0gMDtcclxuXHJcblxyXG5cdFx0XHRcdC8vIGNyZWF0ZSBxdWF0ZXJuaW9uc1xyXG5cclxuXHRcdFx0XHRpZiggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90ICE9PSB1bmRlZmluZWQgJiZcclxuXHRcdFx0XHQgISggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90IGluc3RhbmNlb2YgVEhSRUUuUXVhdGVybmlvbiApICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBxdWF0ID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90O1xyXG5cdFx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oIHF1YXRbMF0sIHF1YXRbMV0sIHF1YXRbMl0sIHF1YXRbM10gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIHByZXBhcmUgbW9ycGggdGFyZ2V0IGtleXNcclxuXHJcblx0XHRcdGlmKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoICYmIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBnZXQgYWxsIHVzZWRcclxuXHJcblx0XHRcdFx0dmFyIHVzZWRNb3JwaFRhcmdldHMgPSB7fTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7IG0gPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0TmFtZSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdO1xyXG5cdFx0XHRcdFx0XHR1c2VkTW9ycGhUYXJnZXRzWyBtb3JwaFRhcmdldE5hbWUgXSA9IC0xO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLnVzZWRNb3JwaFRhcmdldHMgPSB1c2VkTW9ycGhUYXJnZXRzO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gc2V0IGFsbCB1c2VkIG9uIGFsbCBmcmFtZXNcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgaW5mbHVlbmNlcyA9IHt9O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gdXNlZE1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF0gPT09IG1vcnBoVGFyZ2V0TmFtZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXNbIG0gXTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG0gPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGluZmx1ZW5jZXNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzSW5mbHVlbmNlcyA9IGluZmx1ZW5jZXM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHQvLyByZW1vdmUgYWxsIGtleXMgdGhhdCBhcmUgb24gdGhlIHNhbWUgdGltZVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGsgPSAxOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID09PSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgLSAxIF0udGltZSApIHtcclxuXHJcblx0XHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMuc3BsaWNlKCBrLCAxICk7XHJcblx0XHRcdFx0XHRrIC0tO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Ly8gc2V0IGluZGV4XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5pbmRleCA9IGs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbmVcclxuXHJcblx0XHRkYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8vIGludGVycG9sYXRpb24gdHlwZXNcclxuXHJcblx0dGhhdC5MSU5FQVIgPSAwO1xyXG5cdHRoYXQuQ0FUTVVMTFJPTSA9IDE7XHJcblx0dGhhdC5DQVRNVUxMUk9NX0ZPUldBUkQgPSAyO1xyXG5cclxuXHRyZXR1cm4gdGhhdDtcclxuXHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BbmltYXRpb24gPSBmdW5jdGlvbiAoIHJvb3QsIG5hbWUgKSB7XHJcblxyXG5cdHRoaXMucm9vdCA9IHJvb3Q7XHJcblx0dGhpcy5kYXRhID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQoIG5hbWUgKTtcclxuXHR0aGlzLmhpZXJhcmNoeSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGFyc2UoIHJvb3QgKTtcclxuXHJcblx0dGhpcy5jdXJyZW50VGltZSA9IDA7XHJcblx0dGhpcy50aW1lU2NhbGUgPSAxO1xyXG5cclxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cdHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xyXG5cdHRoaXMubG9vcCA9IHRydWU7XHJcblxyXG5cdHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkxJTkVBUjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoIHN0YXJ0VGltZSApIHtcclxuXHJcblx0dGhpcy5jdXJyZW50VGltZSA9IHN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkID8gc3RhcnRUaW1lIDogMDtcclxuXHJcblx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMucmVzZXQoKTtcclxuXHRcdHRoaXMudXBkYXRlKCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG5cclxuXHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZFRvVXBkYXRlKCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0aWYgKCB0aGlzLmlzUGF1c2VkID09PSB0cnVlICkge1xyXG5cclxuXHRcdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkVG9VcGRhdGUoIHRoaXMgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZUZyb21VcGRhdGUoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmlzUGF1c2VkID0gIXRoaXMuaXNQYXVzZWQ7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cdHRoaXMuaXNQYXVzZWQgID0gZmFsc2U7XHJcblx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5yZW1vdmVGcm9tVXBkYXRlKCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Zm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xyXG5cclxuXHRcdG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5hbmltYXRpb25DYWNoZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlID0ge307XHJcblx0XHRcdG9iamVjdC5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0geyBwb3M6IDAsIHJvdDogMCwgc2NsOiAwIH07XHJcblx0XHRcdG9iamVjdC5hbmltYXRpb25DYWNoZS5uZXh0S2V5ID0geyBwb3M6IDAsIHJvdDogMCwgc2NsOiAwIH07XHJcblx0XHRcdG9iamVjdC5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeCA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgPyBvYmplY3Quc2tpbk1hdHJpeCA6IG9iamVjdC5tYXRyaXg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmV2S2V5ID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlLnByZXZLZXk7XHJcblx0XHR2YXIgbmV4dEtleSA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5uZXh0S2V5O1xyXG5cclxuXHRcdHByZXZLZXkucG9zID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcclxuXHRcdHByZXZLZXkucm90ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcclxuXHRcdHByZXZLZXkuc2NsID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcclxuXHJcblx0XHRuZXh0S2V5LnBvcyA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIFwicG9zXCIsIGgsIDEgKTtcclxuXHRcdG5leHRLZXkucm90ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggXCJyb3RcIiwgaCwgMSApO1xyXG5cdFx0bmV4dEtleS5zY2wgPSB0aGlzLmdldE5leHRLZXlXaXRoKCBcInNjbFwiLCBoLCAxICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS51cGRhdGUgPSAoZnVuY3Rpb24oKXtcclxuXHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cdHZhciB0YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFxyXG5cdC8vIENhdG11bGwtUm9tIHNwbGluZVxyXG5cclxuXHR2YXIgaW50ZXJwb2xhdGVDYXRtdWxsUm9tID0gZnVuY3Rpb24gKCBwb2ludHMsIHNjYWxlICkge1xyXG5cclxuXHRcdHZhciBjID0gW10sIHYzID0gW10sXHJcblx0XHRwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgdzIsIHczLFxyXG5cdFx0cGEsIHBiLCBwYywgcGQ7XHJcblx0XHJcblx0XHRwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHNjYWxlO1xyXG5cdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHRcclxuXHRcdGNbIDAgXSA9IGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XHJcblx0XHRjWyAxIF0gPSBpbnRQb2ludDtcclxuXHRcdGNbIDIgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMTtcclxuXHRcdGNbIDMgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMjtcclxuXHRcclxuXHRcdHBhID0gcG9pbnRzWyBjWyAwIF0gXTtcclxuXHRcdHBiID0gcG9pbnRzWyBjWyAxIF0gXTtcclxuXHRcdHBjID0gcG9pbnRzWyBjWyAyIF0gXTtcclxuXHRcdHBkID0gcG9pbnRzWyBjWyAzIF0gXTtcclxuXHRcclxuXHRcdHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xyXG5cdFx0dzMgPSB3ZWlnaHQgKiB3MjtcclxuXHRcclxuXHRcdHYzWyAwIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDAgXSwgcGJbIDAgXSwgcGNbIDAgXSwgcGRbIDAgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcclxuXHRcdHYzWyAxIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDEgXSwgcGJbIDEgXSwgcGNbIDEgXSwgcGRbIDEgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcclxuXHRcdHYzWyAyIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDIgXSwgcGJbIDIgXSwgcGNbIDIgXSwgcGRbIDIgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcclxuXHRcclxuXHRcdHJldHVybiB2MztcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzICkge1xyXG5cdFxyXG5cdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXHJcblx0XHRcdHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblx0XHJcblx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcclxuXHRcclxuXHR9O1xyXG5cdFxyXG5cdHJldHVybiBmdW5jdGlvbiAoIGRlbHRhICkge1xyXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XHJcblx0XHJcblx0XHR0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XHJcblx0XHJcblx0XHQvL1xyXG5cdFxyXG5cdFx0dmFyIHZlY3RvcjtcclxuXHRcdHZhciB0eXBlcyA9IFsgXCJwb3NcIiwgXCJyb3RcIiwgXCJzY2xcIiBdO1xyXG5cdFxyXG5cdFx0dmFyIGR1cmF0aW9uID0gdGhpcy5kYXRhLmxlbmd0aDtcclxuXHRcclxuXHRcdGlmICggdGhpcy5sb29wID09PSB0cnVlICYmIHRoaXMuY3VycmVudFRpbWUgPiBkdXJhdGlvbiApIHtcclxuXHRcclxuXHRcdFx0dGhpcy5jdXJyZW50VGltZSAlPSBkdXJhdGlvbjtcclxuXHRcdFx0dGhpcy5yZXNldCgpO1xyXG5cdFxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy5sb29wID09PSBmYWxzZSAmJiB0aGlzLmN1cnJlbnRUaW1lID4gZHVyYXRpb24gKSB7XHJcblx0XHJcblx0XHRcdHRoaXMuc3RvcCgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHJcblx0XHR9XHJcblx0XHJcblx0XHR0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5taW4oIHRoaXMuY3VycmVudFRpbWUsIGR1cmF0aW9uICk7XHJcblx0XHJcblx0XHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblx0XHJcblx0XHRcdHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xyXG5cdFx0XHR2YXIgYW5pbWF0aW9uQ2FjaGUgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGU7XHJcblx0XHJcblx0XHRcdC8vIGxvb3AgdGhyb3VnaCBwb3Mvcm90L3NjbFxyXG5cdFxyXG5cdFx0XHRmb3IgKCB2YXIgdCA9IDA7IHQgPCAzOyB0ICsrICkge1xyXG5cdFxyXG5cdFx0XHRcdC8vIGdldCBrZXlzXHJcblx0XHJcblx0XHRcdFx0dmFyIHR5cGUgICAgPSB0eXBlc1sgdCBdO1xyXG5cdFx0XHRcdHZhciBwcmV2S2V5ID0gYW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdO1xyXG5cdFx0XHRcdHZhciBuZXh0S2V5ID0gYW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdO1xyXG5cdFxyXG5cdFx0XHRcdGlmICggbmV4dEtleS50aW1lIDw9IHRoaXMuY3VycmVudFRpbWUgKSB7XHJcblx0XHJcblx0XHRcdFx0XHRwcmV2S2V5ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcclxuXHRcdFx0XHRcdG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCAxICk7XHJcblx0XHJcblx0XHRcdFx0XHR3aGlsZSAoIG5leHRLZXkudGltZSA8IHRoaXMuY3VycmVudFRpbWUgJiYgbmV4dEtleS5pbmRleCA+IHByZXZLZXkuaW5kZXggKSB7XHJcblx0XHJcblx0XHRcdFx0XHRcdHByZXZLZXkgPSBuZXh0S2V5O1xyXG5cdFx0XHRcdFx0XHRuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgbmV4dEtleS5pbmRleCArIDEgKTtcclxuXHRcclxuXHRcdFx0XHRcdH1cclxuXHRcclxuXHRcdFx0XHRcdGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXSA9IHByZXZLZXk7XHJcblx0XHRcdFx0XHRhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF0gPSBuZXh0S2V5O1xyXG5cdFxyXG5cdFx0XHRcdH1cclxuXHRcclxuXHRcdFx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0b2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFxyXG5cdFx0XHRcdHZhciBzY2FsZSA9ICggdGhpcy5jdXJyZW50VGltZSAtIHByZXZLZXkudGltZSApIC8gKCBuZXh0S2V5LnRpbWUgLSBwcmV2S2V5LnRpbWUgKTtcclxuXHRcclxuXHRcdFx0XHR2YXIgcHJldlhZWiA9IHByZXZLZXlbIHR5cGUgXTtcclxuXHRcdFx0XHR2YXIgbmV4dFhZWiA9IG5leHRLZXlbIHR5cGUgXTtcclxuXHRcclxuXHRcdFx0XHRpZiAoIHNjYWxlIDwgMCApIHNjYWxlID0gMDtcclxuXHRcdFx0XHRpZiAoIHNjYWxlID4gMSApIHNjYWxlID0gMTtcclxuXHRcclxuXHRcdFx0XHQvLyBpbnRlcnBvbGF0ZVxyXG5cdFxyXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJwb3NcIiApIHtcclxuXHRcclxuXHRcdFx0XHRcdHZlY3RvciA9IG9iamVjdC5wb3NpdGlvbjtcclxuXHRcclxuXHRcdFx0XHRcdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5MSU5FQVIgKSB7XHJcblx0XHJcblx0XHRcdFx0XHRcdHZlY3Rvci54ID0gcHJldlhZWlsgMCBdICsgKCBuZXh0WFlaWyAwIF0gLSBwcmV2WFlaWyAwIF0gKSAqIHNjYWxlO1xyXG5cdFx0XHRcdFx0XHR2ZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcclxuXHRcdFx0XHRcdFx0dmVjdG9yLnogPSBwcmV2WFlaWyAyIF0gKyAoIG5leHRYWVpbIDIgXSAtIHByZXZYWVpbIDIgXSApICogc2NhbGU7XHJcblx0XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcclxuXHRcdFx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XHJcblx0XHJcblx0XHRcdFx0XHRcdHBvaW50c1sgMCBdID0gdGhpcy5nZXRQcmV2S2V5V2l0aCggXCJwb3NcIiwgaCwgcHJldktleS5pbmRleCAtIDEgKVsgXCJwb3NcIiBdO1xyXG5cdFx0XHRcdFx0XHRwb2ludHNbIDEgXSA9IHByZXZYWVo7XHJcblx0XHRcdFx0XHRcdHBvaW50c1sgMiBdID0gbmV4dFhZWjtcclxuXHRcdFx0XHRcdFx0cG9pbnRzWyAzIF0gPSB0aGlzLmdldE5leHRLZXlXaXRoKCBcInBvc1wiLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApWyBcInBvc1wiIF07XHJcblx0XHJcblx0XHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgKiAwLjMzICsgMC4zMztcclxuXHRcclxuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRQb2ludCA9IGludGVycG9sYXRlQ2F0bXVsbFJvbSggcG9pbnRzLCBzY2FsZSApO1xyXG5cdFxyXG5cdFx0XHRcdFx0XHR2ZWN0b3IueCA9IGN1cnJlbnRQb2ludFsgMCBdO1xyXG5cdFx0XHRcdFx0XHR2ZWN0b3IueSA9IGN1cnJlbnRQb2ludFsgMSBdO1xyXG5cdFx0XHRcdFx0XHR2ZWN0b3IueiA9IGN1cnJlbnRQb2ludFsgMiBdO1xyXG5cdFxyXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xyXG5cdFxyXG5cdFx0XHRcdFx0XHRcdHZhciBmb3J3YXJkUG9pbnQgPSBpbnRlcnBvbGF0ZUNhdG11bGxSb20oIHBvaW50cywgc2NhbGUgKiAxLjAxICk7XHJcblx0XHJcblx0XHRcdFx0XHRcdFx0dGFyZ2V0LnNldCggZm9yd2FyZFBvaW50WyAwIF0sIGZvcndhcmRQb2ludFsgMSBdLCBmb3J3YXJkUG9pbnRbIDIgXSApO1xyXG5cdFx0XHRcdFx0XHRcdHRhcmdldC5zdWIoIHZlY3RvciApO1xyXG5cdFx0XHRcdFx0XHRcdHRhcmdldC55ID0gMDtcclxuXHRcdFx0XHRcdFx0XHR0YXJnZXQubm9ybWFsaXplKCk7XHJcblx0XHJcblx0XHRcdFx0XHRcdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMiggdGFyZ2V0LngsIHRhcmdldC56ICk7XHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnJvdGF0aW9uLnNldCggMCwgYW5nbGUsIDAgKTtcclxuXHRcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFxyXG5cdFx0XHRcdFx0fVxyXG5cdFxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwicm90XCIgKSB7XHJcblx0XHJcblx0XHRcdFx0XHRUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwKCBwcmV2WFlaLCBuZXh0WFlaLCBvYmplY3QucXVhdGVybmlvbiwgc2NhbGUgKTtcclxuXHRcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcInNjbFwiICkge1xyXG5cdFxyXG5cdFx0XHRcdFx0dmVjdG9yID0gb2JqZWN0LnNjYWxlO1xyXG5cdFxyXG5cdFx0XHRcdFx0dmVjdG9yLnggPSBwcmV2WFlaWyAwIF0gKyAoIG5leHRYWVpbIDAgXSAtIHByZXZYWVpbIDAgXSApICogc2NhbGU7XHJcblx0XHRcdFx0XHR2ZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcclxuXHRcdFx0XHRcdHZlY3Rvci56ID0gcHJldlhZWlsgMiBdICsgKCBuZXh0WFlaWyAyIF0gLSBwcmV2WFlaWyAyIF0gKSAqIHNjYWxlO1xyXG5cdFxyXG5cdFx0XHRcdH1cclxuXHRcclxuXHRcdFx0fVxyXG5cdFxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufSkoKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBHZXQgbmV4dCBrZXkgd2l0aFxyXG5cclxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5nZXROZXh0S2V5V2l0aCA9IGZ1bmN0aW9uICggdHlwZSwgaCwga2V5ICkge1xyXG5cclxuXHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xyXG5cclxuXHRpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxyXG5cdFx0IHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xyXG5cclxuXHRcdGtleSA9IGtleSA8IGtleXMubGVuZ3RoIC0gMSA/IGtleSA6IGtleXMubGVuZ3RoIC0gMTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCA7IGtleSA8IGtleXMubGVuZ3RoOyBrZXkrKyApIHtcclxuXHJcblx0XHRpZiAoIGtleXNbIGtleSBdWyB0eXBlIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBrZXlzWyBrZXkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHByZXZpb3VzIGtleSB3aXRoXHJcblxyXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLmdldFByZXZLZXlXaXRoID0gZnVuY3Rpb24gKCB0eXBlLCBoLCBrZXkgKSB7XHJcblxyXG5cdHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XHJcblxyXG5cdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NIHx8XHJcblx0XHR0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcclxuXHJcblx0XHRrZXkgPSBrZXkgPiAwID8ga2V5IDogMDtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHRmb3IgKCA7IGtleSA+PSAwOyBrZXkgLS0gKSB7XHJcblxyXG5cdFx0aWYgKCBrZXlzWyBrZXkgXVsgdHlwZSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4ga2V5c1sga2V5IF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sga2V5cy5sZW5ndGggLSAxIF07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3Iga2hhbmcgZHVvbmdcclxuICogQGF1dGhvciBlcmlrIGtpdHNvblxyXG4gKi9cclxuXHJcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uID0gZnVuY3Rpb24gKCByb290LCBkYXRhICkge1xyXG5cclxuXHR0aGlzLnJvb3QgPSByb290O1xyXG5cdHRoaXMuZGF0YSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuZ2V0KCBkYXRhICk7XHJcblx0dGhpcy5oaWVyYXJjaHkgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKCByb290ICk7XHJcblx0dGhpcy5jdXJyZW50VGltZSA9IDA7XHJcblx0dGhpcy50aW1lU2NhbGUgPSAwLjAwMTtcclxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cdHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xyXG5cdHRoaXMubG9vcCA9IHRydWU7XHJcblxyXG5cdC8vIGluaXRpYWxpemUgdG8gZmlyc3Qga2V5ZnJhbWVzXHJcblxyXG5cdGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0ua2V5cyxcclxuXHRcdFx0c2lkcyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0uc2lkcyxcclxuXHRcdFx0b2JqID0gdGhpcy5oaWVyYXJjaHlbaF07XHJcblxyXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCAmJiBzaWRzICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2lkcy5sZW5ndGg7IHMrKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNpZCA9IHNpZHNbIHMgXSxcclxuXHRcdFx0XHRcdG5leHQgPSB0aGlzLmdldE5leHRLZXlXaXRoKCBzaWQsIGgsIDAgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBuZXh0ICkge1xyXG5cclxuXHRcdFx0XHRcdG5leHQuYXBwbHkoIHNpZCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvYmoubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmRhdGEuaGllcmFyY2h5W2hdLm5vZGUudXBkYXRlTWF0cml4KCk7XHJcblx0XHRcdG9iai5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBQbGF5XHJcblxyXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICggc3RhcnRUaW1lICkge1xyXG5cclxuXHR0aGlzLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgPyBzdGFydFRpbWUgOiAwO1xyXG5cclxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHtcclxuXHJcblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcblxyXG5cdFx0Ly8gcmVzZXQga2V5IGNhY2hlXHJcblxyXG5cdFx0dmFyIGgsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoLFxyXG5cdFx0XHRvYmplY3QsXHJcblx0XHRcdG5vZGU7XHJcblxyXG5cdFx0Zm9yICggaCA9IDA7IGggPCBobDsgaCsrICkge1xyXG5cclxuXHRcdFx0b2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcclxuXHRcdFx0bm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcclxuXHJcblx0XHRcdGlmICggbm9kZS5hbmltYXRpb25DYWNoZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlID0ge307XHJcblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0gbnVsbDtcclxuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBudWxsO1xyXG5cdFx0XHRcdG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXggPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lID8gb2JqZWN0LnNraW5NYXRyaXggOiBvYmplY3QubWF0cml4O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLmtleXM7XHJcblxyXG5cdFx0XHRpZiAoa2V5cy5sZW5ndGgpIHtcclxuXHJcblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0ga2V5c1sgMCBdO1xyXG5cdFx0XHRcdG5vZGUuYW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IGtleXNbIDEgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbigga2V5c1swXS50aW1lLCB0aGlzLnN0YXJ0VGltZSApO1xyXG5cdFx0XHRcdHRoaXMuZW5kVGltZSA9IE1hdGgubWF4KCBrZXlzW2tleXMubGVuZ3RoIC0gMV0udGltZSwgdGhpcy5lbmRUaW1lICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudXBkYXRlKCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG5cclxuXHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZFRvVXBkYXRlKCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBQYXVzZVxyXG5cclxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdGlmKCB0aGlzLmlzUGF1c2VkICkge1xyXG5cclxuXHRcdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkVG9VcGRhdGUoIHRoaXMgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZUZyb21VcGRhdGUoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmlzUGF1c2VkID0gIXRoaXMuaXNQYXVzZWQ7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIFN0b3BcclxuXHJcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblx0dGhpcy5pc1BhdXNlZCAgPSBmYWxzZTtcclxuXHJcblx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5yZW1vdmVGcm9tVXBkYXRlKCB0aGlzICk7XHJcblxyXG5cdC8vIHJlc2V0IEpJVCBtYXRyaXggYW5kIHJlbW92ZSBjYWNoZVxyXG5cclxuXHRmb3IgKCB2YXIgaCA9IDA7IGggPCB0aGlzLmRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCsrICkge1xyXG4gICAgICAgIFxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuaGllcmFyY2h5WyBoIF07XHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcclxuXHJcblx0XHRpZiAoIG5vZGUuYW5pbWF0aW9uQ2FjaGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbCA9IG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg7XHJcblxyXG5cdFx0XHRpZiggb2JqIGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcblx0XHRcdFx0b3JpZ2luYWwuY29weSggb2JqLnNraW5NYXRyaXggKTtcclxuXHRcdFx0XHRvYmouc2tpbk1hdHJpeCA9IG9yaWdpbmFsO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0b3JpZ2luYWwuY29weSggb2JqLm1hdHJpeCApO1xyXG5cdFx0XHRcdG9iai5tYXRyaXggPSBvcmlnaW5hbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRlbGV0ZSBub2RlLmFuaW1hdGlvbkNhY2hlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblxyXG4vLyBVcGRhdGVcclxuXHJcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xyXG5cclxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0dGhpcy5jdXJyZW50VGltZSArPSBkZWx0YSAqIHRoaXMudGltZVNjYWxlO1xyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgZHVyYXRpb24gPSB0aGlzLmRhdGEubGVuZ3RoO1xyXG5cclxuXHRpZiAoIHRoaXMubG9vcCA9PT0gdHJ1ZSAmJiB0aGlzLmN1cnJlbnRUaW1lID4gZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50VGltZSAlPSBkdXJhdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5taW4oIHRoaXMuY3VycmVudFRpbWUsIGR1cmF0aW9uICk7XHJcblxyXG5cdGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCsrICkge1xyXG5cclxuXHRcdHZhciBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xyXG5cdFx0dmFyIG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XHJcblxyXG5cdFx0dmFyIGtleXMgPSBub2RlLmtleXMsXHJcblx0XHRcdGFuaW1hdGlvbkNhY2hlID0gbm9kZS5hbmltYXRpb25DYWNoZTtcclxuXHJcblxyXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdHZhciBwcmV2S2V5ID0gYW5pbWF0aW9uQ2FjaGUucHJldktleTtcclxuXHRcdFx0dmFyIG5leHRLZXkgPSBhbmltYXRpb25DYWNoZS5uZXh0S2V5O1xyXG5cclxuXHRcdFx0aWYgKCBuZXh0S2V5LnRpbWUgPD0gdGhpcy5jdXJyZW50VGltZSApIHtcclxuXHJcblx0XHRcdFx0d2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdHByZXZLZXkgPSBuZXh0S2V5O1xyXG5cdFx0XHRcdFx0bmV4dEtleSA9IGtleXNbIHByZXZLZXkuaW5kZXggKyAxIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5pbWF0aW9uQ2FjaGUucHJldktleSA9IHByZXZLZXk7XHJcblx0XHRcdFx0YW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IG5leHRLZXk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG5leHRLZXkudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICkge1xyXG5cclxuXHRcdFx0XHRwcmV2S2V5LmludGVycG9sYXRlKCBuZXh0S2V5LCB0aGlzLmN1cnJlbnRUaW1lICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRwcmV2S2V5LmludGVycG9sYXRlKCBuZXh0S2V5LCBuZXh0S2V5LnRpbWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5ub2RlLnVwZGF0ZU1hdHJpeCgpO1xyXG5cdFx0XHRvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IG5leHQga2V5IHdpdGhcclxuXHJcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5nZXROZXh0S2V5V2l0aCA9IGZ1bmN0aW9uKCBzaWQsIGgsIGtleSApIHtcclxuXHJcblx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcclxuXHRrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcclxuXHJcblx0Zm9yICggOyBrZXkgPCBrZXlzLmxlbmd0aDsga2V5KysgKSB7XHJcblxyXG5cdFx0aWYgKCBrZXlzWyBrZXkgXS5oYXNUYXJnZXQoIHNpZCApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGtleXNbIGtleSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ga2V5c1sgMCBdO1xyXG5cclxufTtcclxuXHJcbi8vIEdldCBwcmV2aW91cyBrZXkgd2l0aFxyXG5cclxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlLmdldFByZXZLZXlXaXRoID0gZnVuY3Rpb24oIHNpZCwgaCwga2V5ICkge1xyXG5cclxuXHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xyXG5cdGtleSA9IGtleSA+PSAwID8ga2V5IDoga2V5ICsga2V5cy5sZW5ndGg7XHJcblxyXG5cdGZvciAoIDsga2V5ID49IDA7IGtleS0tICkge1xyXG5cclxuXHRcdGlmICgga2V5c1sga2V5IF0uaGFzVGFyZ2V0KCBzaWQgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiBrZXlzWyBrZXkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGtleXNbIGtleXMubGVuZ3RoIC0gMSBdO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuTW9ycGhBbmltYXRpb24gPSBmdW5jdGlvbiAoIG1lc2ggKSB7XHJcblxyXG5cdHRoaXMubWVzaCA9IG1lc2g7XHJcblx0dGhpcy5mcmFtZXMgPSBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7XHJcblx0dGhpcy5jdXJyZW50VGltZSA9IDA7XHJcblx0dGhpcy5kdXJhdGlvbiA9IDEwMDA7XHJcblx0dGhpcy5sb29wID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdHBsYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBhdXNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBsYXN0RnJhbWUgPSAwO1xyXG5cdFx0dmFyIGN1cnJlbnRGcmFtZSA9IDA7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZGVsdGEgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGE7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMubG9vcCA9PT0gdHJ1ZSAmJiB0aGlzLmN1cnJlbnRUaW1lID4gdGhpcy5kdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5jdXJyZW50VGltZSAlPSB0aGlzLmR1cmF0aW9uO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jdXJyZW50VGltZSA9IE1hdGgubWluKCB0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmR1cmF0aW9uICk7XHJcblxyXG5cdFx0XHR2YXIgaW50ZXJwb2xhdGlvbiA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmZyYW1lcztcclxuXHRcdFx0dmFyIGZyYW1lID0gTWF0aC5mbG9vciggdGhpcy5jdXJyZW50VGltZSAvIGludGVycG9sYXRpb24gKTtcclxuXHJcblx0XHRcdGlmICggZnJhbWUgIT0gY3VycmVudEZyYW1lICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBsYXN0RnJhbWUgXSA9IDA7XHJcblx0XHRcdFx0dGhpcy5tZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgY3VycmVudEZyYW1lIF0gPSAxO1xyXG5cdFx0XHRcdHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGZyYW1lIF0gPSAwO1xyXG5cclxuXHRcdFx0XHRsYXN0RnJhbWUgPSBjdXJyZW50RnJhbWU7XHJcblx0XHRcdFx0Y3VycmVudEZyYW1lID0gZnJhbWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBmcmFtZSBdID0gKCB0aGlzLmN1cnJlbnRUaW1lICUgaW50ZXJwb2xhdGlvbiApIC8gaW50ZXJwb2xhdGlvbjtcclxuXHRcdFx0dGhpcy5tZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgbGFzdEZyYW1lIF0gPSAxIC0gdGhpcy5tZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgZnJhbWUgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKSgpXHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbWVyYSBmb3IgcmVuZGVyaW5nIGN1YmUgbWFwc1xyXG4gKlx0LSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcclxuICpcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DdWJlQ2FtZXJhID0gZnVuY3Rpb24gKCBuZWFyLCBmYXIsIGN1YmVSZXNvbHV0aW9uICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIkN1YmVDYW1lcmFcIjtcclxuXHJcblx0dmFyIGZvdiA9IDkwLCBhc3BlY3QgPSAxO1xyXG5cclxuXHR2YXIgY2FtZXJhUFggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFQWC51cC5zZXQoIDAsIC0xLCAwICk7XHJcblx0Y2FtZXJhUFgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYVBYICk7XHJcblxyXG5cdHZhciBjYW1lcmFOWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdGNhbWVyYU5YLnVwLnNldCggMCwgLTEsIDAgKTtcclxuXHRjYW1lcmFOWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAtMSwgMCwgMCApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYU5YICk7XHJcblxyXG5cdHZhciBjYW1lcmFQWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdGNhbWVyYVBZLnVwLnNldCggMCwgMCwgMSApO1xyXG5cdGNhbWVyYVBZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFQWSApO1xyXG5cclxuXHR2YXIgY2FtZXJhTlkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFOWS51cC5zZXQoIDAsIDAsIC0xICk7XHJcblx0Y2FtZXJhTlkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLTEsIDAgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFOWSApO1xyXG5cclxuXHR2YXIgY2FtZXJhUFogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFQWi51cC5zZXQoIDAsIC0xLCAwICk7XHJcblx0Y2FtZXJhUFoubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYVBaICk7XHJcblxyXG5cdHZhciBjYW1lcmFOWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdGNhbWVyYU5aLnVwLnNldCggMCwgLTEsIDAgKTtcclxuXHRjYW1lcmFOWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtMSApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XHJcblxyXG5cdHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggY3ViZVJlc29sdXRpb24sIGN1YmVSZXNvbHV0aW9uLCB7IGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LCBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIgfSApO1xyXG5cclxuXHR0aGlzLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSApIHtcclxuXHJcblx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XHJcblx0XHR2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcztcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAxO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlgsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWSwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA0O1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFosIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuLyoqXHJcbiAqXHRAYXV0aG9yIHp6ODUgLyBodHRwOi8vdHdpdHRlci5jb20vYmx1cnNwbGluZSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICpcdEEgZ2VuZXJhbCBwZXJwb3NlIGNhbWVyYSwgZm9yIHNldHRpbmcgRk9WLCBMZW5zIEZvY2FsIExlbmd0aCxcclxuICpcdFx0YW5kIHN3aXRjaGluZyBiZXR3ZWVuIHBlcnNwZWN0aXZlIGFuZCBvcnRob2dyYXBoaWMgdmlld3MgZWFzaWx5LlxyXG4gKlx0XHRVc2UgdGhpcyBvbmx5IGlmIHlvdSBkbyBub3Qgd2lzaCB0byBtYW5hZ2VcclxuICpcdFx0Ym90aCBhIE9ydGhvZ3JhcGhpYyBhbmQgUGVyc3BlY3RpdmUgQ2FtZXJhXHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBmb3YsIG5lYXIsIGZhciwgb3J0aG9OZWFyLCBvcnRob0ZhciApIHtcclxuXHJcblx0VEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcclxuXHR0aGlzLmNsYXNzTmFtZSA9IFwiQ29tYmluZWRDYW1lcmFcIjtcclxuXHJcblx0dGhpcy5mb3YgPSBmb3Y7XHJcblxyXG5cdHRoaXMubGVmdCA9IC13aWR0aCAvIDI7XHJcblx0dGhpcy5yaWdodCA9IHdpZHRoIC8gMlxyXG5cdHRoaXMudG9wID0gaGVpZ2h0IC8gMjtcclxuXHR0aGlzLmJvdHRvbSA9IC1oZWlnaHQgLyAyO1xyXG5cclxuXHQvLyBXZSBjb3VsZCBhbHNvIGhhbmRsZSB0aGUgcHJvamVjdGlvbk1hdHJpeCBpbnRlcm5hbGx5LCBidXQganVzdCB3YW50ZWQgdG8gdGVzdCBuZXN0ZWQgY2FtZXJhIG9iamVjdHNcclxuXHJcblx0dGhpcy5jYW1lcmFPID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggd2lkdGggLyAtIDIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgaGVpZ2h0IC8gLSAyLCBcdG9ydGhvTmVhciwgb3J0aG9GYXIgKTtcclxuXHR0aGlzLmNhbWVyYVAgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgd2lkdGggLyBoZWlnaHQsIG5lYXIsIGZhciApO1xyXG5cclxuXHR0aGlzLnpvb20gPSAxO1xyXG5cclxuXHR0aGlzLnRvUGVyc3BlY3RpdmUoKTtcclxuXHJcblx0dmFyIGFzcGVjdCA9IHdpZHRoL2hlaWdodDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9QZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Ly8gU3dpdGNoZXMgdG8gdGhlIFBlcnNwZWN0aXZlIENhbWVyYVxyXG5cclxuXHR0aGlzLm5lYXIgPSB0aGlzLmNhbWVyYVAubmVhcjtcclxuXHR0aGlzLmZhciA9IHRoaXMuY2FtZXJhUC5mYXI7XHJcblxyXG5cdHRoaXMuY2FtZXJhUC5mb3YgPSAgdGhpcy5mb3YgLyB0aGlzLnpvb20gO1xyXG5cclxuXHR0aGlzLmNhbWVyYVAudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHR0aGlzLnByb2plY3Rpb25NYXRyaXggPSB0aGlzLmNhbWVyYVAucHJvamVjdGlvbk1hdHJpeDtcclxuXHJcblx0dGhpcy5pblBlcnNwZWN0aXZlTW9kZSA9IHRydWU7XHJcblx0dGhpcy5pbk9ydGhvZ3JhcGhpY01vZGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9PcnRob2dyYXBoaWMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIFN3aXRjaGVzIHRvIHRoZSBPcnRob2dyYXBoaWMgY2FtZXJhIGVzdGltYXRpbmcgdmlld3BvcnQgZnJvbSBQZXJzcGVjdGl2ZVxyXG5cclxuXHR2YXIgZm92ID0gdGhpcy5mb3Y7XHJcblx0dmFyIGFzcGVjdCA9IHRoaXMuY2FtZXJhUC5hc3BlY3Q7XHJcblx0dmFyIG5lYXIgPSB0aGlzLmNhbWVyYVAubmVhcjtcclxuXHR2YXIgZmFyID0gdGhpcy5jYW1lcmFQLmZhcjtcclxuXHJcblx0Ly8gVGhlIHNpemUgdGhhdCB3ZSBzZXQgaXMgdGhlIG1pZCBwbGFuZSBvZiB0aGUgdmlld2luZyBmcnVzdHVtXHJcblxyXG5cdHZhciBoeXBlcmZvY3VzID0gKCBuZWFyICsgZmFyICkgLyAyO1xyXG5cclxuXHR2YXIgaGFsZkhlaWdodCA9IE1hdGgudGFuKCBmb3YgLyAyICkgKiBoeXBlcmZvY3VzO1xyXG5cdHZhciBwbGFuZUhlaWdodCA9IDIgKiBoYWxmSGVpZ2h0O1xyXG5cdHZhciBwbGFuZVdpZHRoID0gcGxhbmVIZWlnaHQgKiBhc3BlY3Q7XHJcblx0dmFyIGhhbGZXaWR0aCA9IHBsYW5lV2lkdGggLyAyO1xyXG5cclxuXHRoYWxmSGVpZ2h0IC89IHRoaXMuem9vbTtcclxuXHRoYWxmV2lkdGggLz0gdGhpcy56b29tO1xyXG5cclxuXHR0aGlzLmNhbWVyYU8ubGVmdCA9IC1oYWxmV2lkdGg7XHJcblx0dGhpcy5jYW1lcmFPLnJpZ2h0ID0gaGFsZldpZHRoO1xyXG5cdHRoaXMuY2FtZXJhTy50b3AgPSBoYWxmSGVpZ2h0O1xyXG5cdHRoaXMuY2FtZXJhTy5ib3R0b20gPSAtaGFsZkhlaWdodDtcclxuXHJcblx0Ly8gdGhpcy5jYW1lcmFPLmxlZnQgPSAtZmFySGFsZldpZHRoO1xyXG5cdC8vIHRoaXMuY2FtZXJhTy5yaWdodCA9IGZhckhhbGZXaWR0aDtcclxuXHQvLyB0aGlzLmNhbWVyYU8udG9wID0gZmFySGFsZkhlaWdodDtcclxuXHQvLyB0aGlzLmNhbWVyYU8uYm90dG9tID0gLWZhckhhbGZIZWlnaHQ7XHJcblxyXG5cdC8vIHRoaXMuY2FtZXJhTy5sZWZ0ID0gdGhpcy5sZWZ0IC8gdGhpcy56b29tO1xyXG5cdC8vIHRoaXMuY2FtZXJhTy5yaWdodCA9IHRoaXMucmlnaHQgLyB0aGlzLnpvb207XHJcblx0Ly8gdGhpcy5jYW1lcmFPLnRvcCA9IHRoaXMudG9wIC8gdGhpcy56b29tO1xyXG5cdC8vIHRoaXMuY2FtZXJhTy5ib3R0b20gPSB0aGlzLmJvdHRvbSAvIHRoaXMuem9vbTtcclxuXHJcblx0dGhpcy5jYW1lcmFPLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0dGhpcy5uZWFyID0gdGhpcy5jYW1lcmFPLm5lYXI7XHJcblx0dGhpcy5mYXIgPSB0aGlzLmNhbWVyYU8uZmFyO1xyXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMuY2FtZXJhTy5wcm9qZWN0aW9uTWF0cml4O1xyXG5cclxuXHR0aGlzLmluUGVyc3BlY3RpdmVNb2RlID0gZmFsc2U7XHJcblx0dGhpcy5pbk9ydGhvZ3JhcGhpY01vZGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHR0aGlzLmNhbWVyYVAuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XHJcblx0dGhpcy5sZWZ0ID0gLXdpZHRoIC8gMjtcclxuXHR0aGlzLnJpZ2h0ID0gd2lkdGggLyAyXHJcblx0dGhpcy50b3AgPSBoZWlnaHQgLyAyO1xyXG5cdHRoaXMuYm90dG9tID0gLWhlaWdodCAvIDI7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS5zZXRGb3YgPSBmdW5jdGlvbiggZm92ICkge1xyXG5cclxuXHR0aGlzLmZvdiA9IGZvdjtcclxuXHJcblx0aWYgKCB0aGlzLmluUGVyc3BlY3RpdmVNb2RlICkge1xyXG5cclxuXHRcdHRoaXMudG9QZXJzcGVjdGl2ZSgpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMudG9PcnRob2dyYXBoaWMoKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZvciBtYW50YWluaW5nIHNpbWlsYXIgQVBJIHdpdGggUGVyc3BlY3RpdmVDYW1lcmFcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdGlmICggdGhpcy5pblBlcnNwZWN0aXZlTW9kZSApIHtcclxuXHJcblx0XHR0aGlzLnRvUGVyc3BlY3RpdmUoKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLnRvUGVyc3BlY3RpdmUoKTtcclxuXHRcdHRoaXMudG9PcnRob2dyYXBoaWMoKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qXHJcbiogVXNlcyBGb2NhbCBMZW5ndGggKGluIG1tKSB0byBlc3RpbWF0ZSBhbmQgc2V0IEZPVlxyXG4qIDM1bW0gKGZ1bGxmcmFtZSkgY2FtZXJhIGlzIHVzZWQgaWYgZnJhbWUgc2l6ZSBpcyBub3Qgc3BlY2lmaWVkO1xyXG4qIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcclxuKi9cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoLCBmcmFtZUhlaWdodCApIHtcclxuXHJcblx0aWYgKCBmcmFtZUhlaWdodCA9PT0gdW5kZWZpbmVkICkgZnJhbWVIZWlnaHQgPSAyNDtcclxuXHJcblx0dmFyIGZvdiA9IDIgKiBUSFJFRS5NYXRoLnJhZFRvRGVnKCBNYXRoLmF0YW4oIGZyYW1lSGVpZ2h0IC8gKCBmb2NhbExlbmd0aCAqIDIgKSApICk7XHJcblxyXG5cdHRoaXMuc2V0Rm92KCBmb3YgKTtcclxuXHJcblx0cmV0dXJuIGZvdjtcclxufTtcclxuXHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uKCB6b29tICkge1xyXG5cclxuXHR0aGlzLnpvb20gPSB6b29tO1xyXG5cclxuXHRpZiAoIHRoaXMuaW5QZXJzcGVjdGl2ZU1vZGUgKSB7XHJcblxyXG5cdFx0dGhpcy50b1BlcnNwZWN0aXZlKCk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy50b09ydGhvZ3JhcGhpYygpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvRnJvbnRWaWV3ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMucm90YXRpb24ueCA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbi55ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xyXG5cclxuXHQvLyBzaG91bGQgd2UgYmUgbW9kaWZpbmcgdGhlIG1hdHJpeCBpbnN0ZWFkP1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b0JhY2tWaWV3ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMucm90YXRpb24ueCA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbi55ID0gTWF0aC5QSTtcclxuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvTGVmdFZpZXcgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5yb3RhdGlvbi54ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnkgPSAtIE1hdGguUEkgLyAyO1xyXG5cdHRoaXMucm90YXRpb24ueiA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9SaWdodFZpZXcgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5yb3RhdGlvbi54ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnkgPSBNYXRoLlBJIC8gMjtcclxuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvVG9wVmlldyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uLnggPSAtIE1hdGguUEkgLyAyO1xyXG5cdHRoaXMucm90YXRpb24ueSA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbi56ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b0JvdHRvbVZpZXcgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5yb3RhdGlvbi54ID0gTWF0aC5QSSAvIDI7XHJcblx0dGhpcy5yb3RhdGlvbi55ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9DdWJlLmFzXHJcbiAqL1xyXG5cclxuVEhSRUUuQm94R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cdHRoaXMuY2xhc3NOYW1lID0gXCJCb3hHZW9tZXRyeVwiO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR0aGlzLndpZHRoID0gd2lkdGg7XHJcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0dGhpcy5kZXB0aCA9IGRlcHRoO1xyXG5cclxuXHR0aGlzLndpZHRoU2VnbWVudHMgPSB3aWR0aFNlZ21lbnRzIHx8IDE7XHJcblx0dGhpcy5oZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XHJcblx0dGhpcy5kZXB0aFNlZ21lbnRzID0gZGVwdGhTZWdtZW50cyB8fCAxO1xyXG5cclxuXHR2YXIgd2lkdGhfaGFsZiA9IHRoaXMud2lkdGggLyAyO1xyXG5cdHZhciBoZWlnaHRfaGFsZiA9IHRoaXMuaGVpZ2h0IC8gMjtcclxuXHR2YXIgZGVwdGhfaGFsZiA9IHRoaXMuZGVwdGggLyAyO1xyXG5cclxuXHRidWlsZFBsYW5lKCAneicsICd5JywgLSAxLCAtIDEsIHRoaXMuZGVwdGgsIHRoaXMuaGVpZ2h0LCB3aWR0aF9oYWxmLCAwICk7IC8vIHB4XHJcblx0YnVpbGRQbGFuZSggJ3onLCAneScsICAgMSwgLSAxLCB0aGlzLmRlcHRoLCB0aGlzLmhlaWdodCwgLSB3aWR0aF9oYWxmLCAxICk7IC8vIG54XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgICAxLCB0aGlzLndpZHRoLCB0aGlzLmRlcHRoLCBoZWlnaHRfaGFsZiwgMiApOyAvLyBweVxyXG5cdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAgIDEsIC0gMSwgdGhpcy53aWR0aCwgdGhpcy5kZXB0aCwgLSBoZWlnaHRfaGFsZiwgMyApOyAvLyBueVxyXG5cdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAgIDEsIC0gMSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGRlcHRoX2hhbGYsIDQgKTsgLy8gcHpcclxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgLSAxLCAtIDEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAtIGRlcHRoX2hhbGYsIDUgKTsgLy8gbnpcclxuXHJcblx0ZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG5cdFx0dmFyIHcsIGl4LCBpeSxcclxuXHRcdGdyaWRYID0gc2NvcGUud2lkdGhTZWdtZW50cyxcclxuXHRcdGdyaWRZID0gc2NvcGUuaGVpZ2h0U2VnbWVudHMsXHJcblx0XHR3aWR0aF9oYWxmID0gd2lkdGggLyAyLFxyXG5cdFx0aGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyLFxyXG5cdFx0b2Zmc2V0ID0gc2NvcGUudmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3gnICkgKSB7XHJcblxyXG5cdFx0XHR3ID0gJ3onO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd6JyApIHx8ICggdSA9PT0gJ3onICYmIHYgPT09ICd4JyApICkge1xyXG5cclxuXHRcdFx0dyA9ICd5JztcclxuXHRcdFx0Z3JpZFkgPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoICggdSA9PT0gJ3onICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd6JyApICkge1xyXG5cclxuXHRcdFx0dyA9ICd4JztcclxuXHRcdFx0Z3JpZFggPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxLFxyXG5cdFx0Z3JpZFkxID0gZ3JpZFkgKyAxLFxyXG5cdFx0c2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFgsXHJcblx0XHRzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZLFxyXG5cdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRub3JtYWxbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtIDE7XHJcblxyXG5cdFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdFx0dmVjdG9yWyB1IF0gPSAoIGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGYgKSAqIHVkaXI7XHJcblx0XHRcdFx0dmVjdG9yWyB2IF0gPSAoIGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZiApICogdmRpcjtcclxuXHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoO1xyXG5cclxuXHRcdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XHJcblx0XHRcdFx0dmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcblx0XHRcdFx0dmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0XHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcclxuXHJcblx0XHRcdFx0dmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xyXG5cdFx0XHRcdHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xyXG5cdFx0XHRcdHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICk7XHJcblx0XHRcdFx0dmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICk7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhICsgb2Zmc2V0LCBiICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XHJcblx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcclxuXHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIgKyBvZmZzZXQsIGMgKyBvZmZzZXQsIGQgKyBvZmZzZXQgKTtcclxuXHRcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xyXG5cdFx0XHRcdGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgaHVnaGVzXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIkNpcmNsZUdlb21ldHJ5XCI7XHJcblxyXG5cdHRoaXMucmFkaXVzID0gcmFkaXVzID0gcmFkaXVzIHx8IDUwO1xyXG5cdHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XHJcblxyXG5cdHRoaXMudGhldGFTdGFydCA9IHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGlzLnRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcclxuXHJcblx0dmFyIGksIHV2cyA9IFtdLFxyXG5cdGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGNlbnRlclVWID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAuNSwgMC41ICk7XHJcblxyXG5cdHRoaXMudmVydGljZXMucHVzaChjZW50ZXIpO1xyXG5cdHV2cy5wdXNoKCBjZW50ZXJVViApO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIGkgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xyXG5cclxuXHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcclxuXHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gcmFkaXVzICsgMSApIC8gMiwgKCB2ZXJ0ZXgueSAvIHJhZGl1cyArIDEgKSAvIDIgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHJcblx0Zm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gaTtcclxuXHRcdHZhciB2MiA9IGkgKyAxIDtcclxuXHRcdHZhciB2MyA9IDA7XHJcblxyXG5cdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcclxuXHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBpIF0uY2xvbmUoKSwgdXZzWyBpICsgMSBdLmNsb25lKCksIGNlbnRlclVWLmNsb25lKCkgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8vIERFUFJFQ0FURURcclxuXHJcblRIUkVFLkN1YmVHZW9tZXRyeSA9IFRIUkVFLkJveEdlb21ldHJ5O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHR0aGlzLmNsYXNzTmFtZSA9IFwiQ3lsaW5kZXJHZW9tZXRyeVwiO1xyXG5cclxuXHR0aGlzLnJhZGl1c1RvcCA9IHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XHJcblx0dGhpcy5yYWRpdXNCb3R0b20gPSByYWRpdXNCb3R0b20gPSByYWRpdXNCb3R0b20gIT09IHVuZGVmaW5lZCA/IHJhZGl1c0JvdHRvbSA6IDIwO1xyXG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiAxMDA7XHJcblxyXG5cdHRoaXMucmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XHJcblx0dGhpcy5oZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHJcblx0dGhpcy5vcGVuRW5kZWQgPSBvcGVuRW5kZWQgPSBvcGVuRW5kZWQgIT09IHVuZGVmaW5lZCA/IG9wZW5FbmRlZCA6IGZhbHNlO1xyXG5cclxuXHR2YXIgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XHJcblxyXG5cdHZhciB4LCB5LCB2ZXJ0aWNlcyA9IFtdLCB1dnMgPSBbXTtcclxuXHJcblx0Zm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzUm93ID0gW107XHJcblx0XHR2YXIgdXZzUm93ID0gW107XHJcblxyXG5cdFx0dmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XHJcblx0XHR2YXIgcmFkaXVzID0gdiAqICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgKyByYWRpdXNUb3A7XHJcblxyXG5cdFx0Zm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICogTWF0aC5QSSAqIDIgKTtcclxuXHRcdFx0dmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoZWlnaHRIYWxmO1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICogTWF0aC5QSSAqIDIgKTtcclxuXHJcblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcclxuXHRcdFx0dXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XHJcblx0XHR1dnMucHVzaCggdXZzUm93ICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHRhblRoZXRhID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcclxuXHR2YXIgbmEsIG5iO1xyXG5cclxuXHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdGlmICggcmFkaXVzVG9wICE9PSAwICkge1xyXG5cclxuXHRcdFx0bmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4IF0gXS5jbG9uZSgpO1xyXG5cdFx0XHRuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggXSBdLmNsb25lKCk7XHJcblx0XHRcdG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCArIDEgXSBdLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG5hLnNldFkoIE1hdGguc3FydCggbmEueCAqIG5hLnggKyBuYS56ICogbmEueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcclxuXHRcdG5iLnNldFkoIE1hdGguc3FydCggbmIueCAqIG5iLnggKyBuYi56ICogbmIueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcclxuXHJcblx0XHRcdHZhciBuMSA9IG5hLmNsb25lKCk7XHJcblx0XHRcdHZhciBuMiA9IG5hLmNsb25lKCk7XHJcblx0XHRcdHZhciBuMyA9IG5iLmNsb25lKCk7XHJcblx0XHRcdHZhciBuNCA9IG5iLmNsb25lKCk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHY0LCBbIG4xLCBuMiwgbjQgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIHRvcCBjYXBcclxuXHJcblx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c1RvcCA+IDAgKSB7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgaGVpZ2h0SGFsZiwgMCApICk7XHJcblxyXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyAwIF1bIHggXTtcclxuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcblx0XHRcdHZhciB1djEgPSB1dnNbIDAgXVsgeCBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djIgPSB1dnNbIDAgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAwICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0gKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBib3R0b20gY2FwXHJcblxyXG5cdGlmICggb3BlbkVuZGVkID09PSBmYWxzZSAmJiByYWRpdXNCb3R0b20gPiAwICkge1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gaGVpZ2h0SGFsZiwgMCApICk7XHJcblxyXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XHJcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcclxuXHRcdFx0dmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xyXG5cdFx0XHR2YXIgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XHJcblx0XHRcdHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcclxuXHJcblx0XHRcdHZhciB1djEgPSB1dnNbIHkgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAxICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0gKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxufVxyXG5cclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqXHJcbiAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqXHJcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXHJcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnZW1lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xyXG4gKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcclxuICpcclxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xyXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxyXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcclxuICpcclxuICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmVQYXRoPiAvLyAzZCBzcGxpbmUgcGF0aCB0byBleHRydWRlIHNoYXBlIGFsb25nLiAoY3JlYXRlcyBGcmFtZXMgaWYgLmZyYW1lcyBhcmVuJ3QgZGVmaW5lZClcclxuICogIGZyYW1lczogPFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcclxuICpcclxuICogIG1hdGVyaWFsOiA8aW50PiAvLyBtYXRlcmlhbCBpbmRleCBmb3IgZnJvbnQgYW5kIGJhY2sgZmFjZXNcclxuICogIGV4dHJ1ZGVNYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGV4dHJ1c2lvbiBhbmQgYmV2ZWxlZCBmYWNlc1xyXG4gKiAgdXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcclxuICpcclxuICogfVxyXG4gKiovXHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcblx0aWYgKCB0eXBlb2YoIHNoYXBlcyApID09PSBcInVuZGVmaW5lZFwiICkge1xyXG5cdFx0c2hhcGVzID0gW107XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIkV4dHJ1ZGVHZW9tZXRyeVwiO1xyXG5cclxuXHRzaGFwZXMgPSBzaGFwZXMgaW5zdGFuY2VvZiBBcnJheSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XHJcblxyXG5cdHRoaXMuc2hhcGViYiA9IHNoYXBlc1sgc2hhcGVzLmxlbmd0aCAtIDEgXS5nZXRCb3VuZGluZ0JveCgpO1xyXG5cclxuXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXHJcblx0Ly8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXHJcblx0Ly8gc2hvdWxkIGRvIHNlcGFyYXRlIHNtb290aGluZyBqdXN0IGZvciBzaWRlc1xyXG5cclxuXHQvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0Ly9jb25zb2xlLmxvZyggXCJ0b29rXCIsICggRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHR2YXIgc2wgPSBzaGFwZXMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcclxuXHRcdHZhciBzaGFwZSA9IHNoYXBlc1sgcyBdO1xyXG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcclxuXHR9XHJcbn07XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcclxuXHJcblx0dmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcclxuXHJcblx0dmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXHJcblx0dmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxyXG5cdHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xyXG5cclxuXHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcclxuXHJcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuXHR2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcclxuXHJcblx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcclxuXHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xyXG5cdHZhciBleHRydWRlTWF0ZXJpYWwgPSBvcHRpb25zLmV4dHJ1ZGVNYXRlcmlhbDtcclxuXHJcblx0Ly8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXHJcblx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yO1xyXG5cclxuXHR2YXIgc2hhcGViYiA9IHRoaXMuc2hhcGViYjtcclxuXHQvL3NoYXBlYmIgPSBzaGFwZS5nZXRCb3VuZGluZ0JveCgpO1xyXG5cclxuXHJcblxyXG5cdHZhciBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XHJcblx0aWYgKCBleHRydWRlUGF0aCApIHtcclxuXHJcblx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xyXG5cclxuXHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xyXG5cdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxyXG5cclxuXHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcclxuXHJcblx0XHQvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxyXG5cdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cclxuXHJcblx0XHRzcGxpbmVUdWJlID0gb3B0aW9ucy5mcmFtZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZnJhbWVzIDogbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoZXh0cnVkZVBhdGgsIHN0ZXBzLCBmYWxzZSk7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XHJcblxyXG5cdFx0Ymlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHBvc2l0aW9uMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXHJcblxyXG5cdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XHJcblxyXG5cdFx0YmV2ZWxTZWdtZW50cyA9IDA7XHJcblx0XHRiZXZlbFRoaWNrbmVzcyA9IDA7XHJcblx0XHRiZXZlbFNpemUgPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFZhcmlhYmxlcyBpbml0YWxpemF0aW9uXHJcblxyXG5cdHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdHZhciBiZXZlbFBvaW50cyA9IFtdO1xyXG5cclxuXHR2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XHJcblx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XHJcblxyXG5cdHZhciByZXZlcnNlID0gIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApIDtcclxuXHJcblx0aWYgKCByZXZlcnNlICkge1xyXG5cclxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xyXG5cclxuXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xyXG5cclxuXHRcdFx0XHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXZlcnNlID0gZmFsc2U7IC8vIElmIHZlcnRpY2VzIGFyZSBpbiBvcmRlciBub3csIHdlIHNob3VsZG4ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZW0gYWdhaW4gKGhvcGVmdWxseSkhXHJcblxyXG5cdH1cclxuXHJcblxyXG5cdHZhciBmYWNlcyA9IFRIUkVFLlNoYXBlLlV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUgKCB2ZXJ0aWNlcywgaG9sZXMgKTtcclxuXHJcblx0LyogVmVydGljZXMgKi9cclxuXHJcblx0dmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcclxuXHJcblx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyAgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0ZnVuY3Rpb24gc2NhbGVQdDIgKCBwdCwgdmVjLCBzaXplICkge1xyXG5cclxuXHRcdGlmICggIXZlYyApIHJldHVybiBUSFJFRS5vbmVycm9yKCBcImRpZSwgdmVjIG5vdCBzcGVjaWZpZWRcIiApO1xyXG5cclxuXHRcdHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgYiwgYnMsIHQsIHosXHJcblx0XHR2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxyXG5cdFx0ZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aCxcclxuXHRcdGNvbnQsIGNsZW4gPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblxyXG5cdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcclxuXHJcblx0dmFyIFJBRF9UT19ERUdSRUVTID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcclxuXHJcblx0XHR2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcclxuXHRcdHZhciBzaWduID0gVEhSRUUuTWF0aC5zaWduO1xyXG5cdFx0XHJcblx0XHQvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXHJcblx0XHQvLyAgIHNoaWZ0ZXQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XHJcblx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcclxuXHRcdC8vXHJcblx0XHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xyXG5cdFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cclxuXHRcdFxyXG5cdFx0dmFyIHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnkgPSAxO1x0XHQvLyByZXN1bHRpbmcgdHJhbnNsYXRpb24gdmVjdG9yIGZvciBpblB0XHJcblxyXG5cdFx0Ly8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxyXG5cdFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcclxuXHJcblx0XHR2YXIgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCwgdl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcclxuXHRcdHZhciB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LCB2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xyXG5cdFx0XHJcblx0XHR2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xyXG5cdFx0XHJcblx0XHQvLyBjaGVjayBmb3IgY29saW5lYXIgZWRnZXNcclxuXHRcdHZhciBjb2xpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XHJcblx0XHRcclxuXHRcdGlmICggTWF0aC5hYnMoIGNvbGluZWFyMCApID4gRVBTSUxPTiApIHtcdFx0Ly8gbm90IGNvbGluZWFyXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBsZW5ndGggb2YgdmVjdG9ycyBmb3Igbm9ybWFsaXppbmdcclxuXHRcclxuXHRcdFx0dmFyIHZfcHJldl9sZW4gPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xyXG5cdFx0XHR2YXIgdl9uZXh0X2xlbiA9IE1hdGguc3FydCggdl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kgKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcclxuXHRcclxuXHRcdFx0dmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XHJcblx0XHRcdHZhciBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XHJcblx0XHRcdHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xyXG5cdFxyXG5cdFx0XHQvLyBzY2FsaW5nIGZhY3RvciBmb3Igdl9wcmV2IHRvIGludGVyc2VjdGlvbiBwb2ludFxyXG5cdFxyXG5cdFx0XHR2YXIgc2YgPSAoICAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXHJcblx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICAgICkgL1xyXG5cdFx0XHRcdFx0ICAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XHJcblx0XHJcblx0XHRcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblx0XHJcblx0XHRcdHZfdHJhbnNfeCA9ICggcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0LnggKTtcclxuXHRcdFx0dl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xyXG5cdFxyXG5cdFx0XHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxyXG5cdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXHJcblx0XHRcdHZhciB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKVxyXG5cdFx0XHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcclxuXHRcdFx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH0gZWxzZSB7XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29saW5lYXIgZWRnZXNcclxuXHJcblx0XHRcdHZhciBkaXJlY3Rpb25fZXEgPSBmYWxzZTtcdFx0Ly8gYXNzdW1lczogb3Bwb3NpdGVcclxuXHRcdFx0aWYgKCB2X3ByZXZfeCA+IEVQU0lMT04gKSB7XHJcblx0XHRcdFx0aWYgKCB2X25leHRfeCA+IEVQU0lMT04gKSB7IGRpcmVjdGlvbl9lcSA9IHRydWU7IH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoIHZfcHJldl94IDwgLUVQU0lMT04gKSB7XHJcblx0XHRcdFx0XHRpZiAoIHZfbmV4dF94IDwgLUVQU0lMT04gKSB7IGRpcmVjdGlvbl9lcSA9IHRydWU7IH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCBzaWduKHZfcHJldl95KSA9PSBzaWduKHZfbmV4dF95KSApIHsgZGlyZWN0aW9uX2VxID0gdHJ1ZTsgfVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBkaXJlY3Rpb25fZXEgKSB7XHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVwiKTtcclxuXHRcdFx0XHR2X3RyYW5zX3ggPSAtdl9wcmV2X3k7XHJcblx0XHRcdFx0dl90cmFuc195ID0gIHZfcHJldl94O1xyXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzcGlrZVwiKTtcclxuXHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcclxuXHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcclxuXHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSAvIDIgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHR2YXIgY29udG91ck1vdmVtZW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xyXG5cclxuXHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuXHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcblx0XHQvLyAgKGopLS0tKGkpLS0tKGspXHJcblx0XHQvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcclxuXHJcblx0XHR2YXIgcHRfaSA9IGNvbnRvdXJbIGkgXTtcclxuXHRcdHZhciBwdF9qID0gY29udG91clsgaiBdO1xyXG5cdFx0dmFyIHB0X2sgPSBjb250b3VyWyBrIF07XHJcblxyXG5cdFx0Y29udG91ck1vdmVtZW50c1sgaSBdPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBob2xlc01vdmVtZW50cyA9IFtdLCBvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XHJcblxyXG5cdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRvbmVIb2xlTW92ZW1lbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcblx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuXHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xyXG5cclxuXHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxyXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF09IGdldEJldmVsVmVjKCBhaG9sZVsgaSBdLCBhaG9sZVsgaiBdLCBhaG9sZVsgayBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcclxuXHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xyXG5cclxuXHRmb3IgKCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XHJcblx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XHJcblxyXG5cdFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xyXG5cdFx0eiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xyXG5cclxuXHRcdC8veiA9IGJldmVsVGhpY2tuZXNzICogdDtcclxuXHRcdGJzID0gYmV2ZWxTaXplICogKCBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJLzIgKSApIDsgLy8gY3VydmVkXHJcblx0XHQvL2JzID0gYmV2ZWxTaXplICogdCA7IC8vIGxpbmVhclxyXG5cclxuXHRcdC8vIGNvbnRyYWN0IHNoYXBlXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblx0XHRcdC8vdmVydCA9IHNjYWxlUHQoIGNvbnRvdXJbIGkgXSwgY29udG91ckNlbnRyb2lkLCBicywgZmFsc2UgKTtcclxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHRcdFx0XHQvL3ZlcnQgPSBzY2FsZVB0KCBhaG9sZVsgaSBdLCBob2xlc0NlbnRyb2lkc1sgaCBdLCBicywgdHJ1ZSApO1xyXG5cclxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIC16ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGJzID0gYmV2ZWxTaXplO1xyXG5cclxuXHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcclxuXHJcblx0XHRpZiAoICFleHRydWRlQnlQYXRoICkge1xyXG5cclxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcclxuXHJcblx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbMF0gKS5tdWx0aXBseVNjYWxhcih2ZXJ0LngpO1xyXG5cdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1swXSApLm11bHRpcGx5U2NhbGFyKHZlcnQueSk7XHJcblxyXG5cdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1swXSApLmFkZChub3JtYWwpLmFkZChiaW5vcm1hbCk7XHJcblxyXG5cdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIEFkZCBzdGVwcGVkIHZlcnRpY2VzLi4uXHJcblx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xyXG5cclxuXHR2YXIgcztcclxuXHJcblx0Zm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggIWV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgLyBzdGVwcyAqIHMgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgcyAtIDEgXS55LCBleHRydWRlUHRzWyBzIC0gMSBdLnggKTtcclxuXHJcblx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1tzXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcclxuXHRcdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1tzXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbc10gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xyXG5cclxuXHQvL2ZvciAoIGIgPSAxOyBiIDw9IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XHJcblx0Zm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XHJcblxyXG5cdFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xyXG5cdFx0eiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xyXG5cdFx0Ly9icyA9IGJldmVsU2l6ZSAqICggMS1NYXRoLnNpbiAoICggMSAtIHQgKSAqIE1hdGguUEkvMiApICk7XHJcblx0XHRicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luICggdCAqIE1hdGguUEkvMiApIDtcclxuXHJcblx0XHQvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cclxuXHRcdFx0XHRpZiAoICFleHRydWRlQnlQYXRoICkge1xyXG5cclxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKiBGYWNlcyAqL1xyXG5cclxuXHQvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xyXG5cclxuXHRidWlsZExpZEZhY2VzKCk7XHJcblxyXG5cdC8vIFNpZGVzIGZhY2VzXHJcblxyXG5cdGJ1aWxkU2lkZUZhY2VzKCk7XHJcblxyXG5cclxuXHQvLy8vLyAgSW50ZXJuYWwgZnVuY3Rpb25zXHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XHJcblxyXG5cdFx0aWYgKCBiZXZlbEVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgbGF5ZXIgPSAwIDsgLy8gc3RlcHMgKyAxXHJcblx0XHRcdHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XHJcblxyXG5cdFx0XHQvLyBCb3R0b20gZmFjZXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0ZjMoIGZhY2VbIDIgXSsgb2Zmc2V0LCBmYWNlWyAxIF0rIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0LCB0cnVlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XHJcblx0XHRcdG9mZnNldCA9IHZsZW4gKiBsYXllcjtcclxuXHJcblx0XHRcdC8vIFRvcCBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCwgZmFsc2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gQm90dG9tIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkrKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0sIHRydWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRvcCBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcywgZmFsc2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBDcmVhdGUgZmFjZXMgZm9yIHRoZSB6LXNpZGVzIG9mIHRoZSBzaGFwZVxyXG5cclxuXHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcclxuXHJcblx0XHR2YXIgbGF5ZXJvZmZzZXQgPSAwO1xyXG5cdFx0c2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xyXG5cdFx0bGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyAgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cdFx0XHRzaWRld2FsbHMoIGFob2xlLCBsYXllcm9mZnNldCApO1xyXG5cclxuXHRcdFx0Ly8sIHRydWVcclxuXHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xyXG5cclxuXHRcdHZhciBqLCBrO1xyXG5cdFx0aSA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuXHRcdHdoaWxlICggLS1pID49IDAgKSB7XHJcblxyXG5cdFx0XHRqID0gaTtcclxuXHRcdFx0ayA9IGkgLSAxO1xyXG5cdFx0XHRpZiAoIGsgPCAwICkgayA9IGNvbnRvdXIubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xyXG5cclxuXHRcdFx0dmFyIHMgPSAwLCBzbCA9IHN0ZXBzICArIGJldmVsU2VnbWVudHMgKiAyO1xyXG5cclxuXHRcdFx0Zm9yICggcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNsZW4xID0gdmxlbiAqIHM7XHJcblx0XHRcdFx0dmFyIHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcclxuXHJcblx0XHRcdFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcclxuXHRcdFx0XHRcdGIgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMSxcclxuXHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcclxuXHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcclxuXHJcblx0XHRcdFx0ZjQoIGEsIGIsIGMsIGQsIGNvbnRvdXIsIHMsIHNsLCBqLCBrICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGYzKCBhLCBiLCBjLCBpc0JvdHRvbSApIHtcclxuXHJcblx0XHRhICs9IHNoYXBlc09mZnNldDtcclxuXHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0YyArPSBzaGFwZXNPZmZzZXQ7XHJcblxyXG5cdFx0Ly8gbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxcclxuXHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbnVsbCwgbnVsbCwgbWF0ZXJpYWwgKSApO1xyXG5cclxuXHRcdHZhciB1dnMgPSBpc0JvdHRvbSA/IHV2Z2VuLmdlbmVyYXRlQm90dG9tVVYoIHNjb3BlLCBzaGFwZSwgb3B0aW9ucywgYSwgYiwgYyApIDogdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIHNoYXBlLCBvcHRpb25zLCBhLCBiLCBjICk7XHJcblxyXG4gXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmNCggYSwgYiwgYywgZCwgd2FsbENvbnRvdXIsIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsIGNvbnRvdXJJbmRleDEsIGNvbnRvdXJJbmRleDIgKSB7XHJcblxyXG5cdFx0YSArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRiICs9IHNoYXBlc09mZnNldDtcclxuXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0ZCArPSBzaGFwZXNPZmZzZXQ7XHJcblxyXG4gXHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgbnVsbCwgbnVsbCwgZXh0cnVkZU1hdGVyaWFsICkgKTtcclxuIFx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQsIG51bGwsIG51bGwsIGV4dHJ1ZGVNYXRlcmlhbCApICk7XHJcblxyXG4gXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCBzaGFwZSwgd2FsbENvbnRvdXIsIG9wdGlvbnMsIGEsIGIsIGMsIGQsXHJcbiBcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCwgY29udG91ckluZGV4MSwgY29udG91ckluZGV4MiApO1xyXG5cclxuIFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDAgXSwgdXZzWyAxIF0sIHV2c1sgMyBdIF0gKTtcclxuIFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDEgXSwgdXZzWyAyIF0sIHV2c1sgMyBdIF0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xyXG5cclxuXHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiggZ2VvbWV0cnksIGV4dHJ1ZGVkU2hhcGUsIGV4dHJ1ZGVPcHRpb25zLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xyXG5cdFx0dmFyIGF4ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QSBdLngsXHJcblx0XHRcdGF5ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QSBdLnksXHJcblxyXG5cdFx0XHRieCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEIgXS54LFxyXG5cdFx0XHRieSA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEIgXS55LFxyXG5cclxuXHRcdFx0Y3ggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhDIF0ueCxcclxuXHRcdFx0Y3kgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhDIF0ueTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYXgsIGF5ICksXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBieCwgYnkgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGN4LCBjeSApXHJcblx0XHRdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUJvdHRvbVVWOiBmdW5jdGlvbiggZ2VvbWV0cnksIGV4dHJ1ZGVkU2hhcGUsIGV4dHJ1ZGVPcHRpb25zLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlVG9wVVYoIGdlb21ldHJ5LCBleHRydWRlZFNoYXBlLCBleHRydWRlT3B0aW9ucywgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uKCBnZW9tZXRyeSwgZXh0cnVkZWRTaGFwZSwgd2FsbENvbnRvdXIsIGV4dHJ1ZGVPcHRpb25zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCwgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250b3VySW5kZXgxLCBjb250b3VySW5kZXgyICkge1xyXG5cclxuXHRcdHZhciBheCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEEgXS54LFxyXG5cdFx0XHRheSA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEEgXS55LFxyXG5cdFx0XHRheiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEEgXS56LFxyXG5cclxuXHRcdFx0YnggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhCIF0ueCxcclxuXHRcdFx0YnkgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhCIF0ueSxcclxuXHRcdFx0YnogPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhCIF0ueixcclxuXHJcblx0XHRcdGN4ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QyBdLngsXHJcblx0XHRcdGN5ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QyBdLnksXHJcblx0XHRcdGN6ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QyBdLnosXHJcblxyXG5cdFx0XHRkeCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEQgXS54LFxyXG5cdFx0XHRkeSA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEQgXS55LFxyXG5cdFx0XHRkeiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEQgXS56O1xyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIGF5IC0gYnkgKSA8IDAuMDEgKSB7XHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGF4LCAxIC0gYXogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYngsIDEgLSBieiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBjeCwgMSAtIGN6ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGR4LCAxIC0gZHogKVxyXG5cdFx0XHRdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYXksIDEgLSBheiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBieSwgMSAtIGJ6ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGN5LCAxIC0gY3ogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggZHksIDEgLSBkeiApXHJcblx0XHRcdF07XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192MiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3YzID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192NSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3Y2ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb21cclxuICpcclxuICogQ3JlYXRlcyBhIG9uZS1zaWRlZCBwb2x5Z29uYWwgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuIFNpbWlsYXIgdG9cclxuICogRXh0cnVkZUdlb21ldHJ5LlxyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKlxyXG4gKlx0Y3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlcy4gTk9UIFVTRUQgQVQgVEhFIE1PTUVOVC5cclxuICpcclxuICpcdG1hdGVyaWFsOiA8aW50PiAvLyBtYXRlcmlhbCBpbmRleCBmb3IgZnJvbnQgYW5kIGJhY2sgZmFjZXNcclxuICpcdHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIH1cclxuICoqL1xyXG5cclxuVEhSRUUuU2hhcGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIlNoYXBlR2VvbWV0cnlcIjtcclxuXHJcblx0aWYgKCBzaGFwZXMgaW5zdGFuY2VvZiBBcnJheSA9PT0gZmFsc2UgKSBzaGFwZXMgPSBbIHNoYXBlcyBdO1xyXG5cclxuXHR0aGlzLnNoYXBlYmIgPSBzaGFwZXNbIHNoYXBlcy5sZW5ndGggLSAxIF0uZ2V0Qm91bmRpbmdCb3goKTtcclxuXHJcblx0dGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG4vKipcclxuICogQWRkIGFuIGFycmF5IG9mIHNoYXBlcyB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LlxyXG4gKi9cclxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcblxyXG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGVzWyBpIF0sIG9wdGlvbnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cclxuICovXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcclxuXHJcblx0aWYgKCBvcHRpb25zID09PSB1bmRlZmluZWQgKSBvcHRpb25zID0ge307XHJcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xyXG5cdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgPT09IHVuZGVmaW5lZCA/IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yIDogb3B0aW9ucy5VVkdlbmVyYXRvcjtcclxuXHJcblx0dmFyIHNoYXBlYmIgPSB0aGlzLnNoYXBlYmI7XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBpLCBsLCBob2xlLCBzO1xyXG5cclxuXHR2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblx0dmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcclxuXHR2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcclxuXHJcblx0dmFyIHJldmVyc2UgPSAhVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XHJcblxyXG5cdGlmICggcmV2ZXJzZSApIHtcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcclxuXHJcblx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlLi4uXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcblxyXG5cdFx0XHRob2xlID0gaG9sZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIGhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0aG9sZXNbIGkgXSA9IGhvbGUucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXZlcnNlID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XHJcblxyXG5cdC8vIFZlcnRpY2VzXHJcblxyXG5cdHZhciBjb250b3VyID0gdmVydGljZXM7XHJcblxyXG5cdGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG5cclxuXHRcdGhvbGUgPSBob2xlc1sgaSBdO1xyXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGhvbGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHR2YXIgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcclxuXHR2YXIgY29udCwgY2xlbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkrKyApIHtcclxuXHJcblx0XHR2ZXJ0ID0gdmVydGljZXNbIGkgXTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0LngsIHZlcnQueSwgMCApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpKysgKSB7XHJcblxyXG5cdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0dmFyIGEgPSBmYWNlWyAwIF0gKyBzaGFwZXNPZmZzZXQ7XHJcblx0XHR2YXIgYiA9IGZhY2VbIDEgXSArIHNoYXBlc09mZnNldDtcclxuXHRcdHZhciBjID0gZmFjZVsgMiBdICsgc2hhcGVzT2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCBtYXRlcmlhbCApICk7XHJcblx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dmdlbi5nZW5lcmF0ZUJvdHRvbVVWKCB0aGlzLCBzaGFwZSwgb3B0aW9ucywgYSwgYiwgYyApICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhc3Ryb2R1ZCAvIGh0dHA6Ly9hc3Ryb2R1ZC5pc2dyZWF0Lm9yZy9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuLy8gcG9pbnRzIC0gdG8gY3JlYXRlIGEgY2xvc2VkIHRvcnVzLCBvbmUgbXVzdCB1c2UgYSBzZXQgb2YgcG9pbnRzIFxyXG4vLyAgICBsaWtlIHNvOiBbIGEsIGIsIGMsIGQsIGEgXSwgc2VlIGZpcnN0IGlzIHRoZSBzYW1lIGFzIGxhc3QuXHJcbi8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxyXG4vLyBwaGlTdGFydCAtIHRoZSBzdGFydGluZyByYWRpYW5cclxuLy8gcGhpTGVuZ3RoIC0gdGhlIHJhZGlhbiAoMCB0byAyKlBJKSByYW5nZSBvZiB0aGUgbGF0aGVkIHNlY3Rpb25cclxuLy8gICAgMipwaSBpcyBhIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXHJcblRIUkVFLkxhdGhlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHR0aGlzLmNsYXNzTmFtZSA9IFwiTGF0aGVHZW9tZXRyeVwiO1xyXG5cclxuXHRzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDEyO1xyXG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgfHwgMDtcclxuXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgMiAqIE1hdGguUEk7XHJcblxyXG5cdHZhciBpbnZlcnNlUG9pbnRMZW5ndGggPSAxLjAgLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XHJcblx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPD0gaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBwaGkgKSxcclxuXHRcdFx0cyA9IE1hdGguc2luKCBwaGkgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHB0ID0gcG9pbnRzWyBqIF07XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZlcnRleC54ID0gYyAqIHB0LnggLSBzICogcHQueTtcclxuXHRcdFx0dmVydGV4LnkgPSBzICogcHQueCArIGMgKiBwdC55O1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHB0Lno7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR2YXIgbnAgPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aCAtIDE7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHZhciBiYXNlID0gaiArIG5wICogaTtcclxuXHRcdFx0dmFyIGEgPSBiYXNlO1xyXG5cdFx0XHR2YXIgYiA9IGJhc2UgKyBucDtcclxuXHRcdFx0dmFyIGMgPSBiYXNlICsgMSArIG5wO1xyXG5cdFx0XHR2YXIgZCA9IGJhc2UgKyAxO1xyXG5cclxuXHRcdFx0dmFyIHUwID0gaSAqIGludmVyc2VTZWdtZW50cztcclxuXHRcdFx0dmFyIHYwID0gaiAqIGludmVyc2VQb2ludExlbmd0aDtcclxuXHRcdFx0dmFyIHUxID0gdTAgKyBpbnZlcnNlU2VnbWVudHM7XHJcblx0XHRcdHZhciB2MSA9IHYwICsgaW52ZXJzZVBvaW50TGVuZ3RoO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYwICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MCApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxyXG5cclxuXHRcdFx0XSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MSApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxyXG5cclxuXHRcdFx0XSApO1xyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcclxuICovXHJcblxyXG5USFJFRS5QbGFuZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cdHRoaXMuY2xhc3NOYW1lID0gXCJQbGFuZUdlb21ldHJ5XCI7XHJcblxyXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0dGhpcy53aWR0aFNlZ21lbnRzID0gd2lkdGhTZWdtZW50cyB8fCAxO1xyXG5cdHRoaXMuaGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xyXG5cclxuXHR2YXIgaXgsIGl6O1xyXG5cdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xyXG5cdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XHJcblxyXG5cdHZhciBncmlkWCA9IHRoaXMud2lkdGhTZWdtZW50cztcclxuXHR2YXIgZ3JpZFogPSB0aGlzLmhlaWdodFNlZ21lbnRzO1xyXG5cclxuXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xyXG5cdHZhciBncmlkWjEgPSBncmlkWiArIDE7XHJcblxyXG5cdHZhciBzZWdtZW50X3dpZHRoID0gdGhpcy53aWR0aCAvIGdyaWRYO1xyXG5cdHZhciBzZWdtZW50X2hlaWdodCA9IHRoaXMuaGVpZ2h0IC8gZ3JpZFo7XHJcblxyXG5cdHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRmb3IgKCBpeiA9IDA7IGl6IDwgZ3JpZFoxOyBpeiArKyApIHtcclxuXHJcblx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcclxuXHRcdFx0dmFyIHkgPSBpeiAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGY7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCAtIHksIDAgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCBpeiA9IDA7IGl6IDwgZ3JpZFo7IGl6ICsrICkge1xyXG5cclxuXHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXo7XHJcblx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl6ICsgMSApO1xyXG5cdFx0XHR2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl6ICsgMSApO1xyXG5cdFx0XHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpejtcclxuXHJcblx0XHRcdHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtIGl6IC8gZ3JpZFogKTtcclxuXHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gKCBpeiArIDEgKSAvIGdyaWRaICk7XHJcblx0XHRcdHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gKCBpeiArIDEgKSAvIGdyaWRaICk7XHJcblx0XHRcdHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXogLyBncmlkWiApO1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcclxuXHJcblx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBLYWxlYiBNdXJwaHlcclxuICovXHJcblxyXG5USFJFRS5SaW5nR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIlJpbmdHZW9tZXRyeVwiO1xyXG5cclxuXHRpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDA7XHJcblx0b3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyB8fCA1MDtcclxuXHJcblx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG5cdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XHJcblxyXG5cdHRoZXRhU2VnbWVudHMgPSB0aGV0YVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgdGhldGFTZWdtZW50cyApIDogODtcclxuXHRwaGlTZWdtZW50cyA9IHBoaVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgcGhpU2VnbWVudHMgKSA6IDg7XHJcblxyXG5cdHZhciBpLCBvLCB1dnMgPSBbXSwgcmFkaXVzID0gaW5uZXJSYWRpdXMsIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPD0gcGhpU2VnbWVudHM7IGkgKysgKSB7IC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xyXG5cclxuXHRcdGZvciAoIG8gPSAwOyBvIDw9IHRoZXRhU2VnbWVudHM7IG8gKysgKSB7IC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgbyAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcclxuXHJcblx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcclxuXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyLCAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyICkgKTtcclxuXHRcdH1cclxuXHJcblx0XHRyYWRpdXMgKz0gcmFkaXVzU3RlcDtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHM7IGkgKysgKSB7IC8vIGNvbmNlbnRyaWMgY2lyY2xlcyBpbnNpZGUgcmluZ1xyXG5cclxuXHRcdHZhciB0aGV0YVNlZ21lbnQgPSBpICogdGhldGFTZWdtZW50cztcclxuXHJcblx0XHRmb3IgKCBvID0gMDsgbyA8PSB0aGV0YVNlZ21lbnRzOyBvICsrICkgeyAvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxyXG5cclxuXHRcdFx0dmFyIHNlZ21lbnQgPSBvICsgdGhldGFTZWdtZW50O1xyXG5cclxuXHRcdFx0dmFyIHYxID0gc2VnbWVudCArIGk7XHJcblx0XHRcdHZhciB2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgaTtcclxuXHRcdFx0dmFyIHYzID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxICsgaTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdKTtcclxuXHJcblx0XHRcdHYxID0gc2VnbWVudCArIGk7XHJcblx0XHRcdHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxICsgaTtcclxuXHRcdFx0djMgPSBzZWdtZW50ICsgMSArIGk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgdjEgXS5jbG9uZSgpLCB1dnNbIHYyIF0uY2xvbmUoKSwgdXZzWyB2MyBdLmNsb25lKCkgXSk7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwaGVyZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cdHRoaXMuY2xhc3NOYW1lID0gXCJTcGhlcmVHZW9tZXRyeVwiO1xyXG5cclxuXHR0aGlzLnJhZGl1cyA9IHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcclxuXHJcblx0dGhpcy53aWR0aFNlZ21lbnRzID0gd2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xyXG5cdHRoaXMuaGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDYgKTtcclxuXHJcblx0dGhpcy5waGlTdGFydCA9IHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcclxuXHR0aGlzLnBoaUxlbmd0aCA9IHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XHJcblxyXG5cdHRoaXMudGhldGFTdGFydCA9IHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHR0aGlzLnRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xyXG5cclxuXHR2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XHJcblxyXG5cdGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xyXG5cdFx0dmFyIHV2c1JvdyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDw9IHdpZHRoU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdSA9IHggLyB3aWR0aFNlZ21lbnRzO1xyXG5cdFx0XHR2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHR2ZXJ0ZXgueCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0dmVydGljZXNSb3cucHVzaCggdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XHJcblx0XHRcdHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xyXG5cdFx0dXZzLnB1c2goIHV2c1JvdyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHkgPSAwOyB5IDwgdGhpcy5oZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcblx0XHRmb3IgKCB4ID0gMDsgeCA8IHRoaXMud2lkdGhTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XHJcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcclxuXHRcdFx0dmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcclxuXHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XHJcblxyXG5cdFx0XHR2YXIgbjEgPSB0aGlzLnZlcnRpY2VzWyB2MSBdLmNsb25lKCkubm9ybWFsaXplKCk7XHJcblx0XHRcdHZhciBuMiA9IHRoaXMudmVydGljZXNbIHYyIF0uY2xvbmUoKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0dmFyIG4zID0gdGhpcy52ZXJ0aWNlc1sgdjMgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHR2YXIgbjQgPSB0aGlzLnZlcnRpY2VzWyB2NCBdLmNsb25lKCkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MiA9IHV2c1sgeSBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djQgPSB1dnNbIHkgKyAxIF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIHRoaXMudmVydGljZXNbIHYxIF0ueSApID09PSB0aGlzLnJhZGl1cyApIHtcclxuXHJcblx0XHRcdFx0dXYxLnggPSAoIHV2MS54ICsgdXYyLnggKSAvIDI7XHJcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MywgdjQsIFsgbjEsIG4zLCBuNCBdICkgKTtcclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYzLCB1djQgXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggTWF0aC5hYnMoIHRoaXMudmVydGljZXNbIHYzIF0ueSApID09PSB0aGlzLnJhZGl1cyApIHtcclxuXHJcblx0XHRcdFx0dXYzLnggPSAoIHV2My54ICsgdXY0LnggKSAvIDI7XHJcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdICkgKTtcclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjQsIFsgbjEsIG4yLCBuNCBdICkgKTtcclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djQgXSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Mi5jbG9uZSgpLCB1djMsIHV2NC5jbG9uZSgpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogRm9yIGNyZWF0aW5nIDNEIHRleHQgZ2VvbWV0cnkgaW4gdGhyZWUuanNcclxuICpcclxuICogVGV4dCA9IDNEIFRleHRcclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIHNpemU6IFx0XHRcdDxmbG9hdD4sIFx0Ly8gc2l6ZSBvZiB0aGUgdGV4dFxyXG4gKiAgaGVpZ2h0OiBcdFx0PGZsb2F0PiwgXHQvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XHJcbiAqICBjdXJ2ZVNlZ21lbnRzOiBcdDxpbnQ+LFx0XHQvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcclxuICpcclxuICogIGZvbnQ6IFx0XHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IG5hbWVcclxuICogIHdlaWdodDogXHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHdlaWdodCAobm9ybWFsLCBib2xkKVxyXG4gKiAgc3R5bGU6IFx0XHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHN0eWxlICAobm9ybWFsLCBpdGFsaWNzKVxyXG4gKlxyXG4gKiAgYmV2ZWxFbmFibGVkOlx0PGJvb2w+LFx0XHRcdC8vIHR1cm4gb24gYmV2ZWxcclxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCBcdFx0Ly8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcclxuICogIGJldmVsU2l6ZTpcdFx0PGZsb2F0PiwgXHRcdC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgaXMgYmV2ZWxcclxuICogIH1cclxuICpcclxuICovXHJcblxyXG4vKlx0VXNhZ2UgRXhhbXBsZXNcclxuXHJcblx0Ly8gVGV4dEdlb21ldHJ5IHdyYXBwZXJcclxuXHJcblx0dmFyIHRleHQzZCA9IG5ldyBUZXh0R2VvbWV0cnkoIHRleHQsIG9wdGlvbnMgKTtcclxuXHJcblx0Ly8gQ29tcGxldGUgbWFubmVyXHJcblxyXG5cdHZhciB0ZXh0U2hhcGVzID0gVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBvcHRpb25zICk7XHJcblx0dmFyIHRleHQzZCA9IG5ldyBFeHRydWRlR2VvbWV0cnkoIHRleHRTaGFwZXMsIG9wdGlvbnMgKTtcclxuXHJcbiovXHJcblxyXG5cclxuVEhSRUUuVGV4dEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xyXG5cdHRoaXMuY2xhc3NOYW1lID0gXCJUZXh0R2VvbWV0cnlcIjtcclxuXHJcblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XHJcblxyXG5cdHZhciB0ZXh0U2hhcGVzID0gVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdC8vIHRyYW5zbGF0ZSBwYXJhbWV0ZXJzIHRvIEV4dHJ1ZGVHZW9tZXRyeSBBUElcclxuXHJcblx0cGFyYW1ldGVycy5hbW91bnQgPSBwYXJhbWV0ZXJzLmhlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5oZWlnaHQgOiA1MDtcclxuXHJcblx0Ly8gZGVmYXVsdHNcclxuXHJcblx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID0gMTA7XHJcblx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFNpemUgPSA4O1xyXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5jYWxsKCB0aGlzLCB0ZXh0U2hhcGVzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVGV4dEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0RMaXRlL3NyYy9hd2F5M2RsaXRlL3ByaW1pdGl2ZXMvVG9ydXMuYXM/cj0yODg4XHJcbiAqL1xyXG5cclxuVEhSRUUuVG9ydXNHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHR0aGlzLmNsYXNzTmFtZSA9IFwiVG9ydXNHZW9tZXRyeVwiO1xyXG5cdFxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcclxuXHR0aGlzLnR1YmUgPSB0dWJlIHx8IDQwO1xyXG5cdHRoaXMucmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG5cdHRoaXMudHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY7XHJcblx0dGhpcy5hcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XHJcblxyXG5cdHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB1dnMgPSBbXSwgbm9ybWFscyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gdGhpcy5yYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdGhpcy50dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdSA9IGkgLyB0aGlzLnR1YnVsYXJTZWdtZW50cyAqIHRoaXMuYXJjO1xyXG5cdFx0XHR2YXIgdiA9IGogLyB0aGlzLnJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XHJcblxyXG5cdFx0XHRjZW50ZXIueCA9IHRoaXMucmFkaXVzICogTWF0aC5jb3MoIHUgKTtcclxuXHRcdFx0Y2VudGVyLnkgPSB0aGlzLnJhZGl1cyAqIE1hdGguc2luKCB1ICk7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dmVydGV4LnggPSAoIHRoaXMucmFkaXVzICsgdGhpcy50dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcclxuXHRcdFx0dmVydGV4LnkgPSAoIHRoaXMucmFkaXVzICsgdGhpcy50dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5zaW4oIHUgKTtcclxuXHRcdFx0dmVydGV4LnogPSB0aGlzLnR1YmUgKiBNYXRoLnNpbiggdiApO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcblx0XHRcdHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHRoaXMudHVidWxhclNlZ21lbnRzLCBqIC8gdGhpcy5yYWRpYWxTZWdtZW50cyApICk7XHJcblx0XHRcdG5vcm1hbHMucHVzaCggdmVydGV4LmNsb25lKCkuc3ViKCBjZW50ZXIgKS5ub3JtYWxpemUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHRoaXMucmFkaWFsU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAxOyBpIDw9IHRoaXMudHVidWxhclNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGEgPSAoIHRoaXMudHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xyXG5cdFx0XHR2YXIgYiA9ICggdGhpcy50dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcclxuXHRcdFx0dmFyIGMgPSAoIHRoaXMudHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcclxuXHRcdFx0dmFyIGQgPSAoIHRoaXMudHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgWyBub3JtYWxzWyBhIF0uY2xvbmUoKSwgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGQgXS5jbG9uZSgpIF0gKTtcclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkLCBbIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBjIF0uY2xvbmUoKSwgbm9ybWFsc1sgZCBdLmNsb25lKCkgXSApO1xyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGIgXS5jbG9uZSgpLCB1dnNbIGMgXS5jbG9uZSgpLCB1dnNbIGQgXS5jbG9uZSgpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcclxuICovXHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cdHRoaXMuY2xhc3NOYW1lID0gXCJUb3J1c0tub3RHZW9tZXRyeVwiO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XHJcblx0dGhpcy50dWJlID0gdHViZSB8fCA0MDtcclxuXHR0aGlzLnJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgNjQ7XHJcblx0dGhpcy50dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgODtcclxuXHR0aGlzLnAgPSBwIHx8IDI7XHJcblx0dGhpcy5xID0gcSB8fCAzO1xyXG5cdHRoaXMuaGVpZ2h0U2NhbGUgPSBoZWlnaHRTY2FsZSB8fCAxO1xyXG5cdHRoaXMuZ3JpZCA9IG5ldyBBcnJheSggdGhpcy5yYWRpYWxTZWdtZW50cyApO1xyXG5cclxuXHR2YXIgdGFuZyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBiaXRhbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMucmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XHJcblxyXG5cdFx0dGhpcy5ncmlkWyBpIF0gPSBuZXcgQXJyYXkoIHRoaXMudHVidWxhclNlZ21lbnRzICk7XHJcblx0XHR2YXIgdSA9IGkgLyB0aGlzLnJhZGlhbFNlZ21lbnRzICogMiAqIHRoaXMucCAqIE1hdGguUEk7XHJcblx0XHR2YXIgcDEgPSBnZXRQb3MoIHUsIHRoaXMucSwgdGhpcy5wLCB0aGlzLnJhZGl1cywgdGhpcy5oZWlnaHRTY2FsZSApO1xyXG5cdFx0dmFyIHAyID0gZ2V0UG9zKCB1ICsgMC4wMSwgdGhpcy5xLCB0aGlzLnAsIHRoaXMucmFkaXVzLCB0aGlzLmhlaWdodFNjYWxlICk7XHJcblx0XHR0YW5nLnN1YlZlY3RvcnMoIHAyLCBwMSApO1xyXG5cdFx0bi5hZGRWZWN0b3JzKCBwMiwgcDEgKTtcclxuXHJcblx0XHRiaXRhbi5jcm9zc1ZlY3RvcnMoIHRhbmcsIG4gKTtcclxuXHRcdG4uY3Jvc3NWZWN0b3JzKCBiaXRhbiwgdGFuZyApO1xyXG5cdFx0Yml0YW4ubm9ybWFsaXplKCk7XHJcblx0XHRuLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHRoaXMudHVidWxhclNlZ21lbnRzOyArKyBqICkge1xyXG5cclxuXHRcdFx0dmFyIHYgPSBqIC8gdGhpcy50dWJ1bGFyU2VnbWVudHMgKiAyICogTWF0aC5QSTtcclxuXHRcdFx0dmFyIGN4ID0gLSB0aGlzLnR1YmUgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxyXG5cdFx0XHR2YXIgY3kgPSB0aGlzLnR1YmUgKiBNYXRoLnNpbiggdiApO1xyXG5cclxuXHRcdFx0dmFyIHBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHBvcy54ID0gcDEueCArIGN4ICogbi54ICsgY3kgKiBiaXRhbi54O1xyXG5cdFx0XHRwb3MueSA9IHAxLnkgKyBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcclxuXHRcdFx0cG9zLnogPSBwMS56ICsgY3ggKiBuLnogKyBjeSAqIGJpdGFuLno7XHJcblxyXG5cdFx0XHR0aGlzLmdyaWRbIGkgXVsgaiBdID0gc2NvcGUudmVydGljZXMucHVzaCggcG9zICkgLSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHRoaXMudHVidWxhclNlZ21lbnRzOyArKyBqICkge1xyXG5cclxuXHRcdFx0dmFyIGlwID0gKCBpICsgMSApICUgdGhpcy5yYWRpYWxTZWdtZW50cztcclxuXHRcdFx0dmFyIGpwID0gKCBqICsgMSApICUgdGhpcy50dWJ1bGFyU2VnbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgYSA9IHRoaXMuZ3JpZFsgaSBdWyBqIF07XHJcblx0XHRcdHZhciBiID0gdGhpcy5ncmlkWyBpcCBdWyBqIF07XHJcblx0XHRcdHZhciBjID0gdGhpcy5ncmlkWyBpcCBdWyBqcCBdO1xyXG5cdFx0XHR2YXIgZCA9IHRoaXMuZ3JpZFsgaSBdWyBqcCBdO1xyXG5cclxuXHRcdFx0dmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdGhpcy5yYWRpYWxTZWdtZW50cywgaiAvIHRoaXMudHVidWxhclNlZ21lbnRzICk7XHJcblx0XHRcdHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gdGhpcy5yYWRpYWxTZWdtZW50cywgaiAvIHRoaXMudHVidWxhclNlZ21lbnRzICk7XHJcblx0XHRcdHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gdGhpcy5yYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdGhpcy50dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdFx0dmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdGhpcy5yYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdGhpcy50dWJ1bGFyU2VnbWVudHMgKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdGZ1bmN0aW9uIGdldFBvcyggdSwgaW5fcSwgaW5fcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcblx0XHR2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xyXG5cdFx0dmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcclxuXHRcdHZhciBxdU92ZXJQID0gaW5fcSAvIGluX3AgKiB1O1xyXG5cdFx0dmFyIGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcclxuXHJcblx0XHR2YXIgdHggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XHJcblx0XHR2YXIgdHkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XHJcblx0XHR2YXIgdHogPSBoZWlnaHRTY2FsZSAqIHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0eCwgdHksIHR6ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIEBhdXRob3IgbWluaW5nb2xkIC8gaHR0cHM6Ly9naXRodWIuY29tL21pbmluZ29sZFxyXG4gKlxyXG4gKiBNb2RpZmllZCBmcm9tIHRoZSBUb3J1c0tub3RHZW9tZXRyeSBieSBAb29zbW94aWVjb2RlXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSB0dWJlIHdoaWNoIGV4dHJ1ZGVzIGFsb25nIGEgM2Qgc3BsaW5lXHJcbiAqXHJcbiAqIFVzZXMgcGFyYWxsZWwgdHJhbnNwb3J0IGZyYW1lcyBhcyBkZXNjcmliZWQgaW5cclxuICogaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXHJcbiAqL1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHBhdGgsIHNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHR0aGlzLmNsYXNzTmFtZSA9IFwiVHViZUdlb21ldHJ5XCI7XHJcblxyXG5cdHRoaXMucGF0aCA9IHBhdGg7XHJcblx0dGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzIHx8IDY0O1xyXG5cdHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDE7XHJcblx0dGhpcy5yYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XHJcblx0dGhpcy5jbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XHJcblxyXG5cdHRoaXMuZ3JpZCA9IFtdO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzLFxyXG5cclxuXHRcdHRhbmdlbnQsXHJcblx0XHRub3JtYWwsXHJcblx0XHRiaW5vcm1hbCxcclxuXHJcblx0XHRudW1wb2ludHMgPSB0aGlzLnNlZ21lbnRzICsgMSxcclxuXHJcblx0XHR4LCB5LCB6LFxyXG5cdFx0dHgsIHR5LCB0eixcclxuXHRcdHUsIHYsXHJcblxyXG5cdFx0Y3gsIGN5LFxyXG5cdFx0cG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdGksIGosXHJcblx0XHRpcCwganAsXHJcblx0XHRhLCBiLCBjLCBkLFxyXG5cdFx0dXZhLCB1dmIsIHV2YywgdXZkO1xyXG5cclxuXHR2YXIgZnJhbWVzID0gbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIHRoaXMucGF0aCwgdGhpcy5zZWdtZW50cywgdGhpcy5jbG9zZWQgKSxcclxuXHRcdHRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzLFxyXG5cdFx0bm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzLFxyXG5cdFx0Ymlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcclxuXHJcblx0Ly8gcHJveHkgaW50ZXJuYWxzXHJcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xyXG5cdHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XHJcblx0dGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XHJcblxyXG5cdGZ1bmN0aW9uIHZlcnQoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKSAtIDE7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIGNvbnNydWN0IHRoZSBncmlkXHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpKysgKSB7XHJcblxyXG5cdFx0dGhpcy5ncmlkWyBpIF0gPSBbXTtcclxuXHJcblx0XHR1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xyXG5cclxuXHRcdHBvcyA9IHBhdGguZ2V0UG9pbnRBdCggdSApO1xyXG5cclxuXHRcdHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xyXG5cdFx0bm9ybWFsID0gbm9ybWFsc1sgaSBdO1xyXG5cdFx0Ymlub3JtYWwgPSBiaW5vcm1hbHNbIGkgXTtcclxuXHJcblx0XHRmb3IgKCBqID0gMDsgaiA8IHRoaXMucmFkaWFsU2VnbWVudHM7IGorKyApIHtcclxuXHJcblx0XHRcdHYgPSBqIC8gdGhpcy5yYWRpYWxTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xyXG5cclxuXHRcdFx0Y3ggPSAtdGhpcy5yYWRpdXMgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxyXG5cdFx0XHRjeSA9IHRoaXMucmFkaXVzICogTWF0aC5zaW4oIHYgKTtcclxuXHJcblx0XHRcdHBvczIuY29weSggcG9zICk7XHJcblx0XHRcdHBvczIueCArPSBjeCAqIG5vcm1hbC54ICsgY3kgKiBiaW5vcm1hbC54O1xyXG5cdFx0XHRwb3MyLnkgKz0gY3ggKiBub3JtYWwueSArIGN5ICogYmlub3JtYWwueTtcclxuXHRcdFx0cG9zMi56ICs9IGN4ICogbm9ybWFsLnogKyBjeSAqIGJpbm9ybWFsLno7XHJcblxyXG5cdFx0XHR0aGlzLmdyaWRbIGkgXVsgaiBdID0gdmVydCggcG9zMi54LCBwb3MyLnksIHBvczIueiApO1xyXG5cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvLyBjb25zdHJ1Y3QgdGhlIG1lc2hcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLnNlZ21lbnRzOyBpKysgKSB7XHJcblxyXG5cdFx0Zm9yICggaiA9IDA7IGogPCB0aGlzLnJhZGlhbFNlZ21lbnRzOyBqKysgKSB7XHJcblxyXG5cdFx0XHRpcCA9ICggdGhpcy5jbG9zZWQgKSA/IChpICsgMSkgJSB0aGlzLnNlZ21lbnRzIDogaSArIDE7XHJcblx0XHRcdGpwID0gKGogKyAxKSAlIHRoaXMucmFkaWFsU2VnbWVudHM7XHJcblxyXG5cdFx0XHRhID0gdGhpcy5ncmlkWyBpIF1bIGogXTtcdFx0Ly8gKioqIE5PVCBORUNFU1NBUklMWSBQTEFOQVIgISAqKipcclxuXHRcdFx0YiA9IHRoaXMuZ3JpZFsgaXAgXVsgaiBdO1xyXG5cdFx0XHRjID0gdGhpcy5ncmlkWyBpcCBdWyBqcCBdO1xyXG5cdFx0XHRkID0gdGhpcy5ncmlkWyBpIF1bIGpwIF07XHJcblxyXG5cdFx0XHR1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHRoaXMuc2VnbWVudHMsIGogLyB0aGlzLnJhZGlhbFNlZ21lbnRzICk7XHJcblx0XHRcdHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyB0aGlzLnNlZ21lbnRzLCBqIC8gdGhpcy5yYWRpYWxTZWdtZW50cyApO1xyXG5cdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gdGhpcy5zZWdtZW50cywgKCBqICsgMSApIC8gdGhpcy5yYWRpYWxTZWdtZW50cyApO1xyXG5cdFx0XHR1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHRoaXMuc2VnbWVudHMsICggaiArIDEgKSAvIHRoaXMucmFkaWFsU2VnbWVudHMgKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuXHJcbi8vIEZvciBjb21wdXRpbmcgb2YgRnJlbmV0IGZyYW1lcywgZXhwb3NpbmcgdGhlIHRhbmdlbnRzLCBub3JtYWxzIGFuZCBiaW5vcm1hbHMgdGhlIHNwbGluZVxyXG5USFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzID0gZnVuY3Rpb24ocGF0aCwgc2VnbWVudHMsIGNsb3NlZCkge1xyXG5cclxuXHR2YXJcdHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdGJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcblx0XHR0YW5nZW50cyA9IFtdLFxyXG5cdFx0bm9ybWFscyA9IFtdLFxyXG5cdFx0Ymlub3JtYWxzID0gW10sXHJcblxyXG5cdFx0dmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdG1hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcblxyXG5cdFx0bnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxyXG5cdFx0dGhldGEsXHJcblx0XHRlcHNpbG9uID0gMC4wMDAxLFxyXG5cdFx0c21hbGxlc3QsXHJcblxyXG5cdFx0dHgsIHR5LCB0eixcclxuXHRcdGksIHUsIHY7XHJcblxyXG5cclxuXHQvLyBleHBvc2UgaW50ZXJuYWxzXHJcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xyXG5cdHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XHJcblx0dGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XHJcblxyXG5cdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpKysgKSB7XHJcblxyXG5cdFx0dSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcclxuXHJcblx0XHR0YW5nZW50c1sgaSBdID0gcGF0aC5nZXRUYW5nZW50QXQoIHUgKTtcclxuXHRcdHRhbmdlbnRzWyBpIF0ubm9ybWFsaXplKCk7XHJcblxyXG5cdH1cclxuXHJcblx0aW5pdGlhbE5vcm1hbDMoKTtcclxuXHJcblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDEobGFzdEJpbm9ybWFsKSB7XHJcblx0XHQvLyBmaXhlZCBzdGFydCBiaW5vcm1hbC4gSGFzIGRhbmdlcnMgb2YgMCB2ZWN0b3JzXHJcblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0aWYgKGxhc3RCaW5vcm1hbD09PXVuZGVmaW5lZCkgbGFzdEJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGxhc3RCaW5vcm1hbCwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwyKCkge1xyXG5cclxuXHRcdC8vIFRoaXMgdXNlcyB0aGUgRnJlbmV0LVNlcnJldCBmb3JtdWxhIGZvciBkZXJpdmluZyBiaW5vcm1hbFxyXG5cdFx0dmFyIHQyID0gcGF0aC5nZXRUYW5nZW50QXQoIGVwc2lsb24gKTtcclxuXHJcblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLnN1YlZlY3RvcnMoIHQyLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcclxuXHJcblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBiaW5vcm1hbHNbIDAgXSwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpOyAvLyBsYXN0IGJpbm9ybWFsIHggdGFuZ2VudFxyXG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMygpIHtcclxuXHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuaWN1bGFyIHRvIHRoZSBmaXJzdCB0YW5nZW50IHZlY3RvcixcclxuXHRcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzbWFsbGVzdCB0YW5nZW50IHh5eiBjb21wb25lbnRcclxuXHJcblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0c21hbGxlc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cdFx0dHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XHJcblx0XHR0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcclxuXHRcdHR6ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueiApO1xyXG5cclxuXHRcdGlmICggdHggPD0gc21hbGxlc3QgKSB7XHJcblx0XHRcdHNtYWxsZXN0ID0gdHg7XHJcblx0XHRcdG5vcm1hbC5zZXQoIDEsIDAsIDAgKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR5IDw9IHNtYWxsZXN0ICkge1xyXG5cdFx0XHRzbWFsbGVzdCA9IHR5O1xyXG5cdFx0XHRub3JtYWwuc2V0KCAwLCAxLCAwICk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eiA8PSBzbWFsbGVzdCApIHtcclxuXHRcdFx0bm9ybWFsLnNldCggMCwgMCwgMSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcclxuXHR9XHJcblxyXG5cclxuXHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxyXG5cclxuXHRmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSsrICkge1xyXG5cclxuXHRcdG5vcm1hbHNbIGkgXSA9IG5vcm1hbHNbIGktMSBdLmNsb25lKCk7XHJcblxyXG5cdFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGktMSBdLmNsb25lKCk7XHJcblxyXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGktMSBdLCB0YW5nZW50c1sgaSBdICk7XHJcblxyXG5cdFx0aWYgKCB2ZWMubGVuZ3RoKCkgPiBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0dmVjLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0dGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRhbmdlbnRzWyBpLTEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLTEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXHJcblxyXG5cdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcclxuXHJcblx0aWYgKCBjbG9zZWQgKSB7XHJcblxyXG5cdFx0dGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIG5vcm1hbHNbIDAgXS5kb3QoIG5vcm1hbHNbIG51bXBvaW50cy0xIF0gKSwgLTEsIDEgKSApO1xyXG5cdFx0dGhldGEgLz0gKCBudW1wb2ludHMgLSAxICk7XHJcblxyXG5cdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBudW1wb2ludHMtMSBdICkgKSA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGV0YSA9IC10aGV0YTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkrKyApIHtcclxuXHJcblx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXHJcblx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xyXG5cdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgY2xvY2t3b3JrZ2VlayAvIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG9ja3dvcmtnZWVrXHJcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiovXHJcblxyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHZlcnRpY2VzLCBmYWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHR0aGlzLmNsYXNzTmFtZSA9IFwiUG9seWhlZHJvbkdlb21ldHJ5XCI7XHJcblxyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xyXG5cdGRldGFpbCA9IGRldGFpbCB8fCAwO1xyXG5cclxuXHR2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF1bIDAgXSwgdmVydGljZXNbIGkgXVsgMSBdLCB2ZXJ0aWNlc1sgaSBdWyAyIF0gKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBtaWRwb2ludHMgPSBbXSwgcCA9IHRoaXMudmVydGljZXM7XHJcblxyXG5cdHZhciBmID0gW107XHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgdjEgPSBwWyBmYWNlc1sgaSBdWyAwIF0gXTtcclxuXHRcdHZhciB2MiA9IHBbIGZhY2VzWyBpIF1bIDEgXSBdO1xyXG5cdFx0dmFyIHYzID0gcFsgZmFjZXNbIGkgXVsgMiBdIF07XHJcblxyXG5cdFx0ZlsgaSBdID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGYubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRzdWJkaXZpZGUoZlsgaSBdLCBkZXRhaWwpO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIGZhY2Ugc3RyYWRkbGVzIHRoZSBzZWFtXHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG5cdFx0dmFyIHgwID0gdXZzWyAwIF0ueDtcclxuXHRcdHZhciB4MSA9IHV2c1sgMSBdLng7XHJcblx0XHR2YXIgeDIgPSB1dnNbIDIgXS54O1xyXG5cclxuXHRcdHZhciBtYXggPSBNYXRoLm1heCggeDAsIE1hdGgubWF4KCB4MSwgeDIgKSApO1xyXG5cdFx0dmFyIG1pbiA9IE1hdGgubWluKCB4MCwgTWF0aC5taW4oIHgxLCB4MiApICk7XHJcblxyXG5cdFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkgeyAvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XHJcblxyXG5cdFx0XHRpZiAoIHgwIDwgMC4yICkgdXZzWyAwIF0ueCArPSAxO1xyXG5cdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZzWyAxIF0ueCArPSAxO1xyXG5cdFx0XHRpZiAoIHgyIDwgMC4yICkgdXZzWyAyIF0ueCArPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQXBwbHkgcmFkaXVzXHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBNZXJnZSB2ZXJ0aWNlc1xyXG5cclxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblxyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcblxyXG5cdC8vIFByb2plY3QgdmVjdG9yIG9udG8gc3BoZXJlJ3Mgc3VyZmFjZVxyXG5cclxuXHRmdW5jdGlvbiBwcmVwYXJlKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRleCA9IHZlY3Rvci5ub3JtYWxpemUoKS5jbG9uZSgpO1xyXG5cdFx0dmVydGV4LmluZGV4ID0gdGhhdC52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKSAtIDE7XHJcblxyXG5cdFx0Ly8gVGV4dHVyZSBjb29yZHMgYXJlIGVxdWl2YWxlbnQgdG8gbWFwIGNvb3JkcywgY2FsY3VsYXRlIGFuZ2xlIGFuZCBjb252ZXJ0IHRvIGZyYWN0aW9uIG9mIGEgY2lyY2xlLlxyXG5cclxuXHRcdHZhciB1ID0gYXppbXV0aCggdmVjdG9yICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcclxuXHRcdHZhciB2ID0gaW5jbGluYXRpb24oIHZlY3RvciApIC8gTWF0aC5QSSArIDAuNTtcclxuXHRcdHZlcnRleC51diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApO1xyXG5cclxuXHRcdHJldHVybiB2ZXJ0ZXg7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEFwcHJveGltYXRlIGEgY3VydmVkIGZhY2Ugd2l0aCByZWN1cnNpdmVseSBzdWItZGl2aWRlZCB0cmlhbmdsZXMuXHJcblxyXG5cdGZ1bmN0aW9uIG1ha2UoIHYxLCB2MiwgdjMgKSB7XHJcblxyXG5cdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEuY2xvbmUoKSwgdjIuY2xvbmUoKSwgdjMuY2xvbmUoKSBdICk7XHJcblx0XHRmYWNlLmNlbnRyb2lkLmFkZCggdjEgKS5hZGQoIHYyICkuYWRkKCB2MyApLmRpdmlkZVNjYWxhciggMyApO1xyXG5cdFx0dGhhdC5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0dmFyIGF6aSA9IGF6aW11dGgoIGZhY2UuY2VudHJvaWQgKTtcclxuXHJcblx0XHR0aGF0LmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXHJcblx0XHRcdGNvcnJlY3RVViggdjEudXYsIHYxLCBhemkgKSxcclxuXHRcdFx0Y29ycmVjdFVWKCB2Mi51diwgdjIsIGF6aSApLFxyXG5cdFx0XHRjb3JyZWN0VVYoIHYzLnV2LCB2MywgYXppIClcclxuXHRcdF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQW5hbHl0aWNhbGx5IHN1YmRpdmlkZSBhIGZhY2UgdG8gdGhlIHJlcXVpcmVkIGRldGFpbCBsZXZlbC5cclxuXHJcblx0ZnVuY3Rpb24gc3ViZGl2aWRlKGZhY2UsIGRldGFpbCApIHtcclxuXHJcblx0XHR2YXIgY29scyA9IE1hdGgucG93KDIsIGRldGFpbCk7XHJcblx0XHR2YXIgY2VsbHMgPSBNYXRoLnBvdyg0LCBkZXRhaWwpO1xyXG5cdFx0dmFyIGEgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG5cdFx0dmFyIGIgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG5cdFx0dmFyIGMgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cdFx0dmFyIHYgPSBbXTtcclxuXHJcblx0XHQvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvbi5cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAgOyBpIDw9IGNvbHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2WyBpIF0gPSBbXTtcclxuXHJcblx0XHRcdHZhciBhaiA9IHByZXBhcmUoIGEuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApICk7XHJcblx0XHRcdHZhciBiaiA9IHByZXBhcmUoIGIuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApICk7XHJcblx0XHRcdHZhciByb3dzID0gY29scyAtIGk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gcm93czsgaiArKykge1xyXG5cclxuXHRcdFx0XHRpZiAoIGogPT0gMCAmJiBpID09IGNvbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhajtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2WyBpIF1bIGogXSA9IHByZXBhcmUoIGFqLmNsb25lKCkubGVycCggYmosIGogLyByb3dzICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlcy5cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb2xzIDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDIgKiAoY29scyAtIGkpIC0gMTsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGogJSAyID09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWFrZShcclxuXHRcdFx0XHRcdFx0dlsgaSBdWyBrICsgMV0sXHJcblx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgXSxcclxuXHRcdFx0XHRcdFx0dlsgaSBdWyBrIF1cclxuXHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0bWFrZShcclxuXHRcdFx0XHRcdFx0dlsgaSBdWyBrICsgMSBdLFxyXG5cdFx0XHRcdFx0XHR2WyBpICsgMV1bIGsgKyAxXSxcclxuXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayBdXHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXHJcblxyXG5cdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC12ZWN0b3IueCApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXHJcblxyXG5cdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYXRhbjIoIC12ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gVGV4dHVyZSBmaXhpbmcgaGVscGVyLiBTcGhlcmVzIGhhdmUgc29tZSBvZGQgYmVoYXZpb3Vycy5cclxuXHJcblx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xyXG5cclxuXHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcclxuXHRcdGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNSwgdXYueSApO1xyXG5cdFx0cmV0dXJuIHV2LmNsb25lKCk7XHJcblxyXG5cdH1cclxuXHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcclxuICovXHJcblxyXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcblx0dGhpcy5kZXRhaWwgPSBkZXRhaWw7XHJcblxyXG5cdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IFtcclxuXHRcdFsgLTEsICB0LCAgMCBdLCBbICAxLCB0LCAwIF0sIFsgLTEsIC10LCAgMCBdLCBbICAxLCAtdCwgIDAgXSxcclxuXHRcdFsgIDAsIC0xLCAgdCBdLCBbICAwLCAxLCB0IF0sIFsgIDAsIC0xLCAtdCBdLCBbICAwLCAgMSwgLXQgXSxcclxuXHRcdFsgIHQsICAwLCAtMSBdLCBbICB0LCAwLCAxIF0sIFsgLXQsICAwLCAtMSBdLCBbIC10LCAgMCwgIDEgXVxyXG5cdF07XHJcblxyXG5cdHZhciBmYWNlcyA9IFtcclxuXHRcdFsgMCwgMTEsICA1IF0sIFsgMCwgIDUsICAxIF0sIFsgIDAsICAxLCAgNyBdLCBbICAwLCAgNywgMTAgXSwgWyAgMCwgMTAsIDExIF0sXHJcblx0XHRbIDEsICA1LCAgOSBdLCBbIDUsIDExLCAgNCBdLCBbIDExLCAxMCwgIDIgXSwgWyAxMCwgIDcsICA2IF0sIFsgIDcsICAxLCAgOCBdLFxyXG5cdFx0WyAzLCAgOSwgIDQgXSwgWyAzLCAgNCwgIDIgXSwgWyAgMywgIDIsICA2IF0sIFsgIDMsICA2LCAgOCBdLCBbICAzLCAgOCwgIDkgXSxcclxuXHRcdFsgNCwgIDksICA1IF0sIFsgMiwgIDQsIDExIF0sIFsgIDYsICAyLCAxMCBdLCBbICA4LCAgNiwgIDcgXSwgWyAgOSwgIDgsICAxIF1cclxuXHRdO1xyXG5cclxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGZhY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cdHRoaXMuY2xhc3NOYW1lID0gXCJJY29zYWhlZHJvbkdlb21ldHJ5XCI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gW1xyXG5cdFx0WyAxLCAwLCAwIF0sIFsgLTEsIDAsIDAgXSwgWyAwLCAxLCAwIF0sIFsgMCwgLTEsIDAgXSwgWyAwLCAwLCAxIF0sIFsgMCwgMCwgLTEgXVxyXG5cdF07XHJcblxyXG5cdHZhciBmYWNlcyA9IFtcclxuXHRcdFsgMCwgMiwgNCBdLCBbIDAsIDQsIDMgXSwgWyAwLCAzLCA1IF0sIFsgMCwgNSwgMiBdLCBbIDEsIDIsIDUgXSwgWyAxLCA1LCAzIF0sIFsgMSwgMywgNCBdLCBbIDEsIDQsIDIgXVxyXG5cdF07XHJcblxyXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgZmFjZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIk9jdGFoZWRyb25HZW9tZXRyeVwiO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIlRldHJhaGVkcm9uR2VvbWV0cnlcIjtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gW1xyXG5cdFx0WyAxLCAgMSwgIDEgXSwgWyAtMSwgLTEsIDEgXSwgWyAtMSwgMSwgLTEgXSwgWyAxLCAtMSwgLTEgXVxyXG5cdF07XHJcblxyXG5cdHZhciBmYWNlcyA9IFtcclxuXHRcdFsgMiwgMSwgMCBdLCBbIDAsIDMsIDIgXSwgWyAxLCAzLCAwIF0sIFsgMiwgMywgMSBdXHJcblx0XTtcclxuXHJcblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBmYWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcclxuICogYmFzZWQgb24gdGhlIGJyaWxsaWFudCBhcnRpY2xlIGJ5IEBwcmlkZW91dCBodHRwOi8vcHJpZGVvdXQubmV0L2Jsb2cvP3A9NDRcclxuICpcclxuICogbmV3IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSggcGFyYW1ldHJpY0Z1bmN0aW9uLCB1U2VnbWVudHMsIHlTZWdlbWVudHMgKTtcclxuICpcclxuICovXHJcblxyXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIlBhcmFtZXRyaWNHZW9tZXRyeVwiO1xyXG5cclxuXHR2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XHJcblx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cclxuXHR2YXIgaSwgaWwsIGosIHA7XHJcblx0dmFyIHUsIHY7XHJcblxyXG5cdHZhciBzdGFja0NvdW50ID0gc3RhY2tzICsgMTtcclxuXHR2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDw9IHN0YWNrczsgaSArKyApIHtcclxuXHJcblx0XHR2ID0gaSAvIHN0YWNrcztcclxuXHJcblx0XHRmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGogKysgKSB7XHJcblxyXG5cdFx0XHR1ID0gaiAvIHNsaWNlcztcclxuXHJcblx0XHRcdHAgPSBmdW5jKCB1LCB2ICk7XHJcblx0XHRcdHZlcnRzLnB1c2goIHAgKTtcclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YXIgYSwgYiwgYywgZDtcclxuXHR2YXIgdXZhLCB1dmIsIHV2YywgdXZkO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHN0YWNrczsgaSArKyApIHtcclxuXHJcblx0XHRmb3IgKCBqID0gMDsgaiA8IHNsaWNlczsgaiArKyApIHtcclxuXHJcblx0XHRcdGEgPSBpICogc2xpY2VDb3VudCArIGo7XHJcblx0XHRcdGIgPSBpICogc2xpY2VDb3VudCArIGogKyAxO1xyXG5cdFx0XHRjID0gKGkgKyAxKSAqIHNsaWNlQ291bnQgKyBqICsgMTtcclxuXHRcdFx0ZCA9IChpICsgMSkgKiBzbGljZUNvdW50ICsgajtcclxuXHJcblx0XHRcdHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XHJcblx0XHRcdHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGogKyAxICkgLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcclxuXHRcdFx0dXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XHJcblx0XHRcdHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcclxuXHJcblx0XHRcdGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XHJcblx0XHRcdHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcclxuXHRcdFx0dXZzLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBjb25zb2xlLmxvZyh0aGlzKTtcclxuXHJcblx0Ly8gbWFnaWMgYnVsbGV0XHJcblx0Ly8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHQvLyBjb25zb2xlLmxvZygncmVtb3ZlZCAnLCBkaWZmLCAnIHZlcnRpY2VzIGJ5IG1lcmdpbmcnKTtcclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3Igc3JvdWNoZXJheSAvIGh0dHA6Ly9zcm91Y2hlcmF5Lm9yZy9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BeGlzSGVscGVyID0gZnVuY3Rpb24gKCBzaXplICkge1xyXG5cclxuXHRzaXplID0gc2l6ZSB8fCAxO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCBzaXplLCAwLCAwICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgc2l6ZSwgMCApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIHNpemUgKVxyXG5cdCk7XHJcblxyXG5cdGdlb21ldHJ5LmNvbG9ycy5wdXNoKFxyXG5cdFx0bmV3IFRIUkVFLkNvbG9yKCAweGZmMDAwMCApLCBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZhYTAwICksXHJcblx0XHRuZXcgVEhSRUUuQ29sb3IoIDB4MDBmZjAwICksIG5ldyBUSFJFRS5Db2xvciggMHhhYWZmMDAgKSxcclxuXHRcdG5ldyBUSFJFRS5Db2xvciggMHgwMDAwZmYgKSwgbmV3IFRIUkVFLkNvbG9yKCAweDAwYWFmZiApXHJcblx0KTtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0gKTtcclxuXHJcblx0VEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIFRIUkVFLkxpbmVQaWVjZXMgKTtcclxuXHR0aGlzLmNsYXNzTmFtZSA9IFwiQXhpc0hlbHBlclwiO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICpcclxuICogQ3JlYXRlcyBhbiBhcnJvdyBmb3IgdmlzdWFsaXppbmcgZGlyZWN0aW9uc1xyXG4gKlxyXG4gKiBQYXJhbWV0ZXJzOlxyXG4gKiAgZGlyIC0gVmVjdG9yM1xyXG4gKiAgb3JpZ2luIC0gVmVjdG9yM1xyXG4gKiAgbGVuZ3RoIC0gTnVtYmVyXHJcbiAqICBoZXggLSBjb2xvciBpbiBoZXggdmFsdWVcclxuICogIGhlYWRMZW5ndGggLSBOdW1iZXJcclxuICogIGhlYWRXaWR0aCAtIE51bWJlclxyXG4gKi9cclxuXHJcblRIUkVFLkFycm93SGVscGVyID0gZnVuY3Rpb24gKCBkaXIsIG9yaWdpbiwgbGVuZ3RoLCBoZXgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcclxuXHJcblx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblx0dGhpcy5jbGFzc05hbWUgPSBcIkFycm93SGVscGVyXCI7XHJcblxyXG5cdGlmICggaGV4ID09PSB1bmRlZmluZWQgKSBoZXggPSAweGZmZmYwMDtcclxuXHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gMTtcclxuXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XHJcblx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XHJcblxyXG5cdHRoaXMucG9zaXRpb24gPSBvcmlnaW47XHJcblxyXG5cdHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRsaW5lR2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKSApO1xyXG5cdGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XHJcblxyXG5cdHRoaXMubGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4IH0gKSApO1xyXG5cdHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5hZGQoIHRoaXMubGluZSApO1xyXG5cclxuXHR2YXIgY29uZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDAuNSwgMSwgNSwgMSApO1xyXG5cdGNvbmVHZW9tZXRyeS5hcHBseU1hdHJpeCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oIDAsIC0gMC41LCAwICkgKTtcclxuXHJcblx0dGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGNvbmVHZW9tZXRyeSwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXggfSApICk7XHJcblx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmFkZCggdGhpcy5jb25lICk7XHJcblxyXG5cdHRoaXMuc2V0RGlyZWN0aW9uKCBkaXIgKTtcclxuXHR0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBheGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgcmFkaWFucztcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggZGlyICkge1xyXG5cclxuXHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDAsIDAsIDAsIDEgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBkaXIueSA8IC0gMC45OTk5OSApIHtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRyYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIHJhZGlhbnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcclxuXHJcblx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xyXG5cdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xyXG5cclxuXHR0aGlzLmxpbmUuc2NhbGUuc2V0KCAxLCBsZW5ndGgsIDEgKTtcclxuXHR0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XHJcblx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XHJcblx0dGhpcy5jb25lLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggaGV4ICkge1xyXG5cclxuXHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Cb3hIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0Ly8gICA1X19fXzRcclxuXHQvLyAxL19fXzAvfFxyXG5cdC8vIHwgNl9ffF83XHJcblx0Ly8gMi9fX18zL1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggICAxLCAgIDEsICAgMSApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoIC0gMSwgICAxLCAgIDEgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAtIDEsIC0gMSwgICAxICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggICAxLCAtIDEsICAgMSApLFxyXG5cclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAgIDEsICAgMSwgLSAxICksXHJcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSAxLCAgIDEsIC0gMSApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoIC0gMSwgLSAxLCAtIDEgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAgIDEsIC0gMSwgLSAxIClcclxuXHRdO1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XHJcblxyXG5cdC8vIFRPRE86IFdvdWxkbid0IGJlIG5pY2UgaWYgTGluZSBoYWQgLnNlZ21lbnRzP1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxyXG5cdFx0dmVydGljZXNbIDAgXSwgdmVydGljZXNbIDEgXSxcclxuXHRcdHZlcnRpY2VzWyAxIF0sIHZlcnRpY2VzWyAyIF0sXHJcblx0XHR2ZXJ0aWNlc1sgMiBdLCB2ZXJ0aWNlc1sgMyBdLFxyXG5cdFx0dmVydGljZXNbIDMgXSwgdmVydGljZXNbIDAgXSxcclxuXHJcblx0XHR2ZXJ0aWNlc1sgNCBdLCB2ZXJ0aWNlc1sgNSBdLFxyXG5cdFx0dmVydGljZXNbIDUgXSwgdmVydGljZXNbIDYgXSxcclxuXHRcdHZlcnRpY2VzWyA2IF0sIHZlcnRpY2VzWyA3IF0sXHJcblx0XHR2ZXJ0aWNlc1sgNyBdLCB2ZXJ0aWNlc1sgNCBdLFxyXG5cclxuXHRcdHZlcnRpY2VzWyAwIF0sIHZlcnRpY2VzWyA0IF0sXHJcblx0XHR2ZXJ0aWNlc1sgMSBdLCB2ZXJ0aWNlc1sgNSBdLFxyXG5cdFx0dmVydGljZXNbIDIgXSwgdmVydGljZXNbIDYgXSxcclxuXHRcdHZlcnRpY2VzWyAzIF0sIHZlcnRpY2VzWyA3IF1cclxuXHQpO1xyXG5cclxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZjAwIH0gKSwgVEhSRUUuTGluZVBpZWNlcyApO1xyXG5cclxuXHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRoaXMudXBkYXRlKCBvYmplY3QgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBtaW4gPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5taW47XHJcblx0dmFyIG1heCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heDtcclxuXHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuXHR2ZXJ0aWNlc1sgMCBdLnNldCggbWF4LngsIG1heC55LCBtYXgueiApO1xyXG5cdHZlcnRpY2VzWyAxIF0uc2V0KCBtaW4ueCwgbWF4LnksIG1heC56ICk7XHJcblx0dmVydGljZXNbIDIgXS5zZXQoIG1pbi54LCBtaW4ueSwgbWF4LnogKTtcclxuXHR2ZXJ0aWNlc1sgMyBdLnNldCggbWF4LngsIG1pbi55LCBtYXgueiApO1xyXG5cdHZlcnRpY2VzWyA0IF0uc2V0KCBtYXgueCwgbWF4LnksIG1pbi56ICk7XHJcblx0dmVydGljZXNbIDUgXS5zZXQoIG1pbi54LCBtYXgueSwgbWluLnogKTtcclxuXHR2ZXJ0aWNlc1sgNiBdLnNldCggbWluLngsIG1pbi55LCBtaW4ueiApO1xyXG5cdHZlcnRpY2VzWyA3IF0uc2V0KCBtYXgueCwgbWluLnksIG1pbi56ICk7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblx0dGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLm1hdHJpeFdvcmxkID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG4vLyBhIGhlbHBlciB0byBzaG93IHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhbiBvYmplY3RcclxuXHJcblRIUkVFLkJvdW5kaW5nQm94SGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCApIHtcclxuXHJcblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHg4ODg4ODg7XHJcblxyXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHR0aGlzLmJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgbmV3IFRIUkVFLkJveEdlb21ldHJ5KCAxLCAxLCAxICksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIHdpcmVmcmFtZTogdHJ1ZSB9ICkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5ib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcclxuXHJcblx0dGhpcy5ib3guc2l6ZSggdGhpcy5zY2FsZSApO1xyXG5cclxuXHR0aGlzLmJveC5jZW50ZXIoIHRoaXMucG9zaXRpb24gKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxyXG4gKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXHJcbiAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxyXG4gKlx0XHRodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FtZXJhSGVscGVyID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycyB9ICk7XHJcblxyXG5cdHZhciBwb2ludE1hcCA9IHt9O1xyXG5cclxuXHQvLyBjb2xvcnNcclxuXHJcblx0dmFyIGhleEZydXN0dW0gPSAweGZmYWEwMDtcclxuXHR2YXIgaGV4Q29uZSA9IDB4ZmYwMDAwO1xyXG5cdHZhciBoZXhVcCA9IDB4MDBhYWZmO1xyXG5cdHZhciBoZXhUYXJnZXQgPSAweGZmZmZmZjtcclxuXHR2YXIgaGV4Q3Jvc3MgPSAweDMzMzMzMztcclxuXHJcblx0Ly8gbmVhclxyXG5cclxuXHRhZGRMaW5lKCBcIm4xXCIsIFwibjJcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjJcIiwgXCJuNFwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuNFwiLCBcIm4zXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4zXCIsIFwibjFcIiwgaGV4RnJ1c3R1bSApO1xyXG5cclxuXHQvLyBmYXJcclxuXHJcblx0YWRkTGluZSggXCJmMVwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcImYyXCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwiZjRcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJmM1wiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcclxuXHJcblx0Ly8gc2lkZXNcclxuXHJcblx0YWRkTGluZSggXCJuMVwiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4yXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjNcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuNFwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcclxuXHJcblx0Ly8gY29uZVxyXG5cclxuXHRhZGRMaW5lKCBcInBcIiwgXCJuMVwiLCBoZXhDb25lICk7XHJcblx0YWRkTGluZSggXCJwXCIsIFwibjJcIiwgaGV4Q29uZSApO1xyXG5cdGFkZExpbmUoIFwicFwiLCBcIm4zXCIsIGhleENvbmUgKTtcclxuXHRhZGRMaW5lKCBcInBcIiwgXCJuNFwiLCBoZXhDb25lICk7XHJcblxyXG5cdC8vIHVwXHJcblxyXG5cdGFkZExpbmUoIFwidTFcIiwgXCJ1MlwiLCBoZXhVcCApO1xyXG5cdGFkZExpbmUoIFwidTJcIiwgXCJ1M1wiLCBoZXhVcCApO1xyXG5cdGFkZExpbmUoIFwidTNcIiwgXCJ1MVwiLCBoZXhVcCApO1xyXG5cclxuXHQvLyB0YXJnZXRcclxuXHJcblx0YWRkTGluZSggXCJjXCIsIFwidFwiLCBoZXhUYXJnZXQgKTtcclxuXHRhZGRMaW5lKCBcInBcIiwgXCJjXCIsIGhleENyb3NzICk7XHJcblxyXG5cdC8vIGNyb3NzXHJcblxyXG5cdGFkZExpbmUoIFwiY24xXCIsIFwiY24yXCIsIGhleENyb3NzICk7XHJcblx0YWRkTGluZSggXCJjbjNcIiwgXCJjbjRcIiwgaGV4Q3Jvc3MgKTtcclxuXHJcblx0YWRkTGluZSggXCJjZjFcIiwgXCJjZjJcIiwgaGV4Q3Jvc3MgKTtcclxuXHRhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBoZXhDcm9zcyApO1xyXG5cclxuXHRmdW5jdGlvbiBhZGRMaW5lKCBhLCBiLCBoZXggKSB7XHJcblxyXG5cdFx0YWRkUG9pbnQoIGEsIGhleCApO1xyXG5cdFx0YWRkUG9pbnQoIGIsIGhleCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgaGV4ICkge1xyXG5cclxuXHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcclxuXHRcdGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XHJcblxyXG5cdFx0aWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cG9pbnRNYXBbIGlkIF0gPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cG9pbnRNYXBbIGlkIF0ucHVzaCggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC0gMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsLCBUSFJFRS5MaW5lUGllY2VzICk7XHJcblxyXG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG5cdHRoaXMubWF0cml4V29ybGQgPSBjYW1lcmEubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgY2FtZXJhID0gbmV3IFRIUkVFLkNhbWVyYSgpO1xyXG5cdHZhciBwcm9qZWN0b3IgPSBuZXcgVEhSRUUuUHJvamVjdG9yKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR2YXIgdyA9IDEsIGggPSAxO1xyXG5cclxuXHRcdC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXhcclxuXHRcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XHJcblxyXG5cdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdC8vIGNlbnRlciAvIHRhcmdldFxyXG5cclxuXHRcdHNldFBvaW50KCBcImNcIiwgMCwgMCwgLTEgKTtcclxuXHRcdHNldFBvaW50KCBcInRcIiwgMCwgMCwgIDEgKTtcclxuXHJcblx0XHQvLyBuZWFyXHJcblxyXG5cdFx0c2V0UG9pbnQoIFwibjFcIiwgLXcsIC1oLCAtMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwibjJcIiwgIHcsIC1oLCAtMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwibjNcIiwgLXcsICBoLCAtMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwibjRcIiwgIHcsICBoLCAtMSApO1xyXG5cclxuXHRcdC8vIGZhclxyXG5cclxuXHRcdHNldFBvaW50KCBcImYxXCIsIC13LCAtaCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiZjJcIiwgIHcsIC1oLCAxICk7XHJcblx0XHRzZXRQb2ludCggXCJmM1wiLCAtdywgIGgsIDEgKTtcclxuXHRcdHNldFBvaW50KCBcImY0XCIsICB3LCAgaCwgMSApO1xyXG5cclxuXHRcdC8vIHVwXHJcblxyXG5cdFx0c2V0UG9pbnQoIFwidTFcIiwgIHcgKiAwLjcsIGggKiAxLjEsIC0xICk7XHJcblx0XHRzZXRQb2ludCggXCJ1MlwiLCAtdyAqIDAuNywgaCAqIDEuMSwgLTEgKTtcclxuXHRcdHNldFBvaW50KCBcInUzXCIsICAgICAgICAwLCBoICogMiwgICAtMSApO1xyXG5cclxuXHRcdC8vIGNyb3NzXHJcblxyXG5cdFx0c2V0UG9pbnQoIFwiY2YxXCIsIC13LCAgMCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY2YyXCIsICB3LCAgMCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY2YzXCIsICAwLCAtaCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY2Y0XCIsICAwLCAgaCwgMSApO1xyXG5cclxuXHRcdHNldFBvaW50KCBcImNuMVwiLCAtdywgIDAsIC0xICk7XHJcblx0XHRzZXRQb2ludCggXCJjbjJcIiwgIHcsICAwLCAtMSApO1xyXG5cdFx0c2V0UG9pbnQoIFwiY24zXCIsICAwLCAtaCwgLTEgKTtcclxuXHRcdHNldFBvaW50KCBcImNuNFwiLCAgMCwgIGgsIC0xICk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0dmVjdG9yLnNldCggeCwgeSwgeiApO1xyXG5cdFx0XHRwcm9qZWN0b3IudW5wcm9qZWN0VmVjdG9yKCB2ZWN0b3IsIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0dmFyIHBvaW50cyA9IHNjb3BlLnBvaW50TWFwWyBwb2ludCBdO1xyXG5cclxuXHRcdFx0aWYgKCBwb2ludHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5nZW9tZXRyeS52ZXJ0aWNlc1sgcG9pbnRzWyBpIF0gXS5jb3B5KCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNpemUgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5saWdodCA9IGxpZ2h0O1xyXG5cdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0dGhpcy5tYXRyaXhXb3JsZCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRzaXplID0gc2l6ZSB8fCAxO1xyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KCBzaXplLCBzaXplICk7XHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0UGxhbmUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHRQbGFuZSApO1xyXG5cclxuXHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcclxuXHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblxyXG5cdG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcblx0dGhpcy50YXJnZXRMaW5lID0gbmV3IFRIUkVFLkxpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLnRhcmdldExpbmUgKTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcclxuXHR0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHYzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdHYzLnN1YlZlY3RvcnMoIHYyLCB2MSApO1xyXG5cclxuXHRcdHRoaXMubGlnaHRQbGFuZS5sb29rQXQoIHYzICk7XHJcblx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc1sgMSBdLmNvcHkoIHYzICk7XHJcblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IgKTtcclxuXHJcblx0fVxyXG5cclxufSgpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5FZGdlc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXggKSB7XHJcblxyXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xyXG5cclxuXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XHJcblx0dmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uICggYSwgYiApIHsgcmV0dXJuIGEgLSBiIH07XHJcblxyXG5cdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdHZhciBnZW9tZXRyeTIgPSBvYmplY3QuZ2VvbWV0cnkuY2xvbmUoKTtcclxuXHJcblx0Z2VvbWV0cnkyLm1lcmdlVmVydGljZXMoKTtcclxuXHRnZW9tZXRyeTIuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5Mi52ZXJ0aWNlcztcclxuXHR2YXIgZmFjZXMgPSBnZW9tZXRyeTIuZmFjZXM7XHJcblx0dmFyIG51bUVkZ2VzID0gMDtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG5cdFx0XHRlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcclxuXHRcdFx0ZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcclxuXHJcblx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGhhc2hbIGtleSBdID0geyB2ZXJ0MTogZWRnZVsgMCBdLCB2ZXJ0MjogZWRnZVsgMSBdLCBmYWNlMTogaSwgZmFjZTI6IHVuZGVmaW5lZCB9O1xyXG5cdFx0XHRcdG51bUVkZ2VzICsrO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aGFzaFsga2V5IF0uZmFjZTIgPSBpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIEZsb2F0MzJBcnJheSwgMiAqIG51bUVkZ2VzLCAzICk7XHJcblxyXG5cdHZhciBjb29yZHMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuXHR2YXIgaW5kZXggPSAwO1xyXG5cclxuXHRmb3IgKCB2YXIga2V5IGluIGhhc2ggKSB7XHJcblxyXG5cdFx0dmFyIGggPSBoYXNoWyBrZXkgXTtcclxuXHJcblx0XHRpZiAoIGguZmFjZTIgPT09IHVuZGVmaW5lZCB8fCBmYWNlc1sgaC5mYWNlMSBdLm5vcm1hbC5kb3QoIGZhY2VzWyBoLmZhY2UyIF0ubm9ybWFsICkgPCAwLjk5OTkgKSB7IC8vIGhhcmR3aXJlZCBjb25zdCBPS1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XHJcblx0XHRcdGNvb3Jkc1sgaW5kZXggKysgXSA9IHZlcnRleC54O1xyXG5cdFx0XHRjb29yZHNbIGluZGV4ICsrIF0gPSB2ZXJ0ZXgueTtcclxuXHRcdFx0Y29vcmRzWyBpbmRleCArKyBdID0gdmVydGV4Lno7XHJcblxyXG5cdFx0XHR2ZXJ0ZXggPSB2ZXJ0aWNlc1sgaC52ZXJ0MiBdO1xyXG5cdFx0XHRjb29yZHNbIGluZGV4ICsrIF0gPSB2ZXJ0ZXgueDtcclxuXHRcdFx0Y29vcmRzWyBpbmRleCArKyBdID0gdmVydGV4Lnk7XHJcblx0XHRcdGNvb3Jkc1sgaW5kZXggKysgXSA9IHZlcnRleC56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSwgVEhSRUUuTGluZVBpZWNlcyApO1xyXG5cclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLm1hdHJpeFdvcmxkID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiovXHJcblxyXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcclxuXHJcblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcclxuXHJcblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XHJcblxyXG5cdHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuXHR2YXIgZmFjZXMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5mYWNlcztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblxyXG5cdH1cclxuXHJcblx0VEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICksIFRIUkVFLkxpbmVQaWVjZXMgKTtcclxuXHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMubm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdHZhciBmYWNlcyA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xyXG5cclxuXHRcdHZhciB3b3JsZE1hdHJpeCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHR2MS5jb3B5KCBmYWNlLm5vcm1hbCApLmFwcGx5TWF0cml4MyggdGhpcy5ub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICk7XHJcblxyXG5cdFx0XHR2YXIgaWR4ID0gMiAqIGk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1sgaWR4IF0uY29weSggZmFjZS5jZW50cm9pZCApLmFwcGx5TWF0cml4NCggd29ybGRNYXRyaXggKTtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyBpZHggKyAxIF0uYWRkVmVjdG9ycyggdmVydGljZXNbIGlkeCBdLCB2MSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn0oKSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuR3JpZEhlbHBlciA9IGZ1bmN0aW9uICggc2l6ZSwgc3RlcCApIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0gKTtcclxuXHJcblx0dGhpcy5jb2xvcjEgPSBuZXcgVEhSRUUuQ29sb3IoIDB4NDQ0NDQ0ICk7XHJcblx0dGhpcy5jb2xvcjIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ODg4ODg4ICk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gLSBzaXplOyBpIDw9IHNpemU7IGkgKz0gc3RlcCApIHtcclxuXHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAwLCBpICksIG5ldyBUSFJFRS5WZWN0b3IzKCBzaXplLCAwLCBpICksXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCAtIHNpemUgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIGksIDAsIHNpemUgKVxyXG5cdFx0KTtcclxuXHJcblx0XHR2YXIgY29sb3IgPSBpID09PSAwID8gdGhpcy5jb2xvcjEgOiB0aGlzLmNvbG9yMjtcclxuXHJcblx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcclxuXHJcblx0fVxyXG5cclxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCwgVEhSRUUuTGluZVBpZWNlcyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uKCBjb2xvckNlbnRlckxpbmUsIGNvbG9yR3JpZCApIHtcclxuXHJcblx0dGhpcy5jb2xvcjEuc2V0KCBjb2xvckNlbnRlckxpbmUgKTtcclxuXHR0aGlzLmNvbG9yMi5zZXQoIGNvbG9yR3JpZCApO1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSwgYXJyb3dMZW5ndGgsIGRvbWVTaXplICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdHRoaXMubWF0cml4V29ybGQgPSBsaWdodC5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5jb2xvcnMgPSBbIG5ldyBUSFJFRS5Db2xvcigpLCBuZXcgVEhSRUUuQ29sb3IoKSBdO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcclxuXHRnZW9tZXRyeS5hcHBseU1hdHJpeCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlUm90YXRpb25YKCAtIE1hdGguUEkgLyAyICkgKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IDg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5mYWNlc1sgaSBdLmNvbG9yID0gdGhpcy5jb2xvcnNbIGkgPCA0ID8gMCA6IDEgXTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzLCB3aXJlZnJhbWU6IHRydWUgfSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0U3BoZXJlICk7XHJcblxyXG5cdHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG59O1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29sb3JzWyAwIF0uY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xyXG5cdFx0dGhpcy5jb2xvcnNbIDEgXS5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0dGhpcy5saWdodFNwaGVyZS5sb29rQXQoIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xyXG5cdFx0dGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufSgpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xyXG5cclxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMubWF0cml4V29ybGQgPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHQvKlxyXG5cdHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcclxuXHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcclxuXHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xyXG5cclxuXHR2YXIgZCA9IGxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuXHRpZiAoIGQgPT09IDAuMCApIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XHJcblx0Ki9cclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cdFxyXG5cdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcblx0LypcclxuXHR2YXIgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XHJcblxyXG5cdGlmICggZCA9PT0gMC4wICkge1xyXG5cclxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xyXG5cclxuXHR9XHJcblx0Ki9cclxuXHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4qL1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHR0aGlzLm1hdHJpeFdvcmxkID0gbGlnaHQubWF0cml4V29ybGQ7XHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAxLCAxLCA4LCAxLCB0cnVlICk7XHJcblxyXG5cdGdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbiggMCwgLTAuNSwgMCApICk7XHJcblx0Z2VvbWV0cnkuYXBwbHlNYXRyaXgoIG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVJvdGF0aW9uWCggLSBNYXRoLlBJIC8gMiApICk7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xyXG5cdFxyXG5cdHRoaXMuY29uZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHR0aGlzLmFkZCggdGhpcy5jb25lICk7XHJcblxyXG5cdHRoaXMudXBkYXRlKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxufTtcclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgdmVjdG9yMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDAwO1xyXG5cdFx0dmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xyXG5cclxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XHJcblxyXG5cdFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0dmVjdG9yMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dGhpcy5jb25lLmxvb2tBdCggdmVjdG9yMi5zdWIoIHZlY3RvciApICk7XHJcblxyXG5cdFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuKi9cclxuXHJcblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XHJcblxyXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XHJcblxyXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmYwMDAwO1xyXG5cclxuXHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gb2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHR2YXIgZmFjZXMgPSBvYmplY3QuZ2VvbWV0cnkuZmFjZXM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0VEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICksIFRIUkVFLkxpbmVQaWVjZXMgKTtcclxuXHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMubm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuXHJcblx0dGhpcy51cGRhdGUoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24oIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJywgJ2QnIF07XHJcblxyXG5cdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHR0aGlzLm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHR2YXIgdmVydHMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHR2YXIgZmFjZXMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5mYWNlcztcclxuXHJcblx0XHR2YXIgd29ybGRNYXRyaXggPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHR2YXIgaWR4ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleElkID0gZmFjZVsga2V5c1sgaiBdIF07XHJcblx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRzWyB2ZXJ0ZXhJZCBdO1xyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF07XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzWyBpZHggXS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIHdvcmxkTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdHYxLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4MyggdGhpcy5ub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICk7XHJcblxyXG5cdFx0XHRcdHYxLmFkZCggdmVydGljZXNbIGlkeCBdICk7XHJcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdFx0dmVydGljZXNbIGlkeCBdLmNvcHkoIHYxICk7XHJcblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59KCkpO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4qL1xyXG5cclxuVEhSRUUuVmVydGV4VGFuZ2VudHNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XHJcblxyXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XHJcblxyXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4MDAwMGZmO1xyXG5cclxuXHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gb2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHR2YXIgZmFjZXMgPSBvYmplY3QuZ2VvbWV0cnkuZmFjZXM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleFRhbmdlbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApLCBUSFJFRS5MaW5lUGllY2VzICk7XHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5WZXJ0ZXhUYW5nZW50c0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xyXG5cclxuXHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHR2YXIgdmVydHMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHR2YXIgZmFjZXMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5mYWNlcztcclxuXHJcblx0XHR2YXIgd29ybGRNYXRyaXggPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHR2YXIgaWR4ID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4VGFuZ2VudHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0ZXhJZCA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0c1sgdmVydGV4SWQgXTtcclxuXHJcblx0XHRcdFx0dmFyIHRhbmdlbnQgPSBmYWNlLnZlcnRleFRhbmdlbnRzWyBqIF07XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzWyBpZHggXS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIHdvcmxkTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdHYxLmNvcHkoIHRhbmdlbnQgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIHdvcmxkTWF0cml4ICkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApO1xyXG5cclxuXHRcdFx0XHR2MS5hZGQoIHZlcnRpY2VzWyBpZHggXSApO1xyXG5cdFx0XHRcdGlkeCA9IGlkeCArIDE7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzWyBpZHggXS5jb3B5KCB2MSApO1xyXG5cdFx0XHRcdGlkeCA9IGlkeCArIDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufSgpKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLldpcmVmcmFtZUhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBoZXggKSB7XHJcblxyXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xyXG5cclxuXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XHJcblx0dmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uICggYSwgYiApIHsgcmV0dXJuIGEgLSBiIH07XHJcblxyXG5cdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdGlmICggb2JqZWN0Lmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gb2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0dmFyIGZhY2VzID0gb2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xyXG5cdFx0dmFyIG51bUVkZ2VzID0gMDtcclxuXHJcblx0XHQvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcclxuXHRcdHZhciBlZGdlcyA9IG5ldyBVaW50MzJBcnJheSggNiAqIGZhY2VzLmxlbmd0aCApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcclxuXHRcdFx0XHRlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcclxuXHRcdFx0XHRlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xyXG5cclxuXHRcdFx0XHR2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xyXG5cdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcclxuXHRcdFx0XHRcdGhhc2hbIGtleSBdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdG51bUVkZ2VzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgRmxvYXQzMkFycmF5LCAyICogbnVtRWRnZXMsIDMgKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGVkZ2VzIFsgMiAqIGkgKyBqXSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xyXG5cdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0ZXgueDtcclxuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGV4Lnk7XHJcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRleC56O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICggb2JqZWN0Lmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgJiYgb2JqZWN0Lmdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5kZXggIT09IHVuZGVmaW5lZCApIHsgLy8gaW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IG9iamVjdC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cdFx0dmFyIGluZGljZXMgPSBvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleC5hcnJheTtcclxuXHRcdHZhciBvZmZzZXRzID0gb2JqZWN0Lmdlb21ldHJ5Lm9mZnNldHM7XHJcblx0XHR2YXIgbnVtRWRnZXMgPSAwO1xyXG5cclxuXHRcdC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxyXG5cdFx0dmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCAyICogaW5kaWNlcy5sZW5ndGggKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgbyA9IDAsIG9sID0gb2Zmc2V0cy5sZW5ndGg7IG8gPCBvbDsgKysgbyApIHtcclxuXHJcblx0XHRcdHZhciBzdGFydCA9IG9mZnNldHNbIG8gXS5zdGFydDtcclxuXHRcdFx0dmFyIGNvdW50ID0gb2Zmc2V0c1sgbyBdLmNvdW50O1xyXG5cdFx0XHR2YXIgaW5kZXggPSBvZmZzZXRzWyBvIF0uaW5kZXg7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGVkZ2VbIDAgXSA9IGluZGV4ICsgaW5kaWNlc1sgaSArIGogXTtcclxuXHRcdFx0XHRcdGVkZ2VbIDEgXSA9IGluZGV4ICsgaW5kaWNlc1sgaSArICggaiArIDEgKSAlIDMgXTtcclxuXHRcdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XHJcblx0XHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XHJcblx0XHRcdFx0XHRcdGhhc2hbIGtleSBdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0bnVtRWRnZXMgKys7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgRmxvYXQzMkFycmF5LCAyICogbnVtRWRnZXMsIDMgKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xyXG5cdFx0XHRcdHZhciBpbmRleDIgPSAzICogZWRnZXNbIDIgKiBpICsgal07XHJcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzWyBpbmRleDIgXTtcclxuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcclxuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXNbIGluZGV4MiArIDIgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoIG9iamVjdC5nZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5XHQpIHsgLy8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuXHRcdHZhciBudW1FZGdlcyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XHJcblx0XHR2YXIgbnVtVHJpcyA9IG51bUVkZ2VzIC8gMztcclxuXHJcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIEZsb2F0MzJBcnJheSwgMiAqIG51bUVkZ2VzLCAzICk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtVHJpczsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kZXggPSAxOCAqIGkgKyA2ICogajtcclxuXHJcblx0XHRcdFx0dmFyIGluZGV4MSA9IDkgKiBpICsgMyAqIGo7XHJcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzWyBpbmRleDEgXTtcclxuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MSArIDEgXTtcclxuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXNbIGluZGV4MSArIDIgXTtcclxuXHJcblx0XHRcdFx0dmFyIGluZGV4MiA9IDkgKiBpICsgMyAqICggKCBqICsgMSApICUgMyApO1xyXG5cdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAzIF0gPSB2ZXJ0aWNlc1sgaW5kZXgyIF07XHJcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDQgXSA9IHZlcnRpY2VzWyBpbmRleDIgKyAxIF07XHJcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDUgXSA9IHZlcnRpY2VzWyBpbmRleDIgKyAyIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApLCBUSFJFRS5MaW5lUGllY2VzICk7XHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMubWF0cml4V29ybGQgPSBvYmplY3QubWF0cml4V29ybGQ7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHJlbmRlckNhbGxiYWNrICkgeyB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmxlbnNGbGFyZXMgPSBbXTtcclxuXHJcblx0dGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHVuZGVmaW5lZDtcclxuXHJcblx0aWYoIHRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuXHJcbi8qXHJcbiAqIEFkZDogYWRkcyBhbm90aGVyIGZsYXJlXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IsIG9wYWNpdHkgKSB7XHJcblxyXG5cdGlmKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gLTE7XHJcblx0aWYoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XHJcblx0aWYoIG9wYWNpdHkgPT09IHVuZGVmaW5lZCApIG9wYWNpdHkgPSAxO1xyXG5cdGlmKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblx0aWYoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuXHRkaXN0YW5jZSA9IE1hdGgubWluKCBkaXN0YW5jZSwgTWF0aC5tYXgoIDAsIGRpc3RhbmNlICkgKTtcclxuXHJcblx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHsgdGV4dHVyZTogdGV4dHVyZSwgXHRcdFx0Ly8gVEhSRUUuVGV4dHVyZVxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLCBcdFx0XHRcdC8vIHNpemUgaW4gcGl4ZWxzICgtMSA9IHVzZSB0ZXh0dXJlLndpZHRoKVxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsIFx0XHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXHJcblx0XHQgICAgICAgICAgICAgICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsXHRcdFx0Ly8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBvbnRvcCB6ID0gMSBpcyBiYWNrXHJcblx0XHQgICAgICAgICAgICAgICAgICAgIHNjYWxlOiAxLCBcdFx0XHRcdFx0Ly8gc2NhbGVcclxuXHRcdCAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IDEsIFx0XHRcdFx0Ly8gcm90YXRpb25cclxuXHRcdCAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcdFx0XHQvLyBvcGFjaXR5XHJcblx0XHRcdFx0XHRcdFx0Y29sb3I6IGNvbG9yLFx0XHRcdFx0Ly8gY29sb3JcclxuXHRcdCAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmc6IGJsZW5kaW5nIH0gKTtcdFx0Ly8gYmxlbmRpbmdcclxuXHJcbn07XHJcblxyXG5cclxuLypcclxuICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXHJcbiAqIFNldCBteUxlbnNGbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayB0byBhbHRlciB0aGUgZmxhcmVzIGluIHlvdXIgcHJvamVjdCBzcGVjaWZpYyB3YXkuXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS51cGRhdGVMZW5zRmxhcmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xyXG5cdHZhciBmbGFyZTtcclxuXHR2YXIgdmVjWCA9IC10aGlzLnBvc2l0aW9uU2NyZWVuLnggKiAyO1xyXG5cdHZhciB2ZWNZID0gLXRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XHJcblxyXG5cdGZvciggZiA9IDA7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRmbGFyZSA9IHRoaXMubGVuc0ZsYXJlc1sgZiBdO1xyXG5cclxuXHRcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XHJcblx0XHRmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xyXG5cclxuXHRcdGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xyXG5cdFx0ZmxhcmUucm90YXRpb24gKz0gKCBmbGFyZS53YW50ZWRSb3RhdGlvbiAtIGZsYXJlLnJvdGF0aW9uICkgKiAwLjI1O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcclxuXHR0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XHJcblxyXG5cdC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cclxuXHQvLyAoYWxsIGZyYW1lcyBwbGF5ZWQgdG9nZXRoZXIgaW4gMSBzZWNvbmQpXHJcblxyXG5cdHZhciBudW1GcmFtZXMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG5cdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcclxuXHJcblx0dmFyIHN0YXJ0RnJhbWUgPSAwO1xyXG5cdHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XHJcblxyXG5cdHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xyXG5cclxuXHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xyXG5cdHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jcmVhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIHN0YXJ0LCBlbmQsIGZwcyApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHtcclxuXHJcblx0XHRzdGFydEZyYW1lOiBzdGFydCxcclxuXHRcdGVuZEZyYW1lOiBlbmQsXHJcblxyXG5cdFx0bGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXHJcblxyXG5cdFx0ZnBzOiBmcHMsXHJcblx0XHRkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxyXG5cclxuXHRcdGxhc3RGcmFtZTogMCxcclxuXHRcdGN1cnJlbnRGcmFtZTogMCxcclxuXHJcblx0XHRhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdHRpbWU6IDAsXHJcblx0XHRkaXJlY3Rpb246IDEsXHJcblx0XHR3ZWlnaHQ6IDEsXHJcblxyXG5cdFx0ZGlyZWN0aW9uQmFja3dhcmRzOiBmYWxzZSxcclxuXHRcdG1pcnJvcmVkTG9vcDogZmFsc2VcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF0gPSBhbmltYXRpb247XHJcblx0dGhpcy5hbmltYXRpb25zTGlzdC5wdXNoKCBhbmltYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcclxuXHJcblx0dmFyIHBhdHRlcm4gPSAvKFthLXpdKykoXFxkKykvO1xyXG5cclxuXHR2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XHJcblx0XHR2YXIgY2h1bmtzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xyXG5cclxuXHRcdGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0dmFyIG5hbWUgPSBjaHVua3NbIDEgXTtcclxuXHRcdFx0dmFyIG51bSA9IGNodW5rc1sgMiBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGZyYW1lUmFuZ2VzWyBuYW1lIF0gKSBmcmFtZVJhbmdlc1sgbmFtZSBdID0geyBzdGFydDogSW5maW5pdHksIGVuZDogLUluZmluaXR5IH07XHJcblxyXG5cdFx0XHR2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0aWYgKCBpIDwgcmFuZ2Uuc3RhcnQgKSByYW5nZS5zdGFydCA9IGk7XHJcblx0XHRcdGlmICggaSA+IHJhbmdlLmVuZCApIHJhbmdlLmVuZCA9IGk7XHJcblxyXG5cdFx0XHRpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IG5hbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHZhciBuYW1lIGluIGZyYW1lUmFuZ2VzICkge1xyXG5cclxuXHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcblx0XHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgZnBzICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAxO1xyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAtMTtcclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5mcHMgPSBmcHM7XHJcblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5mcHM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG5cdFx0YW5pbWF0aW9uLmZwcyA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbldlaWdodCA9IGZ1bmN0aW9uICggbmFtZSwgd2VpZ2h0ICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi53ZWlnaHQgPSB3ZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSwgdGltZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSA9IHRpbWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIHRpbWUgPSAwO1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdHRpbWUgPSBhbmltYXRpb24udGltZTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGltZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBkdXJhdGlvbiA9IC0xO1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBkdXJhdGlvbjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSA9IDA7XHJcblx0XHRhbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRUSFJFRS5vbndhcm5pbmcoIFwiYW5pbWF0aW9uW1wiICsgbmFtZSArIFwiXSB1bmRlZmluZWRcIiApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNMaXN0WyBpIF07XHJcblxyXG5cdFx0aWYgKCAhIGFuaW1hdGlvbi5hY3RpdmUgKSBjb250aW51ZTtcclxuXHJcblx0XHR2YXIgZnJhbWVUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uIC8gYW5pbWF0aW9uLmxlbmd0aDtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZGlyZWN0aW9uICogZGVsdGE7XHJcblxyXG5cdFx0aWYgKCBhbmltYXRpb24ubWlycm9yZWRMb29wICkge1xyXG5cclxuXHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiB8fCBhbmltYXRpb24udGltZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gKj0gLTE7XHJcblxyXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0YW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24uZHVyYXRpb247XHJcblx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IDA7XHJcblx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24udGltZSAlIGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcblx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIga2V5ZnJhbWUgPSBhbmltYXRpb24uc3RhcnRGcmFtZSArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XHJcblx0XHR2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcclxuXHJcblx0XHRpZiAoIGtleWZyYW1lICE9PSBhbmltYXRpb24uY3VycmVudEZyYW1lICkge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9IDA7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSAxICogd2VpZ2h0O1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XHJcblx0XHRcdGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcclxuXHJcblx0XHRpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xyXG5cclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gKCAxIC0gbWl4ICkgKiB3ZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MZW5zRmxhcmVQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBfZ2wsIF9yZW5kZXJlciwgX3ByZWNpc2lvbiwgX2xlbnNGbGFyZSA9IHt9O1xyXG5cclxuXHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdF9nbCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcblx0XHRfcmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHJcblx0XHRfcHJlY2lzaW9uID0gcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCk7XHJcblxyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKyA4ICk7XHJcblx0XHRfbGVuc0ZsYXJlLmZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCA2ICk7XHJcblxyXG5cdFx0dmFyIGkgPSAwO1xyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAtMTsgX2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAtMTtcdC8vIHZlcnRleFxyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAwOyAgX2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAwO1x0Ly8gdXYuLi4gZXRjLlxyXG5cclxuXHRcdF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMTsgIF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gLTE7XHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDE7ICBfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDA7XHJcblxyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAxOyAgX2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAxO1xyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAxOyAgX2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAxO1xyXG5cclxuXHRcdF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gLTE7IF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMTtcclxuXHRcdF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMDsgIF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMTtcclxuXHJcblx0XHRpID0gMDtcclxuXHRcdF9sZW5zRmxhcmUuZmFjZXNbIGkrKyBdID0gMDsgX2xlbnNGbGFyZS5mYWNlc1sgaSsrIF0gPSAxOyBfbGVuc0ZsYXJlLmZhY2VzWyBpKysgXSA9IDI7XHJcblx0XHRfbGVuc0ZsYXJlLmZhY2VzWyBpKysgXSA9IDA7IF9sZW5zRmxhcmUuZmFjZXNbIGkrKyBdID0gMjsgX2xlbnNGbGFyZS5mYWNlc1sgaSsrIF0gPSAzO1xyXG5cclxuXHRcdC8vIGJ1ZmZlcnNcclxuXHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRleEJ1ZmZlciAgICAgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRfbGVuc0ZsYXJlLmVsZW1lbnRCdWZmZXIgICAgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIF9sZW5zRmxhcmUudmVydGV4QnVmZmVyICk7XHJcblx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgX2xlbnNGbGFyZS52ZXJ0aWNlcywgX2dsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX2xlbnNGbGFyZS5lbGVtZW50QnVmZmVyICk7XHJcblx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBfbGVuc0ZsYXJlLmZhY2VzLCBfZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcblx0XHQvLyB0ZXh0dXJlc1xyXG5cclxuXHRcdF9sZW5zRmxhcmUudGVtcFRleHR1cmUgICAgICA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblx0XHRfbGVuc0ZsYXJlLm9jY2x1c2lvblRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIF9sZW5zRmxhcmUudGVtcFRleHR1cmUgKTtcclxuXHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgX2dsLlJHQiwgMTYsIDE2LCAwLCBfZ2wuUkdCLCBfZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xyXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIF9nbC5URVhUVVJFXzJELCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggX2dsLlRFWFRVUkVfMkQsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCBfZ2wuVEVYVFVSRV8yRCwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgX2dsLk5FQVJFU1QgKTtcclxuXHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCBfZ2wuVEVYVFVSRV8yRCwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgX2dsLk5FQVJFU1QgKTtcclxuXHJcblx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBfbGVuc0ZsYXJlLm9jY2x1c2lvblRleHR1cmUgKTtcclxuXHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgX2dsLlJHQkEsIDE2LCAxNiwgMCwgX2dsLlJHQkEsIF9nbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XHJcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggX2dsLlRFWFRVUkVfMkQsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCBfZ2wuVEVYVFVSRV8yRCwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIF9nbC5URVhUVVJFXzJELCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBfZ2wuTkVBUkVTVCApO1xyXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIF9nbC5URVhUVVJFXzJELCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBfZ2wuTkVBUkVTVCApO1xyXG5cclxuXHRcdGlmICggX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApIDw9IDAgKSB7XHJcblxyXG5cdFx0XHRfbGVuc0ZsYXJlLmhhc1ZlcnRleFRleHR1cmUgPSBmYWxzZTtcclxuXHRcdFx0X2xlbnNGbGFyZS5wcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggVEhSRUUuU2hhZGVyRmxhcmVzWyBcImxlbnNGbGFyZVwiIF0sIF9wcmVjaXNpb24gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2xlbnNGbGFyZS5oYXNWZXJ0ZXhUZXh0dXJlID0gdHJ1ZTtcclxuXHRcdFx0X2xlbnNGbGFyZS5wcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggVEhSRUUuU2hhZGVyRmxhcmVzWyBcImxlbnNGbGFyZVZlcnRleFRleHR1cmVcIiBdLCBfcHJlY2lzaW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9sZW5zRmxhcmUuYXR0cmlidXRlcyA9IHt9O1xyXG5cdFx0X2xlbnNGbGFyZS51bmlmb3JtcyA9IHt9O1xyXG5cclxuXHRcdF9sZW5zRmxhcmUuYXR0cmlidXRlcy52ZXJ0ZXggICAgICAgPSBfZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwicG9zaXRpb25cIiApO1xyXG5cdFx0X2xlbnNGbGFyZS5hdHRyaWJ1dGVzLnV2ICAgICAgICAgICA9IF9nbC5nZXRBdHRyaWJMb2NhdGlvbiAoIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJ1dlwiICk7XHJcblxyXG5cdFx0X2xlbnNGbGFyZS51bmlmb3Jtcy5yZW5kZXJUeXBlICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJyZW5kZXJUeXBlXCIgKTtcclxuXHRcdF9sZW5zRmxhcmUudW5pZm9ybXMubWFwICAgICAgICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwibWFwXCIgKTtcclxuXHRcdF9sZW5zRmxhcmUudW5pZm9ybXMub2NjbHVzaW9uTWFwICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwib2NjbHVzaW9uTWFwXCIgKTtcclxuXHRcdF9sZW5zRmxhcmUudW5pZm9ybXMub3BhY2l0eSAgICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwib3BhY2l0eVwiICk7XHJcblx0XHRfbGVuc0ZsYXJlLnVuaWZvcm1zLmNvbG9yICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX2xlbnNGbGFyZS5wcm9ncmFtLCBcImNvbG9yXCIgKTtcclxuXHRcdF9sZW5zRmxhcmUudW5pZm9ybXMuc2NhbGUgICAgICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwic2NhbGVcIiApO1xyXG5cdFx0X2xlbnNGbGFyZS51bmlmb3Jtcy5yb3RhdGlvbiAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJyb3RhdGlvblwiICk7XHJcblx0XHRfbGVuc0ZsYXJlLnVuaWZvcm1zLnNjcmVlblBvc2l0aW9uID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX2xlbnNGbGFyZS5wcm9ncmFtLCBcInNjcmVlblBvc2l0aW9uXCIgKTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8qXHJcblx0ICogUmVuZGVyIGxlbnMgZmxhcmVzXHJcblx0ICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcclxuXHQgKiAgICAgICAgIHJlYWRzIHRoZXNlIGJhY2sgYW5kIGNhbGN1bGF0ZXMgb2NjbHVzaW9uLlxyXG5cdCAqICAgICAgICAgVGhlbiBfbGVuc0ZsYXJlLnVwZGF0ZV9sZW5zRmxhcmVzKCkgaXMgY2FsbGVkIHRvIHJlLXBvc2l0aW9uIGFuZFxyXG5cdCAqICAgICAgICAgdXBkYXRlIHRyYW5zcGFyZW5jeSBvZiBmbGFyZXMuIFRoZW4gdGhleSBhcmUgcmVuZGVyZWQuXHJcblx0ICpcclxuXHQgKi9cclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0ICkge1xyXG5cclxuXHRcdHZhciBmbGFyZXMgPSBzY2VuZS5fX3dlYmdsRmxhcmVzLFxyXG5cdFx0XHRuRmxhcmVzID0gZmxhcmVzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoICEgbkZsYXJlcyApIHJldHVybjtcclxuXHJcblx0XHR2YXIgdGVtcFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgaW52QXNwZWN0ID0gdmlld3BvcnRIZWlnaHQgLyB2aWV3cG9ydFdpZHRoLFxyXG5cdFx0XHRoYWxmVmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0V2lkdGggKiAwLjUsXHJcblx0XHRcdGhhbGZWaWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0SGVpZ2h0ICogMC41O1xyXG5cclxuXHRcdHZhciBzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodCxcclxuXHRcdFx0c2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xyXG5cclxuXHRcdHZhciBzY3JlZW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAwICksXHJcblx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0XHR2YXIgdW5pZm9ybXMgPSBfbGVuc0ZsYXJlLnVuaWZvcm1zLFxyXG5cdFx0XHRhdHRyaWJ1dGVzID0gX2xlbnNGbGFyZS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdC8vIHNldCBfbGVuc0ZsYXJlIHByb2dyYW0gYW5kIHJlc2V0IGJsZW5kaW5nXHJcblxyXG5cdFx0X2dsLnVzZVByb2dyYW0oIF9sZW5zRmxhcmUucHJvZ3JhbSApO1xyXG5cclxuXHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggX2xlbnNGbGFyZS5hdHRyaWJ1dGVzLnZlcnRleCApO1xyXG5cdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBfbGVuc0ZsYXJlLmF0dHJpYnV0ZXMudXYgKTtcclxuXHJcblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIGxlbnMgZmxhcmVzIHRvIHVwZGF0ZSB0aGVpciBvY2NsdXNpb24gYW5kIHBvc2l0aW9uc1xyXG5cdFx0Ly8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5mb3Jtc1xyXG5cclxuXHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xyXG5cdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAxICk7XHJcblxyXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIF9sZW5zRmxhcmUudmVydGV4QnVmZmVyICk7XHJcblx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XHJcblx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcclxuXHJcblx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBfbGVuc0ZsYXJlLmVsZW1lbnRCdWZmZXIgKTtcclxuXHJcblx0XHRfZ2wuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cdFx0X2dsLmRlcHRoTWFzayggZmFsc2UgKTtcclxuXHJcblx0XHR2YXIgaSwgaiwgamwsIGZsYXJlLCBzcHJpdGU7XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBuRmxhcmVzOyBpICsrICkge1xyXG5cclxuXHRcdFx0c2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQ7XHJcblx0XHRcdHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xyXG5cclxuXHRcdFx0Ly8gY2FsYyBvYmplY3Qgc2NyZWVuIHBvc2l0aW9uXHJcblxyXG5cdFx0XHRmbGFyZSA9IGZsYXJlc1sgaSBdO1xyXG5cclxuXHRcdFx0dGVtcFBvc2l0aW9uLnNldCggZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbMTJdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxM10sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzE0XSApO1xyXG5cclxuXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cdFx0XHR0ZW1wUG9zaXRpb24uYXBwbHlQcm9qZWN0aW9uKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0Ly8gc2V0dXAgYXJyYXlzIGZvciBnbCBwcm9ncmFtc1xyXG5cclxuXHRcdFx0c2NyZWVuUG9zaXRpb24uY29weSggdGVtcFBvc2l0aW9uIClcclxuXHJcblx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPSBzY3JlZW5Qb3NpdGlvbi54ICogaGFsZlZpZXdwb3J0V2lkdGggKyBoYWxmVmlld3BvcnRXaWR0aDtcclxuXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA9IHNjcmVlblBvc2l0aW9uLnkgKiBoYWxmVmlld3BvcnRIZWlnaHQgKyBoYWxmVmlld3BvcnRIZWlnaHQ7XHJcblxyXG5cdFx0XHQvLyBzY3JlZW4gY3VsbFxyXG5cclxuXHRcdFx0aWYgKCBfbGVuc0ZsYXJlLmhhc1ZlcnRleFRleHR1cmUgfHwgKFxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPiAwICYmXHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA8IHZpZXdwb3J0V2lkdGggJiZcclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID4gMCAmJlxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPCB2aWV3cG9ydEhlaWdodCApICkge1xyXG5cclxuXHRcdFx0XHQvLyBzYXZlIGN1cnJlbnQgUkdCIHRvIHRlbXAgdGV4dHVyZVxyXG5cclxuXHRcdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUxICk7XHJcblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgX2xlbnNGbGFyZS50ZW1wVGV4dHVyZSApO1xyXG5cdFx0XHRcdF9nbC5jb3B5VGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIF9nbC5SR0IsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgcGluayBxdWFkXHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDAgKTtcclxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xyXG5cdFx0XHRcdF9nbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XHJcblxyXG5cdFx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuVFJJQU5HTEVTLCA2LCBfZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIGNvcHkgcmVzdWx0IHRvIG9jY2x1c2lvbk1hcFxyXG5cclxuXHRcdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICk7XHJcblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgX2xlbnNGbGFyZS5vY2NsdXNpb25UZXh0dXJlICk7XHJcblx0XHRcdFx0X2dsLmNvcHlUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgX2dsLlJHQkEsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggLSA4LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHQvLyByZXN0b3JlIGdyYXBoaWNzXHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDEgKTtcclxuXHRcdFx0XHRfZ2wuZGlzYWJsZSggX2dsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMSApO1xyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIF9sZW5zRmxhcmUudGVtcFRleHR1cmUgKTtcclxuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuVFJJQU5HTEVTLCA2LCBfZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXHJcblxyXG5cdFx0XHRcdGZsYXJlLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNjcmVlblBvc2l0aW9uIClcclxuXHJcblx0XHRcdFx0aWYgKCBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayApIHtcclxuXHJcblx0XHRcdFx0XHRmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayggZmxhcmUgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmbGFyZS51cGRhdGVMZW5zRmxhcmVzKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIGZsYXJlc1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAyICk7XHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IGZsYXJlLmxlbnNGbGFyZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3ByaXRlID0gZmxhcmUubGVuc0ZsYXJlc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggc3ByaXRlLm9wYWNpdHkgPiAwLjAwMSAmJiBzcHJpdGUuc2NhbGUgPiAwLjAwMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcclxuXHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueSA9IHNwcml0ZS55O1xyXG5cdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XHJcblxyXG5cdFx0XHRcdFx0XHRzaXplID0gc3ByaXRlLnNpemUgKiBzcHJpdGUuc2NhbGUgLyB2aWV3cG9ydEhlaWdodDtcclxuXHJcblx0XHRcdFx0XHRcdHNjYWxlLnggPSBzaXplICogaW52QXNwZWN0O1xyXG5cdFx0XHRcdFx0XHRzY2FsZS55ID0gc2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XHJcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XHJcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBzcHJpdGUucm90YXRpb24gKTtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIHNwcml0ZS5vcGFjaXR5ICk7XHJcblx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRcdFx0XHRfcmVuZGVyZXIuc2V0QmxlbmRpbmcoIHNwcml0ZS5ibGVuZGluZywgc3ByaXRlLmJsZW5kRXF1YXRpb24sIHNwcml0ZS5ibGVuZFNyYywgc3ByaXRlLmJsZW5kRHN0ICk7XHJcblx0XHRcdFx0XHRcdF9yZW5kZXJlci5zZXRUZXh0dXJlKCBzcHJpdGUudGV4dHVyZSwgMSApO1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggX2dsLlRSSUFOR0xFUywgNiwgX2dsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlc3RvcmUgZ2xcclxuXHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0X2dsLmRlcHRoTWFzayggdHJ1ZSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICggc2hhZGVyLCBwcmVjaXNpb24gKSB7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBfZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdHZhciBmcmFnbWVudFNoYWRlciA9IF9nbC5jcmVhdGVTaGFkZXIoIF9nbC5GUkFHTUVOVF9TSEFERVIgKTtcclxuXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBfZ2wuY3JlYXRlU2hhZGVyKCBfZ2wuVkVSVEVYX1NIQURFUiApO1xyXG5cclxuXHRcdHZhciBwcmVmaXggPSBcInByZWNpc2lvbiBcIiArIHByZWNpc2lvbiArIFwiIGZsb2F0O1xcblwiO1xyXG5cclxuXHRcdF9nbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdF9nbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdF9nbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0X2dsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdF9nbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XHJcblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRfZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TaGFkb3dNYXBQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBfZ2wsXHJcblx0X3JlbmRlcmVyLFxyXG5cdF9kZXB0aE1hdGVyaWFsLCBfZGVwdGhNYXRlcmlhbE1vcnBoLCBfZGVwdGhNYXRlcmlhbFNraW4sIF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLFxyXG5cclxuXHRfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXHJcblx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuXHRfbWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRfbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcblx0X21hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCByZW5kZXJlciApIHtcclxuXHJcblx0XHRfZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cdFx0X3JlbmRlcmVyID0gcmVuZGVyZXI7XHJcblxyXG5cdFx0dmFyIGRlcHRoU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRlcHRoUkdCQVwiIF07XHJcblx0XHR2YXIgZGVwdGhVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRlcHRoU2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0X2RlcHRoTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMgfSApO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxNb3JwaCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggeyBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogZGVwdGhVbmlmb3JtcywgbW9ycGhUYXJnZXRzOiB0cnVlIH0gKTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsU2tpbiA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggeyBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogZGVwdGhVbmlmb3Jtcywgc2tpbm5pbmc6IHRydWUgfSApO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsIG1vcnBoVGFyZ2V0czogdHJ1ZSwgc2tpbm5pbmc6IHRydWUgfSApO1xyXG5cclxuXHRcdF9kZXB0aE1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGguX3NoYWRvd1Bhc3MgPSB0cnVlO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCAhICggX3JlbmRlcmVyLnNoYWRvd01hcEVuYWJsZWQgJiYgX3JlbmRlcmVyLnNoYWRvd01hcEF1dG9VcGRhdGUgKSApIHJldHVybjtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSggc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHR2YXIgaSwgaWwsIGosIGpsLCBuLFxyXG5cclxuXHRcdHNoYWRvd01hcCwgc2hhZG93TWF0cml4LCBzaGFkb3dDYW1lcmEsXHJcblx0XHRwcm9ncmFtLCBidWZmZXIsIG1hdGVyaWFsLFxyXG5cdFx0d2ViZ2xPYmplY3QsIG9iamVjdCwgbGlnaHQsXHJcblx0XHRyZW5kZXJMaXN0LFxyXG5cclxuXHRcdGxpZ2h0cyA9IFtdLFxyXG5cdFx0ayA9IDAsXHJcblxyXG5cdFx0Zm9nID0gbnVsbDtcclxuXHJcblx0XHQvLyBzZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcFxyXG5cclxuXHRcdF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XHJcblx0XHRfZ2wuZGlzYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xyXG5cclxuXHRcdGlmICggX3JlbmRlcmVyLnNoYWRvd01hcEN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xyXG5cclxuXHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfcmVuZGVyZXIuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblxyXG5cdFx0Ly8gcHJlcHJvY2VzcyBsaWdodHNcclxuXHRcdC8vIFx0LSBza2lwIGxpZ2h0cyB0aGF0IGFyZSBub3QgY2FzdGluZyBzaGFkb3dzXHJcblx0XHQvL1x0LSBjcmVhdGUgdmlydHVhbCBsaWdodHMgZm9yIGNhc2NhZGVkIHNoYWRvdyBtYXBzXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gc2NlbmUuX19saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRsaWdodCA9IHNjZW5lLl9fbGlnaHRzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0aWYgKCAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApICYmIGxpZ2h0LnNoYWRvd0Nhc2NhZGUgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIG4gPSAwOyBuIDwgbGlnaHQuc2hhZG93Q2FzY2FkZUNvdW50OyBuICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2aXJ0dWFsTGlnaHQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIGxpZ2h0LnNoYWRvd0Nhc2NhZGVBcnJheVsgbiBdICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmlydHVhbExpZ2h0ID0gY3JlYXRlVmlydHVhbExpZ2h0KCBsaWdodCwgbiApO1xyXG5cdFx0XHRcdFx0XHR2aXJ0dWFsTGlnaHQub3JpZ2luYWxDYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZ3lybyA9IG5ldyBUSFJFRS5HeXJvc2NvcGUoKTtcclxuXHRcdFx0XHRcdFx0Z3lyby5wb3NpdGlvbiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVPZmZzZXQ7XHJcblxyXG5cdFx0XHRcdFx0XHRneXJvLmFkZCggdmlydHVhbExpZ2h0ICk7XHJcblx0XHRcdFx0XHRcdGd5cm8uYWRkKCB2aXJ0dWFsTGlnaHQudGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRjYW1lcmEuYWRkKCBneXJvICk7XHJcblxyXG5cdFx0XHRcdFx0XHRsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXSA9IHZpcnR1YWxMaWdodDtcclxuXHJcblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coIFwiQ3JlYXRlZCB2aXJ0dWFsTGlnaHRcIiwgdmlydHVhbExpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHZpcnR1YWxMaWdodCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVBcnJheVsgbiBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR1cGRhdGVWaXJ0dWFsTGlnaHQoIGxpZ2h0LCBuICk7XHJcblxyXG5cdFx0XHRcdFx0bGlnaHRzWyBrIF0gPSB2aXJ0dWFsTGlnaHQ7XHJcblx0XHRcdFx0XHRrICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRsaWdodHNbIGsgXSA9IGxpZ2h0O1xyXG5cdFx0XHRcdGsgKys7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlbmRlciBkZXB0aCBtYXBcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRsaWdodCA9IGxpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGxpZ2h0LnNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNoYWRvd0ZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdFx0aWYgKCBfcmVuZGVyZXIuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdFx0XHRzaGFkb3dGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IHNoYWRvd0ZpbHRlciwgbWFnRmlsdGVyOiBzaGFkb3dGaWx0ZXIsIGZvcm1hdDogVEhSRUUuUkdCQUZvcm1hdCB9O1xyXG5cclxuXHRcdFx0XHRsaWdodC5zaGFkb3dNYXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIGxpZ2h0LnNoYWRvd01hcFdpZHRoLCBsaWdodC5zaGFkb3dNYXBIZWlnaHQsIHBhcnMgKTtcclxuXHRcdFx0XHRsaWdodC5zaGFkb3dNYXBTaXplID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxpZ2h0LnNoYWRvd01hcFdpZHRoLCBsaWdodC5zaGFkb3dNYXBIZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0bGlnaHQuc2hhZG93TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggISBsaWdodC5zaGFkb3dDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0bGlnaHQuc2hhZG93Q2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBsaWdodC5zaGFkb3dDYW1lcmFGb3YsIGxpZ2h0LnNoYWRvd01hcFdpZHRoIC8gbGlnaHQuc2hhZG93TWFwSGVpZ2h0LCBsaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBsaWdodC5zaGFkb3dDYW1lcmFGYXIgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdGxpZ2h0LnNoYWRvd0NhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGxpZ2h0LnNoYWRvd0NhbWVyYUxlZnQsIGxpZ2h0LnNoYWRvd0NhbWVyYVJpZ2h0LCBsaWdodC5zaGFkb3dDYW1lcmFUb3AsIGxpZ2h0LnNoYWRvd0NhbWVyYUJvdHRvbSwgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgbGlnaHQuc2hhZG93Q2FtZXJhRmFyICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0VEhSRUUub25lcnJvciggXCJVbnN1cHBvcnRlZCBsaWdodCB0eXBlIGZvciBzaGFkb3dcIiApO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2NlbmUuYWRkKCBsaWdodC5zaGFkb3dDYW1lcmEgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSAmJiAhIGxpZ2h0LmNhbWVyYUhlbHBlciApIHtcclxuXHJcblx0XHRcdFx0bGlnaHQuY2FtZXJhSGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggbGlnaHQuc2hhZG93Q2FtZXJhICk7XHJcblx0XHRcdFx0bGlnaHQuc2hhZG93Q2FtZXJhLmFkZCggbGlnaHQuY2FtZXJhSGVscGVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0LmlzVmlydHVhbCAmJiB2aXJ0dWFsTGlnaHQub3JpZ2luYWxDYW1lcmEgPT0gY2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHR1cGRhdGVTaGFkb3dDYW1lcmEoIGNhbWVyYSwgbGlnaHQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNoYWRvd01hcCA9IGxpZ2h0LnNoYWRvd01hcDtcclxuXHRcdFx0c2hhZG93TWF0cml4ID0gbGlnaHQuc2hhZG93TWF0cml4O1xyXG5cdFx0XHRzaGFkb3dDYW1lcmEgPSBsaWdodC5zaGFkb3dDYW1lcmE7XHJcblxyXG5cdFx0XHRzaGFkb3dDYW1lcmEucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRfbWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0c2hhZG93Q2FtZXJhLmxvb2tBdCggX21hdHJpeFBvc2l0aW9uICk7XHJcblx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdFx0c2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdGlmICggbGlnaHQuY2FtZXJhSGVscGVyICkgbGlnaHQuY2FtZXJhSGVscGVyLnZpc2libGUgPSBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlO1xyXG5cdFx0XHRpZiAoIGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgKSBsaWdodC5jYW1lcmFIZWxwZXIudXBkYXRlKCk7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIHNoYWRvdyBtYXRyaXhcclxuXHJcblx0XHRcdHNoYWRvd01hdHJpeC5zZXQoIDAuNSwgMC4wLCAwLjAsIDAuNSxcclxuXHRcdFx0XHRcdFx0XHQgIDAuMCwgMC41LCAwLjAsIDAuNSxcclxuXHRcdFx0XHRcdFx0XHQgIDAuMCwgMC4wLCAwLjUsIDAuNSxcclxuXHRcdFx0XHRcdFx0XHQgIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xyXG5cclxuXHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG5cdFx0XHQvLyByZW5kZXIgc2hhZG93IG1hcFxyXG5cclxuXHRcdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93TWFwICk7XHJcblx0XHRcdF9yZW5kZXJlci5jbGVhcigpO1xyXG5cclxuXHRcdFx0Ly8gc2V0IG9iamVjdCBtYXRyaWNlcyAmIGZydXN0dW0gY3VsbGluZ1xyXG5cclxuXHRcdFx0cmVuZGVyTGlzdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBqIF07XHJcblx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cclxuXHRcdFx0XHR3ZWJnbE9iamVjdC5yZW5kZXIgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSAmJiBvYmplY3QuY2FzdFNoYWRvdyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkgfHwgISAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkICkgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHRcdHdlYmdsT2JqZWN0LnJlbmRlciA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZW5kZXIgcmVndWxhciBvYmplY3RzXHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0TWF0ZXJpYWwsIHVzZU1vcnBoaW5nLCB1c2VTa2lubmluZztcclxuXHJcblx0XHRcdGZvciAoIGogPSAwLCBqbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaiBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHdlYmdsT2JqZWN0LnJlbmRlciApIHtcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XHJcblx0XHRcdFx0XHRidWZmZXIgPSB3ZWJnbE9iamVjdC5idWZmZXI7XHJcblxyXG5cdFx0XHRcdFx0Ly8gY3VsbGluZyBpcyBvdmVycmlkZW4gZ2xvYmFsbHkgZm9yIGFsbCBvYmplY3RzXHJcblx0XHRcdFx0XHQvLyB3aGlsZSByZW5kZXJpbmcgZGVwdGggbWFwXHJcblxyXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBkZWFsIHdpdGggTWVzaEZhY2VNYXRlcmlhbCBzb21laG93XHJcblx0XHRcdFx0XHQvLyBpbiB0aGF0IGNhc2UganVzdCB1c2UgdGhlIGZpcnN0IG9mIG1hdGVyaWFsLm1hdGVyaWFscyBmb3Igbm93XHJcblx0XHRcdFx0XHQvLyAocHJvcGVyIHNvbHV0aW9uIHdvdWxkIHJlcXVpcmUgdG8gYnJlYWsgb2JqZWN0cyBieSBtYXRlcmlhbHNcclxuXHRcdFx0XHRcdC8vICBzaW1pbGFybHkgdG8gcmVndWxhciByZW5kZXJpbmcgYW5kIHRoZW4gc2V0IGNvcnJlc3BvbmRpbmdcclxuXHRcdFx0XHRcdC8vICBkZXB0aCBtYXRlcmlhbHMgcGVyIGVhY2ggY2h1bmsgaW5zdGVhZCBvZiBqdXN0IG9uY2UgcGVyIG9iamVjdClcclxuXHJcblx0XHRcdFx0XHRvYmplY3RNYXRlcmlhbCA9IGdldE9iamVjdE1hdGVyaWFsKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHR1c2VNb3JwaGluZyA9IG9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgJiYgb2JqZWN0TWF0ZXJpYWwubW9ycGhUYXJnZXRzO1xyXG5cdFx0XHRcdFx0dXNlU2tpbm5pbmcgPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCAmJiBvYmplY3RNYXRlcmlhbC5za2lubmluZztcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VTa2lubmluZyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsID0gdXNlTW9ycGhpbmcgPyBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbiA6IF9kZXB0aE1hdGVyaWFsU2tpbjtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VNb3JwaGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWxNb3JwaDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBidWZmZXIgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgc2NlbmUuX19saWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXIoIHNoYWRvd0NhbWVyYSwgc2NlbmUuX19saWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzZXQgbWF0cmljZXMgYW5kIHJlbmRlciBpbW1lZGlhdGUgb2JqZWN0c1xyXG5cclxuXHRcdFx0cmVuZGVyTGlzdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBqIF07XHJcblx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICYmIG9iamVjdC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIHNoYWRvd0NhbWVyYSwgc2NlbmUuX19saWdodHMsIGZvZywgX2RlcHRoTWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlc3RvcmUgR0wgc3RhdGVcclxuXHJcblx0XHR2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXHJcblx0XHRjbGVhckFscGhhID0gX3JlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcclxuXHJcblx0XHRfZ2wuY2xlYXJDb2xvciggY2xlYXJDb2xvci5yLCBjbGVhckNvbG9yLmcsIGNsZWFyQ29sb3IuYiwgY2xlYXJBbHBoYSApO1xyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0aWYgKCBfcmVuZGVyZXIuc2hhZG93TWFwQ3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsTGlnaHQoIGxpZ2h0LCBjYXNjYWRlICkge1xyXG5cclxuXHRcdHZhciB2aXJ0dWFsTGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgpO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5pc1ZpcnR1YWwgPSB0cnVlO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5vbmx5U2hhZG93ID0gdHJ1ZTtcclxuXHRcdHZpcnR1YWxMaWdodC5jYXN0U2hhZG93ID0gdHJ1ZTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhTmVhciA9IGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXI7XHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhRmFyID0gbGlnaHQuc2hhZG93Q2FtZXJhRmFyO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFMZWZ0ID0gbGlnaHQuc2hhZG93Q2FtZXJhTGVmdDtcclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFSaWdodCA9IGxpZ2h0LnNoYWRvd0NhbWVyYVJpZ2h0O1xyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYUJvdHRvbSA9IGxpZ2h0LnNoYWRvd0NhbWVyYUJvdHRvbTtcclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFUb3AgPSBsaWdodC5zaGFkb3dDYW1lcmFUb3A7XHJcblxyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgPSBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dEYXJrbmVzcyA9IGxpZ2h0LnNoYWRvd0RhcmtuZXNzO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dCaWFzID0gbGlnaHQuc2hhZG93Q2FzY2FkZUJpYXNbIGNhc2NhZGUgXTtcclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dNYXBXaWR0aCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVXaWR0aFsgY2FzY2FkZSBdO1xyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd01hcEhlaWdodCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVIZWlnaHRbIGNhc2NhZGUgXTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQucG9pbnRzV29ybGQgPSBbXTtcclxuXHRcdHZpcnR1YWxMaWdodC5wb2ludHNGcnVzdHVtID0gW107XHJcblxyXG5cdFx0dmFyIHBvaW50c1dvcmxkID0gdmlydHVhbExpZ2h0LnBvaW50c1dvcmxkLFxyXG5cdFx0XHRwb2ludHNGcnVzdHVtID0gdmlydHVhbExpZ2h0LnBvaW50c0ZydXN0dW07XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgODsgaSArKyApIHtcclxuXHJcblx0XHRcdHBvaW50c1dvcmxkWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRwb2ludHNGcnVzdHVtWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmVhclogPSBsaWdodC5zaGFkb3dDYXNjYWRlTmVhclpbIGNhc2NhZGUgXTtcclxuXHRcdHZhciBmYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZUZhclpbIGNhc2NhZGUgXTtcclxuXHJcblx0XHRwb2ludHNGcnVzdHVtWyAwIF0uc2V0KCAtMSwgLTEsIG5lYXJaICk7XHJcblx0XHRwb2ludHNGcnVzdHVtWyAxIF0uc2V0KCAgMSwgLTEsIG5lYXJaICk7XHJcblx0XHRwb2ludHNGcnVzdHVtWyAyIF0uc2V0KCAtMSwgIDEsIG5lYXJaICk7XHJcblx0XHRwb2ludHNGcnVzdHVtWyAzIF0uc2V0KCAgMSwgIDEsIG5lYXJaICk7XHJcblxyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgNCBdLnNldCggLTEsIC0xLCBmYXJaICk7XHJcblx0XHRwb2ludHNGcnVzdHVtWyA1IF0uc2V0KCAgMSwgLTEsIGZhclogKTtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDYgXS5zZXQoIC0xLCAgMSwgZmFyWiApO1xyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgNyBdLnNldCggIDEsICAxLCBmYXJaICk7XHJcblxyXG5cdFx0cmV0dXJuIHZpcnR1YWxMaWdodDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBTeW5jaHJvbml6ZSB2aXJ0dWFsIGxpZ2h0IHdpdGggdGhlIG9yaWdpbmFsIGxpZ2h0XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIGNhc2NhZGUgKSB7XHJcblxyXG5cdFx0dmFyIHZpcnR1YWxMaWdodCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVBcnJheVsgY2FzY2FkZSBdO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5wb3NpdGlvbi5jb3B5KCBsaWdodC5wb3NpdGlvbiApO1xyXG5cdFx0dmlydHVhbExpZ2h0LnRhcmdldC5wb3NpdGlvbi5jb3B5KCBsaWdodC50YXJnZXQucG9zaXRpb24gKTtcclxuXHRcdHZpcnR1YWxMaWdodC5sb29rQXQoIHZpcnR1YWxMaWdodC50YXJnZXQgKTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93RGFya25lc3MgPSBsaWdodC5zaGFkb3dEYXJrbmVzcztcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93QmlhcyA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVCaWFzWyBjYXNjYWRlIF07XHJcblxyXG5cdFx0dmFyIG5lYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZU5lYXJaWyBjYXNjYWRlIF07XHJcblx0XHR2YXIgZmFyWiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVGYXJaWyBjYXNjYWRlIF07XHJcblxyXG5cdFx0dmFyIHBvaW50c0ZydXN0dW0gPSB2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bTtcclxuXHJcblx0XHRwb2ludHNGcnVzdHVtWyAwIF0ueiA9IG5lYXJaO1xyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgMSBdLnogPSBuZWFyWjtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDIgXS56ID0gbmVhclo7XHJcblx0XHRwb2ludHNGcnVzdHVtWyAzIF0ueiA9IG5lYXJaO1xyXG5cclxuXHRcdHBvaW50c0ZydXN0dW1bIDQgXS56ID0gZmFyWjtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDUgXS56ID0gZmFyWjtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDYgXS56ID0gZmFyWjtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDcgXS56ID0gZmFyWjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBGaXQgc2hhZG93IGNhbWVyYSdzIG9ydGhvIGZydXN0dW0gdG8gY2FtZXJhIGZydXN0dW1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlU2hhZG93Q2FtZXJhKCBjYW1lcmEsIGxpZ2h0ICkge1xyXG5cclxuXHRcdHZhciBzaGFkb3dDYW1lcmEgPSBsaWdodC5zaGFkb3dDYW1lcmEsXHJcblx0XHRcdHBvaW50c0ZydXN0dW0gPSBsaWdodC5wb2ludHNGcnVzdHVtLFxyXG5cdFx0XHRwb2ludHNXb3JsZCA9IGxpZ2h0LnBvaW50c1dvcmxkO1xyXG5cclxuXHRcdF9taW4uc2V0KCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5ICk7XHJcblx0XHRfbWF4LnNldCggLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcCA9IHBvaW50c1dvcmxkWyBpIF07XHJcblxyXG5cdFx0XHRwLmNvcHkoIHBvaW50c0ZydXN0dW1bIGkgXSApO1xyXG5cdFx0XHRUSFJFRS5TaGFkb3dNYXBQbHVnaW4uX19wcm9qZWN0b3IudW5wcm9qZWN0VmVjdG9yKCBwLCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdHAuYXBwbHlNYXRyaXg0KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0XHRpZiAoIHAueCA8IF9taW4ueCApIF9taW4ueCA9IHAueDtcclxuXHRcdFx0aWYgKCBwLnggPiBfbWF4LnggKSBfbWF4LnggPSBwLng7XHJcblxyXG5cdFx0XHRpZiAoIHAueSA8IF9taW4ueSApIF9taW4ueSA9IHAueTtcclxuXHRcdFx0aWYgKCBwLnkgPiBfbWF4LnkgKSBfbWF4LnkgPSBwLnk7XHJcblxyXG5cdFx0XHRpZiAoIHAueiA8IF9taW4ueiApIF9taW4ueiA9IHAuejtcclxuXHRcdFx0aWYgKCBwLnogPiBfbWF4LnogKSBfbWF4LnogPSBwLno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNoYWRvd0NhbWVyYS5sZWZ0ID0gX21pbi54O1xyXG5cdFx0c2hhZG93Q2FtZXJhLnJpZ2h0ID0gX21heC54O1xyXG5cdFx0c2hhZG93Q2FtZXJhLnRvcCA9IF9tYXgueTtcclxuXHRcdHNoYWRvd0NhbWVyYS5ib3R0b20gPSBfbWluLnk7XHJcblxyXG5cdFx0Ly8gY2FuJ3QgcmVhbGx5IGZpdCBuZWFyL2ZhclxyXG5cdFx0Ly9zaGFkb3dDYW1lcmEubmVhciA9IF9taW4uejtcclxuXHRcdC8vc2hhZG93Q2FtZXJhLmZhciA9IF9tYXguejtcclxuXHJcblx0XHRzaGFkb3dDYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEZvciB0aGUgbW9tZW50IGp1c3QgaWdub3JlIG9iamVjdHMgdGhhdCBoYXZlIG11bHRpcGxlIG1hdGVyaWFscyB3aXRoIGRpZmZlcmVudCBhbmltYXRpb24gbWV0aG9kc1xyXG5cdC8vIE9ubHkgdGhlIGZpcnN0IG1hdGVyaWFsIHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50IGZvciBkZWNpZGluZyB3aGljaCBkZXB0aCBtYXRlcmlhbCB0byB1c2UgZm9yIHNoYWRvdyBtYXBzXHJcblxyXG5cdGZ1bmN0aW9uIGdldE9iamVjdE1hdGVyaWFsKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdC5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWxcclxuXHRcdFx0PyBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzWyAwIF1cclxuXHRcdFx0OiBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhZG93TWFwUGx1Z2luLl9fcHJvamVjdG9yID0gbmV3IFRIUkVFLlByb2plY3RvcigpO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgX2dsLCBfcmVuZGVyZXIsIF90ZXh0dXJlO1xyXG5cclxuXHR2YXIgdmVydGljZXMsIGZhY2VzLCB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XHJcblx0dmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xyXG5cclxuXHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdF9nbCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcblx0XHRfcmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHRcdFx0LSAwLjUsIC0gMC41LCAwLCAwLCBcclxuXHRcdFx0ICAwLjUsIC0gMC41LCAxLCAwLFxyXG5cdFx0XHQgIDAuNSwgICAwLjUsIDEsIDEsXHJcblx0XHRcdC0gMC41LCAgIDAuNSwgMCwgMVxyXG5cdFx0XSApO1xyXG5cclxuXHRcdGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXHJcblx0XHRcdDAsIDEsIDIsXHJcblx0XHRcdDAsIDIsIDNcclxuXHRcdF0gKTtcclxuXHJcblx0XHR2ZXJ0ZXhCdWZmZXIgID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0ZWxlbWVudEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XHJcblx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIF9nbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcclxuXHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBfZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcblx0XHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdGF0dHJpYnV0ZXMgPSB7XHJcblx0XHRcdHBvc2l0aW9uOlx0XHRcdF9nbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICdwb3NpdGlvbicgKSxcclxuXHRcdFx0dXY6XHRcdFx0XHRcdF9nbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICd1dicgKVxyXG5cdFx0fTtcclxuXHJcblx0XHR1bmlmb3JtcyA9IHtcclxuXHRcdFx0dXZPZmZzZXQ6XHRcdFx0X2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxyXG5cdFx0XHR1dlNjYWxlOlx0XHRcdF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dlNjYWxlJyApLFxyXG5cclxuXHRcdFx0cm90YXRpb246XHRcdFx0X2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JvdGF0aW9uJyApLFxyXG5cdFx0XHRzY2FsZTpcdFx0XHRcdF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcclxuXHJcblx0XHRcdGNvbG9yOlx0XHRcdFx0X2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NvbG9yJyApLFxyXG5cdFx0XHRtYXA6XHRcdFx0XHRfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxyXG5cdFx0XHRvcGFjaXR5Olx0XHRcdF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxyXG5cclxuXHRcdFx0bW9kZWxWaWV3TWF0cml4OiBcdF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtb2RlbFZpZXdNYXRyaXgnICksXHJcblx0XHRcdHByb2plY3Rpb25NYXRyaXg6XHRfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncHJvamVjdGlvbk1hdHJpeCcgKSxcclxuXHJcblx0XHRcdGZvZ1R5cGU6XHRcdFx0X2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXHJcblx0XHRcdGZvZ0RlbnNpdHk6XHRcdFx0X2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXHJcblx0XHRcdGZvZ05lYXI6XHRcdFx0X2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ05lYXInICksXHJcblx0XHRcdGZvZ0ZhcjpcdFx0XHRcdF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dGYXInICksXHJcblx0XHRcdGZvZ0NvbG9yOlx0XHRcdF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcclxuXHJcblx0XHRcdGFscGhhVGVzdDpcdFx0XHRfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnYWxwaGFUZXN0JyApXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cdFx0Y2FudmFzLndpZHRoID0gODtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSA4O1xyXG5cclxuXHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRcdGNvbnRleHQuZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xyXG5cdFx0Y29udGV4dC5maWxsUmVjdCggMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XHJcblxyXG5cdFx0X3RleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggY2FudmFzICk7XHJcblx0XHRfdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCApIHtcclxuXHJcblx0XHR2YXIgc3ByaXRlcyA9IHNjZW5lLl9fd2ViZ2xTcHJpdGVzLFxyXG5cdFx0XHRuU3ByaXRlcyA9IHNwcml0ZXMubGVuZ3RoO1xyXG5cclxuXHRcdGlmICggISBuU3ByaXRlcyApIHJldHVybjtcclxuXHJcblx0XHQvLyBzZXR1cCBnbFxyXG5cclxuXHRcdF9nbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZXMudXYgKTtcclxuXHJcblx0XHRfZ2wuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG5cdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XHJcblx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcclxuXHJcblx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcblxyXG5cdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKTtcclxuXHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMCApO1xyXG5cclxuXHRcdHZhciBvbGRGb2dUeXBlID0gMDtcclxuXHRcdHZhciBzY2VuZUZvZ1R5cGUgPSAwO1xyXG5cdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcclxuXHJcblx0XHRpZiAoIGZvZyApIHtcclxuXHJcblx0XHRcdF9nbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMSApO1xyXG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSAxO1xyXG5cdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAyICk7XHJcblx0XHRcdFx0b2xkRm9nVHlwZSA9IDI7XHJcblx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMCApO1xyXG5cdFx0XHRvbGRGb2dUeXBlID0gMDtcclxuXHRcdFx0c2NlbmVGb2dUeXBlID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcclxuXHJcblx0XHR2YXIgaSwgc3ByaXRlLCBtYXRlcmlhbCwgZm9nVHlwZSwgc2NhbGUgPSBbXTtcclxuXHJcblx0XHRmb3IoIGkgPSAwOyBpIDwgblNwcml0ZXM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRzcHJpdGUgPSBzcHJpdGVzWyBpIF07XHJcblx0XHRcdG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0aWYgKCBzcHJpdGUudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHNwcml0ZS5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRzcHJpdGUueiA9IC0gc3ByaXRlLl9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbIDE0IF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNwcml0ZXMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHJcblx0XHQvLyByZW5kZXIgYWxsIHNwcml0ZXNcclxuXHJcblx0XHRmb3IoIGkgPSAwOyBpIDwgblNwcml0ZXM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRzcHJpdGUgPSBzcHJpdGVzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHNwcml0ZS52aXNpYmxlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwgPSBzcHJpdGUubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xyXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgc3ByaXRlLl9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdHNjYWxlWyAwIF0gPSBzcHJpdGUuc2NhbGUueDtcclxuXHRcdFx0c2NhbGVbIDEgXSA9IHNwcml0ZS5zY2FsZS55O1xyXG5cclxuXHRcdFx0aWYgKCBzY2VuZS5mb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xyXG5cclxuXHRcdFx0XHRmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Zm9nVHlwZSA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9sZEZvZ1R5cGUgIT09IGZvZ1R5cGUgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcclxuXHRcdFx0XHRvbGRGb2dUeXBlID0gZm9nVHlwZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcclxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIDAsIDAgKTtcclxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBtYXRlcmlhbC5vcGFjaXR5ICk7XHJcblx0XHRcdF9nbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgbWF0ZXJpYWwucm90YXRpb24gKTtcclxuXHRcdFx0X2dsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xyXG5cclxuXHRcdFx0X3JlbmRlcmVyLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0ICk7XHJcblx0XHRcdF9yZW5kZXJlci5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xyXG5cdFx0XHRfcmVuZGVyZXIuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmltYWdlICYmIG1hdGVyaWFsLm1hcC5pbWFnZS53aWR0aCApIHtcclxuXHJcblx0XHRcdFx0X3JlbmRlcmVyLnNldFRleHR1cmUoIG1hdGVyaWFsLm1hcCwgMCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X3JlbmRlcmVyLnNldFRleHR1cmUoIF90ZXh0dXJlLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuVFJJQU5HTEVTLCA2LCBfZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSBnbFxyXG5cclxuXHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSAoKSB7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBfZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBfZ2wuY3JlYXRlU2hhZGVyKCBfZ2wuVkVSVEVYX1NIQURFUiApO1xyXG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gX2dsLmNyZWF0ZVNoYWRlciggX2dsLkZSQUdNRU5UX1NIQURFUiApO1xyXG5cclxuXHRcdF9nbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgW1xyXG5cclxuXHRcdFx0J3ByZWNpc2lvbiAnICsgX3JlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxyXG5cclxuXHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcclxuXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXHJcblx0XHRcdCd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXHJcblx0XHRcdCd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcclxuXHRcdFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxyXG5cdFx0XHQndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcclxuXHJcblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxyXG5cdFx0XHQnYXR0cmlidXRlIHZlYzIgdXY7JyxcclxuXHJcblx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXHJcblxyXG5cdFx0XHQndm9pZCBtYWluKCkgeycsXHJcblxyXG5cdFx0XHRcdCd2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTsnLFxyXG5cclxuXHRcdFx0XHQndmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiAqIHNjYWxlOycsXHJcblxyXG5cdFx0XHRcdCd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxyXG5cdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcclxuXHRcdFx0XHQncm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXHJcblxyXG5cdFx0XHRcdCd2ZWM0IGZpbmFsUG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0J2ZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxyXG5cdFx0XHRcdCdmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxyXG5cdFx0XHRcdCdmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIGZpbmFsUG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0J2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0J30nXHJcblxyXG5cdFx0XS5qb2luKCAnXFxuJyApICk7XHJcblxyXG5cdFx0X2dsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIFtcclxuXHJcblx0XHRcdCdwcmVjaXNpb24gJyArIF9yZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcclxuXHJcblx0XHRcdCd1bmlmb3JtIHZlYzMgY29sb3I7JyxcclxuXHRcdFx0J3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxyXG5cdFx0XHQndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXHJcblxyXG5cdFx0XHQndW5pZm9ybSBpbnQgZm9nVHlwZTsnLFxyXG5cdFx0XHQndW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOycsXHJcblx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcclxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nTmVhcjsnLFxyXG5cdFx0XHQndW5pZm9ybSBmbG9hdCBmb2dGYXI7JyxcclxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXHJcblxyXG5cdFx0XHQndmFyeWluZyB2ZWMyIHZVVjsnLFxyXG5cclxuXHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxyXG5cclxuXHRcdFx0XHQndmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXHJcblxyXG5cdFx0XHRcdCdpZiAoIHRleHR1cmUuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7JyxcclxuXHJcblx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxyXG5cclxuXHRcdFx0XHQnaWYgKCBmb2dUeXBlID4gMCApIHsnLFxyXG5cclxuXHRcdFx0XHRcdCdmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7JyxcclxuXHRcdFx0XHRcdCdmbG9hdCBmb2dGYWN0b3IgPSAwLjA7JyxcclxuXHJcblx0XHRcdFx0XHQnaWYgKCBmb2dUeXBlID09IDEgKSB7JyxcclxuXHJcblx0XHRcdFx0XHRcdCdmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7JyxcclxuXHJcblx0XHRcdFx0XHQnfSBlbHNlIHsnLFxyXG5cclxuXHRcdFx0XHRcdFx0J2NvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTsnLFxyXG5cdFx0XHRcdFx0XHQnZmxvYXQgZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7JyxcclxuXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcclxuXHJcblx0XHRcdFx0XHQnfScsXHJcblxyXG5cdFx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IG1peCggZ2xfRnJhZ0NvbG9yLCB2ZWM0KCBmb2dDb2xvciwgZ2xfRnJhZ0NvbG9yLncgKSwgZm9nRmFjdG9yICk7JyxcclxuXHJcblx0XHRcdFx0J30nLFxyXG5cclxuXHRcdFx0J30nXHJcblxyXG5cdFx0XS5qb2luKCAnXFxuJyApICk7XHJcblxyXG5cdFx0X2dsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xyXG5cdFx0X2dsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XHJcblxyXG5cdFx0X2dsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdF9nbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdHJldHVybiBwcm9ncmFtO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XHJcblxyXG5cdFx0aWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiLnogLSBhLno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBiLmlkIC0gYS5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRGVwdGhQYXNzUGx1Z2luID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuXHR0aGlzLnJlbmRlclRhcmdldCA9IG51bGw7XHJcblxyXG5cdHZhciBfZ2wsXHJcblx0X3JlbmRlcmVyLFxyXG5cdF9kZXB0aE1hdGVyaWFsLCBfZGVwdGhNYXRlcmlhbE1vcnBoLCBfZGVwdGhNYXRlcmlhbFNraW4sIF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLFxyXG5cclxuXHRfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXHJcblx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdF9nbCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcblx0XHRfcmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHJcblx0XHR2YXIgZGVwdGhTaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwiZGVwdGhSR0JBXCIgXTtcclxuXHRcdHZhciBkZXB0aFVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggZGVwdGhTaGFkZXIudW5pZm9ybXMgKTtcclxuXHJcblx0XHRfZGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggeyBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyB9ICk7XHJcblx0XHRfZGVwdGhNYXRlcmlhbE1vcnBoID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7IGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLCBtb3JwaFRhcmdldHM6IHRydWUgfSApO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxTa2luID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7IGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLCBza2lubmluZzogdHJ1ZSB9ICk7XHJcblx0XHRfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbiA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggeyBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogZGVwdGhVbmlmb3JtcywgbW9ycGhUYXJnZXRzOiB0cnVlLCBza2lubmluZzogdHJ1ZSB9ICk7XHJcblxyXG5cdFx0X2RlcHRoTWF0ZXJpYWwuX3NoYWRvd1Bhc3MgPSB0cnVlO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxNb3JwaC5fc2hhZG93UGFzcyA9IHRydWU7XHJcblx0XHRfZGVwdGhNYXRlcmlhbFNraW4uX3NoYWRvd1Bhc3MgPSB0cnVlO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4uX3NoYWRvd1Bhc3MgPSB0cnVlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoICEgdGhpcy5lbmFibGVkICkgcmV0dXJuO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlKCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdHZhciBpLCBpbCwgaiwgamwsIG4sXHJcblxyXG5cdFx0cHJvZ3JhbSwgYnVmZmVyLCBtYXRlcmlhbCxcclxuXHRcdHdlYmdsT2JqZWN0LCBvYmplY3QsIGxpZ2h0LFxyXG5cdFx0cmVuZGVyTGlzdCxcclxuXHJcblx0XHRmb2cgPSBudWxsO1xyXG5cclxuXHRcdC8vIHNldCBHTCBzdGF0ZSBmb3IgZGVwdGggbWFwXHJcblxyXG5cdFx0X2dsLmNsZWFyQ29sb3IoIDEsIDEsIDEsIDEgKTtcclxuXHRcdF9nbC5kaXNhYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRfcmVuZGVyZXIuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHNjZW5lXHJcblxyXG5cdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXHJcblxyXG5cdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHQvLyByZW5kZXIgZGVwdGggbWFwXHJcblxyXG5cdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggdGhpcy5yZW5kZXJUYXJnZXQgKTtcclxuXHRcdF9yZW5kZXJlci5jbGVhcigpO1xyXG5cclxuXHRcdC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcclxuXHJcblx0XHRyZW5kZXJMaXN0ID0gc2NlbmUuX193ZWJnbE9iamVjdHM7XHJcblxyXG5cdFx0Zm9yICggaiA9IDAsIGpsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaiBdO1xyXG5cdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XHJcblxyXG5cdFx0XHR3ZWJnbE9iamVjdC5yZW5kZXIgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gKSB8fCAhICggb2JqZWN0LmZydXN0dW1DdWxsZWQgKSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApIHtcclxuXHJcblx0XHRcdFx0XHRvYmplY3QuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHR3ZWJnbE9iamVjdC5yZW5kZXIgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlbmRlciByZWd1bGFyIG9iamVjdHNcclxuXHJcblx0XHR2YXIgb2JqZWN0TWF0ZXJpYWwsIHVzZU1vcnBoaW5nLCB1c2VTa2lubmluZztcclxuXHJcblx0XHRmb3IgKCBqID0gMCwgamwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBqIF07XHJcblxyXG5cdFx0XHRpZiAoIHdlYmdsT2JqZWN0LnJlbmRlciApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cdFx0XHRcdGJ1ZmZlciA9IHdlYmdsT2JqZWN0LmJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0Ly8gdG9kbzogY3JlYXRlIHByb3BlciBkZXB0aCBtYXRlcmlhbCBmb3IgcGFydGljbGVzXHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gJiYgIW9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdG9iamVjdE1hdGVyaWFsID0gZ2V0T2JqZWN0TWF0ZXJpYWwoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdE1hdGVyaWFsICkgX3JlbmRlcmVyLnNldE1hdGVyaWFsRmFjZXMoIG9iamVjdC5tYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHR1c2VNb3JwaGluZyA9IG9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCAmJiBvYmplY3RNYXRlcmlhbC5tb3JwaFRhcmdldHM7XHJcblx0XHRcdFx0dXNlU2tpbm5pbmcgPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCAmJiBvYmplY3RNYXRlcmlhbC5za2lubmluZztcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VTa2lubmluZyApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbCA9IHVzZU1vcnBoaW5nID8gX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gOiBfZGVwdGhNYXRlcmlhbFNraW47XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHVzZU1vcnBoaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWxNb3JwaDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbCA9IF9kZXB0aE1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggYnVmZmVyIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBzY2VuZS5fX2xpZ2h0cywgZm9nLCBtYXRlcmlhbCwgYnVmZmVyLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyKCBjYW1lcmEsIHNjZW5lLl9fbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNldCBtYXRyaWNlcyBhbmQgcmVuZGVyIGltbWVkaWF0ZSBvYmplY3RzXHJcblxyXG5cdFx0cmVuZGVyTGlzdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlO1xyXG5cclxuXHRcdGZvciAoIGogPSAwLCBqbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGogXTtcclxuXHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIGNhbWVyYSwgc2NlbmUuX19saWdodHMsIGZvZywgX2RlcHRoTWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIEdMIHN0YXRlXHJcblxyXG5cdFx0dmFyIGNsZWFyQ29sb3IgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpLFxyXG5cdFx0Y2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XHJcblxyXG5cdFx0X2dsLmNsZWFyQ29sb3IoIGNsZWFyQ29sb3IuciwgY2xlYXJDb2xvci5nLCBjbGVhckNvbG9yLmIsIGNsZWFyQWxwaGEgKTtcclxuXHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBGb3IgdGhlIG1vbWVudCBqdXN0IGlnbm9yZSBvYmplY3RzIHRoYXQgaGF2ZSBtdWx0aXBsZSBtYXRlcmlhbHMgd2l0aCBkaWZmZXJlbnQgYW5pbWF0aW9uIG1ldGhvZHNcclxuXHQvLyBPbmx5IHRoZSBmaXJzdCBtYXRlcmlhbCB3aWxsIGJlIHRha2VuIGludG8gYWNjb3VudCBmb3IgZGVjaWRpbmcgd2hpY2ggZGVwdGggbWF0ZXJpYWwgdG8gdXNlXHJcblxyXG5cdGZ1bmN0aW9uIGdldE9iamVjdE1hdGVyaWFsKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdC5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWxcclxuXHRcdFx0PyBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzWyAwIF1cclxuXHRcdFx0OiBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKi9cclxuXHJcblRIUkVFLlNoYWRlckZsYXJlcyA9IHtcclxuXHJcblx0J2xlbnNGbGFyZVZlcnRleFRleHR1cmUnOiB7XHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXHJcblxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2VVYgPSB1djtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcImlmKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7XCIsXHJcblx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC4xICkgKTtcIixcclxuXHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7XCIsXHJcblx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKTtcIixcclxuXHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7XCIsXHJcblx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC41ICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ID0gICAgICAgIHZpc2liaWxpdHkuciAvIDkuMDtcIixcclxuXHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5nIC8gOS4wO1wiLFxyXG5cdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XCIsXHJcblx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuYSAvIDkuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblx0XHRcdFx0XHRcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0Ly8gcGluayBzcXVhcmVcclxuXHJcblx0XHRcdFx0XCJpZiggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDEuMCwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vIHJlc3RvcmVcclxuXHJcblx0XHRcdFx0XCJ9IGVsc2UgaWYoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gZmxhcmVcclxuXHJcblx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1wiLFxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwifVwiXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHJcblx0J2xlbnNGbGFyZSc6IHtcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXHJcblxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidlVWID0gdXY7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XCJpZiggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuXHRcdFx0XHRcdFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHQvLyBwaW5rIHNxdWFyZVxyXG5cclxuXHRcdFx0XHRcImlmKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQoIG1hcCwgdlVWICkucmdiLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gcmVzdG9yZVxyXG5cclxuXHRcdFx0XHRcIn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cclxuXHRcdFx0XHQvLyBmbGFyZVxyXG5cclxuXHRcdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hO1wiLFxyXG5cdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICkuYTtcIixcclxuXHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApLmE7XCIsXHJcblx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxyXG5cdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ID0gKCAxLjAgLSB2aXNpYmlsaXR5IC8gNC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXHJcblx0XHRcdFx0XHRcInRleHR1cmUuYSAqPSBvcGFjaXR5ICogdmlzaWJpbGl0eTtcIixcclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApXHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuLy8gRXhwb3J0IHRoZSBUSFJFRSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXHJcbi8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cclxuLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxyXG4vLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cclxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVEhSRUU7XHJcbiAgfVxyXG4gIGV4cG9ydHMuVEhSRUUgPSBUSFJFRTtcclxufSBlbHNlIHtcclxuICB0aGlzWydUSFJFRSddID0gVEhSRUU7XHJcbn1cclxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy90aHJlZS90aHJlZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy90aHJlZVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vICAgICBVbmRlcnNjb3JlLmpzIDEuNS4yXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBFc3RhYmxpc2ggdGhlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgdG8gYnJlYWsgb3V0IG9mIGEgbG9vcCBpdGVyYXRpb24uXG4gIHZhciBicmVha2VyID0ge307XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIGNvbmNhdCAgICAgICAgICAgPSBBcnJheVByb3RvLmNvbmNhdCxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlRm9yRWFjaCAgICAgID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZU1hcCAgICAgICAgICA9IEFycmF5UHJvdG8ubWFwLFxuICAgIG5hdGl2ZVJlZHVjZSAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlLFxuICAgIG5hdGl2ZVJlZHVjZVJpZ2h0ICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQsXG4gICAgbmF0aXZlRmlsdGVyICAgICAgID0gQXJyYXlQcm90by5maWx0ZXIsXG4gICAgbmF0aXZlRXZlcnkgICAgICAgID0gQXJyYXlQcm90by5ldmVyeSxcbiAgICBuYXRpdmVTb21lICAgICAgICAgPSBBcnJheVByb3RvLnNvbWUsXG4gICAgbmF0aXZlSW5kZXhPZiAgICAgID0gQXJyYXlQcm90by5pbmRleE9mLFxuICAgIG5hdGl2ZUxhc3RJbmRleE9mICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2YsXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZDtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjUuMic7XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyBvYmplY3RzIHdpdGggdGhlIGJ1aWx0LWluIGBmb3JFYWNoYCwgYXJyYXlzLCBhbmQgcmF3IG9iamVjdHMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmb3JFYWNoYCBpZiBhdmFpbGFibGUuXG4gIHZhciBlYWNoID0gXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYG1hcGAgaWYgYXZhaWxhYmxlLlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VSaWdodGAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSArbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGluZGV4ID0ga2V5cyA/IGtleXNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IG9ialtpbmRleF07XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2luZGV4XSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGFueShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkge1xuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVGaWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSByZXR1cm4gb2JqLmZpbHRlcihpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiAhaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgIH0sIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZXZlcnlgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlRXZlcnkgJiYgb2JqLmV2ZXJ5ID09PSBuYXRpdmVFdmVyeSkgcmV0dXJuIG9iai5ldmVyeShpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCEocmVzdWx0ID0gcmVzdWx0ICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHNvbWVgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yIHx8IChpdGVyYXRvciA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpIHJldHVybiBvYmouc29tZShpdGVyYXRvciwgY29udGV4dCk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHJlc3VsdCB8fCAocmVzdWx0ID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gb2JqLmluZGV4T2YodGFyZ2V0KSAhPSAtMTtcbiAgICByZXR1cm4gYW55KG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiB2YWx1ZVtrZXldOyB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzLCBmaXJzdCkge1xuICAgIGlmIChfLmlzRW1wdHkoYXR0cnMpKSByZXR1cm4gZmlyc3QgPyB2b2lkIDAgOiBbXTtcbiAgICByZXR1cm4gX1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IHZhbHVlW2tleV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8ud2hlcmUob2JqLCBhdHRycywgdHJ1ZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgb3IgKGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICAvLyBDYW4ndCBvcHRpbWl6ZSBhcnJheXMgb2YgaW50ZWdlcnMgbG9uZ2VyIHRoYW4gNjUsNTM1IGVsZW1lbnRzLlxuICAvLyBTZWUgW1dlYktpdCBCdWcgODA3OTddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD04MDc5NylcbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2JqKTtcbiAgICB9XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzRW1wdHkob2JqKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogLUluZmluaXR5LCB2YWx1ZTogLUluZmluaXR5fTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgY29tcHV0ZWQgPiByZXN1bHQuY29tcHV0ZWQgJiYgKHJlc3VsdCA9IHt2YWx1ZSA6IHZhbHVlLCBjb21wdXRlZCA6IGNvbXB1dGVkfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIG9iaik7XG4gICAgfVxuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0VtcHR5KG9iaikpIHJldHVybiBJbmZpbml0eTtcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogSW5maW5pdHksIHZhbHVlOiBJbmZpbml0eX07XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgIGNvbXB1dGVkIDwgcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhbiBhcnJheSwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZSBcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmFuZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaHVmZmxlZCA9IFtdO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKGluZGV4KyspO1xuICAgICAgc2h1ZmZsZWRbaW5kZXggLSAxXSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudCBmcm9tIHRoZSBhcnJheS5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyIHx8IGd1YXJkKSB7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbG9va3VwIGl0ZXJhdG9ycy5cbiAgdmFyIGxvb2t1cEl0ZXJhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24ob2JqKXsgcmV0dXJuIG9ialt2YWx1ZV07IH07XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdG9yLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgaXRlcmF0b3IgPSB2YWx1ZSA9PSBudWxsID8gXy5pZGVudGl0eSA6IGxvb2t1cEl0ZXJhdG9yKHZhbHVlKTtcbiAgICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgKF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldIDogKHJlc3VsdFtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5LCB2YWx1ZSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIGtleSkge1xuICAgIF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldKysgOiByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhdG9yID09IG51bGwgPyBfLmlkZW50aXR5IDogbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbbWlkXSkgPCB2YWx1ZSA/IGxvdyA9IG1pZCArIDEgOiBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIChuID09IG51bGwpIHx8IGd1YXJkID8gYXJyYXlbMF0gOiBzbGljZS5jYWxsKGFycmF5LCAwLCBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXG4gIC8vIGBfLm1hcGAuXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbikpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmICgobiA9PSBudWxsKSB8fCBndWFyZCkge1xuICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgTWF0aC5tYXgoYXJyYXkubGVuZ3RoIC0gbiwgMCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKlxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIG91dHB1dCkge1xuICAgIGlmIChzaGFsbG93ICYmIF8uZXZlcnkoaW5wdXQsIF8uaXNBcnJheSkpIHtcbiAgICAgIHJldHVybiBjb25jYXQuYXBwbHkob3V0cHV0LCBpbnB1dCk7XG4gICAgfVxuICAgIGVhY2goaW5wdXQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICBzaGFsbG93ID8gcHVzaC5hcHBseShvdXRwdXQsIHZhbHVlKSA6IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIG91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRvcjtcbiAgICAgIGl0ZXJhdG9yID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaW5pdGlhbCA9IGl0ZXJhdG9yID8gXy5tYXAoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSA6IGFycmF5O1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBlYWNoKGluaXRpYWwsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKGlzU29ydGVkID8gKCFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IHZhbHVlKSA6ICFfLmNvbnRhaW5zKHNlZW4sIHZhbHVlKSkge1xuICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuICAgICAgICByZXN1bHRzLnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKF8uZmxhdHRlbihhcmd1bWVudHMsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoXy51bmlxKGFycmF5KSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZXZlcnkocmVzdCwgZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIF8uaW5kZXhPZihvdGhlciwgaXRlbSkgPj0gMDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpOyB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBfLm1heChfLnBsdWNrKGFyZ3VtZW50cywgXCJsZW5ndGhcIikuY29uY2F0KDApKTtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdHNbaV0gPSBfLnBsdWNrKGFyZ3VtZW50cywgJycgKyBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIGlmIChsaXN0ID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBseSB1cyB3aXRoIGluZGV4T2YgKEknbSBsb29raW5nIGF0IHlvdSwgKipNU0lFKiopLFxuICAvLyB3ZSBuZWVkIHRoaXMgZnVuY3Rpb24uIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW5cbiAgLy8gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGluZGV4T2ZgIGlmIGF2YWlsYWJsZS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdudW1iZXInKSB7XG4gICAgICAgIGkgPSAoaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0sIGlzU29ydGVkKTtcbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbGFzdEluZGV4T2ZgIGlmIGF2YWlsYWJsZS5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaGFzSW5kZXggPSBmcm9tICE9IG51bGw7XG4gICAgaWYgKG5hdGl2ZUxhc3RJbmRleE9mICYmIGFycmF5Lmxhc3RJbmRleE9mID09PSBuYXRpdmVMYXN0SW5kZXhPZikge1xuICAgICAgcmV0dXJuIGhhc0luZGV4ID8gYXJyYXkubGFzdEluZGV4T2YoaXRlbSwgZnJvbSkgOiBhcnJheS5sYXN0SW5kZXhPZihpdGVtKTtcbiAgICB9XG4gICAgdmFyIGkgPSAoaGFzSW5kZXggPyBmcm9tIDogYXJyYXkubGVuZ3RoKTtcbiAgICB3aGlsZSAoaS0tKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gYXJndW1lbnRzWzJdIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUoaWR4IDwgbGVuZ3RoKSB7XG4gICAgICByYW5nZVtpZHgrK10gPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV1c2FibGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHByb3RvdHlwZSBzZXR0aW5nLlxuICB2YXIgY3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICB2YXIgYXJncywgYm91bmQ7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICB2YXIgc2VsZiA9IG5ldyBjdG9yO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQmluZCBhbGwgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0XG4gIC8vIGFsbCBjYWxsYmFja3MgZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgZnVuY3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lc1wiKTtcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbihmKSB7IG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7IH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW8gPSB7fTtcbiAgICBoYXNoZXIgfHwgKGhhc2hlciA9IF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpeyByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTsgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5ldyBEYXRlO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3QgPSAobmV3IERhdGUoKSkgLSB0aW1lc3RhbXA7XG4gICAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbE5vdykgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtmdW5jXTtcbiAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB3cmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IGZ1bmNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3MgPSBbZnVuY3NbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gbmF0aXZlS2V5cyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqICE9PSBPYmplY3Qob2JqKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBlYWNoKGtleXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGtleSBpbiBvYmopIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmICghXy5jb250YWlucyhrZXlzLCBrZXkpKSBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAob2JqW3Byb3BdID09PSB2b2lkIDApIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS4gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvclxuICAgICAgICAvLyBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIGEgIT0gK2EgPyBiICE9ICtiIDogKGEgPT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYik7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgcmV0dXJuIGEuc291cmNlID09IGIuc291cmNlICYmXG4gICAgICAgICAgICAgICBhLmdsb2JhbCA9PSBiLmdsb2JhbCAmJlxuICAgICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgICAgIGEuaWdub3JlQ2FzZSA9PSBiLmlnbm9yZUNhc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PSBiO1xuICAgIH1cbiAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHNcbiAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiAoYUN0b3IgaW5zdGFuY2VvZiBhQ3RvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiAoYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcbiAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gYi5sZW5ndGg7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBlcShhW3NpemVdLCBiW3NpemVdLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChfLmhhcyhhLCBrZXkpKSB7XG4gICAgICAgICAgLy8gQ291bnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAgICAgaWYgKF8uaGFzKGIsIGtleSkgJiYgIShzaXplLS0pKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSAhc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cC5cbiAgZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLlxuICBpZiAodHlwZW9mICgvLi8pICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRvcnMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgZXNjYXBlOiB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjeDI3OydcbiAgICB9XG4gIH07XG4gIGVudGl0eU1hcC51bmVzY2FwZSA9IF8uaW52ZXJ0KGVudGl0eU1hcC5lc2NhcGUpO1xuXG4gIC8vIFJlZ2V4ZXMgY29udGFpbmluZyB0aGUga2V5cyBhbmQgdmFsdWVzIGxpc3RlZCBpbW1lZGlhdGVseSBhYm92ZS5cbiAgdmFyIGVudGl0eVJlZ2V4ZXMgPSB7XG4gICAgZXNjYXBlOiAgIG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxuICAgIHVuZXNjYXBlOiBuZXcgUmVnRXhwKCcoJyArIF8ua2V5cyhlbnRpdHlNYXAudW5lc2NhcGUpLmpvaW4oJ3wnKSArICcpJywgJ2cnKVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgXy5lYWNoKFsnZXNjYXBlJywgJ3VuZXNjYXBlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdCc6ICAgICAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdHxcXHUyMDI4fFxcdTIwMjkvZztcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcmVuZGVyO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAgIC5yZXBsYWNlKGVzY2FwZXIsIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTsgfSk7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyBcInJldHVybiBfX3A7XFxuXCI7XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChkYXRhKSByZXR1cm4gcmVuZGVyKGRhdGEsIF8pO1xuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24gc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVyLlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PSAnc2hpZnQnIHx8IG5hbWUgPT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICBfLmV4dGVuZChfLnByb3RvdHlwZSwge1xuXG4gICAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICAgIGNoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgICB9XG5cbiAgfSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIFRIUiA9IHJlcXVpcmUoJ3RocmVlJyk7XG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBfICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblJPVEFURSAgPSAxMDtcblJPVEFURUMgPSAxMTtcbk1PVkUgPSAxMjtcblNIT09UID0gMTM7XG5ISVQgPSAxNTtcblJFTE9BRF9XRUFQT05TID0gMTY7XG5VSV9TRVRUSU5HUyA9IDEwMDA7XG5cblxuXG5cbi8qXG7QkNC60YLQvtGAINC/0YDQuNCy0Y/Qt9Cw0L0g0Log0LzQtdGI0YMsINC80LXRiCDQuiDRgdGG0LXQvdC1LlxuXG7QndC10L7QsdGF0L7QtNC40LzQvjpcbjEg0YHQvtC30LTQsNCy0LDRgtGMINCw0LrRhtC40Lgg0LjQtyDQvdCw0LbQsNGC0LjQuSDQutC90L7Qv9C+0LpcbjIg0YHQvtC30LTQsNCy0LDRgtGMINCw0LrRhtC40Lgg0LjQtyDQvdCw0LbQsNGC0LjQuSDQvdCwINC60L7QvdGC0YDQvtC70YtcbjMg0YHQvtC30LTQsNCy0LDRgtGMINCw0LrRhtC40Lgg0LjQtyDQtNGA0YPQs9C40YUg0LDQutGG0LjQuSDQsNCy0YLQvtC80LDRgtC40YfQtdGB0LrQuCAtINCz0LXQvdC10YDQsNGC0L7RgCDQsNC60YbQuNC5INC00L7Qu9C20LXQvSDQsdGL0YLRjCDQtNC+0YHRgtGD0L/QtdC9INCy0L3Rg9GC0YDQuCDQutC70LDRgdGB0L7QsiDRgNC10LDQs9C40YDQvtCy0LDQvdC40Y8uXG5cbtCh0L7Qt9C00LDQvdC90YvQtSDQsNC60YbQuNC4INC40LzQtdGO0YIg0LLRgdC1INC90LXQvtCx0YXQvtC00LjQvNGL0LUg0L/QsNGA0LDQvNC10YLRgNGLINC00LvRjyDQvtCx0YDQsNCx0L7RgtC60Lgg0LLQvdGD0YLRgNC4INC60LvQsNGB0YHQvtCyXG5cbtCf0L7RgdC70LUg0LPQtdC90LXRgNCw0YbQuNC4INCw0LrRhtC40Lgg0L7RgtC/0YDQsNCy0LvRj9GO0YLRgdGPINC90LAg0YHQtdGA0LLQtdGALlxu0JIg0YDQtdC30YPQu9GM0YLQsNGC0LUg0YDQtdCw0LPQuNGA0L7QstCw0L3QuNGPINCw0LrRhtC40Lgg0LzQvtCz0YPRgiDQv9C+0Y/QstC40YLRjNGB0Y8g0L3QsCDRgdC10YDQstC10YDQtSAtINGC0LDQutC40LUg0LDQutGG0LjQuCDQvdC1INC/0LXRgNC10YHRi9C70LDRjtGC0YHRjyDQvdCwINGB0LXRgNCy0LXRgCDRgSDQutC70LjQtdC90YLQsCwg0LAg0YLQvtC70YzQutC+INC90LDQvtCx0L7RgNC+0YJcblxuXG5cblxu0KLQsNC60LjQvCDQvtCx0YDQsNC30L7QvCwg0L3QtdC+0LHQvtGF0L7QtNC40LzQviDQsiDQuNC90YLQtdGA0YTQtdC50YEg0LrQvtC90YLRgNC+0LvQu9C10YDQsCDQstC60LvRjtGH0LDRgtGMINC40L3RgdGC0LDQvdGBINCz0LXQvdC10YDQsNGC0L7RgNCwINCw0LrRhtC40LkuXG4qL1xuXG4vKlxudmFyIG5ld0FjdGlvbiA9IGZ1bmN0aW9uKHR5cGUsIHdwLCBkZXZpY2UsIG1lc2hfaWQsIHNjZW5lX2lkLCBhY3Rvcl9pZCwgdHMsIHRkaWZmKXtcblx0cmV0dXJuIHt0eXBlOnR5cGUsXG5cdFx0XHR3cDp3cCxcblx0XHRcdGRldmljZTpkZXZpY2UsXG5cdFx0XHRcblx0XHRcdG1lc2hfaWQ6bWVzaF9pZCxcblx0XHRcdHNjZW5lX2lkOnNjZW5lX2lkLFxuXHRcdFx0YWN0b3JfaWQ6YWN0b3JfaWQsXG5cdFx0XHR0czogdHMsXG5cdFx0XHR0ZGlmZjogdGRpZmZ9XG59XG5mdW5jdGlvbiBjdXJyeShmbikge1xuICAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICAgIHN0b3JlZF9hcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3X2FyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgIGFyZ3MgPSBzdG9yZWRfYXJncy5jb25jYXQobmV3X2FyZ3MpO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgIH07XG59XG5cblxudmFyIHdvcmtwb2ludHNBY3Rpb25MaXN0ID0ge1xuXHRwaWxvdDogW11cbn1cblxuKi9cblxuXG52YXIgQ29udHJvbGxlciA9IHtkZXNjcmlwdGlvbjonY29udHJvbGxlcid9XG5cbmlmKHR5cGVvZiB3aW5kb3cgPT09J3VuZGVmaW5lZCcpe1xuXHRcblx0dmFyIEwgPSB7c2V0VmFsdWU6ZnVuY3Rpb24oKXt9fTtcblx0aXNfYnJvd3NlciA9IGZhbHNlO1xufWVsc2V7XG5cdHZhciBMID0gU0w7XG5cdGlzX2Jyb3dzZXIgPSB0cnVlO1xufVxuXG5cblx0XG5Db250cm9sbGVyLk5ldHdvcmtBY3RvciA9ICAgZnVuY3Rpb24ob25BY3QsIFcpe1xuXHRcdFxuXHRcdHZhciBtYXAgPSBDb250cm9sbGVyLkNvbnRyb2xsZXJzQWN0aW9uTWFwKClcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XG5cdFx0dGhpcy5ydW4gPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gbm8gbmVlZCB0byBib3RoZXIgLSBldmVudCBzdHlsZVxuXHRcdH1cblx0XHR0aGlzLmFjdD1mdW5jdGlvbihTLCBhY3Rpb24sIGlzX29uLCBhY3Rvcil7XG5cdFx0XHRpZiAoVyAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0YWN0aW9uLnRpbWVzdGFtcCAtPSBXLl90aW1lX2RpZmZcblx0XHRcdH1cblx0XHRcdHZhciBfYSA9IG1hcFthY3Rpb24uY29udHJvbGxlcl0uYWN0KFMsIGFjdGlvbiwgaXNfb24sIGFjdG9yLCBvbkFjdCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuQ29udHJvbGxlci5Mb2NhbElucHV0QWN0b3IgPSBmdW5jdGlvbihXLCBzb2NrZXQpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLldvcmxkID0gVztcblx0XHR2YXIgbWFwID0gQ29udHJvbGxlci5Db250cm9sbGVyc0FjdGlvbk1hcCgpXG5cdFx0dmFyIGFjdG9yID0gVy5sb2dpbjtcblx0XHRzZWxmLmFjdGlvbnNfYnlfc2NlbmUgPSB7fVxuXHRcdC8vLy8vIEFDVElPTiBUWVBFUyBcblx0XHRST1RBVEUgID0gMTBcblx0XHRST1RBVEVDID0gMTFcblx0XHRNT1ZFID0gMTJcblx0XHRTSE9PVCA9IDEzXG5cdFx0XG5cdFx0XG5cdFx0XG5cblx0XHRzZWxmLl9kZWZhdWx0X2FjdGlvbnM9e1xuXHRcdFxuXHRcdFx0ODc6IHt0eXBlOlJPVEFURSwgY29udHJvbGxlcjpcInBpbG90XCIsICBwOnsgYTowLGQ6LTF9fSxcblx0XHRcdDgzOiB7dHlwZTpST1RBVEUsIGNvbnRyb2xsZXI6XCJwaWxvdFwiLCAgcDp7IGE6MCxkOjF9fSxcblx0XHRcdFxuXHRcdFx0NjU6IHt0eXBlOlJPVEFURSwgY29udHJvbGxlcjpcInBpbG90XCIsICBwOnsgYToxLGQ6MX19LFxuXHRcdFx0Njg6IHt0eXBlOlJPVEFURSwgY29udHJvbGxlcjpcInBpbG90XCIsICBwOnsgYToxLGQ6LTF9fSxcblx0XHRcdFxuXHRcdFx0OTA6IHt0eXBlOlJPVEFURSwgY29udHJvbGxlcjpcInBpbG90XCIsICBwOnsgYToyLGQ6MX19LFxuXHRcdFx0Njc6IHt0eXBlOlJPVEFURSwgY29udHJvbGxlcjpcInBpbG90XCIsICBwOnsgYToyLGQ6LTF9fSxcblx0XHRcblx0XHRcblx0XHRcdDc5OiB7dHlwZTpST1RBVEVDLCBjb250cm9sbGVyOlwicGlsb3RcIiwgcDp7IGE6J3gnLGQ6JysnfX0sXG5cdFx0XHQ4MDoge3R5cGU6Uk9UQVRFQywgY29udHJvbGxlcjpcInBpbG90XCIsIHA6eyBhOid4JyxkOictJ319LFxuXHRcdFxuXHRcdFx0NzM6IHt0eXBlOlJPVEFURUMsIGNvbnRyb2xsZXI6XCJwaWxvdFwiLCBwOnsgYToneScsZDonKyd9fSxcblx0XHRcdDc1OiB7dHlwZTpST1RBVEVDLCBjb250cm9sbGVyOlwicGlsb3RcIiwgcDp7IGE6J3knLGQ6Jy0nfX0sXG5cdFx0XG5cdFx0XHQzODoge3R5cGU6TU9WRSwgY29udHJvbGxlcjpcInBpbG90XCIsIHA6eyBhOjIsZDotMX19LFxuXHRcdFx0NDA6IHt0eXBlOk1PVkUsIGNvbnRyb2xsZXI6XCJwaWxvdFwiLCBwOnsgYToyLGQ6MX19LFxuXHRcdFx0XG5cdFx0XHQ4Mjoge3R5cGU6UkVMT0FEX1dFQVBPTlMsIGNvbnRyb2xsZXI6XCJ0dXJyZXRcIn0sXG5cdFx0XG5cdFx0XHQnbG1vdXNlJzp7dHlwZTogU0hPT1QsIE1BOnRydWUsIGNvbnRyb2xsZXI6XCJ0dXJyZXRcIiwgcDp7ICdfdHVycmV0X2RpcmVjdGlvbic6IGZ1bmN0aW9uKHQsayl7XG5cdFx0XHRcdC8vIGRlbGV0ZSB0W2tdXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwid1wiKVxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhXLmNvbnRyb2xsYWJsZSgpKTtcblx0XHRcdFx0Ly92YXIgVCA9IENvbnRyb2xsZXIuVCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly92YXIgQyA9IFcuY29udHJvbGxhYmxlKCk7XG5cdFx0XHRcdC8vdmFyIENjID0gVy5nZXRfbWFpbl92aWV3cG9ydCgpLmNhbWVyYVxuXHRcdFx0XHQvL3ZhciBjYW1lcmFfcG9zaXRpb25fdmVjdG9yID0gbmV3IFQuVmVjdG9yMygpXG5cdFx0XHRcdC8vY29uc29sZS5sb2coQy5qc29uKTtcblx0XHRcdFx0Ly92YXIgY2FtZXJhID0gIEMuanNvbi5jYW1lcmFzW0NjXVxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKGNhbWVyYSk7XG5cdFx0XHRcdC8vY2FtZXJhX3Bvc2l0aW9uX3ZlY3Rvci5mcm9tQXJyYXkoY2FtZXJhLnBvc2l0aW9uKTtcblx0XHRcdFx0Ly9jYW1lcmFfcG9zaXRpb25fdmVjdG9yLmFwcGx5RXVsZXIoIEMucm90YXRpb24uY2xvbmUoKSApXG5cdFx0XHRcdC8vY2FtZXJhX3Bvc2l0aW9uX3ZlY3Rvci5hZGQoQy5wb3NpdGlvbi5jbG9uZSgpKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcImNhbWVyYSBwb3MgaW4gV1wiLCBjYW1lcmFfcG9zaXRpb25fdmVjdG9yKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJSRVBMQUNJTkdcIixXLm1vdXNlX3Byb2plY3Rpb25fdmVjLmNsb25lKCkpXG5cdFx0XHRcdFxuXHRcdFx0XHR0W2suc3Vic3RyKDEpXSA9IFcubW91c2VfcHJvamVjdGlvbl92ZWMuY2xvbmUoKSAvLy5zdWIoY2FtZXJhX3Bvc2l0aW9uX3ZlY3Rvcilcblx0XHRcdH19fSxcblx0XHR9XG5cdFxuXHRcdHNlbGYuYWN0aW9ucyA9IHNlbGYuX2RlZmF1bHRfYWN0aW9ucztcblx0XHRzZWxmLl9rZXljb2Rlc19pbl9hY3Rpb24gPSB7fVxuXHRcdHRoaXMuaW5wdXQgPSBmdW5jdGlvbihrZXljb2RlLCB1cF9vcl9kb3duLCBtb2RpZmllcnMpe1xuXHRcdFx0dmFyIHRzID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblx0XHRcdFxuXHRcdFx0Ly8gVXBkYXRpbmcgdmFsdWVzIGluIGV2ZW50OlxuXHRcdFx0XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlNTU1NcIik7XG5cdFx0XHRcblx0XHRcdGlmKHVwX29yX2Rvd24pIHsvLyBkb3duID09IHRydWVcblx0XHRcdFx0c2VsZi5fa2V5Y29kZXNfaW5fYWN0aW9uW2tleWNvZGVdID0ge2luX2FjdGlvbjp0cnVlLCB0czp0c31cblx0XHRcdH1lbHNle1xuXHRcdFx0XHRpZihzZWxmLl9rZXljb2Rlc19pbl9hY3Rpb25ba2V5Y29kZV0pe1xuXHRcdFx0XHRcdC8vINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjCDQvNC+0LMg0L3QsNC20LDRgtGMINC60L3QvtC/0LrRgyDQvNGL0YjQuCDQsiDQvtC00L3QvtC8INC80LXRgdGC0LUgLSDQsCDQvtGC0L/Rg9GB0YLQuNGC0Ywg0L3QsNC0INC00YDRg9Cz0LjQvC5cblx0XHRcdFx0XHR2YXIgdCA9IHNlbGYuX2tleWNvZGVzX2luX2FjdGlvbltrZXljb2RlXS50c1xuXHRcdFx0XHRcdHNlbGYuX2tleWNvZGVzX2luX2FjdGlvbltrZXljb2RlXS5pbl9hY3Rpb24gPSBmYWxzZVxuXHRcdFx0XHRcdHNlbGYuX2tleWNvZGVzX2luX2FjdGlvbltrZXljb2RlXS50cyA9IHRzXG5cdFx0XHRcdFx0c2VsZi5fa2V5Y29kZXNfaW5fYWN0aW9uW2tleWNvZGVdLmRlbHRhID0gdHMgLSB0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuZ2V0TGF0ZXN0QWN0aW9ucyA9IGZ1bmN0aW9uKHNjZW5lLCBub3cpe1xuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBhY3Rpb25zID0gW107XG5cdFx0XHRfLmVhY2goc2VsZi5fa2V5Y29kZXNfaW5fYWN0aW9uLCBmdW5jdGlvbihrX2FjdGlvbiwga2V5Y29kZSl7XG5cdFx0XHRcdGlmKGtfYWN0aW9uLmluX2FjdGlvbil7XG5cdFx0XHRcdFx0dmFyIGRlbHRhID0gbm93IC0ga19hY3Rpb24udHNcblx0XHRcdFx0XHR2YXIgdHMgPSBub3dcblx0XHRcdFx0XHRrX2FjdGlvbi50cyA9IG5vd1xuXHRcdFx0XHRcdFxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHR2YXIgZGVsdGEgPSBrX2FjdGlvbi5kZWx0YVxuXHRcdFx0XHRcdHZhciB0cyA9IGtfYWN0aW9uLnRzXG5cdFx0XHRcdFx0ZGVsZXRlIHNlbGYuX2tleWNvZGVzX2luX2FjdGlvbltrZXljb2RlXVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBhY3Rpb24gPSBfLmNsb25lKHNlbGYuYWN0aW9uc1trZXljb2RlXSk7XG5cblx0XHRcdFx0aWYoa2V5Y29kZSBpbiBXLl9pbnB1dF9rZXltYXApe1xuXHRcdFx0XHRcdHZhciBhY3RfZGVzYyAgPSBXLl9pbnB1dF9rZXltYXBba2V5Y29kZV07XG5cdFx0XHRcdFx0dmFyIG5ld19hY3Rpb24gPSB7XG5cdFx0XHRcdFx0XHRtZXNoIDogYWN0X2Rlc2MubWVzaCxcblx0XHRcdFx0XHRcdGRldiA6IGFjdF9kZXNjLmRldmljZSxcblx0XHRcdFx0XHRcdG5hbWU6IGFjdF9kZXNjLm5hbWUsXG5cdFx0XHRcdFx0XHR0cyA6dHMsXG5cdFx0XHRcdFx0XHRpZGVudDogdHMgKyBXLl90aW1lX2RpZmYgKyBXLmF2Z19sYXRlbmNpdHksXG5cdFx0XHRcdFx0XHRkZWx0YTpkZWx0YS8xMDAwLFxuXHRcdFx0XHRcdFx0d21vdXNlOlcubW91c2VfcHJvamVjdGlvbl92ZWMuY2xvbmUoKS50b0FycmF5KClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YWN0aW9ucy5wdXNoKG5ld19hY3Rpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBhY3Rpb25zO1xuXG5cblx0XHR9XG5cdH07XG5Db250cm9sbGVyLkNTZXR0aW5nQ29udHJvbGxlciA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMudHlwZT1cInNldHRpbmdzXCJcblx0dGhpcy5wcm9jZXNzID0gZnVuY3Rpb24ocmF3X2FjdGlvbiwgbWVzaCl7XG5cdFx0XG5cdFx0Ly8gY29uc29sZS5sb2coXCJTRVRUSU5HIGNvTlQgUkVBRFlcIiwgcmF3X2FjdGlvbilcblx0XHRpZihyYXdfYWN0aW9uLnN3aXRjaCl7XG5cdFx0XHRcblx0XHRcdG1lc2guYWx0ZXJXb3JrcG9pbnRWYWx1ZShyYXdfYWN0aW9uLndwLCByYXdfYWN0aW9uLm5hbWUsIGZ1bmN0aW9uKHYpe1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkFsdGVyaW5nIGFtb3VudCBcIiwgdik7XG5cdFx0XHRcdHJldHVybiAoISB2KVxuXHRcdFx0fSk7XG5cdFx0fWVsc2V7XG5cdFx0XHRtZXNoLnNhdmVXb3JrcG9pbnRWYWx1ZShyYXdfYWN0aW9uLndwLCByYXdfYWN0aW9uLm5hbWUsIHJhd19hY3Rpb24udmFsdWUpO1xuXHRcdH1cblx0fVxufVxuLy8gVE9ETyDQmtC+0L3RgtGA0L7Qu9C70LXRgCDQtNC70Y8g0YjQuNC70LTQsFxuXG5cblxuQ29udHJvbGxlci5DUGlsb3RDb250cm9sbGVyID0gZnVuY3Rpb24oKXtcblx0XG5cdFx0Ly8g0J7QsdGA0LDQsdC+0YLQutCwINGB0L7QsdGL0YLQuNGPINC+0YHRg9GJ0LXRgdGC0LLQu9GP0LXRgtGB0Y8g0LIg0LTQstCwINGN0YLQsNC/0LA6XG5cdFx0Ly8g0J/QtdGA0LLRi9C5INGN0YLQsNC/IC0g0LLRi9GH0LjRgdC70LXQvdC40Y8g0LjRgdGF0L7QtNGPINC40Lcg0L/QsNGA0LDQvNC10YLRgNC+0LIg0YHQvtCx0YvRgtC40Y8g0YLQtdGFINGF0LDRgNCw0LrRgtC10YDQuNGB0YLQuNC6LCDQutC+0YLQvtGA0YvQtSDQvdCw0L/RgNCw0LLQu9C10L3RiyDQvdCwINC90YPQttC90YvQuSDQutC+0YDQsNCx0LvRjCAo0JLQtdC60YLQvtGA0LApXG5cdFx0Ly8g0JLRgtC+0YDQvtC5INGN0YLQsNC/IC0g0L/QtdGA0LXRgdGH0LXRgiDQutC+0L7RgNC00LjQvdCw0YIgKNGA0LDQsdC+0YLQsCDQtNCy0LjQs9Cw0YLQtdC70LXQuSlcblx0XHQgXG5cdFx0dGhpcy50eXBlPSdwaWxvdCc7XG5cdFx0dGhpcy5hY3Rpb25fdHlwZXM9W1JPVEFURSwgTU9WRV07XG5cdFx0dGhpcy5nZXRVSSA9IGZ1bmN0aW9uKFcsIGFjdG9yKXtcblx0XHRcdHZhciB1aSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHRoaXMuYWN0b3IgPSBhY3Rvcjtcblx0XHRcdFx0dGhpcy5jb25zdHJ1Y3QgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yc19sZW5ndGggPSAxMTA7XG5cdFx0XHRcdFx0dGhpcy50b3RhbF93aWR0aCA9IDE3MDtcblx0XHRcdFx0XHR0aGlzLmNvbnQgPSAkKCc8ZGl2PicpLmNzcyh7XG5cdFx0XHRcdFx0XHQncG9zaXRpb24nOidmaXhlZCcsXG5cdFx0XHRcdFx0XHQvLyAnYm9yZGVyJzogJzFweCBzb2xpZCByZWQnLFxuXHRcdFx0XHRcdFx0J3dpZHRoJzogdGhpcy50b3RhbF93aWR0aCArIFwicHhcIixcblx0XHRcdFx0XHRcdCdoZWlnaHQnOiAnNjBweCcsXG5cdFx0XHRcdFx0XHQndG9wJzo0MCxcblx0XHRcdFx0XHRcdCdsZWZ0Jzo1MCszMDAsXG5cdFx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6J3doaXRlJ1xuXHRcdFx0XHRcdH0pLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLnNoaWVsZF9jb250ID0gJCgnPGRpdj4nKS5jc3Moe1xuXHRcdFx0XHRcdFx0cG9zaXRpb246J2ZpeGVkJyxcblx0XHRcdFx0XHRcdGxlZnQ6MCxcblx0XHRcdFx0XHRcdGhlaWdodDo1MCxcblx0XHRcdFx0XHRcdGJvdHRvbTo1MCxcblx0XHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzonI2YzZicsXG5cdFx0XHRcdFx0XHR3aWR0aDo0MDBcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH0pLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHRcdHZhciBtZXNoID0gVy5zY2VuZXNbYWN0b3Iuc2NlbmVdLm1lc2hlc1thY3Rvci5jb250cm9sLm9iamVjdF9ndWlkXTtcblx0XHRcdFx0dmFyIHNjZW5lID0gVy5zY2VuZXNbYWN0b3Iuc2NlbmVdO1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdFxuXHRcdFx0XHRzZWxmLnNoaWVsZF91cGRhdGVfY2xvc3VyZXMgPSBbXVxuXHRcdFx0XHRfLmVhY2gobWVzaC50eXBlLnNoaWVsZHMsIGZ1bmN0aW9uKHNoaWVsZHMsIHR5cGUpe1xuXHRcdFx0XHRcdF8uZWFjaChzaGllbGRzLCBmdW5jdGlvbihzaGllbGRfaWQpe1xuXHRcdFx0XHRcdFx0dmFyIHNoaWVsZF9kZXYgPSBtZXNoLnR5cGUuZGV2aWNlc1tzaGllbGRfaWRdO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR2YXIgZCAgPSAkKCc8ZGl2PicpLmNzcyh7d2lkdGg6NTAsIGhlaWdodDpcIjEwMCVcIiwgZmxvYXQ6J2xlZnQnLCAnbWFyZ2luLXJpZ2h0JzpcIjEwcHhcIn0pLmFwcGVuZFRvKHNlbGYuc2hpZWxkX2NvbnQpO1xuXHRcdFx0XHRcdFx0dmFyIHNpYyA9ICQoJzxkaXY+JykuY3NzKHt3aWR0aDpcIjEwMCVcIiwgaGVpZ2h0OjEwIH0pLmFwcGVuZFRvKGQpIC8vIHN0cmVudGggaW5kaWNhdG9yIGNvbnRhaW5lclxuXHRcdFx0XHRcdFx0dmFyIGwgPSBzaGllbGRfZGV2LnNoaWVsZF90eXBlLnRvTG9jYWxlVXBwZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHR2YXIgYiA9ICQoJzxkaXY+JykuY3NzKHt3aWR0aDpcIjEwMCVcIiwgaGVpZ2h0OjMwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0ZXh0LWFsaWduXCI6J2NlbnRlcicsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQndmVydGljYWwtYWxpZ24nOiAnbWlkZGxlJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCdsaW5lLWhlaWdodCc6JzMwcHgnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOicjMzMzJywnY29sb3InOlwiI0YwRlwifSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQudGV4dChsKS5hcHBlbmRUbyhkKS5jbGljayhmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtZXNoLnN0YXJ0RGV2aWNlQWN0aW9uKHNoaWVsZF9pZCwgXCJ0b2dnbGVcIiwwKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pIFxuXHRcdFx0XHRcdFx0dmFyIGNpYyA9ICQoJzxkaXY+JykuY3NzKHt3aWR0aDpcIjEwMCVcIiwgaGVpZ2h0OjEwfSkuYXBwZW5kVG8oZCkgLy8gY2FwYWNpdG9yIGluZGljYXRvciBjb250YWluZXJcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0dmFyIHNpID0gJCgnPGRpdj4nKS5jc3Moe3dpZHRoOlwiMTAwJVwiLCBoZWlnaHQ6XCIxMDAlXCIsICdiYWNrZ3JvdW5kLWNvbG9yJzpcImJsdWVcIiB9KS5hcHBlbmRUbyhzaWMpO1xuXHRcdFx0XHRcdFx0dmFyIGNpID0gJChcIjxkaXY+XCIpLmNzcyh7d2lkdGg6XCIxMDAlXCIsIGhlaWdodDpcIjEwMCVcIiwnYmFja2dyb3VuZC1jb2xvcic6XCJ5ZWxsb3dcIiB9KS5hcHBlbmRUbyhjaWMpO1xuXHRcdFx0XHRcdFx0dmFyIGNsb3N1cmUgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHR2YXIgcmVzZXJ2ZV9jYXBfYW1vdW50ID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKHNoaWVsZF9pZCwgXCJyZXNlcnZlX2NhcGFjaXR5XCIpO1xuXHRcdFx0XHRcdFx0XHR2YXIgdG90X2NhcF9hbW91bnQgPSBzaGllbGRfZGV2LmNhcGFjaXRvcjtcblx0XHRcdFx0XHRcdFx0dmFyIHcgPSByZXNlcnZlX2NhcF9hbW91bnQvdG90X2NhcF9hbW91bnQgKiAxMDA7XG5cdFx0XHRcdFx0XHRcdGNpLndpZHRoKCB3ICsgJyUnICk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR2YXIgaXNfb24gPSBtZXNoLmdldERldmljZVNldHRpbmcoc2hpZWxkX2lkLCAnc3RhdGUnKSA7XG5cdFx0XHRcdFx0XHRcdGlmIChpc19vbil7XG5cdFx0XHRcdFx0XHRcdFx0Yi5jc3Moe2NvbG9yOidyZWQnLCAnYmFja2dyb3VuZC1jb2xvcic6J3doaXRlJ30pO1xuXHRcdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0XHRiLmNzcyh7J2JhY2tncm91bmQtY29sb3InOicjMzMzJywnY29sb3InOlwiI0YwRlwifSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50X2NhcGFjaXR5ID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKHNoaWVsZF9pZCwgJ2NhcGFjaXR5Jyk7XG5cdFx0XHRcdFx0XHRcdHZhciBtYXhfY2FwYWNpdHkgPSBzaGllbGRfZGV2LmNhcGFjaXR5O1xuXHRcdFx0XHRcdFx0XHR2YXIgd3cgPSggY3VycmVudF9jYXBhY2l0eSAvIG1heF9jYXBhY2l0eSAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHRcdFx0c2kud2lkdGgod3cpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJ1cGRhdGluZyBzaGllbGRcIiwgc2hpZWxkLCBudW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2VsZi5zaGllbGRfdXBkYXRlX2Nsb3N1cmVzLnB1c2goY2xvc3VyZSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9ycyA9ICQoJzxkaXY+JykuY3NzKHtcblx0XHRcdFx0XHRcIndpZHRoXCI6IHRoaXMuaW5kaWNhdG9yc19sZW5ndGgsXG5cdFx0XHRcdFx0XCJoZWlnaHRcIjpcIjEwMCVcIixcblx0XHRcdFx0XHRcImZsb2F0XCI6IFwibGVmdFwiLFxuXHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzond2hpdGUnXG5cdFx0XHRcdH0pLmFwcGVuZFRvKHRoaXMuY29udCk7XG5cblx0XHRcdFx0dGhpcy5zd2l0Y2hlcyA9ICQoJzxkaXY+JykuY3NzKHtcblx0XHRcdFx0XHRcIndpZHRoXCI6IHRoaXMudG90YWxfd2lkdGggLSB0aGlzLmluZGljYXRvcnNfbGVuZ3RoICxcblx0XHRcdFx0XHRcImhlaWdodFwiOlwiMTAwJVwiLFxuXHRcdFx0XHRcdFwiZmxvYXRcIjogXCJsZWZ0XCIsXG5cdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOid3aGl0ZSdcblx0XHRcdFx0fSkuYXBwZW5kVG8odGhpcy5jb250KTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuZnVlbF9pbmRpY2F0b3IgPSAkKCc8ZGl2PicpIC5jc3Moe1xuXHRcdFx0XHRcdFwid2lkdGhcIjogdGhpcy5pbmRpY2F0b3JzX2xlbmd0aCAsXG5cdFx0XHRcdFx0XCJoZWlnaHRcIjpcIjI1JVwiLFxuXHRcdFx0XHRcdC8vIFwiZmxvYXRcIjogXCJsZWZ0XCIsXG5cdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOidncmVlbidcblx0XHRcdFx0fSkuYXBwZW5kVG8odGhpcy5pbmRpY2F0b3JzKTtcblx0XHRcdFxuXHRcdFx0XHR0aGlzLnBvd2VyX2luZGljYXRvciA9ICQoJzxkaXY+JykgLmNzcyh7XG5cdFx0XHRcdFx0XCJ3aWR0aFwiOiB0aGlzLmluZGljYXRvcnNfbGVuZ3RoICxcblx0XHRcdFx0XHRcImhlaWdodFwiOlwiMjUlXCIsXG5cdFx0XHRcdFx0Ly8gXCJmbG9hdFwiOiBcImxlZnRcIixcblx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6J3JlZCdcblx0XHRcdFx0fSkuYXBwZW5kVG8odGhpcy5pbmRpY2F0b3JzKTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuY2FwYWNpdG9yX2luZGljYXRvciA9ICQoJzxkaXY+JykgLmNzcyh7XG5cdFx0XHRcdFx0XCJ3aWR0aFwiOiB0aGlzLmluZGljYXRvcnNfbGVuZ3RoICxcblx0XHRcdFx0XHRcImhlaWdodFwiOlwiNTAlXCIsXG5cdFx0XHRcdFx0Ly8gXCJmbG9hdFwiOiBcImxlZnRcIixcblx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6J3llbGxvdydcblx0XHRcdFx0fSkuYXBwZW5kVG8odGhpcy5pbmRpY2F0b3JzKTtcblx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0dGhpcy5lbmdpbmVzX2tleSA9ICQoXCI8ZGl2PlwiKS5jc3Moe1xuXHRcdFx0XHRcdHdpZHRoOlwiMTAwJVwiLFxuXHRcdFx0XHRcdGhlaWdodDpcIjIwcHhcIixcblx0XHRcdFx0XHRcblx0XHRcdFx0fSkudGV4dChcIkVcIikuYXBwZW5kVG8odGhpcy5zd2l0Y2hlcykuY2xpY2soZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRzZWxmLl9lbmdpbmVzX2RpYWxvZygpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuc2hpZWxkX2tleSA9ICQoXCI8ZGl2PlwiKS5jc3Moe1xuXHRcdFx0XHRcdHdpZHRoOlwiMTAwJVwiLFxuXHRcdFx0XHRcdGhlaWdodDpcIjIwcHhcIixcblx0XHRcdFx0XHRcblx0XHRcdFx0fSkudGV4dChcIlNcIikuYXBwZW5kVG8odGhpcy5zd2l0Y2hlcykuY2xpY2soZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRzZWxmLl9zaGllbGRzX2RpYWxvZygpO1xuXHRcdFx0XHR9KTs7XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnR1cnJldF9rZXlzID0gJChcIjxkaXY+XCIpLmNzcyh7XG5cdFx0XHRcdFx0d2lkdGg6XCIxMDAlXCIsXG5cdFx0XHRcdFx0aGVpZ2h0OlwiMjBweFwiLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHR9KS50ZXh0KFwiVFwiKS5hcHBlbmRUbyh0aGlzLnN3aXRjaGVzKTtcblx0XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdXBkYXRlX3NoaWVsZF9pbmRpY2F0b3IgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdF8uZWFjaCh0aGlzLnNoaWVsZF91cGRhdGVfY2xvc3VyZXMsIGZ1bmN0aW9uKGNsKXtcblx0XHRcdFx0XHRcdGNsKCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl91cGRhdGVfZnVlbF9pbmRpY2F0b3IgPSBmdW5jdGlvbigpe31cblx0XHRcdFx0dGhpcy5fdXBkYXRlX3Bvd2VyX2luZGljYXRvciA9IGZ1bmN0aW9uKCl7fVxuXHRcdFx0XHR0aGlzLl91cGRhdGVfY2FwYWNpdG9yX2luZGljYXRvciA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dmFyIG1lc2ggPSBXLnNjZW5lc1thY3Rvci5zY2VuZV0ubWVzaGVzW2FjdG9yLmNvbnRyb2wub2JqZWN0X2d1aWRdO1xuXHRcdFx0XHRcdHZhciBwc2QgPSBtZXNoLnR5cGUuZGV2aWNlc1ttZXNoLnR5cGUucG93ZXJfc291cmNlXTtcblx0XHRcdFx0XHR2YXIgdG90YWxfY2FwID0gcHNkLmNhcGFjaXRvcjtcblx0XHRcdFx0XHR2YXIgY3VycmVudF9jYXAgPSBtZXNoLmdldERldmljZVNldHRpbmcobWVzaC50eXBlLnBvd2VyX3NvdXJjZSwgXCJjYXBhY2l0b3JcIik7XG5cdFx0XHRcdFx0TC5zZXRWYWx1ZShcIkNVUiBDT05TXCIsIGN1cnJlbnRfY2FwKTtcblx0XHRcdFxuXHRcdFx0XHRcdGlmKGN1cnJlbnRfY2FwID4gdG90YWxfY2FwKXtcblx0XHRcdFx0XHRcdHBlcmNlbnRhZ2UgPSAxO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0cGVyY2VudGFnZSA9IGN1cnJlbnRfY2FwIC8gdG90YWxfY2FwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmNhcGFjaXRvcl9pbmRpY2F0b3Iud2lkdGgocGVyY2VudGFnZSAqIHRoaXMuaW5kaWNhdG9yc19sZW5ndGgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3NoaWVsZHNfZGlhbG9nID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgbWVzaCA9IFcuc2NlbmVzW2FjdG9yLnNjZW5lXS5tZXNoZXNbYWN0b3IuY29udHJvbC5vYmplY3RfZ3VpZF07XG5cdFx0XHRcdFx0dmFyIHNjZW5lID0gVy5zY2VuZXNbYWN0b3Iuc2NlbmVdO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnQgPSAkKCc8ZGl2PicpLmNzcyh7XG5cdFx0XHRcdFx0XHQncG9zaXRpb24nOidhYnNvbHV0ZScsXG5cdFx0XHRcdFx0XHQvLyAnYm9yZGVyJzogJzFweCBzb2xpZCByZWQnLFxuXHRcdFx0XHRcdFx0J3dpZHRoJzogNDAwICsgXCJweFwiLFxuXHRcdFx0XHRcdFx0J2hlaWdodCc6ICc2MDBweCcsXG5cdFx0XHRcdFx0XHQndG9wJzo0MCArIDEwMCxcblx0XHRcdFx0XHRcdCdsZWZ0Jzo1MCszMDAsXG5cdFx0XHRcdFx0XHQncGFkZGluZyc6IFwiMTBweFwiLFxuXHRcdFx0XHRcdFx0J2JvcmRlci1yYWRpdXMnOiczcHgnLFxuXHRcdFx0XHRcdFx0J2JvcmRlci13aWR0aCc6JzFweCcsXG5cdFx0XHRcdFx0XHQnYm9yZGVyLXN0eWxlJzonc29saWQnLFxuXHRcdFx0XHRcdFx0J2JvcmRlci1jb2xvcic6JyNhYWEnLFxuXHRcdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOicjMjIyJ30pLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHRcdFx0dmFyICBjYyA9ICQoJzxkaXY+JykuYXBwZW5kVG8oY29udCkuY3NzKHsnd2lkdGgnOlwiMTAwJVwiLGhlaWdodDoyMCwgJ3BhZGRpbmctYm90dG9tJzogJzMwcHgnfSk7XG5cdFx0XHRcdFx0dmFyICBjbG9zZXIgPSAkKCc8ZGl2PicpLmFwcGVuZFRvKGNvbnQpLmNzcyh7J3dpZHRoJzpcIjIwXCIsIGhlaWdodDoyMCwgJ2JhY2tncm91bmQtY29sb3InOidyZWQnLCBmbG9hdDoncmlnaHQnIH0pLmNsaWNrKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRjb250LnJlbW92ZSgpO1xuXHRcdFx0XHRcdH0pLmFwcGVuZFRvKGNjKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRfLmVhY2gobWVzaC50eXBlLnNoaWVsZHMsIGZ1bmN0aW9uKHMsIGkpe1xuXHRcdFx0XHRcdFx0aWYgKGkgPT09ICd0aGVybWFsJyl7cmV0dXJufVxuXHRcdFx0XHRcdFx0Xy5lYWNoKHMsIGZ1bmN0aW9uKHNoaWVsZF9pZCl7XG5cdFx0XHRcdFx0XHRcdHZhciBlMSA9ICQoXCI8ZGl2PlwiKS5jc3Moe1xuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOjMwMCxcblx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6NDBcblx0XHRcdFx0XHRcdFx0fSkuYXBwZW5kVG8oY29udCk7XG5cdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdCQoJzxkaXY+JykuY3NzKHsnZmxvYXQnOidsZWZ0JywgJ2NvbG9yJzonI2JiYid9KS53aWR0aCg0MCkudGV4dChpKS5hcHBlbmRUbyhlMSkgXG5cdFx0XHRcdFx0XHRcdHZhciBzbGMgPSAgJCgnPGRpdj4nKS5jc3MoeydmbG9hdCc6J2xlZnQnLCB3aWR0aDoxMjAsJ21hcmdpbi1sZWZ0JzoxMH0pLmFwcGVuZFRvKGUxKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR2YXIgcGMgPSBuZXcgUG93ZXJDb250cm9sV2lkZ2V0KHtjb250YWluZXI6c2xjWzBdLCBzdGFydGluZ19wZXJjZW50OjAsIGVuZF9wZXJjZW50OjEuNSxwcm9ncmVzc192YWx1ZTowLFxuXHRcdFx0XHRcdFx0XHRcdGNoYW5nZTogZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1lc2guc3RhcnREZXZpY2VBY3Rpb24oc2hpZWxkX2lkLCBcInNldF9wb3dlclwiLCB2YWwpO1xuXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRzbGlkZTpmdW5jdGlvbih2YWwpeyBcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQvLyB2YXIgc2V0dCA9ICBcInNfXCIgKyBpICsgbnVtICsgXCJfcG93ZXJcIlxuXHRcdFx0XHRcdFx0XHR2YXIgY3VyX3ZhbCA9IG1lc2guZ2V0RGV2aWNlU2V0dGluZyhzaGllbGRfaWQsIFwicG93ZXJcIik7XG5cdFx0XHRcdFx0XHRcdHBjLnNldF92YWx1ZSggY3VyX3ZhbCApO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX2VuZ2luZXNfZGlhbG9nID0gZnVuY3Rpb24oKXtcblxuXHRcdFx0XHRcdHZhciBtZXNoID0gVy5zY2VuZXNbYWN0b3Iuc2NlbmVdLm1lc2hlc1thY3Rvci5jb250cm9sLm9iamVjdF9ndWlkXTtcblx0XHRcdFx0XHR2YXIgc2NlbmUgPSBXLnNjZW5lc1thY3Rvci5zY2VuZV07XG5cblx0XHRcdFx0XHRjb250ID0gJCgnPGRpdj4nKS5jc3Moe1xuXHRcdFx0XHRcdFx0J3Bvc2l0aW9uJzonYWJzb2x1dGUnLFxuXHRcdFx0XHRcdFx0Ly8gJ2JvcmRlcic6ICcxcHggc29saWQgcmVkJyxcblx0XHRcdFx0XHRcdCd3aWR0aCc6IDQwMCArIFwicHhcIixcblx0XHRcdFx0XHRcdCdoZWlnaHQnOiAnNjAwcHgnLFxuXHRcdFx0XHRcdFx0J3RvcCc6NDAgKyAxMDAsXG5cdFx0XHRcdFx0XHQnbGVmdCc6NTArMzAwLFxuXHRcdFx0XHRcdFx0J3BhZGRpbmcnOiBcIjEwcHhcIixcblx0XHRcdFx0XHRcdCdib3JkZXItcmFkaXVzJzonM3B4Jyxcblx0XHRcdFx0XHRcdCdib3JkZXItd2lkdGgnOicxcHgnLFxuXHRcdFx0XHRcdFx0J2JvcmRlci1zdHlsZSc6J3NvbGlkJyxcblx0XHRcdFx0XHRcdCdib3JkZXItY29sb3InOicjYWFhJyxcblx0XHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzonIzIyMid9KS5hcHBlbmRUbygnYm9keScpO1xuXHRcdFx0XHRcdFx0dmFyICBjYyA9ICQoJzxkaXY+JykuYXBwZW5kVG8oY29udCkuY3NzKHsnd2lkdGgnOlwiMTAwJVwiLGhlaWdodDoyMCwgJ3BhZGRpbmctYm90dG9tJzogJzMwcHgnfSk7XG5cdFx0XHRcdFx0XHR2YXIgIGNsb3NlciA9ICQoJzxkaXY+JykuYXBwZW5kVG8oY29udCkuY3NzKHsnd2lkdGgnOlwiMjBcIiwgaGVpZ2h0OjIwLCAnYmFja2dyb3VuZC1jb2xvcic6J3JlZCcsIGZsb2F0OidyaWdodCcgfSkuY2xpY2soZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0Y29udC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdH0pLmFwcGVuZFRvKGNjKTs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Xy5lYWNoKG1lc2gudHlwZS5lbmdpbmVzLCBmdW5jdGlvbihlbmdpbmVzLCBlbmdpbmVfdHlwZSl7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdF8uZWFjaChlbmdpbmVzLCBmdW5jdGlvbihlbmdpbmVfaWQpe1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gdmFyIGV0ID0gZW5naW5lX3R5cGU7XG5cdFx0XHRcdFx0XHRcdC8vIHZhciBlYSA9IGVuO1xuXHRcdFx0XHRcdFx0XHR2YXIgZW5fZGV2ID0gbWVzaC50eXBlLmRldmljZXNbZW5naW5lX2lkXTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHZhciBlMSA9ICQoXCI8ZGl2PlwiKS5jc3Moe1xuXHRcdFx0XHRcdFx0XHRcdHdpZHRoOjMwMCxcblx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6NDBcblx0XHRcdFx0XHRcdFx0XHR9KS5hcHBlbmRUbyhjb250KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQkKCc8ZGl2PicpLmNzcyh7J2Zsb2F0JzonbGVmdCcsICdjb2xvcic6JyNiYmInfSkud2lkdGgoNDApLnRleHQoZW5fZGV2Lm5hbWUpLmFwcGVuZFRvKGUxKSBcblx0XHRcdFx0XHRcdFx0dmFyIHNsYyA9ICAkKCc8ZGl2PicpLmNzcyh7J2Zsb2F0JzonbGVmdCcsIHdpZHRoOjEyMCwnbWFyZ2luLWxlZnQnOjEwfSkuYXBwZW5kVG8oZTEpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0dmFyIHBjID0gbmV3IFBvd2VyQ29udHJvbFdpZGdldCh7Y29udGFpbmVyOnNsY1swXSwgc3RhcnRpbmdfcGVyY2VudDowLCBlbmRfcGVyY2VudDoxLjUscHJvZ3Jlc3NfdmFsdWU6MCxcblx0XHRcdFx0XHRcdFx0XHRjaGFuZ2U6IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtZXNoLnN0YXJ0RGV2aWNlQWN0aW9uKGVuZ2luZV9pZCwgXCJzZXRfcG93ZXJcIiwgdmFsKTtcblxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0c2xpZGU6ZnVuY3Rpb24odmFsKXsgXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBtZXNoLnN0YXJ0RGV2aWNlQWN0aW9uKGVuZ2luZV9pZCwgXCJzZXRfcG93ZXJcIiwgdmFsKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdC8vIHZhciBzZXR0ID0gIFwiZW5nX1wiICsgZW5naW5lX25hbWUgKyBcIl9wb3dlclwiXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJfdmFsID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKGVuZ2luZV9pZCwgXCJwb3dlclwiICk7XG5cdFx0XHRcdFx0XHRcdHBjLnNldF92YWx1ZSggY3VyX3ZhbCApO1xuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZV9mdWVsX2luZGljYXRvcigpO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZV9wb3dlcl9pbmRpY2F0b3IoKTtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVfY2FwYWNpdG9yX2luZGljYXRvcigpO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZV9zaGllbGRfaW5kaWNhdG9yKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFxuXHRcdFx0dmFyIFVJID0gbmV3IHVpKCk7XG5cdFx0XHRyZXR1cm4gVUk7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBUID0gQ29udHJvbGxlci5UKCk7XG5cdFx0XG5cdFx0ZnVuY3Rpb24gZ2V0X2F4aXMoYSl7XG5cdFx0XHRpZihhID09ICd4Jyl7XG5cdFx0XHRcdGF4aXMgPSBuZXcgQ29udHJvbGxlci5UKCkuVmVjdG9yMygxLDAsMClcblx0XHRcdH1cblx0XHRcdGlmKGEgPT0gJ3knKXtcblx0XHRcdFx0YXhpcyA9IG5ldyBDb250cm9sbGVyLlQoKS5WZWN0b3IzKDAsMSwwKVxuXHRcdFx0fVxuXHRcdFx0aWYoYSA9PSAneicpe1xuXHRcdFx0XHRheGlzID0gbmV3IENvbnRyb2xsZXIuVCgpLlZlY3RvcjMoMCwwLDEpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXhpc1xuXHRcdFxuXHRcdFxuXHRcdH1cblx0XHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihhY3Rpb24sIG1lc2gpe1xuXHRcdFx0XG5cdFx0XHRpZihhY3Rpb24ubmFtZSA9PSAnc2V0X3Bvd2VyJyl7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCBcInNldHRpbmcgcG93ZXIgb2ZcIiwgYWN0aW9uLmRldiwgXCIgdG8gXCIsIGFjdGlvbi52YWx1ZSlcblx0XHRcdFx0bWVzaC5zZXREZXZpY2VTZXR0aW5nKGFjdGlvbi5kZXYsICdwb3dlcicsIGFjdGlvbi52YWx1ZSk7XG5cdFx0XHRcdFxuXHRcdFx0fWVsc2V7XG5cdFx0XHRcblx0XHRcdFx0dmFyIFQgPSBDb250cm9sbGVyLlQoKTtcblx0XHRcdFxuXHRcdFx0XHR2YXIgdW5pdCA9IG5ldyBULlZlY3RvcjMoKTtcblx0XHRcdFx0dW5pdC5mcm9tQXJyYXkobWVzaC50eXBlLmRldmljZXNbYWN0aW9uLmRldl0udW5pdCk7XG5cdFx0XHRcdHZhciBlbmdpbmVfbmFtZSA9IG1lc2gudHlwZS5kZXZpY2VzW2FjdGlvbi5kZXZdLmVuZ2luZV90eXBlICsgXCJfXCIgKyBtZXNoLnR5cGUuZGV2aWNlc1thY3Rpb24uZGV2XS5uYW1lO1xuXHRcdFx0XHR2YXIgcGVyY2VudF9vZl9wb3dlciA9IG1lc2guZ2V0RGV2aWNlU2V0dGluZyhhY3Rpb24uZGV2LCBcInBvd2VyXCIpO1xuXHRcdFx0XHR2YXIgZW5naW5lX3R5cGUgPSBtZXNoLnR5cGUuZGV2aWNlc1thY3Rpb24uZGV2XS5lbmdpbmVfdHlwZTtcblx0XHRcdFxuXHRcdFx0XHR2YXIgcGVyZm9ybWFuY2UgPSBtZXNoLnR5cGUuZGV2aWNlc1thY3Rpb24uZGV2XS5wZXJmb3JtYW5jZTtcblx0XHRcdFx0dmFyIGNvbnN1bXB0aW9uID0gbWVzaC50eXBlLmRldmljZXNbYWN0aW9uLmRldl0uY29uc3VtcHRpb247XG5cdFx0XHRcdHZhciBjYXBhY2l0b3JfbGVmdCA9IG1lc2guZ2V0RGV2aWNlU2V0dGluZyhtZXNoLnR5cGUucG93ZXJfc291cmNlLCBcImNhcGFjaXRvclwiKTtcblx0XHRcdFx0dmFyIGVuZXJneV9jb25zdW1wdGlvbiA9IHBlcmNlbnRfb2ZfcG93ZXIqIGNvbnN1bXB0aW9uICogYWN0aW9uLmRlbHRhO1xuXHRcdFx0XG5cdFx0XHRcdGlmIChjYXBhY2l0b3JfbGVmdCA8IGVuZXJneV9jb25zdW1wdGlvbil7XG5cdFx0XHRcdFx0ZW5lcmd5X2NvbnN1bXB0aW9uID0gY2FwYWNpdG9yX2xlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcInRvb2sgZW5lcmd5XCIsIGVuZXJneV9jb25zdW1wdGlvbik7XG5cdFx0XHRcdC8vTC5zZXRWYWx1ZShcIk5FVyBDT05TXCIsIGVuZXJneV9jb25zdW1wdGlvbik7XG5cdFx0XHRcblx0XHRcdFx0dmFyIGltcHVsc2UgPSBlbmVyZ3lfY29uc3VtcHRpb24gKiBwZXJmb3JtYW5jZTtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJ3ZSBnbyB3aXRoXCIsIGltcHVsc2UsIHBlcmNlbnRfb2ZfcG93ZXIpO1xuXHRcdFx0XHR1bml0Lm11bHRpcGx5U2NhbGFyKGltcHVsc2UpO1xuXHRcdFx0XG5cdFx0XHRcdG1lc2gudXBkYXRlX3N0YXRpY19waHlzaWNhbF9kYXRhKGFjdGlvbi50cylcblx0XHRcdFxuXHRcdFx0XHRtZXNoLmFsdGVyRGV2aWNlU2V0dGluZyhtZXNoLnR5cGUucG93ZXJfc291cmNlLCAnY2FwYWNpdG9yJyAsZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0XHRcdEwuc2V0VmFsdWUoXCJORVcgQ09OU3VtcDFcIiwgZW5lcmd5X2NvbnN1bXB0aW9uKTtcblx0XHRcdFx0XHR2YXIgbnYgPSB2YWx1ZSAtIGVuZXJneV9jb25zdW1wdGlvbjtcblx0XHRcdFx0XHRpZiAobnYgPCAwKSB7cmV0dXJuIDB9XG5cdFx0XHRcdFx0ZWxzZXsgcmV0dXJuIG52IH1cblx0XHRcdFx0XHRcblx0XHRcdFx0fSlcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcdGlmIChlbmdpbmVfdHlwZSA9PSAncm90YXRpb24nKXtcblx0XHRcdFx0XHRtZXNoLmFuZ3VsYXJfaW1wdWxzZS5hZGQodW5pdClcblx0XHRcdFx0fWVsc2UgaWYoZW5naW5lX3R5cGUgPT0gJ3Byb3B1bHNpb24nKXtcblx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIHR1ZyA9IHVuaXQuY2xvbmUoKS5hcHBseVF1YXRlcm5pb24obWVzaC5xdWF0ZXJuaW9uKTtcblx0XHRcdFx0XHRtZXNoLmltcHVsc2UuYWRkKHR1Zyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcblxuXHRcdFx0XG5cdFx0XHRcdH1cdFxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fVxuXHRcdFxuXHRcdC8qXG5cdFx0dGhpcy5wcm9jZXNzXyA9IGZ1bmN0aW9uKHJhd19hY3Rpb24sIG1lc2gpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJPbiB0aGUgc2VydmVyXCIsIGFjdGlvbik7XG5cdFx0XHRcblx0XHRcdHZhciBwcm9jZXNzID0gZnVuY3Rpb24ob2JqZWN0X2d1aWQsIGFjdGlvbil7XG5cdFx0XHRcdG1lc2gudXBkYXRlX3N0YXRpY19waHlzaWNhbF9kYXRhKGFjdGlvbi50cylcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHRtZXNoLmFsdGVyV29ya3BvaW50VmFsdWUoXCJQaWxvdGluZ1wiLCAnY2FwYWNpdG9yJyAsZnVuY3Rpb24odmFsdWUpe1xuXHRcdFx0XHRcdEwuc2V0VmFsdWUoXCJORVcgQ09OU3VtcDFcIiwgcmF3X2FjdGlvbi5lbmVyZ3lfY29uc3VtcHRpb24pO1xuXHRcdFx0XHRcdHZhciBudiA9IHZhbHVlIC0gcmF3X2FjdGlvbi5lbmVyZ3lfY29uc3VtcHRpb247XG5cdFx0XHRcdFx0aWYgKG52IDwgMCkge3JldHVybiAwfVxuXHRcdFx0XHRcdGVsc2V7IHJldHVybiBudiB9XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0fSlcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhY3Rpb24udHlwZSA9PT0gUk9UQVRFKXtcblx0XHRcdFx0XHRtZXNoLmFuZ3VsYXJfaW1wdWxzZS5hZGQoYWN0aW9uLnZlY3Rvcilcblx0XHRcdFx0fWVsc2UgaWYoYWN0aW9uLnR5cGUgPT09IE1PVkUpe1xuXHRcdFx0XHRcdGlmKGFjdGlvbi52ZWN0b3IgaW5zdGFuY2VvZiBULlZlY3RvcjMpe1xuXHRcdFx0XHRcdFx0dmFyIHYgPSBhY3Rpb24udmVjdG9yXG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHR2YXIgdiA9IG5ldyBULlZlY3RvcjMoYWN0aW9uLnZlY3Rvci54LCBhY3Rpb24udmVjdG9yLnksIGFjdGlvbi52ZWN0b3Iueilcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHR1ZyA9IHYuY2xvbmUoKS5hcHBseVF1YXRlcm5pb24obWVzaC5xdWF0ZXJuaW9uKTtcblx0XHRcdFx0XHRtZXNoLmltcHVsc2UuYWRkKHR1Zyk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cblx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnY2FsbCBwcm9jZXNzJywgIF8uaGFzKHJhd19hY3Rpb24sJ3ZlY3RvcicpICk7XG5cdFx0XHRcblx0XHRcdGlmIChfLmhhcyhyYXdfYWN0aW9uLCAndmVjdG9yJykpICB7IC8vINCV0YHQu9C4INCw0LrRhtC40Y4g0YPQttC1INCy0YvRh9C40YHQu9C40LvQuCAtINCx0YPQtNC10Lwg0L/RgNC40LzQtdC90Y/RgtGMINCy0YHQtSDQstC10LrRgtC+0YDQsCDQvdCwINC90LXQtVxuXHRcdFx0XHRwcm9jZXNzKCctJywgcmF3X2FjdGlvbilcblx0XHRcdH1lbHNle1xuXHRcdFx0XHR0aGlzLmFjdF9mb3JfbWVzaChtZXNoLCByYXdfYWN0aW9uLCBwcm9jZXNzKTsgLy8g0JXRgdC70Lgg0L3QtdGCIC0g0YLQviDRgdC90LDRh9Cw0LvQsCDQstGL0YfQuNGB0LvQuNC8INC40YVcblx0XHRcdH1cblx0XHR9O1xuXHRcdHRoaXMuYWN0X2Zvcl9tZXNoPWZ1bmN0aW9uKG1lc2gsIGFjdGlvbiwgb25BY3Qpe1xuXHRcdFx0dmFyIEMgPSBtZXNoO1xuXHRcdFx0dmFyIFQgPSBDb250cm9sbGVyLlQoKTtcblx0XHRcdFxuXHRcdFx0dmFyIGV0cyA9e307XG5cdFx0XHRldHNbUk9UQVRFXT0ncm90YXRpb24nO1xuXHRcdFx0ZXRzW01PVkVdID0gJ3Byb3B1bHNpb24nO1xuXHRcdFx0XG5cdFx0XHR2YXIgZXQgPSBldHNbYWN0aW9uLnR5cGVdXG5cdFx0XHRpZih0eXBlb2YgYWN0aW9uLnAgPT09ICdzdHJpbmcnKXtcblx0XHRcdFx0YWN0aW9uLnAgPSBKU09OLnBhcnNlKGFjdGlvbi5wKTtcblx0XHRcdH1cblx0XHRcdHZhciBlYSA9IGFjdGlvbi5wLmEgPT0wID8gJ3gnIDogYWN0aW9uLnAuYSA9PTEgPyAneSc6ICd6J1xuXHRcdFx0aWYoYWN0aW9uLnAuZCA8MCl7ZWEgKz0nLSd9ZWxzZXtlYSArPSAnKycgfVxuXHRcdFx0dmFyIGVuZ2luZV9uYW1lID0gZXQgKyBcIl9cIiArIGVhXG5cdFx0XHRcblx0XHRcdHZhciBBWD0gYWN0aW9uLnAuYTtcblx0XHRcdHZhciBhciA9IFswLDAsMF07XG5cdFx0XHRhcltBWF0gPSBhY3Rpb24ucC5kXG5cdFx0XHRcblx0XHRcdHZhciB2ZWMgPSBuZXcgVC5WZWN0b3IzKCk7XG5cdFx0XHR2ZWMuZnJvbUFycmF5KGFyKTsgICAgICAgICAvLyBBWCA9PSAneCc/bmV3IFQuVmVjdG9yMyhhLDAsMCk6KEFYID09J3knP25ldyBULlZlY3RvcjMoMCwgYSwgMCk6IG5ldyBULlZlY3RvcjMoMCwwLGEpKVxuXHRcdFx0Ly8g0KLQtdC/0LXRgNGMINC10LPQviDQvdCw0LTQviDRg9C80L3QvtC20LjRgtGMINC90LAg0LzQvtGJ0L3QvtGB0YLRjCDQtNCy0LjQs9Cw0YLQtdC70Y8g0Lgg0L/QvtC70YPRh9C40YLRjCDRgdC40LvRg1xuXHRcdFx0Ly8g0KLQtdC60YPRidCw0Y8g0LzQvtGJ0L3QvtGB0YLRjCDQtNCy0LjQs9Cw0YLQtdC70Y8gLSDRjdGC0L4g0L/RgNC+0YbQtdC90YIg0LXQs9C+INC80L7RidC90L7RgdGC0LgsINGD0LzQvdC+0LbQtdC90L3Ri9C5INC90LAg0LXQs9C+INC80LDQutGB0LjQvNCw0LvRjNC90YPRjiDQvNC+0YnQvdC+0YHRgtGMLCDRg9C80L3QvtC20LXQvdC90YvQuSDQvdCwINC10LPQviDQmtCf0JQg0LIg0LTQttC+0YPQu9GP0YVcblx0XHRcdC8vIGNvbnNvbGUubG9nKGFjdGlvbi53cCk7XG5cdFx0XHR2YXIgcGVyY2VudF9vZl9wb3dlciA9IG1lc2guZ2V0V29ya3BvaW50VmFsdWUoYWN0aW9uLndwLCBcImVuZ19cIiArIGVuZ2luZV9uYW1lICsgXCJfcG93ZXJcIik7XG5cdFx0XHQvL2NvbnNvbGUubG9nIChcIk1NXCIsIG1lc2gud29ya3BvaW50X3N0YXRlcyxhY3Rpb24ucCwgYWN0aW9uLndwLCBcImVuZ19cIiArIGVuZ2luZV9uYW1lICsgXCJfcG93ZXJcIik7XG5cdFx0XHR2YXIgbWF4X3Bvd2VyID0gbWVzaC50eXBlLmVuZ2luZXNbZXRdW2VhXS5jb25zdW1wdGlvbjtcblx0XHRcdHZhciBwZXJmb3JtYW5jZSA9IG1lc2gudHlwZS5lbmdpbmVzW2V0XVtlYV0ucGVyZm9ybWFuY2U7XG5cdFx0XHR2YXIgZW5lcmd5X2NvbnN1bXB0aW9uID0gcGVyY2VudF9vZl9wb3dlciogbWF4X3Bvd2VyICogYWN0aW9uLmRlbHRhO1xuXHRcdFx0YWN0aW9uLmVuZXJneV9jb25zdW1wdGlvbiA9IGVuZXJneV9jb25zdW1wdGlvbjtcblx0XHRcdFxuXHRcdFx0dmFyIGNhcGFjaXRvcl9sZWZ0ID0gbWVzaC5nZXRXb3JrcG9pbnRWYWx1ZShcIlBpbG90aW5nXCIsIFwiY2FwYWNpdG9yXCIpO1xuXHRcdFx0aWYgKGNhcGFjaXRvcl9sZWZ0IDwgZW5lcmd5X2NvbnN1bXB0aW9uKXtcblx0XHRcdFx0ZW5lcmd5X2NvbnN1bXB0aW9uID0gY2FwYWNpdG9yX2xlZnQ7XG5cdFx0XHR9XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwidG9vayBlbmVyZ3lcIiwgZW5lcmd5X2NvbnN1bXB0aW9uKTtcblx0XHRcdC8vTC5zZXRWYWx1ZShcIk5FVyBDT05TXCIsIGVuZXJneV9jb25zdW1wdGlvbik7XG5cdFx0XHRcblx0XHRcdHZhciBpbXB1bHNlID0gZW5lcmd5X2NvbnN1bXB0aW9uICogcGVyZm9ybWFuY2U7XG5cdFx0XHQvL0wuc2V0VmFsdWUoXCJORVcgSU1QVUxTRVwiLCBpbXB1bHNlKTtcblx0XHRcdFxuXHRcdFx0Ly8gdmFyIHBvd2VyID0gQy5lbmdpbmVzW2V0XVtlYV07XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhwZXJjZW50X29mX3Bvd2VyLCBtYXhfcG93ZXIsIGVuZXJneV9jb25zdW1wdGlvbiwgaW1wdWxzZSk7XG5cdFx0XHRcblx0XHRcdHZlYy5tdWx0aXBseVNjYWxhcihpbXB1bHNlKTtcblx0XHRcdC8vY29uc29sZS5sb2coXCJhY3Rpb24gZGVsdGFcIiwgYWN0aW9uLnRzLCBhY3Rpb24uZGVsdGEpO1xuXHRcdFx0Ly8gdmVjLm11bHRpcGx5U2NhbGFyKGFjdGlvbi5kZWx0YSlcblx0XHRcdGFjdGlvbi52ZWN0b3IgPSB2ZWNcblx0XHRcdFxuXHRcdFx0Ly8g0J3QsNGI0LvQuCDQstGB0LUg0YHQuNC70Ysg0Lgg0LLQvtC30LLRgNCw0YnQsNC10Lwg0L7QsdGA0LDRgtC90L4g0YHQvtCx0YvRgtC40LVcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwiTUVTSFwiLCBcIkdVSURcIiwgQyk7XG5cdFx0XHRvbkFjdChDLmpzb24uR1VJRCwgYWN0aW9uKVxuXHRcdFx0XG5cdFx0fSxcblx0XHR0aGlzLmFjdCA9IGZ1bmN0aW9uKFMsIGFjdGlvbiwgIGFjdG9yX2d1aWQsIG9uQWN0XyApe1xuXHRcdFx0Ly8g0K3RgtCwINGE0YPQvdC60YbQuNGPINGB0L7Qt9C00LDRkdC10YIg0LDQutGG0LjRjiDQuNGB0YXQvtC00Y8g0LjQtyDRg9GB0LvQvtCy0LjQuSDQvtC60YDRg9C20LXQvdC40Y9cblx0XHRcdC8vINCSINC00LDQvdC90L7QvCDRgdC70YPRh9Cw0LUg0L3QsNC8INC90LDQtNC+INGB0L7Qt9C00LDRgtGMINC/0L7QtNGA0L7QsdC90L4g0L7Qv9C40YHRi9Cy0LDRjtGJ0LXQtSDRgdC+0LHRi9GC0LjQtSDQviDRgtC+0LwsINGH0YLQviDQvNC+0LbQtdGCINC4INC00L7QttC90L4g0L/RgNC+0LjRgdGF0L7QtNC40YLRjCDRgSDQutC+0YDQsNCx0LvQtdC8XG5cdFx0XHRpZihTID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cdFx0XHR2YXIgQyA9IFMubWVzaF9mb3IoYWN0b3JfZ3VpZCk7XG5cdFx0XHR2YXIgYWN0b3IgPSBTLmFjdG9yc1thY3Rvcl9ndWlkXTtcblx0XHRcdHZhciBvbkFjdCA9IGZ1bmN0aW9uKGd1aWQsIGFjdGlvbil7XG5cdFx0XHRcdG9uQWN0XyhndWlkLCBhY3Rpb24pO1xuXHRcdFx0fVxuXHRcdFx0YWN0aW9uLndwID0gYWN0b3IuY29udHJvbC53b3JrcG9pbnQ7XG5cdFx0XHR0aGlzLmFjdF9mb3JfbWVzaChDLCBhY3Rpb24sIG9uQWN0ICk7XG5cblx0XHRcdFxuXHRcdH1cblx0XHQqL1xuXHRcdC8vIHJldHVybiB0aGlzO1xuXHRcblx0fTtcblxuXG5Db250cm9sbGVyLmJhc2ljQXV0b1BpbG90QWN0b3I9ZnVuY3Rpb24gKFMsIGlkLCBvaWQpe1xuXHRcdHRoaXMudGFyZ2V0cyA9IFtcIm9yYml0X29iamVjdFwiLCBcImNsb3NlX3RvX29iamVjdFwiXTtcblx0XHR0aGlzLmRlZmF1bHRfZGlzdGFuY2UgPSAyMDBcblx0XHR0aGlzLmdldF9mb2VzID0gZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuZm9lcyA9IFtdXG5cdFx0XHRmb3IgKHZhciBpID0wOyBpIDwgVy5tZXNoZXMubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRpZihpICE9IGlkKSBmb2VzLnB1c2goe2lkOmlkLCBvYmo6Vy5tZXNoZXNbaV19KVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRcbkNvbnRyb2xsZXIuQ1R1cnJldENvbnRyb2xsZXIgPSBmdW5jdGlvbigpe1xuXHR0aGlzLnR5cGUgPSAndHVycmV0Jztcblx0XG5cdHRoaXMuZ2V0VUkgPSBmdW5jdGlvbihXLCBhY3Rvcil7XG5cdFx0dmFyIHVpID0gZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMucnVsZXNfaGVpZ2h0ID0gMTQwXG5cdFx0XHR0aGlzLmFjdG9yID0gYWN0b3I7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHRoaXMuY29udCA9ICQoJzxkaXY+JykuY3NzKHsncG9zaXRpb24nOidmaXhlZCcsXG5cdFx0XHRcdFx0XHRcdFx0Ly8gJ2JvcmRlcic6ICcxcHggc29saWQgcmVkJyxcblx0XHRcdFx0XHRcdFx0XHQnd2lkdGgnOlwiNjZweFwiLFxuXHRcdFx0XHRcdFx0XHRcdCdoZWlnaHQnOiAnMTcwcHgnLFxuXHRcdFx0XHRcdFx0XHRcdCd0b3AnOjQwLFxuXHRcdFx0XHRcdFx0XHRcdCdsZWZ0Jzo1MCxcblx0XHRcdFx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6J3doaXRlJ30pLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgcnVsX2NvbnQgPSAkKCc8ZGl2PicpLmNzcyh7XG5cdFx0XHRcdFx0XCJ3aWR0aFwiOiAgXCIxMDAlXCIsXG5cdFx0XHRcdFx0XCJoZWlnaHRcIjogdGhpcy5ydWxlc19oZWlnaHQgKyAncHgnLFxuXHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzonYmx1ZSdcblx0XHRcblx0XHRcdFx0fSkuYXBwZW5kVG8odGhpcy5jb250KTtcblx0XG5cdFx0XHRcdHZhciBidWxfY29udCA9ICQoJzxkaXY+JykuY3NzKHtcblx0XHRcdFx0XHRcIndpZHRoXCI6ICBcIjEwMCVcIixcblx0XHRcdFx0XHRcImhlaWdodFwiOiAoMTcwIC0gdGhpcy5ydWxlc19oZWlnaHQpICsgXCJweFwiLFxuXHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzonZ3JlZW4nXG5cdFx0XHRcdH0pLmFwcGVuZFRvKHRoaXMuY29udCk7XG5cdFxuXHRcdFx0XHR2YXIgYXV0b190cmFja19zd2l0Y2ggPSAkKCc8ZGl2PicpLmNzcyh7J3dpZHRoJzonMjJweCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J2hlaWdodCc6JzIycHgnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCdib3JkZXItcmFkaXVzJzonMTFweCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J2Zsb2F0JzonbGVmdCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOid3aGl0ZSd9KS5hcHBlbmRUbyhydWxfY29udCk7XG5cdFx0XHRcdHRoaXMubWFnYXppbmVfaW5kaWNhdG9yID0gJCgnPGRpdj4nKS5jc3MoXG5cdFx0XHRcdFx0eyd3aWR0aCc6JzIycHgnLFxuXHRcdFx0XHRcdCdoZWlnaHQnOiAgdGhpcy5ydWxlc19oZWlnaHQgKyAgJ3B4Jyxcblx0XHRcdFx0XHQnZmxvYXQnOidsZWZ0Jyxcblx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6J3JlZCd9KS5hcHBlbmRUbyhydWxfY29udCk7XG5cdFx0XHRcdHRoaXMudGltZV9pbmRpY2F0b3IgPSAkKCc8ZGl2PicpLmNzcyhcblx0XHRcdFx0XHR7J3dpZHRoJzonMjJweCcsXG5cdFx0XHRcdFx0J2hlaWdodCc6ICB0aGlzLnJ1bGVzX2hlaWdodCsgICdweCcsXG5cdFx0XHRcdFx0J2Zsb2F0JzonbGVmdCcsXG5cdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOidyZWQnfVxuXHRcdFx0XHQpIC5hcHBlbmRUbyhydWxfY29udCk7XG5cdFxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2V0X21hZ2F6aW5lX2NhcGFjaXR5ID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFyIE8gPSBXLnNjZW5lc1thY3Rvci5zY2VuZV0ubWVzaGVzW2FjdG9yLmNvbnRyb2wub2JqZWN0X2d1aWRdO1xuXHRcdFx0XHR2YXIgd3AgPSBPLmpzb24ud29ya3BvaW50c1thY3Rvci5jb250cm9sLndvcmtwb2ludF07XG5cdFx0XHRcdHZhciBtYWdfY2FwID0gTy5qc29uLnR1cnJldHNbd3AudHVycmV0XS5tYWdhemluZV9jYXBhY2l0eTtcblx0XHRcdFx0dmFyIF9tYWcgICAgPSBPLmdldFdvcmtwb2ludFZhbHVlKGFjdG9yLmNvbnRyb2wud29ya3BvaW50LCBcIm1hZ2F6aW5lXCIpO1xuXHRcdFx0XHRpZiAoISBfbWFnKSBfbWFnID0gMDtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBwZXJjZW50YWdlID0gX21hZy8gbWFnX2NhcDtcblx0XHRcdFx0aWYoX21hZyAgPT0gMCl7XG5cdFx0XHRcdFx0dGhpcy5tYWdhemluZV9pbmRpY2F0b3IuaGVpZ2h0KFwiMXB4XCIpO1xuXHRcdFx0XHRcdHRoaXMubWFnYXppbmVfaW5kaWNhdG9yLmNzcygnYmFja2dyb3VuZC1jb2xvcicsJ3JlZCcpXG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHRoaXMubWFnYXppbmVfaW5kaWNhdG9yLmhlaWdodChwZXJjZW50YWdlICogdGhpcy5ydWxlc19oZWlnaHQpO1xuXHRcdFx0XHRcdHRoaXMubWFnYXppbmVfaW5kaWNhdG9yLmNzcygnYmFja2dyb3VuZC1jb2xvcicsJ2dyZWVuJylcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NldF9yZWFkaW5lc3NfdGltZXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHR2YXIgTyA9IFcuc2NlbmVzW2FjdG9yLnNjZW5lXS5tZXNoZXNbYWN0b3IuY29udHJvbC5vYmplY3RfZ3VpZF07XG5cdFx0XHRcdHZhciB3cCA9IE8uanNvbi53b3JrcG9pbnRzW2FjdG9yLmNvbnRyb2wud29ya3BvaW50XTtcblx0XHRcdFx0dmFyIHJhdGUgPSBPLmpzb24udHVycmV0c1t3cC50dXJyZXRdLnR1cnJldF9zaG9vdF9yYXRlO1xuXHRcdFx0XHR2YXIgcmVsb2FkX3JhdGUgPSBPLmpzb24udHVycmV0c1t3cC50dXJyZXRdLnR1cnJldF9yZWxvYWRfcmF0ZTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBfdHMgID0gTy5nZXRXb3JrcG9pbnRWYWx1ZShhY3Rvci5jb250cm9sLndvcmtwb2ludCwgXCJsYXN0X3Nob3RfdGltZVwiKTtcblx0XHRcdFx0dmFyIGlyX3RzID0gTy5nZXRXb3JrcG9pbnRWYWx1ZShhY3Rvci5jb250cm9sLndvcmtwb2ludCwgXCJpc19yZWxvYWRpbmdcIik7XG5cdFx0XHRcdHZhciBub3cgID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cblx0XHRcdFx0dmFyIGlyX2RpZmYgPSBub3cgLSBpcl90cztcblx0XHRcdFx0aWYoaXJfZGlmZiA+IHJlbG9hZF9yYXRlKXtcblx0XHRcdFx0XHR2YXIgX21hZyAgICA9IE8uZ2V0V29ya3BvaW50VmFsdWUoYWN0b3IuY29udHJvbC53b3JrcG9pbnQsIFwibWFnYXppbmVcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBkaWZmID0gbm93IC0gX3RzO1xuXHRcdFx0XHRcdGlmKF9tYWcgPT09IDAgKXtcblx0XHRcdFx0XHRcdHBlcmNlbnRhZ2UgPSAwO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0aWYoZGlmZiA+IHJhdGUpe1xuXHRcdFx0XHRcdFx0XHR2YXIgcGVyY2VudGFnZSA9IDE7XG5cdFx0XHRcdFx0XHR9IGVsc2V7XG5cdFx0XHRcdFx0XHRcdHZhciBwZXJjZW50YWdlID0gIChkaWZmIC8gcmF0ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRwZXJjZW50YWdlID0gaXJfZGlmZi9yZWxvYWRfcmF0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMudGltZV9pbmRpY2F0b3IuaGVpZ2h0KHBlcmNlbnRhZ2UgKiB0aGlzLnJ1bGVzX2hlaWdodCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHRoaXMuX3NldF9yZWFkaW5lc3NfdGltZXIoKTtcblx0XHRcdFx0dGhpcy5fc2V0X21hZ2F6aW5lX2NhcGFjaXR5KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBVSSA9IG5ldyB1aSgpO1xuXHRcdHJldHVybiBVSTtcblx0fVxuXHRcdFxuXHRcblx0XG5cdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKHJhd19hY3Rpb24sIG1lc2gpe1xuXHRcdC8vIGNvbnNvbGUubG9nKFwiT24gdGhlIHNlcnZlclwiLCBhY3Rpb24pO1xuXHRcdFxuXHRcdHZhciBwcm9jZXNzID0gZnVuY3Rpb24ob2JqZWN0X2d1aWQsIGFjdGlvbil7XG5cdFx0XHRjb25zb2xlLmxvZyhcIkNIT1wiLCBhY3Rpb24udHlwZSA9PT0gU0hPT1QsIGFjdGlvbi50eXBlID09IFNIT09ULCBhY3Rpb24udHlwZSlcblx0XHRcdGlmKGFjdGlvbi50eXBlID09IFJFTE9BRF9XRUFQT05TKXtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwicHJvY2VzcyA+IFJFQUxPRElORzpcIiwgYWN0aW9uKTtcblx0XHRcdFx0bWVzaC5zYXZlV29ya3BvaW50VmFsdWUoIGFjdGlvbi53cCwgXCJpc19yZWxvYWRpbmdcIiAsIGFjdGlvbi50cyApOyBcblx0XHRcdFx0bWVzaC5zYXZlV29ya3BvaW50VmFsdWUoIGFjdGlvbi53cCwgJ21hZ2F6aW5lJywgYWN0aW9uLm5ld19jYXBhY2l0eSk7XG5cdFx0XHR9XG5cdFx0XHRpZihhY3Rpb24udHlwZSA9PT0gSElUKXtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJwcm9jZXNzID4gSElURURcIiwgYWN0aW9uKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGFjdGlvbi50eXBlID09IFNIT09UKXtcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHRtZXNoLnNhdmVXb3JrcG9pbnRWYWx1ZShhY3Rpb24ud3AsIFwibGFzdF9zaG90X3RpbWVcIiwgYWN0aW9uLnRzKTtcblx0XHRcdFx0dmFyIGFtID0gbWVzaC5nZXRXb3JrcG9pbnRWYWx1ZShhY3Rpb24ud3AsICdtYWdhemluZScpO1xuXHRcdFx0XHRpZiAoYW0gKXtcblx0XHRcdFx0XHRpZiAoYW0gIT09IDApe1xuXHRcdFx0XHRcdFx0bWVzaC5zYXZlV29ya3BvaW50VmFsdWUoYWN0aW9uLndwLFwibWFnYXppbmVcIiwgYW0gLSAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9XG5cdFx0Ly8gY29uc29sZS5sb2coJ2NhbGwgcHJvY2VzcycsICBfLmhhcyhyYXdfYWN0aW9uLCd2ZWN0b3InKSApO1xuXHRcdFxuXHRcdC8vaWYgKF8uaGFzKHJhd19hY3Rpb24sICd2ZWN0b3InKSkgIHsgLy8g0JXRgdC70Lgg0LDQutGG0LjRjiDRg9C20LUg0LLRi9GH0LjRgdC70LjQu9C4IC0g0LHRg9C00LXQvCDQv9GA0LjQvNC10L3Rj9GC0Ywg0LLRgdC1INCy0LXQutGC0L7RgNCwINC90LAg0L3QtdC1XG5cdFx0cHJvY2VzcygnLScsIHJhd19hY3Rpb24pXG5cdFx0XHQvL31lbHNle1xuXHRcdC8vXHR0aGlzLmFjdF9mb3JfbWVzaChtZXNoLCByYXdfYWN0aW9uLCBwcm9jZXNzKTsgLy8g0JXRgdC70Lgg0L3QtdGCIC0g0YLQviDRgdC90LDRh9Cw0LvQsCDQstGL0YfQuNGB0LvQuNC8INC40YVcblx0XHRcdC8vIH1cblx0fTtcblx0XG5cdFx0dGhpcy5hY3QgPSBmdW5jdGlvbihTLCBhY3Rpb24sICBhY3Rvcl9ndWlkLCBvbkFjdCApe1xuXHRcdFx0aWYgKFMgPT09IHVuZGVmaW5lZCl7cmV0dXJuO31cblx0XHRcdFxuXHRcdFx0dmFyIEMgPSBTLm1lc2hfZm9yKGFjdG9yX2d1aWQpO1xuXHRcdFx0XG5cdFx0XHRpZiAoYWN0aW9uLnR5cGUgPT09IEhJVCl7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwid2UgYWxyZWFkeSBwcm9jZXNzZWQgIGhpdFwiLCBhY3Rpb24pO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoYWN0aW9uLnR5cGUgPT09IFJFTE9BRF9XRUFQT05TKXtcblx0XHRcdFx0Ly8gSGVyZSB3ZSBjb3VsZCBjaGVjayBpZiB3ZSBjYW4gcmVsb2FkIC0gaXNuJ3QgYnVsbGV0IGJ1bmtlciBlbXB0eT9cblx0XHRcdFx0dmFyIGFjdG9yID0gUy5nZXRfYWN0b3IoYWN0b3JfZ3VpZCk7XG5cdFx0XHRcdHZhciBPID0gUy5tZXNoZXNbYWN0b3IuY29udHJvbC5vYmplY3RfZ3VpZF07XG5cdFx0XHRcdHZhciB3cCA9IE8uanNvbi53b3JrcG9pbnRzW2FjdG9yLmNvbnRyb2wud29ya3BvaW50XTtcblx0XHRcdFx0dmFyIG1hZ19jYXAgPSBPLmpzb24udHVycmV0c1t3cC50dXJyZXRdLm1hZ2F6aW5lX2NhcGFjaXR5O1xuXHRcdFx0XHRcblx0XHRcdFx0YWN0b3IgPSBTLmdldF9hY3RvcihhY3Rvcl9ndWlkKTtcblx0XHRcdFx0YWN0aW9uLndwID0gYWN0b3IuY29udHJvbC53b3JrcG9pbnQ7XG5cdFx0XHRcdGFjdGlvbi5uZXdfY2FwYWNpdHkgPSBtYWdfY2FwO1xuXHRcdFx0XHRvbkFjdChDLmpzb24uR1VJRCwgYWN0aW9uKTtcblx0XHRcdH1cblx0XHRcdGlmIChhY3Rpb24udHlwZSA9PT0gU0hPT1QgKXtcblx0XHRcdFx0Ly8gaWYoISBpc19kb3duKSByZXR1cm47XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCc+Pj4nKTtcblx0XHRcdFx0Ly8gdmFyIHdlYXBvbiA9IEMud2VhcG9uc1swXTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcInNob3QgYnlcIiwgYWN0b3IpXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgVCA9IENvbnRyb2xsZXIuVCgpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiV29haFwiKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFRPRE8g0J3QsNC00L4g0YHQtNC10LvQsNGC0Ywg0L/RgNC+0YHRgtC+0Lkg0YHQv9C+0YHQvtCxINC/0YDQvtCy0LXRgNC40YLRjCDQv9C+0L/QsNC00LDQvdC40LUg0LIg0YLQtdC60YPRjtGJ0YPRjiDRhtC10LvRjCDQuNGB0YXQvtC00Y8g0LjQtyDQtNCw0L3QvdGL0YUg0LIg0YHQvtC+0LHRidC10L3QuNC4XG5cdFx0XHRcdC8vIFRPRE8g0J3QtSDQsdGD0LTQtdC8INCz0L3QsNGC0YzRgdGPINC30LAg0LTQvtGB0YLQvtCy0LXRgNC90L7RgdGC0YzRjiAtINC/0YDQvtCy0LXRgNGP0LXQvCDQtNC+0YHRgtC+0LLQtdGA0L3QvtGB0YLQuCDQv9C+0L/QsNC00LDQvdC40Y8gKyDQstCy0L7QtNC40Lwg0LLQtdC70LjRh9C40L3RgyDQstC10LfQtdC90LjRjy5cblx0XHRcdFx0Ly8gVE9ETyDQmtGA0LDRgtGH0LDQudGI0LXQtSDRgNCw0YHRgdGC0L7Rj9C90LjQtSDQvNC10LbQtNGDINGB0LrRgNC10YnQuNCy0LDRjtGJ0LjQvNC40YHRjyDQutGA0LjQstGL0LzQuCDQuCDRgdGA0LDQstC90LXQvdC40LUg0YEg0YTQuNC30LjRh9C10YHQutC40LzQuCDRgNCw0LfQvNC10YDQsNC80Lhcblx0XHRcdFx0Ly8gVE9ETyDQo9C80L3QvtC20LXQvdC90L7QtSDQvdCwINC60L7RjdGE0YTQuNGG0LjQtdC90YLRiyDRgNCw0LfQsdGA0L7RgdCwXG5cdFx0XHRcdC8vINCU0LvRjyDQvNC10LTQu9C10L3QvdC+INC00LLQuNC20YPRjtGJ0LjRhdGB0Y8g0LfQsNGA0LDQtNC+0LIg0LLRi9GH0LjRgdC70Y/RgtGMINCy0LXRgNC+0Y/RgtC90L7RgdGC0Ywg0LjRhSDQv9C+0L/QsNC00LDQvdC40Y8gLSDQstC+0LfQvNC+0LbQvdC+0YHRgtGMINC40LfQvNC10L3QuNGC0Ywg0YHQutC+0YDQvtGB0YLRjCDRhtC10LvQuCDRgtCw0LosINGH0YLQvtCx0Ysg0L/QvtC/0LDRgdGC0Ywg0L/QvtC0INC+0LHRgdGC0YDQtdC7INC40LvQuCDRg9C50YLQuCDQvtGCINC90LXQs9C+XG5cdFx0XHRcdC8vINCU0LvRjyDRgNCw0LrQtdGCIC0g0Y3RgtC+INCx0YPQtNGD0YIg0YTRg9C90LrRhtC40Lgg0LfQsNGF0LLQsNGC0LAg0YbQtdC70Lgg0Lgg0LLRi9GB0YLRgNC10LvQsCAtINCy0LvQuNGP0L3QuNGPINC90LAg0YHQvtGB0YLQvtGP0L3QuNC1INGC0YPRgNC10LvQuC5cblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgc2VlZCA9IE1hdGgucmFuZG9tKCkgLy8g0K3RgtC+INC30LXRgNC90L4g0LHRg9C00LXRgiDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0YzRgdGPINC00LvRjyDQstGL0YfQuNGB0LvQtdC90LjRjyDQstC10YDQvtGP0YLQvdC+0YHRgtC10Lkg0Lgg0L7QvdC+INC00L7Qu9C20L3QviDQsdGL0YLRjCDQt9Cw0L/QuNGB0LDQvdC+INCyINGB0L7QvtCx0YnQtdC90LjQtSAtINGH0YLQvtCx0Ysg0L/QvtC30LLQvtC70LjRgtGMINGB0LXRgNCy0LXRgNGDINCy0YvRh9C40YHQu9C40YLRjCDQv9Cw0YDQsNC80LXRgtGA0Ysg0L/QvtC/0LDQtNCw0L3QuNGPINC00LXRgtC10YDQvNC40L3QuNGA0L7QstCw0L3QvdC+XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKGFjdGlvbilcblx0XHRcdFx0Ly8g0KLQtdC/0LXRgNGMINCy0YvRgdC70Y/QtdC8INCy0LXQutGC0L7RgCDQstGL0YHRgtGA0LXQu9CwINCyINC80LjRgNC+0LLRi9GFINC60L7QvtGA0LTQuNC90LDRgtCw0YVcblx0XHRcdFx0dmFyIHNob290X3ZlYyA9IG5ldyBULlZlY3RvcjMoYWN0aW9uLnAudHVycmV0X2RpcmVjdGlvbi54LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgYWN0aW9uLnAudHVycmV0X2RpcmVjdGlvbi55LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgYWN0aW9uLnAudHVycmV0X2RpcmVjdGlvbi56KTtcblxuXHRcdFx0XHQvL2Rpc3Rcblx0XHRcdFx0Ly8gRm9yIGFsbCB0YXJnZXRzOlxuXHRcdFx0XHQvLyBjYWxjdWxhdGUgY2xvc2VzdCBkaXN0YW5jZSBhbmQgdGltZSB0byB0aGF0IFxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIkFDVE9SXCIsIGFjdG9yKTtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBDID0gUy5tZXNoX2ZvcihhY3Rvcl9ndWlkKTtcblx0XHRcdFx0dmFyIG9iamVjdCA9IEMuanNvblxuXHRcdFx0XHR2YXIgYWN0b3IgPSBTLmFjdG9yc1thY3Rvcl9ndWlkXTtcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgd3AgPSBvYmplY3Qud29ya3BvaW50c1thY3Rvci5jb250cm9sLndvcmtwb2ludF07XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgbGFzdF9zaG90X3RpbWUgPSBDLmdldFdvcmtwb2ludFZhbHVlKGFjdG9yLmNvbnRyb2wud29ya3BvaW50LCBcImxhc3Rfc2hvdF90aW1lXCIpXG5cdFx0XHRcdHZhciBpc19yZWxvYWRpbmcgPSBDLmdldFdvcmtwb2ludFZhbHVlKGFjdG9yLmNvbnRyb2wud29ya3BvaW50LCBcImlzX3JlbG9hZGluZ1wiICApOyBcblx0XHRcdFx0dmFyIF9tYWcgPSBDLmdldFdvcmtwb2ludFZhbHVlKGFjdG9yLmNvbnRyb2wud29ya3BvaW50LCBcIm1hZ2F6aW5lXCIpXG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIlNFUlYgYWN0IGJlZm9yZVwiLCBhY3Rpb24pO1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIkxPRyBUSU1FU1wiLCBpc19yZWxvYWRpbmcsIGxhc3Rfc2hvdF90aW1lLCAgYWN0aW9uLnRzIC0gaXNfcmVsb2FkaW5nLCBhY3Rpb24udHMgLSBsYXN0X3Nob3RfdGltZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiggKGFjdGlvbi50cyAtICBpc19yZWxvYWRpbmcpIDwgQy5qc29uLnR1cnJldHNbd3AudHVycmV0XS50dXJyZXRfcmVsb2FkX3JhdGUpe1xuXHRcdFx0XHRcdHJldHVybiA7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS5sb2coXCJTRVJWIGFjdCAtIHJlbG9hZGVkXCIsIGFjdGlvbik7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZihfbWFnID09IDApe1xuXHRcdFx0XHRcdHJldHVybiA7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS5sb2coXCJTRVJWIGFjdCBmdWxsIG1hZ1wiLCBhY3Rpb24pO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGxhc3Rfc2hvdF90aW1lKXtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcImxhc3Qgc2hvdCB0aW1lXCIsIGxhc3Rfc2hvdF90aW1lLChhY3Rpb24udHMgLSBsYXN0X3Nob3RfdGltZSApIDwgQy5qc29uLnR1cnJldHNbd3AudHVycmV0XS50dXJyZXRfc2hvb3RfcmF0ZSApO1xuXHRcdFx0XHRcdGlmKChhY3Rpb24udHMgLSBsYXN0X3Nob3RfdGltZSApIDwgQy5qc29uLnR1cnJldHNbd3AudHVycmV0XS50dXJyZXRfc2hvb3RfcmF0ZSl7XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZygnbm8gc2hvb3QnKTtcblx0XHRcdFx0XHRcdHJldHVybjsgLy8gdGhpcyB0dXJyZXQgY2Fubm90IHNob290IG5vd1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIlNFUlYgYWN0IHNob290IGZyZWVseVwiLCBhY3Rpb24pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJCT09PU0ghXCIpO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdHZhciB0dXJyZXQgPSBvYmplY3QudHVycmV0c1sgd3AudHVycmV0IF0gXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgdHVycmV0X3Bvc2l0aW9uX3ZlY3RvciA9IG5ldyBULlZlY3RvcjMoKTtcblx0XHRcdFx0dHVycmV0X3Bvc2l0aW9uX3ZlY3Rvci5mcm9tQXJyYXkodHVycmV0LnBvc2l0aW9uICk7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgYnVsbGV0X3BvcyA9IEMucG9zaXRpb24uY2xvbmUoKVxuXHRcdFx0XHRidWxsZXRfcG9zLmFkZCggIHR1cnJldF9wb3NpdGlvbl92ZWN0b3IuY2xvbmUoKSApXG5cdFx0XHRcdFxuXHRcdFx0XHRzaG9vdF92ZWMuc3ViKGJ1bGxldF9wb3MuY2xvbmUoKSlcblx0XHRcdFx0Ly8g0J3QsNC00L4g0YHQvtGB0YLQsNCy0LjRgtGMINGB0L/QuNGB0L7QuiDQvNC10YjQtdC5LCDRh9C10YDQtdC3INC60L7RgtC+0YDRi9C1INC/0YDQvtGF0L7QtNC40YIg0LvRg9GHINGC0YDQsNC10LrRgtC+0YDQuNC4INC00LLQuNC20LXQvdC40Y8g0YHQvdCw0YDRj9C00LAg0YEg0YPRh9C10YLQvtC8INCy0LXRgNC+0Y/RgtC90L7RgdGC0Lgg0L/QvtC/0LDQtNCw0L3QuNGPXG5cdFx0XHRcdHZhciBjb2xsaWRhYmxlcyA9IFtdO1xuXHRcdFx0XHRfLmVhY2goUy5tZXNoZXMsIGZ1bmN0aW9uKG1lc2gsIGkpe1xuXHRcdFx0XHRcdGlmKGkgPT0gIGFjdG9yLmNvbnRyb2wub2JqZWN0X2d1aWQpIHJldHVybjtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgdGFyZ2V0X3BvcyA9IG1lc2gucG9zaXRpb24uY2xvbmUoKTtcblx0XHRcdFx0XHR2YXIgdGFyZ2V0X2ltcHVsc2UgPSBtZXNoLmltcHVsc2UuY2xvbmUoKTtcblx0XHRcdFx0XHR2YXIgdGFyZ2V0X3ZlbG9jaXR5ID0gdGFyZ2V0X2ltcHVsc2UubXVsdGlwbHlTY2FsYXIoMS9tZXNoLm1hc3MpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vINCj0LLQtdC70LjRh9C40Lwg0YHQutC+0YDQvtGB0YLRjCDQstC+INC80L3QvtCz0L4t0LzQvdC+0LPQviDRgNCw0Ldcblx0XHRcdFx0XHQvLyBzaG9vdF92ZWMubXVsdGlwbHlTY2FsYXIoIDEwMCApO1xuXHRcdFx0XHRcdHRhcmdldF9wb3Muc3ViKCBidWxsZXRfcG9zICk7XG5cdFx0XHRcdFx0dGFyZ2V0X3ZlbG9jaXR5LnN1Yiggc2hvb3RfdmVjICk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIGRvdCA9IHRhcmdldF9wb3MuZG90KHRhcmdldF92ZWxvY2l0eSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIGNvc3AgPSBkb3QvKCB0YXJnZXRfcG9zLmxlbmd0aCgpICogdGFyZ2V0X3ZlbG9jaXR5Lmxlbmd0aCgpIClcblx0XHRcdFx0XHR2YXIgc2lucCA9IE1hdGguc3FydCgxIC0gY29zcCpjb3NwKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgdiA9IE1hdGguYWJzKGNvc3ApICogdGFyZ2V0X3ZlbG9jaXR5Lmxlbmd0aCgpO1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKHYsIHRhcmdldF9wb3MubGVuZ3RoKCkpO1xuXHRcdFx0XHRcdHZhciB0aW1lID0gdGFyZ2V0X3Bvcy5sZW5ndGgoKSAvIHYgXG5cdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gc2lucCAqIHRhcmdldF9wb3MubGVuZ3RoKCk7IC8vINCc0LDQutGB0LjQvNCw0LvRjNC90LDRjyDQtNC40YHRgtCw0L3RhtC40Y8sINCyINC60L7RgtC+0YDQvtC5INC/0YDQvtC50LTQtdGCINGB0L3QsNGA0Y/QtCDQvtGCINC60L7RgNCw0LHQu9GPXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcImRpc3RhbmNlIGFuZCB0aW1lXCIsIGRpc3RhbmNlLCB0aW1lKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyDQoNC10YjQtdC90LjQtSDQviDQv9C+0L/QsNC00LDQvdC40Lgg0L3QsNC00L4g0L/RgNC40L3QuNC80LDRgtGMINC30LTQtdGB0Yxcblx0XHRcdFx0XHQvLyAgZGlzdGFuY2Ug0JzQvtC20LXRgiDRg9C80LXQvdGM0YjQuNGC0YzRgdGPINCyINC30LDQstC40YHQuNC80L7RgdGC0Lgg0L7RgiDRgdC60LjQu9C70L7QsiDQuNCz0YDQvtC60LAg0Lgg0YXQsNGA0LDQutGC0LXRgNC40YHRgtC40Log0L7RgNGD0LbQuNGPXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8g0KHRgNCw0LLQvdC10L3QuNC1INGBINCz0LXQvtC80LXRgtGA0LjRh9C10YHQutC40LzQuCDRgNCw0LfQvNC10YDQsNC80Lgg0YLQtdC70LA6XG5cdFx0XHRcdFx0dmFyIGJvdW5kUmFkaXVzID0gbWVzaC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZTtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIlNQSEVSRVwiLCBib3VuZFJhZGl1cy5yYWRpdXMsIGRpc3RhbmNlKTtcblx0XHRcdFx0XHRpZihkaXN0YW5jZSA8IGJvdW5kUmFkaXVzLnJhZGl1cyl7XG5cdFx0XHRcdFx0XHQvLyBoaXQgXG5cdFx0XHRcdFx0XHRjb2xsaWRhYmxlcy5wdXNoKHt0aW1lOiB0aW1lLCBtZXNoOmksIGRpc3RhbmNlOmRpc3RhbmNlfSlcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyDQodC40L3Rg9GBIC0g0Y3RgtC+INC80LXRgNCwINC/0L7Qv9Cw0LTQsNC90LjRjy4g0J/RgNC4INGD0LzQvdC+0LbQtdC90LjQuCDQtdGRINC90LAg0LLQtdC60YLQvtGAINC/0L7Qt9C40YbQuNC4INC80Ysg0YPQt9C90LDQtdC8INC90LAg0LrQsNC60L7QuSDQtNC40YHRgtCw0L3RhtC40Lgg0L/RgNC+0LnQtNC10YIg0YHQvdCw0YDRj9C0INC+0YIg0YbQtdC70Lhcblx0XHRcdFx0XHQvLyDQmtC+0YHQuNC90YPRgSDQtNCw0LXRgiDQv9GA0LXQtNGB0YLQsNCy0LvQtdC90LjQtSDQviDQstGA0LXQvNC10L3QuCAg0LTQviDQutC+0L3RgtCw0LrRgtCwLiDQldGB0LvQuCDQutC+0YHQuNC90YPRgSDQvtGC0YDQuNGG0LDRgtC10LvRjNC90YvQuSAtINC30L3QsNGH0LjRgiAgXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJzaW4gYW5kIGNvc1wiLCB0YXJnZXRfcG9zLnRvQXJyYXkoKSwgbWVzaC5wb3NpdGlvbi50b0FycmF5KCksIHNpbnAsIGNvc3ApO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8g0KLQtdC/0LXRgNGMLCDQvdCw0LTQviDQt9Cw0L/QuNGF0L3Rg9GC0Ywg0Y3RgtC+INGB0L7QsdGL0YLQuNC1INCyINC+0YfQtdGA0LXQtNGMINC/0YDQvtGG0LXRgdGB0LjQvdCz0LA6XG5cdFx0XHRcdC8vIDEuINCh0L7QsdGL0YLQuNC1IC0g0LjQvNC/0YPQu9GM0YEg0L3QsCDQvdCw0YEsINC60L7RgtC+0YDQvtC1INC80L7QttC10YIg0LLQutC70Y7Rh9Cw0YLRjCDRgtCw0LrQttC1INC40LfQvNC10L3QuNC1INGB0L7RgdGC0L7Rj9C90LjQuSDQstC90YPRgtGA0LXQvdC90LjRhSDQv9GA0LjQsdC+0YDQvtCyIC0g0L3QsNC/0YDQuNC80LXRgCDQutC+0LvQuNGH0LXRgdGC0LLQviDQv9Cw0YLRgNC+0L3QvtCyXG5cdFx0XHRcdC8vIDIuINCSINGB0LvRg9GH0LDQtSDQv9C+0L/QsNC00LDQvdC40Y8gLSDQvtGC0L/RgNCw0LLQuNGC0Ywg0LIg0LHRg9C00YPRidC10LUg0YHQvtCx0YvRgtC40LUg0L7QsSDQuNC30LzQtdC90LXQvdC40Lgg0LjQvNC/0YPQu9GM0YHQsCDQuCDRgdC+0YHRgtC+0Y/QvdC40Y8g0YbQtdC70LguXG5cdFx0XHRcdFxuXHRcdFx0XHRhY3Rpb24ud3AgPSBhY3Rvci5jb250cm9sLndvcmtwb2ludDtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJjaGVja291dCBpZiB3ZSBnb3QgaXRcIik7XG5cdFx0XHRcdGlmIChjb2xsaWRhYmxlcy5sZW5ndGggPiAwKXtcblx0XHRcdFx0XHR2YXIgY29sID0gXy5zb3J0QnkoY29sbGlkYWJsZXMsIGZ1bmN0aW9uKGkpeyByZXR1cm4gaS50aW1lfSlbMF1cblx0XHRcdFx0XHR2YXIgIG1lc2hfaWQgPSBjb2wubWVzaFxuXHRcdFx0XHRcdGFjdGlvbi5oaXQgPSB0cnVlO1xuXHRcdFx0XHRcdGFjdGlvbi50aW1lID0gY29sLnRpbWU7XG5cdFx0XHRcdFx0YWN0aW9uLm1lc2ggPSBtZXNoX2lkO1xuXHRcdFx0XHRcdGFjdGlvbi5kaXN0YW5jZSA9IGNvbC5kaXN0YW5jZTtcblx0XHRcdFx0XHRhY3Rpb24uc2VlZCA9IHNlZWQ7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIGhpdF9hY3Rpb24gPSB7fTtcblx0XHRcdFx0XHRoaXRfYWN0aW9uLnRzID0gYWN0aW9uLnRzICsgYWN0aW9uLnRpbWU7XG5cdFx0XHRcdFx0aGl0X2FjdGlvbi5zbGF2ZSA9IHRydWU7XG5cdFx0XHRcdFx0aGl0X2FjdGlvbi5wYXJlbnQgPSBhY3Rpb24uaWRlbnQ7XG5cdFx0XHRcdFx0aGl0X2FjdGlvbi5kaWZmID0gYWN0aW9uLmRpZmY7XG5cdFx0XHRcdFx0aGl0X2FjdGlvbi5wb3dlciA9IDEwMDUwMDtcblx0XHRcdFx0XHRoaXRfYWN0aW9uLmRpc3RhbmNlID0gY29sLmRpc3RhbmNlO1xuXHRcdFx0XHRcdGhpdF9hY3Rpb24ubWVzaCA9IG1lc2hfaWQ7XG5cdFx0XHRcdFx0aGl0X2FjdGlvbi5jb250cm9sbGVyID0gXCJ0dXJyZXRcIjtcblx0XHRcdFx0XHRoaXRfYWN0aW9uLnR5cGUgPSBISVQ7XG5cdFx0XHRcdFx0aGl0X2FjdGlvbi5hY3RvciA9IGFjdGlvbi5hY3Rvcjtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIkhJVFwiLCBhY3Rpb24sIGhpdF9hY3Rpb24pO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiSElISUhJVFwiLCBhY3Rpb24udGltZSk7XG5cdFx0XHRcdFx0b25BY3QobWVzaF9pZCwgaGl0X2FjdGlvbik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGFjdGlvbi5oaXQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvbkFjdChDLmpzb24uR1VJRCwgYWN0aW9uKTtcblx0XHRcdFx0IFxuXHRcdFx0XHRcblx0XHRcdFxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyByZXR1cm4gdGhpcztcblx0XG5cdH07XG5Db250cm9sbGVyLkNvbnRyb2xsZXJzQWN0aW9uTWFwPSBmdW5jdGlvbigpe1xuXHRcdGlmICh0aGlzLl9Db250cm9sbGVyc0FjdGlvbk1hcCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5fQ29udHJvbGxlcnNBY3Rpb25NYXBcblx0XHR9ZWxzZXtcblx0XHRcdC8vINCS0L7QvtCx0YnQtSDQvdCw0Lwg0LHRiyDQvdC1INC/0L7QvNC10YjQsNC70Lgg0LjQvdGB0YLQsNC90YHRiyDQutC+0L3RgtGA0L7Qu9C+0LIg0LjQvdC40YbQuNCw0LvQuNC30LjRgNC+0LLQsNC90L3Ri9C1INC00LvRjyDRgdCy0L7QtdC5IHdwINGH0YLQvtCx0Ysg0L3QtSDQutC+0L3QvtC/0LDRgtC40YLRjCDQvNC+0LfQsy5cblx0XHRcdHZhciBQaWxvdENvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlci5DUGlsb3RDb250cm9sbGVyKCk7XG5cdFx0XHR2YXIgVHVycmV0Q29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyLkNUdXJyZXRDb250cm9sbGVyKCk7XG5cdFx0XHR2YXIgU2V0dGluZ3NDb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIuQ1NldHRpbmdDb250cm9sbGVyKCk7XG5cdFx0XHR0aGlzLl9Db250cm9sbGVyc0FjdGlvbk1hcCA9IHt9XG5cdFx0XHQvL3RoaXMuX0NvbnRyb2xsZXJzQWN0aW9uTWFwW01PVkVdPSBQaWxvdENvbnRyb2xsZXI7XG5cdFx0XHQvL3RoaXMuX0NvbnRyb2xsZXJzQWN0aW9uTWFwW1JPVEFURV09UGlsb3RDb250cm9sbGVyO1xuXHRcdFx0dGhpcy5fQ29udHJvbGxlcnNBY3Rpb25NYXBbJ3BpbG90J109IFBpbG90Q29udHJvbGxlcjtcblx0XHRcdHRoaXMuX0NvbnRyb2xsZXJzQWN0aW9uTWFwWydlbmdpbmUnXT0gUGlsb3RDb250cm9sbGVyO1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9Db250cm9sbGVyc0FjdGlvbk1hcFsndHVycmV0J109IFR1cnJldENvbnRyb2xsZXI7XG5cdFx0XHR0aGlzLl9Db250cm9sbGVyc0FjdGlvbk1hcFsnc2V0dGluZ3MnXSA9IFNldHRpbmdzQ29udHJvbGxlcjtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXMuX0NvbnRyb2xsZXJzQWN0aW9uTWFwO1xuXHRcdFx0XG5cdFx0fVxuXHR9XG5cbmlmKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKXtcblx0Q29udHJvbGxlci5UID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gVEhSXG5cdH07XG5cdENvbnRyb2xsZXIuY3JlYXRlU2hvdFBhcnRpY2xlPWZ1bmN0aW9uKCl7XG5cdFx0dmFyIFQgPSB0aGlzLlQoKTtcblx0XHRjb25zb2xlLmxvZygnUCcpO1xuXHRcdHZhciBjdWJlR2VvbWV0cnkgPSBuZXcgVC5DdWJlR2VvbWV0cnkoMSwxLDEsMSwxLDEpO1xuXHRcdHZhciBtYXBcdD0gVC5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKCBcIi90ZXh0dXJlcy9sZW5zZmxhcmUvbGVuc2ZsYXJlMC5wbmdcIiApO1xuXHRcdHZhciBTcHJpdGVNYXRlcmlhbCA9IG5ldyBULlNwcml0ZU1hdGVyaWFsKCB7IG1hcDogbWFwLCBjb2xvcjogMHhmZmZmZmYsIGZvZzogdHJ1ZSB9ICk7XG5cdFx0cmV0dXJuIG5ldyBULk9iamVjdDNEKCk7XG5cdH07XG5cbn1lbHNle1xuXHRDb250cm9sbGVyLlQgPSBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBUSFJFRVxuXHR9O1xuXHRDb250cm9sbGVyLmNyZWF0ZVNob3RQYXJ0aWNsZT1mdW5jdGlvbigpe1xuXHRcdHZhciBUID0gdGhpcy5UKCk7XG5cdFx0Ly8gY29uc29sZS5sb2coXCJwYXJ0aWNsZVwiKVxuXHRcdC8vIHZhciBjdWJlR2VvbWV0cnkgPSBuZXcgVC5DdWJlR2VvbWV0cnkoMSwxLDEsMSwxLDEpO1xuXHRcdHZhciBtYXBcdD0gVC5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKCBcIi90ZXh0dXJlcy9sZW5zZmxhcmUvbGVuc2ZsYXJlMC5wbmdcIiApO1xuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBULlNwcml0ZU1hdGVyaWFsKCB7IG1hcDogbWFwLCBjb2xvcjogMHhmZmZmZmYsIGZvZzogdHJ1ZSB9ICk7XG5cdFx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXHRcdG1hdGVyaWFsLmJsZW5kaW5nID0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZztcblx0XHRcblx0XHQvLyB2YXIgYSA9IG5ldyBULlNwcml0ZShtYXRlcmlhbCk7XG5cdFx0dmFyIGEgPSBuZXcgVC5NZXNoKG5ldyBULlNwaGVyZUdlb21ldHJ5KDIpKTtcblx0XHRhLnN0YXRpYyA9IGZhbHNlO1xuXHRcdGEuaGFzX2VuZ2luZXMgPSBmYWxzZTtcblx0XHRyZXR1cm4gYVxuXHR9O1xuXHRcbn1cblxuQ29udHJvbGxlci5CYXNpY0J1bGxldEFjdG9yPWZ1bmN0aW9uKFMsIGlkLCBjb2lkKXsgXG5cdFx0Ly8gaWQgPSBpcyBvYmplY3QgaW4gdGhlIHdvcmxkIGNvbnRyb2xsYWJsZSBieSB0aGlzIGFjdG9yXG5cdFx0Ly8gY29pZCAgTVVTVCBCRSBhbiBvYmplY3QsIHdobyBzaG9vdCB0aGlzIGJ1bGxldFxuXHRcdC8vdmFyIFMgPSBXLnNjZW5lXG5cdFx0dGhpcy5uYW1lID0gXCJCYXNpY19hY3Rvcl9cIiArIChuZXcgRGF0ZSgpLmdldFRpbWUoKSlcblx0XHQvLyB0aGlzLlc7XG5cdFx0dGhpcy5vaWQgPSBpZFxuXHRcdHRoaXMuY29pZCA9IGNvaWRcblx0XHQvLyBjb25zb2xlLmxvZyhpZCk7XG5cdFx0dGhpcy5teV9tZXNoID0gUy5tZXNoZXNbaWRdXG5cdFx0Ly9jb25zb2xlLmxvZyhcIk1ZIE1FU0hcIiwgdGhpcy5teV9tZXNoLCBpZClcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0Ly8gY29uc29sZS5sb2coVy5tZXNoZXMsIGlkLCBXLm1lc2hlcy5sZW5ndGgpXG5cdFx0dmFyIHRvdGFsX3RpbWVfaW5fc3BhY2UgPSAwO1xuXHRcdHZhciBfcG9zc2libGVfdGFyZ2V0cyA9IHt9O1xuXHRcdHZhciBUID0gQ29udHJvbGxlci5UKCk7XG5cdFxuXHRcdHRoaXMucnVuID0gZnVuY3Rpb24odGltZV9sZWZ0KXtcblx0XHRcdHRvdGFsX3RpbWVfaW5fc3BhY2UgKz0gdGltZV9sZWZ0XG5cdFx0XHQvL2NvbnNvbGUubG9nKCdydW5uaW5nJyk7XG5cdFx0XHRpZiAodG90YWxfdGltZV9pbl9zcGFjZSA+IDEwKXtcblx0XHRcdFx0Ly9TLm1lc2hlcy5zcGxpY2UoaWQsIDEpXG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJyZW1vdmluZ1wiKVxuXHRcdFx0XHRTLl9kZWxldGVfb2JqZWN0KGlkKVxuXHRcdFx0XHRkZWxldGUgUy5hdXRvbWF0aWNfYWN0b3JzW3RoaXMubmFtZV07XG5cdFx0XHR9XG5cdFx0XHR2YXIgdmVsID0gdGhpcy5teV9tZXNoLnZlbC5jbG9uZSgpO1xuXHRcdFx0dmFyIG1wb3MgPSB0aGlzLm15X21lc2gucG9zaXRpb24uY2xvbmUoKTtcblx0XHRcblx0XHRcdHZhciB0aHJlcyA9IDQgKiB0aGlzLm15X21lc2gudmVsLmxlbmd0aCgpO1xuXHRcdFx0dmFyIGluX3RocmVzID0gW107XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiVEhSZXNcIiwgdGhyZXMpO1xuXHRcdFxuXHRcdFx0Xy5lYWNoKCBTLm1lc2hlcywgZnVuY3Rpb24obSxpKSB7XG5cdFx0XHRcdGlmKGkgPT09IGlkIHx8IGkgPT09IGNvaWQpIHJldHVybjtcblx0XHRcdFx0aWYobS5pc19ub3RfY29sbGlkYWJsZSkgcmV0dXJuO1xuXHRcdFx0XHQvLyB2YXIgbSA9IFcubWVzaGVzW2ldO1xuXHRcdFx0XHR2YXIgbXAgPSAgbS5wb3NpdGlvbi5jbG9uZSgpO1xuXHRcdFx0XHR2YXIgcGQgPSBtcC5zdWIoIG1wb3MgKVxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyggdmVsLCBwZCApXG5cdFx0XHRcdHZhciBhZyA9IE1hdGguYWNvcyhwZC5kb3QodmVsKS8gdmVsLmxlbmd0aCgpIC8gcGQubGVuZ3RoKCkpIC8vINGD0LPQvtC7INC80LXQttC00YMg0L3QsNC/0YDQsNCy0LvQtdC90LjQtdC8INC00LLQuNC20LXQvdC40Y8g0Lgg0YbQtdC90YLRgNC+0Lwg0L7QsdGK0LXQutGC0LBcblx0XHRcdFx0aWYgKGFnIDwgTWF0aC5QSS8xNilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2FnJyk7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJISFwiLCBpLCBhZywgTWF0aC5QSS84KTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJpZCB2ZWZvcmVcIiwgXHRpZCwgKTtcblx0XHRcdFx0XHR2YXIgc3ViID0gc2VsZi5teV9tZXNoLnBvc2l0aW9uLmNsb25lKCkuc3ViKCBtcCApO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBkaXN0ID0gc3ViLmxlbmd0aCgpXG5cdFx0XHRcdFx0aWYoIGRpc3QgPCB0aHJlcyl7XG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiT0tFXCIpO1xuXHRcdFx0XHRcdFx0aWYoIGluX3RocmVzLmluZGV4T2YoIGkgKSA9PT0gLTEgKXtcblx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygncG9zc2libGUnKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpbl90aHJlcy5wdXNoKGkpIC8vIEFkZCBtZXNoIGluZGV4XG5cdFx0XHRcdFx0XHRcdHRhcmdldCA9IHtsYXN0X3BvaW50IDptcG9zLmNsb25lKCksXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGxhc3RfYW5nbGUgOiBhZyxcblx0XHRcdFx0XHRcdFx0XHRcdCAgbGFzdF9kaXN0YW5jZSA6IGRpc3QsXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFuZ2xlX3JhaXNlIDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdCAgZGlzdGFuY2VfcmFpc2UgOjAsXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGRpc3RhbmNlX3Nob3J0ZW5zIDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdCAgYW5nbGVfbG93ZXJzIDogMCxcblx0XHRcdFx0XHRcdFx0XHQgIFx0ICBpZCA6IGl9XG5cdFx0XHRcdFx0XHRcdF9wb3NzaWJsZV90YXJnZXRzW2ldID0gdGFyZ2V0XG5cdFx0XHRcdFx0XHR9Ly9lbHNle31cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGlmKGkgaW4gX3Bvc3NpYmxlX3RhcmdldHMpe1xuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnUE9TJywgaSlcblx0XHRcdFx0XHRcdC8vINCj0LPQvtC7INCx0YvQuyDQvtGB0YLRgNGL0LkgLSDRgdGC0LDQuyDRgtGD0L/QvtC5XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcImhlcmUhXCIsaSk7XG5cdFx0XHRcdFx0XHQvLyDQndCw0LTQviDQv9GA0L7QstC10YDQuNGC0YwsINC90LUg0L/QtdGA0LXRgdC10LrQsNC10YIg0LvQuCDQvtGC0YDQtdC30L7QuiAtINC/0YDQvtGI0LvRi9C1INC60L7QvtGA0LTQuNC90LDRgtGLIC0g0YLQtdC60YPRidC40LUg0LrQvtC+0YDQtNC40L3QsNGC0Ysg0L3QsNGIINC80LXRiFxuXHRcdFx0XHRcdFx0dmFyIGRpcmVjdGlvbiA9IG1wb3MuY2xvbmUoKS5zdWIoIF9wb3NzaWJsZV90YXJnZXRzW2ldLmxhc3RfcG9pbnQpXG5cdFx0XHRcdFx0XHR2YXIgcmF5ID0gbmV3IFQuUmF5Y2FzdGVyKF9wb3NzaWJsZV90YXJnZXRzW2ldLmxhc3RfcG9pbnQsIGRpcmVjdGlvbi5jbG9uZSgpLm5vcm1hbGl6ZSgpIClcblx0XHRcdFx0XHRcdGlmKFMubmVlZF91cGRhdGVfbWF0cml4KXtcblx0XHRcdFx0XHRcdFx0bS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIGlzciA9IHJheS5pbnRlcnNlY3RPYmplY3RzKFttXSlcblx0XHRcdFx0XHRcdC8vaWYgKG0udHlwZSA9PSAnc2hpcCcpe1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJtYXRyaXggYXV0b3VwZFwiLCBtLm1hdHJpeFdvcmxkLmVsZW1lbnRzKVxuXHRcdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhtcG9zKTtcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2cocmF5LGlzcilcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vfVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCBtLnR5cGUgKVxuXHRcdFx0XHRcdFx0aWYgKGlzci5sZW5ndGggPiAwICYmIGlzclswXS5kaXN0YW5jZSA8IGRpcmVjdGlvbi5sZW5ndGgoKSApe1xuXHRcdFx0XHRcdFx0XHQvL2ZvciggdmFyIGluZGV4ID0wOyBpbmRleDxpc3IubGVuZ3RoOyBpbmRleCsrKXtcblx0XHRcdFx0XHRcdFx0Ly9cdGNvbnNvbGUubG9nKFwiSEVSRVwiLCBpc3JbaW5kZXhdLmRpc3RhbmNlLCBkaXJlY3Rpb24ubGVuZ3RoKCkpXG5cdFx0XHRcdFx0XHRcdC8vL31cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ0hJVCcpXG5cdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiRU5EXCIsIGlzclswXS5wb2ludCk7XG5cdFx0XHRcdFx0XHRcdG0ud29ybGRUb0xvY2FsKGlzclswXS5wb2ludCkgLy8g0KLQtdC/0LXRgNGMINGN0YLQviDQv9C70LXRh9C+INGD0LTQsNGA0LBcblx0XHRcdFx0XHRcdFx0dmFyIGltcHVsc2UgPSBzZWxmLm15X21lc2guaW1wdWxzZTsgIC8vdmVsLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoc2VsZi5teV9tZXNoLm1hc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBheGlzID0gbmV3IFQuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyhpc3JbMF0ucG9pbnQsIGltcHVsc2UpXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHZhciBhZyA9IE1hdGguYWNvcyhpc3JbMF0ucG9pbnQuY2xvbmUoKS5kb3QoaW1wdWxzZSkgLyBpbXB1bHNlLmxlbmd0aCgpIC8gaXNyWzBdLnBvaW50Lmxlbmd0aCgpIClcblx0XHRcdFx0XHRcdFx0Ly8g0KLQtdC/0LXRgNGMINGN0YLQviDQstGA0LDRidC10L3QuNC1INC90LDQtNC+INGA0LDQt9Cx0LjRgtGMINC/0L4g0L7RgdGP0Lxcblx0XHRcdFx0XHRcdFx0dmFyIG1hdCA9IG5ldyBULk1hdHJpeDQoKS5tYWtlUm90YXRpb25BeGlzKGF4aXMubm9ybWFsaXplKCksIGFnKVxuXHRcdFx0XHRcdFx0XHR2YXIgZXVsID0gbmV3IFQuRXVsZXIoKVxuXHRcdFx0XHRcdFx0XHRldWwuc2V0RnJvbVJvdGF0aW9uTWF0cml4KG1hdCwgXCJYWVpcIilcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coaSwgZXVsKVxuXHRcdFx0XHRcdFx0XHR2YXIgYXZlbCA9IG5ldyBULlZlY3RvcjMoKTtcblx0XHRcdFx0XHRcdFx0YXZlbC54ID0gZXVsLng7XG5cdFx0XHRcdFx0XHRcdGF2ZWwueSA9IGV1bC55O1xuXHRcdFx0XHRcdFx0XHRhdmVsLnogPSBldWwuejtcblx0XHRcdFx0XHRcdFx0dmFyIGNrID0gaXNyWzBdLnBvaW50Lmxlbmd0aCgpICogTWF0aC5zaW4oYWcgLSBNYXRoLlBJLzIpXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKHRoaXMubXlfbWVzaC5tYXNzIC8gbS5tYXNzICogKGNrICogY2sgKSk7XG5cdFx0XHRcdFx0XHRcdGF2ZWwubXVsdGlwbHlTY2FsYXIoc2VsZi5teV9tZXNoLm1hc3MvbS5tYXNzICogTWF0aC5hYnMoY2spKVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyDQndC1INGD0YfQuNGC0YvQstCw0Y4g0LzQsNGB0YHRgyDQuCDQv9C70LXRh9C+Li4uIFxuXHRcdFx0XHRcdFx0XHR2YXIgbWF2ZWwgPSBTLm1lc2hlc1tpXS5hdmVsXG5cdFx0XHRcdFx0XHRcdGlmICghIG1hdmVsICl7bWF2ZWwgPSBuZXcgVC5WZWN0b3IzKDAsMCwwKX1cblx0XHRcdFx0XHRcdFx0bWF2ZWwueCArPSBhdmVsLnhcblx0XHRcdFx0XHRcdFx0bWF2ZWwueSArPSBhdmVsLnlcblx0XHRcdFx0XHRcdFx0bWF2ZWwueiArPSBhdmVsLno7XG5cdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKG1hdmVsLngsIG1hdmVsLnksIG1hdmVsLnopXG5cdFx0XHRcdFx0XHRcdFMubWVzaGVzW2ldLmF2ZWwgPSBtYXZlbDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly8gYWRkX3ZlbCA9IGltcHVsc2UubXVsdGlwbHlTY2FsYXIoIDEvIG0ubWFzcyk7XG5cdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGFkZF92ZWwpXG5cdFx0XHRcdFx0XHRcdC8vINCj0LHRgNCw0YLRjCDQv9C+0LrQsCDRgdC60L7RgNC+0YHRgtGMXG5cdFx0XHRcdFx0XHRcdC8vaWYgKFMubWVzaGVzW2ldLnZlbCl7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coUy5tZXNoZXNbaV0uaW1wdWxzZSlcblx0XHRcdFx0XHRcdFx0Uy5tZXNoZXNbaV0uaW1wdWxzZS5hZGQoIGltcHVsc2UgKTtcblx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coUy5tZXNoZXNbaV0uaW1wdWxzZSlcblx0XHRcdFx0XHRcdFx0XHQvLyB9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJFTkQgTE9DQUxcIiwgaXNyWzBdLnBvaW50KTtcblx0XHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnb2tlLCB3ZSBzaG9vdCBpdDonLCBpKVxuXHRcdFx0XHRcdFx0XHQvLyBOb3cgd2Ugd2lsbCBqdXN0IHJlbW92ZSBvYmplY3QgZnJvbSBzY2VuZSB3aXRoIHRoZSBidWxsZXRcblx0XHRcdFx0XHRcdFx0Ly9XLnNjZW5lLnJlbW92ZShXLm1lc2hlc1tpXSlcblx0XHRcdFx0XHRcdFx0Uy5fZGVsZXRlX29iamVjdChpZClcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vaWYoUy50aHJlZV9zY2VuZSl7XG5cdFx0XHRcdFx0XHRcdC8vXHRTLnRocmVlX3NjZW5lLnJlbW92ZShTLm1lc2hlc1tpZF0pIC8vINGD0LTRj9C70Y/QtdC8INGP0LTRgNC+INC40Lcg0YHRhtC10L3Ri1xuXHRcdFx0XHRcdFx0XHQvL31cblx0XHRcdFx0XHRcdFx0Ly9kZWxldGUgUy5tZXNoZXNbIGlkIF07IC8vIC4uLiDQuNC3INC80LXRiNC10Llcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIFMuYWN0b3JzW3NlbGYubmFtZV07IC8vIC4uLiDQo9C00LDQu9GP0LXQvCDRjdGC0L7Qs9C+INCw0LrRgtC+0YDQsCAtINCx0L7Qu9GM0YjQtSDQvdC1INC30LDQs9GA0YPQt9C40YLRgdGPINGN0YLQsCDRhNGD0L3QutGG0LjRj1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvL1cubWVzaGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIF9wb3NzaWJsZV90YXJnZXRzW2ldIC8vIC4uLiDQuNC3INCy0L7Qt9C80L7QttC90YvRhSDRhtC10LvQtdC5INGD0LTQsNC70Y/QtdC8INGN0YLQvtGCINC80LXRiFxuXHRcdFx0XHRcdFx0XHQvLyBibGEuYmxhID0gMVxuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBfcG9zc2libGVfdGFyZ2V0c1tpXTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggYWcsIE1hdGguUEkvOCk7XG5cdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdH0pXG5cdFx0XHQvL2JsYS5iYWwgKz0xXG5cdFx0XHQvL2NvbnNvbGUubG9nKGJsYSlcblx0XHRcblx0XHRcblx0XHRcdC8vIGNvbnNvbGUubG9nKHRvdGFsX3RpbWVfaW5fc3BhY2UgLFcubWVzaGVzLmxlbmd0aCwgVy5hY3RvcnMpXG5cdFx0fVxuXHRcblx0XG5cdH07XG5cdFxudmFyIENvbnRyb2xsZXJzID0gZnVuY3Rpb24gKCl7XG5cblx0dmFyIGRldl9jb25fcHJvdG8gPSB7XG5cdFx0cHJvY2VzcyA6IGZ1bmN0aW9uKGFjdGlvbil7XG5cdFx0XHRtZXNoLnNldERldmljZVNldHRpbmcoZGV2aWNlLmlkLCBhY3Rpb24ubmFtZSwgYWN0aW9uLnZhbHVlKTtcblx0XG5cdFx0fVxuXHR9O1xuXHR0aGlzLkVuZ2luZUNvbnRyb2xsZXIgPSBmdW5jdGlvbihtZXNoLCBkZXZpY2VfaWQpe1xuXHRcdFxuXHRcdHRoaXMuZ2V0VUkgPSBmdW5jdGlvbihXKXtcblx0XHRcdFxuXHRcdH1cblx0XHRcblx0XHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihhY3Rpb24pe1xuXHRcdFx0dmFyIFQgPSBDb250cm9sbGVyLlQoKTtcblx0XG5cdFx0XHR2YXIgdW5pdCA9IG5ldyBULlZlY3RvcjMoKTtcblx0XHRcdHVuaXQuZnJvbUFycmF5KG1lc2gudHlwZS5kZXZpY2VzW2FjdGlvbi5kZXZdLnVuaXQpO1xuXHRcdFx0dmFyIGVuZ2luZV9uYW1lID0gbWVzaC50eXBlLmRldmljZXNbYWN0aW9uLmRldl0uZW5naW5lX3R5cGUgKyBcIl9cIiArIG1lc2gudHlwZS5kZXZpY2VzW2FjdGlvbi5kZXZdLm5hbWU7XG5cdFx0XHR2YXIgcGVyY2VudF9vZl9wb3dlciA9IG1lc2guZ2V0RGV2aWNlU2V0dGluZyhhY3Rpb24uZGV2LCBcInBvd2VyXCIpO1xuXHRcdFx0dmFyIGVuZ2luZV90eXBlID0gbWVzaC50eXBlLmRldmljZXNbYWN0aW9uLmRldl0uZW5naW5lX3R5cGU7XG5cdFxuXHRcdFx0dmFyIHBlcmZvcm1hbmNlID0gbWVzaC50eXBlLmRldmljZXNbYWN0aW9uLmRldl0ucGVyZm9ybWFuY2U7XG5cdFx0XHR2YXIgY29uc3VtcHRpb24gPSBtZXNoLnR5cGUuZGV2aWNlc1thY3Rpb24uZGV2XS5jb25zdW1wdGlvbjtcblx0XHRcdHZhciBjYXBhY2l0b3JfbGVmdCA9IG1lc2guZ2V0RGV2aWNlU2V0dGluZyhtZXNoLnR5cGUucG93ZXJfc291cmNlLCBcImNhcGFjaXRvclwiKTtcblx0XHRcdHZhciBlbmVyZ3lfY29uc3VtcHRpb24gPSBwZXJjZW50X29mX3Bvd2VyKiBjb25zdW1wdGlvbiAqIGFjdGlvbi5kZWx0YTtcblx0XG5cdFx0XHRpZiAoY2FwYWNpdG9yX2xlZnQgPCBlbmVyZ3lfY29uc3VtcHRpb24pe1xuXHRcdFx0XHRlbmVyZ3lfY29uc3VtcHRpb24gPSBjYXBhY2l0b3JfbGVmdDtcblx0XHRcdH1cblx0XHRcdHZhciBpbXB1bHNlID0gZW5lcmd5X2NvbnN1bXB0aW9uICogcGVyZm9ybWFuY2U7XG5cdFx0XHR1bml0Lm11bHRpcGx5U2NhbGFyKGltcHVsc2UpO1xuXHRcdFx0bWVzaC51cGRhdGVfc3RhdGljX3BoeXNpY2FsX2RhdGEoYWN0aW9uLnRzKVxuXHRcblx0XHRcdG1lc2guYWx0ZXJEZXZpY2VTZXR0aW5nKG1lc2gudHlwZS5wb3dlcl9zb3VyY2UsICdjYXBhY2l0b3InICxmdW5jdGlvbih2YWx1ZSl7XG5cdFx0XHRcdHZhciBudiA9IHZhbHVlIC0gZW5lcmd5X2NvbnN1bXB0aW9uO1xuXHRcdFx0XHRpZiAobnYgPCAwKSB7cmV0dXJuIDB9XG5cdFx0XHRcdGVsc2V7IHJldHVybiBudiB9XG5cdFx0XHRcblx0XHRcdH0pXG5cdFxuXHRcblx0XHRcdGlmIChlbmdpbmVfdHlwZSA9PSAncm90YXRpb24nKXtcblx0XHRcdFx0bWVzaC5hbmd1bGFyX2ltcHVsc2UuYWRkKHVuaXQpXG5cdFx0XHR9ZWxzZSBpZihlbmdpbmVfdHlwZSA9PSAncHJvcHVsc2lvbicpe1xuXHRcdFx0XHR2YXIgdHVnID0gdW5pdC5jbG9uZSgpLmFwcGx5UXVhdGVybmlvbihtZXNoLnF1YXRlcm5pb24pO1xuXHRcdFx0XHRtZXNoLmltcHVsc2UuYWRkKHR1Zyk7XG5cdFx0XHR9XHRcblx0XHR9XG5cdH1cblx0dGhpcy5FbmdpbmVDb250cm9sbGVyLmRldmljZV90eXBlcyA9IFwiZW5naW5lXCI7XG5cdFxuXHR0aGlzLlNoaWVsZENvbnRyb2xsZXIgPSBmdW5jdGlvbihtZXNoLCBkZXZpY2VfaWQpe1xuXHRcdFxuXHRcdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKGFjdGlvbil7XG5cdFx0XHRtZXNoLmFsdGVyRGV2aWNlU2V0dGluZyhkZXZpY2VfaWQsICdzdGF0ZScsIGZ1bmN0aW9uKHYpeyByZXR1cm4gIXZ9KTtcblx0XHR9XG5cdFx0dGhpcy5nZXRVSSA9IGZ1bmN0aW9uKFcpe1xuXHRcdFx0dmFyIHVpID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0dGhpcy5jb25zdHJ1Y3QgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHZhciBzaGllbGRfZGV2ID0gbWVzaC50eXBlLmRldmljZXNbZGV2aWNlX2lkXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgbXlfaW5kID0gJChcIiNzaGllbGRfaW5kaWNhdG9yX1wiK2RldmljZV9pZCk7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cobXlfaW5kLnNpemUoKSk7XG5cdFx0XHRcdFx0aWYobXlfaW5kLnNpemUoKSAhPSAwKXtcblx0XHRcdFx0XHRcdG15X2luZC5yZW1vdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcblx0XHRcdFx0XHR2YXIgc2hjID0gJChcIiNzaGllbGRzX2hvbGRlcl9jb250YWluZXJcIilcblx0XHRcdFx0XHRpZihzaGMuc2l6ZSgpID09IDApe1xuXHRcdFx0XHRcdFx0c2hjID0gJCgnPGRpdiBpZD1cInNoaWVsZHNfaG9sZGVyX2NvbnRhaW5lclwiPicpLmNzcyh7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOidmaXhlZCcsXG5cdFx0XHRcdFx0XHRcdGxlZnQ6MCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OjUwLFxuXHRcdFx0XHRcdFx0XHRib3R0b206NTAsXG5cdFx0XHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzonI2YzZicsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOjQwMFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fSkuYXBwZW5kVG8oJ2JvZHknKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGQgID0gJCgnPGRpdiA+JykuYXR0cignaWQnLFwic2hpZWxkX2luZGljYXRvcl9cIitkZXZpY2VfaWQpIC5jc3Moe3dpZHRoOjUwLCBoZWlnaHQ6XCIxMDAlXCIsIGZsb2F0OidsZWZ0JywgJ21hcmdpbi1yaWdodCc6XCIxMHB4XCJ9KS5hcHBlbmRUbyhzaGMpO1xuXHRcdFx0XHRcdHZhciBzaWMgPSAkKCc8ZGl2PicpLmNzcyh7d2lkdGg6XCIxMDAlXCIsIGhlaWdodDoxMCB9KS5hcHBlbmRUbyhkKSAvLyBzdHJlbnRoIGluZGljYXRvciBjb250YWluZXJcblx0XHRcdFx0XHR2YXIgbCA9IHNoaWVsZF9kZXYuc2hpZWxkX3R5cGUudG9Mb2NhbGVVcHBlckNhc2UoKTtcblx0XHRcdFx0XHR2YXIgYiA9ICQoJzxkaXY+JykuY3NzKHt3aWR0aDpcIjEwMCVcIiwgaGVpZ2h0OjMwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidGV4dC1hbGlnblwiOidjZW50ZXInLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCd2ZXJ0aWNhbC1hbGlnbic6ICdtaWRkbGUnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCdsaW5lLWhlaWdodCc6JzMwcHgnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzonIzMzMycsJ2NvbG9yJzpcIiNGMEZcIn0pXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC50ZXh0KGwpLmFwcGVuZFRvKGQpLmNsaWNrKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtZXNoLnN0YXJ0RGV2aWNlQWN0aW9uKGRldmljZV9pZCwgXCJ0b2dnbGVcIiwwKTtcblx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KSBcblx0XHRcdFx0XHR2YXIgY2ljID0gJCgnPGRpdj4nKS5jc3Moe3dpZHRoOlwiMTAwJVwiLCBoZWlnaHQ6MTB9KS5hcHBlbmRUbyhkKSAvLyBjYXBhY2l0b3IgaW5kaWNhdG9yIGNvbnRhaW5lclxuXHRcdFx0XG5cdFx0XHRcdFx0dmFyIHNpID0gJCgnPGRpdj4nKS5jc3Moe3dpZHRoOlwiMTAwJVwiLCBoZWlnaHQ6XCIxMDAlXCIsICdiYWNrZ3JvdW5kLWNvbG9yJzpcImJsdWVcIiB9KS5hcHBlbmRUbyhzaWMpO1xuXHRcdFx0XHRcdHZhciBjaSA9ICQoXCI8ZGl2PlwiKS5jc3Moe3dpZHRoOlwiMTAwJVwiLCBoZWlnaHQ6XCIxMDAlXCIsJ2JhY2tncm91bmQtY29sb3InOlwieWVsbG93XCIgfSkuYXBwZW5kVG8oY2ljKTtcblx0XHRcdFx0XHR0aGlzLl9yZWRyYXdfY2xvc3VyZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHR2YXIgcmVzZXJ2ZV9jYXBfYW1vdW50ID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKGRldmljZV9pZCwgXCJyZXNlcnZlX2NhcGFjaXR5XCIpO1xuXHRcdFx0XHRcdFx0dmFyIHRvdF9jYXBfYW1vdW50ID0gc2hpZWxkX2Rldi5jYXBhY2l0b3I7XG5cdFx0XHRcdFx0XHR2YXIgdyA9IHJlc2VydmVfY2FwX2Ftb3VudC90b3RfY2FwX2Ftb3VudCAqIDEwMDtcblx0XHRcdFx0XHRcdGNpLndpZHRoKCB3ICsgJyUnICk7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdFx0dmFyIGlzX29uID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKGRldmljZV9pZCwgJ3N0YXRlJykgO1xuXHRcdFx0XHRcdFx0aWYgKGlzX29uKXtcblx0XHRcdFx0XHRcdFx0Yi5jc3Moe2NvbG9yOidyZWQnLCAnYmFja2dyb3VuZC1jb2xvcic6J3doaXRlJ30pO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdGIuY3NzKHsnYmFja2dyb3VuZC1jb2xvcic6JyMzMzMnLCdjb2xvcic6XCIjRjBGXCJ9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdFx0XHR2YXIgY3VycmVudF9jYXBhY2l0eSA9IG1lc2guZ2V0RGV2aWNlU2V0dGluZyhkZXZpY2VfaWQsICdjYXBhY2l0eScpO1xuXHRcdFx0XHRcdFx0dmFyIG1heF9jYXBhY2l0eSA9IHNoaWVsZF9kZXYuY2FwYWNpdHk7XG5cdFx0XHRcdFx0XHR2YXIgd3cgPSggY3VycmVudF9jYXBhY2l0eSAvIG1heF9jYXBhY2l0eSAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHRcdHNpLndpZHRoKHd3KTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInVwZGF0aW5nIHNoaWVsZFwiLCBzaGllbGQsIG51bSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dGhpcy5fcmVkcmF3X2Nsb3N1cmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyB1aSgpO1xuXHRcdFx0XG5cdFx0XHRcblx0XHR9XG5cdH1cblx0dGhpcy5TaGllbGRDb250cm9sbGVyLmRldmljZV90eXBlcyA9IFwic2hpZWxkXCI7XG5cdFxuXHR0aGlzLkVuZXJneUNvcmVDb250cm9sbGVyID0gZnVuY3Rpb24obWVzaCwgZGV2aWNlX2lkKXtcblx0XHRcblx0XHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihhY3Rpb24pe1xuXHRcdFx0bWVzaC5zZXREZXZpY2VTZXR0aW5nKGFjdGlvbi5kZXZfaWQsIGFjdGlvbi5uYW1lLCBhY3Rpb24udmFsdWUpO1xuXHRcdH1cblx0XHR0aGlzLmdldFVJID0gZnVuY3Rpb24oVyl7XG5cdFx0XHR2YXIgdWkgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcnNfbGVuZ3RoID0gMTEwO1xuXHRcdFx0XHR0aGlzLnRvdGFsX3dpZHRoID0gMTcwO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5jb25zdHJ1Y3QgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHRoaXMuY29udCA9ICQoJzxkaXY+JykuY3NzKHtcblx0XHRcdFx0XHRcdCdwb3NpdGlvbic6J2ZpeGVkJyxcblx0XHRcdFx0XHRcdC8vICdib3JkZXInOiAnMXB4IHNvbGlkIHJlZCcsXG5cdFx0XHRcdFx0XHQnd2lkdGgnOiB0aGlzLnRvdGFsX3dpZHRoICsgXCJweFwiLFxuXHRcdFx0XHRcdFx0J2hlaWdodCc6ICc2MHB4Jyxcblx0XHRcdFx0XHRcdCd0b3AnOjQwLFxuXHRcdFx0XHRcdFx0J2xlZnQnOjUwKzMwMCxcblx0XHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzond2hpdGUnXG5cdFx0XHRcdFx0fSkuYXBwZW5kVG8oJ2JvZHknKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvcnMgPSAkKCc8ZGl2PicpLmNzcyh7XG5cdFx0XHRcdFx0XHRcIndpZHRoXCI6IHRoaXMuaW5kaWNhdG9yc19sZW5ndGgsXG5cdFx0XHRcdFx0XHRcImhlaWdodFwiOlwiMTAwJVwiLFxuXHRcdFx0XHRcdFx0XCJmbG9hdFwiOiBcImxlZnRcIixcblx0XHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzond2hpdGUnXG5cdFx0XHRcdFx0fSkuYXBwZW5kVG8odGhpcy5jb250KTtcblxuXHRcdFx0XHRcdHRoaXMuc3dpdGNoZXMgPSAkKCc8ZGl2PicpLmNzcyh7XG5cdFx0XHRcdFx0XHRcIndpZHRoXCI6IHRoaXMudG90YWxfd2lkdGggLSB0aGlzLmluZGljYXRvcnNfbGVuZ3RoICxcblx0XHRcdFx0XHRcdFwiaGVpZ2h0XCI6XCIxMDAlXCIsXG5cdFx0XHRcdFx0XHRcImZsb2F0XCI6IFwibGVmdFwiLFxuXHRcdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOid3aGl0ZSdcblx0XHRcdFx0XHR9KS5hcHBlbmRUbyh0aGlzLmNvbnQpO1xuXHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLmZ1ZWxfaW5kaWNhdG9yID0gJCgnPGRpdj4nKSAuY3NzKHtcblx0XHRcdFx0XHRcdFwid2lkdGhcIjogdGhpcy5pbmRpY2F0b3JzX2xlbmd0aCAsXG5cdFx0XHRcdFx0XHRcImhlaWdodFwiOlwiMjUlXCIsXG5cdFx0XHRcdFx0XHQvLyBcImZsb2F0XCI6IFwibGVmdFwiLFxuXHRcdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOidncmVlbidcblx0XHRcdFx0XHR9KS5hcHBlbmRUbyh0aGlzLmluZGljYXRvcnMpO1xuXHRcdFx0XG5cdFx0XHRcdFx0dGhpcy5wb3dlcl9pbmRpY2F0b3IgPSAkKCc8ZGl2PicpIC5jc3Moe1xuXHRcdFx0XHRcdFx0XCJ3aWR0aFwiOiB0aGlzLmluZGljYXRvcnNfbGVuZ3RoICxcblx0XHRcdFx0XHRcdFwiaGVpZ2h0XCI6XCIyNSVcIixcblx0XHRcdFx0XHRcdC8vIFwiZmxvYXRcIjogXCJsZWZ0XCIsXG5cdFx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6J3JlZCdcblx0XHRcdFx0XHR9KS5hcHBlbmRUbyh0aGlzLmluZGljYXRvcnMpO1xuXHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLmNhcGFjaXRvcl9pbmRpY2F0b3IgPSAkKCc8ZGl2PicpIC5jc3Moe1xuXHRcdFx0XHRcdFx0XCJ3aWR0aFwiOiB0aGlzLmluZGljYXRvcnNfbGVuZ3RoICxcblx0XHRcdFx0XHRcdFwiaGVpZ2h0XCI6XCI1MCVcIixcblx0XHRcdFx0XHRcdC8vIFwiZmxvYXRcIjogXCJsZWZ0XCIsXG5cdFx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6J3llbGxvdydcblx0XHRcdFx0XHR9KS5hcHBlbmRUbyh0aGlzLmluZGljYXRvcnMpO1xuXHRcdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0XHR0aGlzLmVuZ2luZXNfa2V5ID0gJChcIjxkaXY+XCIpLmNzcyh7XG5cdFx0XHRcdFx0XHR3aWR0aDpcIjEwMCVcIixcblx0XHRcdFx0XHRcdGhlaWdodDpcIjIwcHhcIixcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR9KS50ZXh0KFwiRVwiKS5hcHBlbmRUbyh0aGlzLnN3aXRjaGVzKS5jbGljayhmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0c2VsZi5fZW5naW5lc19kaWFsb2coKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0dGhpcy5zaGllbGRfa2V5ID0gJChcIjxkaXY+XCIpLmNzcyh7XG5cdFx0XHRcdFx0XHR3aWR0aDpcIjEwMCVcIixcblx0XHRcdFx0XHRcdGhlaWdodDpcIjIwcHhcIixcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR9KS50ZXh0KFwiU1wiKS5hcHBlbmRUbyh0aGlzLnN3aXRjaGVzKS5jbGljayhmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0c2VsZi5fc2hpZWxkc19kaWFsb2coKTtcblx0XHRcdFx0XHR9KTs7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdHRoaXMudHVycmV0X2tleXMgPSAkKFwiPGRpdj5cIikuY3NzKHtcblx0XHRcdFx0XHRcdHdpZHRoOlwiMTAwJVwiLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OlwiMjBweFwiLFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdH0pLnRleHQoXCJUXCIpLmFwcGVuZFRvKHRoaXMuc3dpdGNoZXMpO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9zaGllbGRzX2RpYWxvZyA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Ly92YXIgbWVzaCA9IFcuc2NlbmVzW2FjdG9yLnNjZW5lXS5tZXNoZXNbYWN0b3IuY29udHJvbC5vYmplY3RfZ3VpZF07XG5cdFx0XHRcdFx0Ly92YXIgc2NlbmUgPSBXLnNjZW5lc1thY3Rvci5zY2VuZV07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29udCA9ICQoJzxkaXY+JykuY3NzKHtcblx0XHRcdFx0XHRcdCdwb3NpdGlvbic6J2Fic29sdXRlJyxcblx0XHRcdFx0XHRcdC8vICdib3JkZXInOiAnMXB4IHNvbGlkIHJlZCcsXG5cdFx0XHRcdFx0XHQnd2lkdGgnOiA0MDAgKyBcInB4XCIsXG5cdFx0XHRcdFx0XHQnaGVpZ2h0JzogJzYwMHB4Jyxcblx0XHRcdFx0XHRcdCd0b3AnOjQwICsgMTAwLFxuXHRcdFx0XHRcdFx0J2xlZnQnOjUwKzMwMCxcblx0XHRcdFx0XHRcdCdwYWRkaW5nJzogXCIxMHB4XCIsXG5cdFx0XHRcdFx0XHQnYm9yZGVyLXJhZGl1cyc6JzNweCcsXG5cdFx0XHRcdFx0XHQnYm9yZGVyLXdpZHRoJzonMXB4Jyxcblx0XHRcdFx0XHRcdCdib3JkZXItc3R5bGUnOidzb2xpZCcsXG5cdFx0XHRcdFx0XHQnYm9yZGVyLWNvbG9yJzonI2FhYScsXG5cdFx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6JyMyMjInfSkuYXBwZW5kVG8oJ2JvZHknKTtcblx0XHRcdFx0XHR2YXIgIGNjID0gJCgnPGRpdj4nKS5hcHBlbmRUbyhjb250KS5jc3Moeyd3aWR0aCc6XCIxMDAlXCIsaGVpZ2h0OjIwLCAncGFkZGluZy1ib3R0b20nOiAnMzBweCd9KTtcblx0XHRcdFx0XHR2YXIgIGNsb3NlciA9ICQoJzxkaXY+JykuYXBwZW5kVG8oY29udCkuY3NzKHsnd2lkdGgnOlwiMjBcIiwgaGVpZ2h0OjIwLCAnYmFja2dyb3VuZC1jb2xvcic6J3JlZCcsIGZsb2F0OidyaWdodCcgfSkuY2xpY2soZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdGNvbnQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fSkuYXBwZW5kVG8oY2MpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdF8uZWFjaChtZXNoLnR5cGUuc2hpZWxkcywgZnVuY3Rpb24ocywgaSl7XG5cdFx0XHRcdFx0XHRpZiAoaSA9PT0gJ3RoZXJtYWwnKXtyZXR1cm59XG5cdFx0XHRcdFx0XHRfLmVhY2gocywgZnVuY3Rpb24oc2hpZWxkX2lkKXtcblx0XHRcdFx0XHRcdFx0dmFyIGUxID0gJChcIjxkaXY+XCIpLmNzcyh7XG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6MzAwLFxuXHRcdFx0XHRcdFx0XHRcdGhlaWdodDo0MFxuXHRcdFx0XHRcdFx0XHR9KS5hcHBlbmRUbyhjb250KTtcblx0XHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0JCgnPGRpdj4nKS5jc3MoeydmbG9hdCc6J2xlZnQnLCAnY29sb3InOicjYmJiJ30pLndpZHRoKDQwKS50ZXh0KGkpLmFwcGVuZFRvKGUxKSBcblx0XHRcdFx0XHRcdFx0dmFyIHNsYyA9ICAkKCc8ZGl2PicpLmNzcyh7J2Zsb2F0JzonbGVmdCcsIHdpZHRoOjEyMCwnbWFyZ2luLWxlZnQnOjEwfSkuYXBwZW5kVG8oZTEpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHZhciBwYyA9IG5ldyBQb3dlckNvbnRyb2xXaWRnZXQoe2NvbnRhaW5lcjpzbGNbMF0sIHN0YXJ0aW5nX3BlcmNlbnQ6MCwgZW5kX3BlcmNlbnQ6MS41LHByb2dyZXNzX3ZhbHVlOjAsXG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlOiBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bWVzaC5zdGFydERldmljZUFjdGlvbihtZXNoLnR5cGUucG93ZXJfc291cmNlLCBcInBvd2VyXCIsIHZhbCwge1wiZGV2X2lkXCI6IHNoaWVsZF9pZH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRzbGlkZTpmdW5jdGlvbih2YWwpeyBcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQvLyB2YXIgc2V0dCA9ICBcInNfXCIgKyBpICsgbnVtICsgXCJfcG93ZXJcIlxuXHRcdFx0XHRcdFx0XHR2YXIgY3VyX3ZhbCA9IG1lc2guZ2V0RGV2aWNlU2V0dGluZyhzaGllbGRfaWQsIFwicG93ZXJcIik7XG5cdFx0XHRcdFx0XHRcdHBjLnNldF92YWx1ZSggY3VyX3ZhbCApO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcblx0XHRcdFx0fTtcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX2VuZ2luZXNfZGlhbG9nID0gZnVuY3Rpb24oKXtcblxuXHRcdFx0XHRcdC8vdmFyIG1lc2ggPSBXLnNjZW5lc1thY3Rvci5zY2VuZV0ubWVzaGVzW2FjdG9yLmNvbnRyb2wub2JqZWN0X2d1aWRdO1xuXHRcdFx0XHRcdC8vdmFyIHNjZW5lID0gVy5zY2VuZXNbYWN0b3Iuc2NlbmVdO1xuXG5cdFx0XHRcdFx0Y29udCA9ICQoJzxkaXY+JykuY3NzKHtcblx0XHRcdFx0XHRcdCdwb3NpdGlvbic6J2Fic29sdXRlJyxcblx0XHRcdFx0XHRcdC8vICdib3JkZXInOiAnMXB4IHNvbGlkIHJlZCcsXG5cdFx0XHRcdFx0XHQnd2lkdGgnOiA0MDAgKyBcInB4XCIsXG5cdFx0XHRcdFx0XHQnaGVpZ2h0JzogJzYwMHB4Jyxcblx0XHRcdFx0XHRcdCd0b3AnOjQwICsgMTAwLFxuXHRcdFx0XHRcdFx0J2xlZnQnOjUwKzMwMCxcblx0XHRcdFx0XHRcdCdwYWRkaW5nJzogXCIxMHB4XCIsXG5cdFx0XHRcdFx0XHQnYm9yZGVyLXJhZGl1cyc6JzNweCcsXG5cdFx0XHRcdFx0XHQnYm9yZGVyLXdpZHRoJzonMXB4Jyxcblx0XHRcdFx0XHRcdCdib3JkZXItc3R5bGUnOidzb2xpZCcsXG5cdFx0XHRcdFx0XHQnYm9yZGVyLWNvbG9yJzonI2FhYScsXG5cdFx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6JyMyMjInfSkuYXBwZW5kVG8oJ2JvZHknKTtcblx0XHRcdFx0XHRcdHZhciAgY2MgPSAkKCc8ZGl2PicpLmFwcGVuZFRvKGNvbnQpLmNzcyh7J3dpZHRoJzpcIjEwMCVcIixoZWlnaHQ6MjAsICdwYWRkaW5nLWJvdHRvbSc6ICczMHB4J30pO1xuXHRcdFx0XHRcdFx0dmFyICBjbG9zZXIgPSAkKCc8ZGl2PicpLmFwcGVuZFRvKGNvbnQpLmNzcyh7J3dpZHRoJzpcIjIwXCIsIGhlaWdodDoyMCwgJ2JhY2tncm91bmQtY29sb3InOidyZWQnLCBmbG9hdDoncmlnaHQnIH0pLmNsaWNrKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdGNvbnQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHR9KS5hcHBlbmRUbyhjYyk7O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdF8uZWFjaChtZXNoLnR5cGUuZW5naW5lcywgZnVuY3Rpb24oZW5naW5lcywgZW5naW5lX3R5cGUpe1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRfLmVhY2goZW5naW5lcywgZnVuY3Rpb24oZW5naW5lX2lkKXtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIHZhciBldCA9IGVuZ2luZV90eXBlO1xuXHRcdFx0XHRcdFx0XHQvLyB2YXIgZWEgPSBlbjtcblx0XHRcdFx0XHRcdFx0dmFyIGVuX2RldiA9IG1lc2gudHlwZS5kZXZpY2VzW2VuZ2luZV9pZF07XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR2YXIgZTEgPSAkKFwiPGRpdj5cIikuY3NzKHtcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDozMDAsXG5cdFx0XHRcdFx0XHRcdFx0aGVpZ2h0OjQwXG5cdFx0XHRcdFx0XHRcdFx0fSkuYXBwZW5kVG8oY29udCk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0JCgnPGRpdj4nKS5jc3MoeydmbG9hdCc6J2xlZnQnLCAnY29sb3InOicjYmJiJ30pLndpZHRoKDQwKS50ZXh0KGVuX2Rldi5uYW1lKS5hcHBlbmRUbyhlMSkgXG5cdFx0XHRcdFx0XHRcdHZhciBzbGMgPSAgJCgnPGRpdj4nKS5jc3MoeydmbG9hdCc6J2xlZnQnLCB3aWR0aDoxMjAsJ21hcmdpbi1sZWZ0JzoxMH0pLmFwcGVuZFRvKGUxKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdHZhciBwYyA9IG5ldyBQb3dlckNvbnRyb2xXaWRnZXQoe2NvbnRhaW5lcjpzbGNbMF0sIHN0YXJ0aW5nX3BlcmNlbnQ6MCwgZW5kX3BlcmNlbnQ6MS41LHByb2dyZXNzX3ZhbHVlOjAsXG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlOiBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bWVzaC5zdGFydERldmljZUFjdGlvbihtZXNoLnR5cGUucG93ZXJfc291cmNlLCBcInBvd2VyXCIsIHZhbCwge1wiZGV2X2lkXCI6IGVuZ2luZV9pZH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRzbGlkZTpmdW5jdGlvbih2YWwpeyBcblx0XHRcdFx0XHRcdFx0XHRcdC8vIG1lc2guc3RhcnREZXZpY2VBY3Rpb24oZW5naW5lX2lkLCBcInNldF9wb3dlclwiLCB2YWwpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0Ly8gdmFyIHNldHQgPSAgXCJlbmdfXCIgKyBlbmdpbmVfbmFtZSArIFwiX3Bvd2VyXCJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cl92YWwgPSBtZXNoLmdldERldmljZVNldHRpbmcoZW5naW5lX2lkLCBcInBvd2VyXCIgKTtcblx0XHRcdFx0XHRcdFx0cGMuc2V0X3ZhbHVlKCBjdXJfdmFsICk7XG5cdFx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdXBkYXRlX2Z1ZWxfaW5kaWNhdG9yID0gZnVuY3Rpb24oKXt9XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZV9wb3dlcl9pbmRpY2F0b3IgPSBmdW5jdGlvbigpe31cblx0XHRcdFx0dGhpcy5fdXBkYXRlX2NhcGFjaXRvcl9pbmRpY2F0b3IgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdC8vIHZhciBtZXNoID0gVy5zY2VuZXNbYWN0b3Iuc2NlbmVdLm1lc2hlc1thY3Rvci5jb250cm9sLm9iamVjdF9ndWlkXTtcblx0XHRcdFx0XHR2YXIgcHNkID0gbWVzaC50eXBlLmRldmljZXNbbWVzaC50eXBlLnBvd2VyX3NvdXJjZV07XG5cdFx0XHRcdFx0dmFyIHRvdGFsX2NhcCA9IHBzZC5jYXBhY2l0b3I7XG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRfY2FwID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKG1lc2gudHlwZS5wb3dlcl9zb3VyY2UsIFwiY2FwYWNpdG9yXCIpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdEwuc2V0VmFsdWUoXCJDVVIgQ09OU1wiLCBjdXJyZW50X2NhcCk7XG5cdFx0XHRcblx0XHRcdFx0XHRpZihjdXJyZW50X2NhcCA+IHRvdGFsX2NhcCl7XG5cdFx0XHRcdFx0XHRwZXJjZW50YWdlID0gMTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHBlcmNlbnRhZ2UgPSBjdXJyZW50X2NhcCAvIHRvdGFsX2NhcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5jYXBhY2l0b3JfaW5kaWNhdG9yLndpZHRoKHBlcmNlbnRhZ2UgKiB0aGlzLmluZGljYXRvcnNfbGVuZ3RoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVfZnVlbF9pbmRpY2F0b3IoKTtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVfcG93ZXJfaW5kaWNhdG9yKCk7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlX2NhcGFjaXRvcl9pbmRpY2F0b3IoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyB1aSgpO1xuXHRcdFx0XG5cdFx0fVxuXHR9XG5cdHRoaXMuRW5lcmd5Q29yZUNvbnRyb2xsZXIuZGV2aWNlX3R5cGVzID0gXCJwb3dlclwiO1xuXHR0aGlzLlR1cnJldENvbnRyb2xsZXIgID0gZnVuY3Rpb24obWVzaCwgZGV2aWNlX2lkKXtcblx0XHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihhY3Rpb24pe1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIkNIT1wiLCBhY3Rpb24udHlwZSA9PT0gU0hPT1QsIGFjdGlvbi50eXBlID09IFNIT09ULCBhY3Rpb24udHlwZSlcblx0XHRcdHZhciB0dXJyZXQgPSBtZXNoLnR5cGUuZGV2aWNlc1tkZXZpY2VfaWRdO1xuXHRcdFx0aWYoYWN0aW9uLm5hbWUgPT0gJ3JlbG9hZCcpe1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJwcm9jZXNzID4gUkVBTE9ESU5HOlwiLCBhY3Rpb24pO1xuXHRcdFx0XHRtZXNoLnNldERldmljZVNldHRpbmcoIGRldmljZV9pZCwgXCJpc19yZWxvYWRpbmdcIiAsIGFjdGlvbi50cyApOyBcblx0XHRcdFx0bWVzaC5zZXREZXZpY2VTZXR0aW5nKCBkZXZpY2VfaWQsICdtYWdhemluZScsIHR1cnJldC5tYWdhemluZV9jYXBhY2l0eSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChhY3Rpb24ubmFtZSA9PSAnZmlyZScpe1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJGSVJFRFwiKTtcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgVCA9IENvbnRyb2xsZXIuVCgpO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBzZWVkID0gTWF0aC5yYW5kb20oKSAvLyDQrdGC0L4g0LfQtdGA0L3QviDQsdGD0LTQtdGCINC40YHQv9C+0LvRjNC30L7QstCw0YLRjNGB0Y8g0LTQu9GPINCy0YvRh9C40YHQu9C10L3QuNGPINCy0LXRgNC+0Y/RgtC90L7RgdGC0LXQuSDQuCDQvtC90L4g0LTQvtC70LbQvdC+INCx0YvRgtGMINC30LDQv9C40YHQsNC90L4g0LIg0YHQvtC+0LHRidC10L3QuNC1IC0g0YfRgtC+0LHRiyDQv9C+0LfQstC+0LvQuNGC0Ywg0YHQtdGA0LLQtdGA0YMg0LLRi9GH0LjRgdC70LjRgtGMINC/0LDRgNCw0LzQtdGC0YDRiyDQv9C+0L/QsNC00LDQvdC40Y8g0LTQtdGC0LXRgNC80LjQvdC40YDQvtCy0LDQvdC90L5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coYWN0aW9uKVxuXHRcdFx0XHQvLyDQotC10L/QtdGA0Ywg0LLRi9GB0LvRj9C10Lwg0LLQtdC60YLQvtGAINCy0YvRgdGC0YDQtdC70LAg0LIg0LzQuNGA0L7QstGL0YUg0LrQvtC+0YDQtNC40L3QsNGC0LDRhVxuXHRcdFx0XHR2YXIgc2hvb3RfdmVjID0gbmV3IFQuVmVjdG9yMygpO1xuXHRcdFx0XHRzaG9vdF92ZWMuZnJvbUFycmF5KGFjdGlvbi53bW91c2UpO1xuXG5cdFx0XHRcdC8vZGlzdFxuXHRcdFx0XHQvLyBGb3IgYWxsIHRhcmdldHM6XG5cdFx0XHRcdC8vIGNhbGN1bGF0ZSBjbG9zZXN0IGRpc3RhbmNlIGFuZCB0aW1lIHRvIHRoYXQgXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiQUNUT1JcIiwgYWN0b3IpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly92YXIgQyA9IFMubWVzaF9mb3IoYWN0b3JfZ3VpZCk7XG5cdFx0XHRcdC8vdmFyIG9iamVjdCA9IEMuanNvblxuXHRcdFx0XHQvL3ZhciBhY3RvciA9IFMuYWN0b3JzW2FjdG9yX2d1aWRdO1xuXHRcdFx0XHRcblx0XHRcdFx0XG5cdFx0XHRcdC8vdmFyIHdwID0gb2JqZWN0Lndvcmtwb2ludHNbYWN0b3IuY29udHJvbC53b3JrcG9pbnRdO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGxhc3Rfc2hvdF90aW1lID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKGRldmljZV9pZCwgXCJsYXN0X3Nob3RfdGltZVwiKVxuXHRcdFx0XHR2YXIgaXNfcmVsb2FkaW5nID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKGRldmljZV9pZCwgXCJpc19yZWxvYWRpbmdcIiAgKTsgXG5cdFx0XHRcdHZhciBfbWFnID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKGRldmljZV9pZCwgXCJtYWdhemluZVwiKVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJTRVJWIGFjdCBiZWZvcmVcIiwgYWN0aW9uKTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJMT0cgVElNRVNcIiwgaXNfcmVsb2FkaW5nLCBsYXN0X3Nob3RfdGltZSwgIGFjdGlvbi50cyAtIGlzX3JlbG9hZGluZywgYWN0aW9uLnRzIC0gbGFzdF9zaG90X3RpbWUpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYoIChhY3Rpb24udHMgLSAgaXNfcmVsb2FkaW5nKSA8IG1lc2gudHlwZS5kZXZpY2VzW2RldmljZV9pZF0udHVycmV0X3JlbG9hZF9yYXRlKXtcblx0XHRcdFx0XHRyZXR1cm4gO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJTRVJWIGFjdCAtIHJlbG9hZGVkXCIsIGFjdGlvbik7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZihfbWFnID09IDApe1xuXHRcdFx0XHRcdHJldHVybiA7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIlNFUlYgYWN0IGZ1bGwgbWFnXCIsIGFjdGlvbik7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobGFzdF9zaG90X3RpbWUpe1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwibGFzdCBzaG90IHRpbWVcIiwgbGFzdF9zaG90X3RpbWUsKGFjdGlvbi50cyAtIGxhc3Rfc2hvdF90aW1lICkgPCBDLmpzb24udHVycmV0c1t3cC50dXJyZXRdLnR1cnJldF9zaG9vdF9yYXRlICk7XG5cdFx0XHRcdFx0aWYoKGFjdGlvbi50cyAtIGxhc3Rfc2hvdF90aW1lICkgPCBtZXNoLnR5cGUuZGV2aWNlc1tkZXZpY2VfaWRdLnR1cnJldF9zaG9vdF9yYXRlKXtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdubyBzaG9vdCcpO1xuXHRcdFx0XHRcdFx0cmV0dXJuOyAvLyB0aGlzIHR1cnJldCBjYW5ub3Qgc2hvb3Qgbm93XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJTRVJWIGFjdCBzaG9vdCBmcmVlbHlcIiwgYWN0aW9uKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJCT09PU0ghXCIpO1xuXHRcdFx0XHR2YXIgc2hvb3RfaW1wdWxzZSA9IG1lc2gudHlwZS5kZXZpY2VzW2RldmljZV9pZF0uc2hvb3RfaW1wdWxzZTtcblx0XHRcdFx0Ly8gVE9ETyDQn9GA0LjQvNC10L3QuNGC0Ywg0LLRi9GB0YLRgNC10Lsg0Log0YHQvtCx0YHRgtCy0LXQvdC90L7QvNGDINC40LzQv9GD0LvRjNGB0YMgLSBcblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHRtZXNoLnNldERldmljZVNldHRpbmcoZGV2aWNlX2lkLCBcImxhc3Rfc2hvdF90aW1lXCIsIGFjdGlvbi50cyk7XG5cdFx0XHRcdG1lc2guYWx0ZXJEZXZpY2VTZXR0aW5nKGRldmljZV9pZCwgJ21hZ2F6aW5lJywgZnVuY3Rpb24odil7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibWFnXCIpO1xuXHRcdFx0XHRcdHJldHVybiB2IC0gMTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIk5vdyBsZXQncyBzZWUsIGRpZCB3ZSBnZXQgc29tZWJvZHlcIik7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgdHVycmV0ID0gbWVzaC50eXBlLmRldmljZXNbIGRldmljZV9pZCBdIDtcblx0XHRcdFx0XG5cdFx0XHRcdHZhciB0dXJyZXRfcG9zaXRpb25fdmVjdG9yID0gbmV3IFQuVmVjdG9yMygpO1xuXHRcdFx0XHR0dXJyZXRfcG9zaXRpb25fdmVjdG9yLmZyb21BcnJheSggdHVycmV0LnBvc2l0aW9uICk7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgYnVsbGV0X3BvcyA9IG1lc2gucG9zaXRpb24uY2xvbmUoKVxuXHRcdFx0XHRidWxsZXRfcG9zLmFkZCggIHR1cnJldF9wb3NpdGlvbl92ZWN0b3IuY2xvbmUoKSApXG5cblx0XHRcdFx0dmFyIEJVTExFVF9NQVNTID0gMTtcblx0XHRcdFx0XG5cdFx0XHRcdHNob290X3ZlYy5zdWIoYnVsbGV0X3Bvcy5jbG9uZSgpKSAvLyDQndCw0L/RgNCw0LLQu9C10L3QuNC1INCy0YvRgdGC0LXRgNC70LBcblx0XHRcdFx0c2hvb3RfdmVjLm11bHRpcGx5U2NhbGFyKCBzaG9vdF9pbXB1bHNlIC8gQlVMTEVUX01BU1MgKTsgLy8g0YHQutC+0YDQvtGB0YLRjCDQstGL0YHRgtGA0LXQu9CwXG5cdFx0XHRcdFxuXHRcdFx0XHQvLyDQndCw0LTQviDRgdC+0YHRgtCw0LLQuNGC0Ywg0YHQv9C40YHQvtC6INC80LXRiNC10LksINGH0LXRgNC10Lcg0LrQvtGC0L7RgNGL0LUg0L/RgNC+0YXQvtC00LjRgiDQu9GD0Ycg0YLRgNCw0LXQutGC0L7RgNC40Lgg0LTQstC40LbQtdC90LjRjyDRgdC90LDRgNGP0LTQsCDRgSDRg9GH0LXRgtC+0Lwg0LLQtdGA0L7Rj9GC0L3QvtGB0YLQuCDQv9C+0L/QsNC00LDQvdC40Y9cblx0XHRcdFx0dmFyIGNvbGxpZGFibGVzID0gW107XG5cdFx0XHRcdF8uZWFjaChtZXNoLl9zY2VuZS5tZXNoZXMsIGZ1bmN0aW9uKHRtZXNoLCBpKXtcblx0XHRcdFx0XHRpZihpID09ICBtZXNoLkdVSUQpIHJldHVybjtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgdGFyZ2V0X3BvcyA9IHRtZXNoLnBvc2l0aW9uLmNsb25lKCk7XG5cdFx0XHRcdFx0dmFyIHRhcmdldF9pbXB1bHNlID0gdG1lc2guaW1wdWxzZS5jbG9uZSgpO1xuXHRcdFx0XHRcdHZhciB0YXJnZXRfdmVsb2NpdHkgPSB0YXJnZXRfaW1wdWxzZS5tdWx0aXBseVNjYWxhcigxL3RtZXNoLm1hc3MpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vINCj0LLQtdC70LjRh9C40Lwg0YHQutC+0YDQvtGB0YLRjCDQstC+INC80L3QvtCz0L4t0LzQvdC+0LPQviDRgNCw0Ldcblx0XHRcdFx0XHR0YXJnZXRfcG9zLnN1YiggYnVsbGV0X3BvcyApO1xuXHRcdFx0XHRcdHRhcmdldF92ZWxvY2l0eS5zdWIoIHNob290X3ZlYyApO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBkb3QgPSB0YXJnZXRfcG9zLmRvdCh0YXJnZXRfdmVsb2NpdHkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBjb3NwID0gZG90LyggdGFyZ2V0X3Bvcy5sZW5ndGgoKSAqIHRhcmdldF92ZWxvY2l0eS5sZW5ndGgoKSApXG5cdFx0XHRcdFx0dmFyIHNpbnAgPSBNYXRoLnNxcnQoMSAtIGNvc3AqY29zcCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIHYgPSBNYXRoLmFicyhjb3NwKSAqIHRhcmdldF92ZWxvY2l0eS5sZW5ndGgoKTtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyh2LCB0YXJnZXRfcG9zLmxlbmd0aCgpKTtcblx0XHRcdFx0XHR2YXIgdGltZSA9IHRhcmdldF9wb3MubGVuZ3RoKCkgLyB2IFxuXHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHNpbnAgKiB0YXJnZXRfcG9zLmxlbmd0aCgpOyAvLyDQnNCw0LrRgdC40LzQsNC70YzQvdCw0Y8g0LTQuNGB0YLQsNC90YbQuNGPLCDQsiDQutC+0YLQvtGA0L7QuSDQv9GA0L7QudC00LXRgiDRgdC90LDRgNGP0LQg0L7RgiDQutC+0YDQsNCx0LvRj1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJkaXN0YW5jZSBhbmQgdGltZVwiLCBkaXN0YW5jZSwgdGltZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8g0KDQtdGI0LXQvdC40LUg0L4g0L/QvtC/0LDQtNCw0L3QuNC4INC90LDQtNC+INC/0YDQuNC90LjQvNCw0YLRjCDQt9C00LXRgdGMXG5cdFx0XHRcdFx0Ly8gIGRpc3RhbmNlINCc0L7QttC10YIg0YPQvNC10L3RjNGI0LjRgtGM0YHRjyDQsiDQt9Cw0LLQuNGB0LjQvNC+0YHRgtC4INC+0YIg0YHQutC40LvQu9C+0LIg0LjQs9GA0L7QutCwINC4INGF0LDRgNCw0LrRgtC10YDQuNGB0YLQuNC6INC+0YDRg9C20LjRj1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vINCh0YDQsNCy0L3QtdC90LjQtSDRgSDQs9C10L7QvNC10YLRgNC40YfQtdGB0LrQuNC80Lgg0YDQsNC30LzQtdGA0LDQvNC4INGC0LXQu9CwOlxuXHRcdFx0XHRcdHZhciBib3VuZFJhZGl1cyA9IHRtZXNoLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlO1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiU1BIRVJFXCIsIGJvdW5kUmFkaXVzLnJhZGl1cywgZGlzdGFuY2UpO1xuXHRcdFx0XHRcdC8vY29uc29sZS5sb2codGFyZ2V0X3ZlbG9jaXR5LnRvQXJyYXkoKSwgc2hvb3RfdmVjLnRvQXJyYXkoKSk7XG5cdFx0XHRcdFx0aWYoZGlzdGFuY2UgPCBib3VuZFJhZGl1cy5yYWRpdXMpe1xuXHRcdFx0XHRcdFx0Ly8gaGl0IFxuXHRcdFx0XHRcdFx0Y29sbGlkYWJsZXMucHVzaCh7dGltZTogdGltZSwgbWVzaDp0bWVzaCwgZGlzdGFuY2U6ZGlzdGFuY2V9KVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vINCh0LjQvdGD0YEgLSDRjdGC0L4g0LzQtdGA0LAg0L/QvtC/0LDQtNCw0L3QuNGPLiDQn9GA0Lgg0YPQvNC90L7QttC10L3QuNC4INC10ZEg0L3QsCDQstC10LrRgtC+0YAg0L/QvtC30LjRhtC40Lgg0LzRiyDRg9C30L3QsNC10Lwg0L3QsCDQutCw0LrQvtC5INC00LjRgdGC0LDQvdGG0LjQuCDQv9GA0L7QudC00LXRgiDRgdC90LDRgNGP0LQg0L7RgiDRhtC10LvQuFxuXHRcdFx0XHRcdC8vINCa0L7RgdC40L3Rg9GBINC00LDQtdGCINC/0YDQtdC00YHRgtCw0LLQu9C10L3QuNC1INC+INCy0YDQtdC80LXQvdC4ICDQtNC+INC60L7QvdGC0LDQutGC0LAuINCV0YHQu9C4INC60L7RgdC40L3Rg9GBINC+0YLRgNC40YbQsNGC0LXQu9GM0L3Ri9C5IC0g0LfQvdCw0YfQuNGCICBcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInNpbiBhbmQgY29zXCIsIHRhcmdldF9wb3MudG9BcnJheSgpLCBtZXNoLnBvc2l0aW9uLnRvQXJyYXkoKSwgc2lucCwgY29zcCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyDQotC10L/QtdGA0YwsINC90LDQtNC+INC30LDQv9C40YXQvdGD0YLRjCDRjdGC0L4g0YHQvtCx0YvRgtC40LUg0LIg0L7Rh9C10YDQtdC00Ywg0L/RgNC+0YbQtdGB0YHQuNC90LPQsDpcblx0XHRcdFx0Ly8gMS4g0KHQvtCx0YvRgtC40LUgLSDQuNC80L/Rg9C70YzRgSDQvdCwINC90LDRgSwg0LrQvtGC0L7RgNC+0LUg0LzQvtC20LXRgiDQstC60LvRjtGH0LDRgtGMINGC0LDQutC20LUg0LjQt9C80LXQvdC40LUg0YHQvtGB0YLQvtGP0L3QuNC5INCy0L3Rg9GC0YDQtdC90L3QuNGFINC/0YDQuNCx0L7RgNC+0LIgLSDQvdCw0L/RgNC40LzQtdGAINC60L7Qu9C40YfQtdGB0YLQstC+INC/0LDRgtGA0L7QvdC+0LJcblx0XHRcdFx0Ly8gMi4g0JIg0YHQu9GD0YfQsNC1INC/0L7Qv9Cw0LTQsNC90LjRjyAtINC+0YLQv9GA0LDQstC40YLRjCDQsiDQsdGD0LTRg9GJ0LXQtSDRgdC+0LHRi9GC0LjQtSDQvtCxINC40LfQvNC10L3QtdC90LjQuCDQuNC80L/Rg9C70YzRgdCwINC4INGB0L7RgdGC0L7Rj9C90LjRjyDRhtC10LvQuC5cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjb2xsaWRhYmxlcy5sZW5ndGggPiAwKXtcblx0XHRcdFx0XHR2YXIgIGNvbCA9IF8uc29ydEJ5KGNvbGxpZGFibGVzLCBmdW5jdGlvbihpKXsgcmV0dXJuIGkudGltZX0pWzBdXG5cdFx0XHRcdFx0dmFyICB0bWVzaCA9IGNvbC5tZXNoIC8vINCf0L7Qv9Cw0LvQuCFcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiV2UgZ290IHlvdXIgQVNTXCIpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBhY3Rpb25fcHJvY2Vzc29yID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiaGVyZSB3ZSB3aWxsIHByb2Nlc3MgdGhlIGhpdFwiKTtcblx0XHRcdFx0XHRcdHZhciBzaGllbGRfaHAgPSBzaG9vdF9pbXB1bHNlICogMC43O1xuXHRcdFx0XHRcdFx0dmFyIGFybW9yX2hwICA9IHNob290X2ltcHVsc2UgKiAwLjg7XG5cdFx0XHRcdFx0XHR2YXIgaHVsbF9ocCA9IHNob290X2ltcHVsc2UgKiAxLjA1O1xuXHRcdFx0XHRcdFx0dmFyIHNoX3NlcSA9IHRtZXNoLnNoaWVsZHMuY29uY2F0KHRtZXNoLmFybW9ycylcblx0XHRcdFx0XHRcdHNoX3NlcS5wdXNoKHRtZXNoLnR5cGUuaHVsbF9kZXZpY2UpXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHZhciByZWMgPSBmdW5jdGlvbihzZXEpe1xuXHRcdFx0XHRcdFx0XHRpZiAoc2VxLmxlbmd0aCA9PSAwKXtyZXR1cm59O1xuXHRcdFx0XHRcdFx0XHR2YXIgZiA9IHNlcVswXTtcblx0XHRcdFx0XHRcdFx0dmFyIGRldiA9IG1lc2gudHlwZS5kZXZpY2VzW2ZdXG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR2YXIgdGFpbCA9IHNlcS5zbGljZSgxKTtcblx0XHRcdFx0XHRcdFx0dmFyIGhwO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGV2LnNoaWVsZF90eXBlID09ICdhcm1vcicpe2hwID0gc2hvb3RfaW1wdWxzZSAqIDAuN31cblx0XHRcdFx0XHRcdFx0aWYgKGRldi5zaGllbGRfdHlwZSA9PSAnc2hpZWxkJyl7aHAgPSBzaG9vdF9pbXB1bHNlICogMC44fVxuXHRcdFx0XHRcdFx0XHRpZiAoZGV2LnNoaWVsZF90eXBlID09ICdodWxsJyl7aHAgPSBzaG9vdF9pbXB1bHNlICogMS4wNX1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHR0bWVzaC5hbHRlckRldmljZVNldHRpbmcoZiwgXCJjYXBhY2l0eVwiLCBmdW5jdGlvbih2KXtcblx0XHRcdFx0XHRcdFx0XHRpZiAodiA8PSAwKXsgcmVjKHRhaWwpOyByZXR1cm4gMDt9XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG52ID0gdiAtIGhwO1xuXHRcdFx0XHRcdFx0XHRcdGlmKG52IDw9IDApeyByZXR1cm4gMCB9ZWxzZXtyZXR1cm4gbnZ9O1xuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnbGF1bmNoIHJlcScpO1xuXHRcdFx0XHRcdFx0cmVjKHNoX3NlcSk7XG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiSEVSRSdzIE9VUiBSRVNVTFRTXCIpXG5cdFx0XHRcdFx0XHQvLyBERUJVR1wiXG5cdFx0XHRcdFx0XHRfLmVhY2goc2hfc2VxLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0XHRcdFx0dmFyIHNoID0gdG1lc2guZ2V0RGV2aWNlU2V0dGluZyhkLCBcImNhcGFjaXR5XCIpXG5cdFx0XHRcdFx0XHRcdHZhciBkZXYgPSB0bWVzaC50eXBlLmRldmljZXNbZF07XG5cdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJERUJVR0dJTkcgU0hPVFNcIiwgZCwgZGV2Lm5hbWUsIHNoKTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQvL0VORE9GIERFQlVHXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG1lc2guc3RhcnRWaXJ0dWFsRGV2aWNlQWN0aW9uKGFjdGlvbl9wcm9jZXNzb3IsIGFjdGlvbi50cyArIGNvbC50aW1lLCBhY3Rpb24uaWRlbnQgKyBjb2wudGltZSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9XG5cdFx0dGhpcy5nZXRVSSA9IGZ1bmN0aW9uKFcpe1xuICAgIFx0XHR2YXIgdWkgPSBmdW5jdGlvbigpe1xuICAgIFx0XHRcdHRoaXMucnVsZXNfaGVpZ2h0ID0gMTQwXG4gICAgICAgICAgICAgICAgdGhpcy5vbkFjdGlvbiA9IGZ1bmN0aW9uKFcsIHNjZW5lX2d1aWQsIGFjdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aHJlZV9zY2VuZSA9IFcudGhyZWVfc2NlbmVzW3NjZW5lX2d1aWRdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGwgPSBTcHJpdGVVdGlscy5jcmVhdGVFeHBvc2lvbk9iamVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiI1wiICsgYWN0aW9uLm1lc2ggKyBcIl9cIithY3Rpb24uaWRlbnQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnRzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbi53bW91c2UsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJlZV9zY2VuZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0ID0gZnVuY3Rpb24oKXtcbiAgICBcdFx0XHRcdHRoaXMuY29udCA9ICQoJzxkaXY+JykuY3NzKHsncG9zaXRpb24nOidmaXhlZCcsXG4gICAgXHRcdFx0XHRcdFx0XHRcdC8vICdib3JkZXInOiAnMXB4IHNvbGlkIHJlZCcsXG4gICAgXHRcdFx0XHRcdFx0XHRcdCd3aWR0aCc6XCI2NnB4XCIsXG4gICAgXHRcdFx0XHRcdFx0XHRcdCdoZWlnaHQnOiAnMTcwcHgnLFxuICAgIFx0XHRcdFx0XHRcdFx0XHQndG9wJzo0MCxcbiAgICBcdFx0XHRcdFx0XHRcdFx0J2xlZnQnOjUwLFxuICAgIFx0XHRcdFx0XHRcdFx0XHQnYmFja2dyb3VuZC1jb2xvcic6J3doaXRlJ30pLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XG4gICAgXHRcdFx0XHR2YXIgcnVsX2NvbnQgPSAkKCc8ZGl2PicpLmNzcyh7XG4gICAgXHRcdFx0XHRcdFwid2lkdGhcIjogIFwiMTAwJVwiLFxuICAgIFx0XHRcdFx0XHRcImhlaWdodFwiOiB0aGlzLnJ1bGVzX2hlaWdodCArICdweCcsXG4gICAgXHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzonYmx1ZSdcblxuICAgIFx0XHRcdFx0fSkuYXBwZW5kVG8odGhpcy5jb250KTtcblxuICAgIFx0XHRcdFx0dmFyIGJ1bF9jb250ID0gJCgnPGRpdj4nKS5jc3Moe1xuICAgIFx0XHRcdFx0XHRcIndpZHRoXCI6ICBcIjEwMCVcIixcbiAgICBcdFx0XHRcdFx0XCJoZWlnaHRcIjogKDE3MCAtIHRoaXMucnVsZXNfaGVpZ2h0KSArIFwicHhcIixcbiAgICBcdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOidncmVlbidcbiAgICBcdFx0XHRcdH0pLmFwcGVuZFRvKHRoaXMuY29udCk7XG5cbiAgICBcdFx0XHRcdHZhciBhdXRvX3RyYWNrX3N3aXRjaCA9ICQoJzxkaXY+JykuY3NzKHsnd2lkdGgnOicyMnB4JyxcbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J2hlaWdodCc6JzIycHgnLFxuICAgIFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnYm9yZGVyLXJhZGl1cyc6JzExcHgnLFxuICAgIFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnZmxvYXQnOidsZWZ0JyxcbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J2JhY2tncm91bmQtY29sb3InOid3aGl0ZSd9KS5hcHBlbmRUbyhydWxfY29udCk7XG4gICAgXHRcdFx0XHR0aGlzLm1hZ2F6aW5lX2luZGljYXRvciA9ICQoJzxkaXY+JykuY3NzKFxuICAgIFx0XHRcdFx0XHR7J3dpZHRoJzonMjJweCcsXG4gICAgXHRcdFx0XHRcdCdoZWlnaHQnOiAgdGhpcy5ydWxlc19oZWlnaHQgKyAgJ3B4JyxcbiAgICBcdFx0XHRcdFx0J2Zsb2F0JzonbGVmdCcsXG4gICAgXHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzoncmVkJ30pLmFwcGVuZFRvKHJ1bF9jb250KTtcbiAgICBcdFx0XHRcdHRoaXMudGltZV9pbmRpY2F0b3IgPSAkKCc8ZGl2PicpLmNzcyhcbiAgICBcdFx0XHRcdFx0eyd3aWR0aCc6JzIycHgnLFxuICAgIFx0XHRcdFx0XHQnaGVpZ2h0JzogIHRoaXMucnVsZXNfaGVpZ2h0KyAgJ3B4JyxcbiAgICBcdFx0XHRcdFx0J2Zsb2F0JzonbGVmdCcsXG4gICAgXHRcdFx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzoncmVkJ31cbiAgICBcdFx0XHRcdCkgLmFwcGVuZFRvKHJ1bF9jb250KTtcblxuICAgIFx0XHRcdH1cbiAgICBcdFx0XHR0aGlzLl9zZXRfbWFnYXppbmVfY2FwYWNpdHkgPSBmdW5jdGlvbigpe1xuICAgIFx0XHRcdFx0Ly8gdmFyIE8gPSBXLnNjZW5lc1thY3Rvci5zY2VuZV0ubWVzaGVzW2FjdG9yLmNvbnRyb2wub2JqZWN0X2d1aWRdO1xuICAgIFx0XHRcdFx0Ly92YXIgd3AgPSBPLmpzb24ud29ya3BvaW50c1thY3Rvci5jb250cm9sLndvcmtwb2ludF07XG4gICAgXHRcdFx0XHR2YXIgbWFnX2NhcCA9IG1lc2gudHlwZS5kZXZpY2VzW2RldmljZV9pZF0ubWFnYXppbmVfY2FwYWNpdHk7XG4gICAgXHRcdFx0XHR2YXIgX21hZyAgICA9IG1lc2guZ2V0RGV2aWNlU2V0dGluZyhkZXZpY2VfaWQsIFwibWFnYXppbmVcIik7XG4gICAgXHRcdFx0XHRpZiAoISBfbWFnKSBfbWFnID0gMDtcblx0XHRcbiAgICBcdFx0XHRcdHZhciBwZXJjZW50YWdlID0gX21hZy8gbWFnX2NhcDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5tYWdhemluZV9pbmRpY2F0b3IpO1xuICAgIFx0XHRcdFx0aWYoX21hZyAgPT0gMCl7XG4gICAgXHRcdFx0XHRcdHRoaXMubWFnYXppbmVfaW5kaWNhdG9yLmhlaWdodChcIjFweFwiKTtcbiAgICBcdFx0XHRcdFx0dGhpcy5tYWdhemluZV9pbmRpY2F0b3IuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywncmVkJylcblx0XHRcdFxuICAgIFx0XHRcdFx0fWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImhoXCIsIGRldmljZV9pZCwgcGVyY2VudGFnZSAqIHRoaXMucnVsZXNfaGVpZ2h0KVxuICAgIFx0XHRcdFx0XHR0aGlzLm1hZ2F6aW5lX2luZGljYXRvci5oZWlnaHQocGVyY2VudGFnZSAqIHRoaXMucnVsZXNfaGVpZ2h0KTtcbiAgICBcdFx0XHRcdFx0dGhpcy5tYWdhemluZV9pbmRpY2F0b3IuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywnZ3JlZW4nKVxuICAgIFx0XHRcdFx0fVxuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdFxuICAgIFx0XHRcdH1cbiAgICBcdFx0XHR0aGlzLl9zZXRfcmVhZGluZXNzX3RpbWVyID0gZnVuY3Rpb24oKXtcbiAgICBcdFx0XHRcdHZhciByYXRlID0gbWVzaC50eXBlLmRldmljZXNbZGV2aWNlX2lkXS50dXJyZXRfc2hvb3RfcmF0ZTtcbiAgICBcdFx0XHRcdHZhciByZWxvYWRfcmF0ZSA9IG1lc2gudHlwZS5kZXZpY2VzW2RldmljZV9pZF0udHVycmV0X3JlbG9hZF9yYXRlO1xuXHRcdFxuICAgIFx0XHRcdFx0dmFyIF90cyAgPSBtZXNoLmdldERldmljZVNldHRpbmcoZGV2aWNlX2lkLCBcImxhc3Rfc2hvdF90aW1lXCIpO1xuICAgIFx0XHRcdFx0dmFyIGlyX3RzID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKGRldmljZV9pZCwgXCJpc19yZWxvYWRpbmdcIik7XG4gICAgXHRcdFx0XHR2YXIgbm93ICA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhfdHMsIGlyX3RzLCBub3cpO1xuICAgIFx0XHRcdFx0dmFyIGlyX2RpZmYgPSBub3cgLSBpcl90cztcbiAgICBcdFx0XHRcdGlmKGlyX2RpZmYgPiByZWxvYWRfcmF0ZSl7XG4gICAgXHRcdFx0XHRcdHZhciBfbWFnICAgID0gbWVzaC5nZXREZXZpY2VTZXR0aW5nKGRldmljZV9pZCwgXCJtYWdhemluZVwiKTtcblx0XHRcbiAgICBcdFx0XHRcdFx0dmFyIGRpZmYgPSBub3cgLSBfdHM7XG4gICAgXHRcdFx0XHRcdGlmKF9tYWcgPT09IDAgKXtcbiAgICBcdFx0XHRcdFx0XHRwZXJjZW50YWdlID0gMDtcbiAgICBcdFx0XHRcdFx0fWVsc2V7XG4gICAgXHRcdFx0XHRcdFx0aWYoZGlmZiA+IHJhdGUpe1xuICAgIFx0XHRcdFx0XHRcdFx0dmFyIHBlcmNlbnRhZ2UgPSAxO1xuICAgIFx0XHRcdFx0XHRcdH0gZWxzZXtcbiAgICBcdFx0XHRcdFx0XHRcdHZhciBwZXJjZW50YWdlID0gIChkaWZmIC8gcmF0ZSk7XG4gICAgXHRcdFx0XHRcdFx0fVxuXHRcdFx0XG4gICAgXHRcdFx0XHRcdH1cblx0XHRcdFxuICAgIFx0XHRcdFx0fWVsc2V7XG4gICAgXHRcdFx0XHRcdHBlcmNlbnRhZ2UgPSBpcl9kaWZmL3JlbG9hZF9yYXRlO1xuICAgIFx0XHRcdFx0fVxuXHRcdFxuXHRcdFxuICAgIFx0XHRcdFx0dGhpcy50aW1lX2luZGljYXRvci5oZWlnaHQocGVyY2VudGFnZSAqIHRoaXMucnVsZXNfaGVpZ2h0KTtcblx0XHRcblx0XHRcbiAgICBcdFx0XHR9XG4gICAgXHRcdFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24oKXtcbiAgICBcdFx0XHRcdHRoaXMuX3NldF9yZWFkaW5lc3NfdGltZXIoKTtcbiAgICBcdFx0XHRcdHRoaXMuX3NldF9tYWdhemluZV9jYXBhY2l0eSgpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBVSSA9IG5ldyB1aSgpO1xuICAgIFx0XHRyZXR1cm4gVUk7XG5cdFx0fVxuXHR9XG5cdHRoaXMuVHVycmV0Q29udHJvbGxlci5kZXZpY2VfdHlwZXMgPSBcInR1cnJldFwiO1xuXHR0aGlzLlZpcnR1YWxEZXZpY2VDb250cm9sbGVyID0gZnVuY3Rpb24obWVzaCwgZGV2aWNlX2lkKXtcblx0XHR0aGlzLmdldFVJID0gZnVuY3Rpb24oKXt9XG5cdFx0dGhpcy5wcm9jZXNzID0gZnVuY3Rpb24oYWN0aW9uKXtcblx0XHRcdC8vIENhbGwgaXQ7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcIm9rZXkgLSB3ZSBjb3VsZCBkbyB0aGluZyBoZXJlXCIsYWN0aW9uKTtcblx0XHRcdFxuXHRcdFx0bWVzaC5fZm9yZWlnbl9wcm9jc1thY3Rpb24udHNdKCk7XG5cdFx0fVxuXHR9XG5cdHRoaXMuVmlydHVhbERldmljZUNvbnRyb2xsZXIuZGV2aWNlX3R5cGVzID0gXCJ2aXJ0dWFsXCI7XG5cdFxuXHR2YXIgY29udHJvbGxlcnNNYXAgPSB7fVxuXHRmb3IoaSBpbiB0aGlzKXtcblx0XHRjb250cm9sbGVyc01hcFt0aGlzW2ldLmRldmljZV90eXBlc10gPSB0aGlzW2ldO1xuXHR9XG5cdHRoaXMuY29udHJvbGxlcnNNYXAgPSBjb250cm9sbGVyc01hcDtcblx0Ly8gY29uc29sZS5sb2coXCI+PlwiLCB0aGlzLmNvbnRyb2xsZXJzTWFwKTtcblxufVxudmFyIGNjID0gbmV3IENvbnRyb2xsZXJzKCk7XG5Db250cm9sbGVyLmRldmljZUNvbnRyb2xsZXJzID0gY2M7XG5tb2R1bGUuZXhwb3J0cyA9IENvbnRyb2xsZXJcbi8vdmFyIFR1cnJldENvbnRyb2xsZXIgPSBuZXcgQ1R1cnJldENvbnRyb2xsZXIoKVxuLy9DUGlsb3RDb250cm9sbGVyLnByb3RvdHlwZSA9IHtjb25zdHJ1Y3RvcjpDUGlsb3RDb250cm9sbGVyfVxuLy92YXIgUGlsb3RDb250cm9sbGVyID0gbmV3IENQaWxvdENvbnRyb2xsZXIoKTtcblxuLy9jb25zb2xlLmxvZyhUdXJyZXRDb250cm9sbGVyLmFjdCwgUGlsb3RDb250cm9sbGVyLmFjdClcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jb250cm9sbGVyLmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIF8gICAgID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5cblxuaWYodHlwZW9mIHdpbmRvdyA9PT0ndW5kZWZpbmVkJyl7XG5cdFxuXHR2YXIgTCA9IHtzZXRWYWx1ZTpmdW5jdGlvbigpe319O1xuXHRpc19icm93c2VyID0gZmFsc2U7XG59ZWxzZXtcblx0dmFyIEwgPSBTTDtcblx0aXNfYnJvd3NlciA9IHRydWU7XG59XG52YXIgRXZlbnRRdWV1ZSA9IGZ1bmN0aW9uKG1lc2hfaWQpe1xuXHR0aGlzLl9tZXNoX2d1aWQgPSBtZXNoX2lkO1xuXHR0aGlzLl9tZXNoX2lkID0gbWVzaF9pZC5zdWJzdHJpbmcoMCw1KTtcblx0XG5cdHRoaXMuX2V2ZW50cyA9IHt9O1xuXHR0aGlzLl9zdGFtcHMgPSBbXTsgLy8gc29ydGVkO1xuXHR0aGlzLl9yZW1vdmVfYmVmb3JlID0gMDtcblx0dGhpcy5fbGFzdF9wcm9jZXNzZWQgPSAwO1xuXHR0aGlzLl9yZW1fY29tbSA9MFxuXHR0aGlzLl9kaXNwX2NvdW50ZXIxID0gMDtcblx0dGhpcy5fZGlzcF9jb3VudGVyMiA9IDA7XG5cdFxuXHQvLyB0aGlzLl9zdGFtcHNfaXhcbn1cbkV2ZW50UXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKCBlLCB0cyApe1xuXHRpZih0aGlzLl9ldmVudHNbdHNdKXtcblx0XHR0aGlzLl9ldmVudHNbdHNdLnB1c2goZSk7XHRcblx0fWVsc2V7XG5cdFx0dGhpcy5fZXZlbnRzW3RzXSA9IFtlXTtcblx0fVxuXHRcblx0dGhpcy5fc3RhbXBzLnB1c2godHMpO1xuXHR0aGlzLl9zdGFtcHMuc29ydCgpO1xufVxuRXZlbnRRdWV1ZS5wcm90b3R5cGUuc2V0X2xhc3RfcHJvY2Vzc2VkID0gZnVuY3Rpb24odHMpe1xuXHR0aGlzLl9sYXN0X3Byb2Nlc3NlZCA9IHRzO1xuXHR0aGlzLl9pbmNsdWRlX2xhc3Rfb25jZSA9IHRydWU7XG59XG5FdmVudFF1ZXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihyZW1vdmVfYmVmb3JlX3RzKXtcblx0dGhpcy5fcmVtX2NvbW0gKz0gMTtcblx0dGhpcy5fcmVtb3ZlX2JlZm9yZSA9IHJlbW92ZV9iZWZvcmVfdHM7IC8vIExhenkgcmVtb3Zpbmdcblx0XG59XG5FdmVudFF1ZXVlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24obm93LCBwcm9jZXNzb3Ipe1xuXHR2YXIgcmVtb3ZlZF9peGVzID0gW107XG5cdHZhciBzZWxmID0gdGhpcztcblx0Ly8gY29uc29sZS5sb2coXCJTXCIpO1xuXHR2YXIgcHJvY2Vzc2VkX2V2ZW50cyA9IDA7XG5cdF8uZWFjaCh0aGlzLl9zdGFtcHMsIGZ1bmN0aW9uKHRzLCBpeCl7XG5cdFx0XG5cdFx0aWYgKHRzIDw9IHNlbGYuX3JlbW92ZV9iZWZvcmUpe1xuXHRcdFx0cmVtb3ZlZF9peGVzLnB1c2goaXgpO1xuXHRcdFx0ZGVsZXRlIHNlbGYuX2V2ZW50c1t0c107XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBpc19mcm9tID0gc2VsZi5faW5jbHVkZV9sYXN0X29uY2U/IHNlbGYuX2xhc3RfcHJvY2Vzc2VkIDw9IHRzIDogc2VsZi5fbGFzdF9wcm9jZXNzZWQgPCB0cztcblx0XHQvL2NvbnNvbGUubG9nKFwiRkZGXCIsIFtpc19mcm9tLHRzIDw9IG5vd10sIHNlbGYuX2xhc3RfcHJvY2Vzc2VkLCB0cywgbm93LCB0cy1ub3cgKTtcblx0XHRcblx0XHRpZihpc19mcm9tICYmIHRzIDw9IG5vdyl7XG5cdFx0XHRzZWxmLl9pbmNsdWRlX2xhc3Rfb25jZSA9IGZhbHNlO1xuXHRcdFx0Xy5lYWNoKHNlbGYuX2V2ZW50c1t0c10sIGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRpZighaXNfYnJvd3Nlcil7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwcm9jZXNzb3IoICBlLCB0cyApXG5cdFx0XHRcdHByb2Nlc3NlZF9ldmVudHMgKz0gMTtcblx0XHRcdH0pXG5cblx0XHRcdHNlbGYuX2xhc3RfcHJvY2Vzc2VkID0gdHM7XG5cblx0XHRcdFxuXHRcdH1cblx0fSlcblxuXHRfLmVhY2gocmVtb3ZlZF9peGVzLCBmdW5jdGlvbihpeCl7XG5cdFx0c2VsZi5fc3RhbXBzLnNwbGljZShpeCwgMSk7XG5cdH0pXG5cdC8vTC5zZXRWYWx1ZShcIlNUXCIgKyB0aGlzLl9tZXNoX2lkLCB0aGlzLl9zdGFtcHMubGVuZ3RoKVxuXHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFF1ZXVlO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ldmVudF9xdWV1ZS5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblNjZW5lID0gcmVxdWlyZSgnLi9zY2VuZS5qcycpXG5NaXNzaW9uID0gcmVxdWlyZSgnLi9taXNzaW9ucy5qcycpXG5VdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKVxuU3ByaXRlVXRpbHMgPSByZXF1aXJlKCcuL3Nwcml0ZV91dGlscy5qcycpXG5Db250cm9sbGVyID0gcmVxdWlyZSgnLi9jb250cm9sbGVyLmpzJylcbkFPYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC5qcycpXG5cblxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2Zha2VfY2Q1NWNhNzAuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgU2NlbmUgPSByZXF1aXJlKCcuL3NjZW5lJylcbnZhciB1ID0gcmVxdWlyZSgnLi91dGlscycpXG52YXIgXyAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cblxudmFyIGdldE1pc3Npb25UeXBlID1mdW5jdGlvbiAodHlwZSl7XG5cdHJldHVybiBjcmVhdGVfbWlzc2lvbl9qc29uKClcbn1cblxudmFyIGNyZWF0ZV9taXNzaW9uX2pzb24gPSBmdW5jdGlvbiggICl7XG5cdHZhciBwMSA9IFstMTEwLCAxMDAsIDQwXTtcblx0dmFyIHAyID0gWzUwMCwgMjAwLCAtNTBdO1xuXHR2YXIgYyA9IDAuMlxuXHR2YXIgcDEgPSBfLm1hcChwMSxmdW5jdGlvbih2KXtyZXR1cm4gdipjfSk7XG5cdHZhciBwMiA9IF8ubWFwKHAyLGZ1bmN0aW9uKHYpe3JldHVybiB2KmN9KTs7XG5cdHZhciBwc291cmNlID0ge1xuXHRcdGZ1ZWxfY2VsbF9jYXBhY2l0eTogNTAwLCAvLyDQntCx0YrQtdC8INGC0L7Qv9C70LjQstCwXG5cdFx0ZnVlbF9jb25zdW1wdGlvbl9wZXJmb3JtYW5jZTogMSwgLy8g0KPQtNC10LvRjNC90LDRjyDRjdC90LXRgNCz0LjRjyDRgtC+0L/Qu9C40LLQsCAtIFxuXHRcdG1heF9wb3dlcjogNjAwMCwgLy8g0JzQsNC60YHQuNC80LDQu9GM0L3QsNGPINC80L7RidC90L7RgdGC0Ywg0LjRgdGC0L7Rh9C90LjQutCwINGN0L3QtdGA0LPQuNC4IC0g0JTQtiAo0JLRgi7RgSlcblx0XHRtaW5fcG93ZXI6MCwgLy8g0JzQuNC90LjQvNCw0LvRjNC90LDRjyDQvNC+0YnQvdC+0YHRgtGMINC40YHRgtC+0YfQvdC40LrQsCDRjdC90LXRgNCz0LjQuFxuXHRcdHBvd2VydXBfc3BlZWQ6MiwgLy8g0KHQutC+0YDQvtGB0YLRjCDRg9Cy0LXQu9C40YfQtdC90LjRjyDQvNC+0YnQvdC+0YHRgtC4INC40YHRgtC+0YfQvdC40LrQsCAtINC00LbQvtGD0LvQuCDQsiDRgdC10LrRg9C90LTRg1xuXHRcdHBvd2VyZG93bl9zcGVlZDoyLCAvLyDQodC60L7RgNC+0YHRgtGMINGD0LzQtdC90YzRiNC10L3QuNGPINC80L7RidC90L7RgdGC0Lgg0LjRgdGC0L7Rh9C90LjQutCwXG5cdFx0Y2FwYWNpdG9yOjM2MDAwMCAvLyDQldC80LrQvtGB0YLRjCDQutC+0L3QtNC10L3RgdCw0YLQvtGA0LBcblxuXHR9O1xuXG4gICAgZGV2aWNlcyA9IFtcbiAgICAvLyBFbmdpbmVzIGZpcnN0XG4gICAgLy8wXG4gICAge3R5cGU6J2VuZ2luZScsIG5hbWU6J3gtJywgZW5naW5lX3R5cGU6J3JvdGF0aW9uJywgY29uc3VtcHRpb246MTAwMCwgcGVyZm9ybWFuY2U6MC44LCB1bml0OlstMSwgMCwgMF0sIGFjdGlvbnM6e2ltcHVsc2U6e2RlZmF1bHRfa2V5Ojg3fSwgcG93ZXI6e30gfSB9LFxuICAgIC8vMVxuICAgIHt0eXBlOidlbmdpbmUnLCBuYW1lOid4KycsIGVuZ2luZV90eXBlOidyb3RhdGlvbicsIGNvbnN1bXB0aW9uOjEwMDAsIHBlcmZvcm1hbmNlOjAuOCwgdW5pdDpbMSwgMCwgMF0sIGFjdGlvbnM6e2ltcHVsc2U6e2RlZmF1bHRfa2V5OjgzfSwgcG93ZXI6e30gfX0sXG4gICAgXG4gICAgLy8yXG4gICAge3R5cGU6J2VuZ2luZScsIG5hbWU6J3krJywgZW5naW5lX3R5cGU6J3JvdGF0aW9uJywgY29uc3VtcHRpb246MTAwMCwgcGVyZm9ybWFuY2U6MC44LCB1bml0OlswLCAxLCAwXSwgYWN0aW9uczp7aW1wdWxzZTp7ZGVmYXVsdF9rZXk6NjV9LCBwb3dlcjp7fSB9fSxcbiAgICAvLzNcbiAgICB7dHlwZTonZW5naW5lJywgbmFtZToneS0nLCBlbmdpbmVfdHlwZToncm90YXRpb24nLCBjb25zdW1wdGlvbjoxMDAwLCBwZXJmb3JtYW5jZTowLjgsIHVuaXQ6WzAsIC0xLCAwXSwgYWN0aW9uczp7aW1wdWxzZTp7ZGVmYXVsdF9rZXk6Njh9LCBwb3dlcjp7fSB9fSxcbiAgICAvLzRcbiAgICBcbiAgICB7dHlwZTonZW5naW5lJywgbmFtZToneisnLCBlbmdpbmVfdHlwZToncm90YXRpb24nLCBjb25zdW1wdGlvbjoxMDAwLCBwZXJmb3JtYW5jZTowLjgsIHVuaXQ6WzAsIDAsIDFdLCBhY3Rpb25zOntpbXB1bHNlOntkZWZhdWx0X2tleTo5MH0sIHBvd2VyOnt9IH19LFxuICAgIC8vNVxuICAgIHt0eXBlOidlbmdpbmUnLCBuYW1lOid6LScsIGVuZ2luZV90eXBlOidyb3RhdGlvbicsIGNvbnN1bXB0aW9uOjEwMDAsIHBlcmZvcm1hbmNlOjAuOCwgdW5pdDpbMCwgMCwgLTFdLCBhY3Rpb25zOntpbXB1bHNlOntkZWZhdWx0X2tleTo2N30sIHBvd2VyOnt9IH19LFxuICAgIFxuICAgIC8vNlxuICAgIHt0eXBlOidlbmdpbmUnLCBuYW1lOid6KycsIGVuZ2luZV90eXBlOidwcm9wdWxzaW9uJywgY29uc3VtcHRpb246NTAwMCwgcGVyZm9ybWFuY2U6MC44LCB1bml0OlswLCAwLCAtMV0sIGFjdGlvbnM6e2ltcHVsc2U6e2RlZmF1bHRfa2V5OjM4fSwgcG93ZXI6e30gfX0sXG4gICAgLy83XG4gICAge3R5cGU6J2VuZ2luZScsIG5hbWU6J3otJywgZW5naW5lX3R5cGU6J3Byb3B1bHNpb24nLCBjb25zdW1wdGlvbjo1MDAwLCBwZXJmb3JtYW5jZTowLjgsIHVuaXQ6WzAsIDAsIDFdLCBhY3Rpb25zOntpbXB1bHNlOntkZWZhdWx0X2tleTo0MH0sIHBvd2VyOnt9IH19LFxuICAgIFxuICAgIC8vIFNoaWVsZHMgJiBlbmdpbmVcbiAgICAvLzhcbiAgICB7dHlwZToncG93ZXInLCAgbmFtZTonUG93ZXIgU291cmNlJywgcG93ZXJ1cF9zcGVlZDoyLCBwb3dlcmRvd25fc3BlZWQ6MiwgY2FwYWNpdG9yOjM2MDAwMCwgbWF4X3Bvd2VyOjYwMDAsIG1pbl9wb3dlcjowLCBhY3Rpb25zOntwb3dlcjp7fX0gfSxcbiAgICAvLzlcbiAgICB7dHlwZTonc2hpZWxkJywgbmFtZTonQXJtb3InLHNoaWVsZF90eXBlOidhcm1vcicsIGVmZmVjdGl2ZV9pbXB1bHNlOjMwMCwgY2FwYWNpdHk6NDAwMCwgY2FwYWNpdG9yOjQwMDAsIGNoYXJnZV9yYXRlOjUwMCwgcmVwYWlyX3JhdGU6MzAwLCBwZXJmb3JtYW5jZTowLjUsIGFjdGlvbnM6e3Bvd2VyOnt9LCB0b2dnbGU6e2lzX3N3aXRjaDp0cnVlfSB9fSxcbiAgICAvLzEwXG4gICAge3R5cGU6J3NoaWVsZCcsIG5hbWU6J1NoaWVsZCcsc2hpZWxkX3R5cGU6J3NoaWVsZCcsIGNhcGFjaXR5OjUwMDAsIGNhcGFjaXRvcjoxMDAwMCwgY2hhcmdlX3JhdGU6MTAwMCwgc2V0dXBfZW5lcmd5OjMwMDAsIGFjdGlvbnM6e3Bvd2VyOnt9LCB0b2dnbGU6e2lzX3N3aXRjaDp0cnVlfSB9fSxcbiAgICAvLzExXG4gICAge3R5cGU6J3NoaWVsZCcsIG5hbWU6J1RoZXJtYWwnLHNoaWVsZF90eXBlOid0aGVybWFsJywgZWZmZWN0aXZlX2ltcHVsc2U6MzAwLCBhY3Rpb25zOntwb3dlcjp7fSwgdG9nZ2xlOntpc19zd2l0Y2g6dHJ1ZX0gfX0sXG4gICAgXG4gICAgLy8gdHVycmV0cywgYmF5cywgZHJvbmVzLCBsYXVuY2hlcnNcbiAgICAvLzEyXG4gICAge3R5cGU6J3R1cnJldCcsIG5hbWU6XCJGcm9udCB0dXJyZXRcIiwgcG9zaXRpb246IFswLDAuNSwwXSwgbWFnYXppbmVfY2FwYWNpdHk6IDEwMCwgdHVycmV0X3Nob290X3JhdGU6MjAwMCwgdHVycmV0X3JlbG9hZF9yYXRlOjEwMDAwLCBzaG9vdF9pbXB1bHNlOjMyMCwgYWN0aW9uczp7ZmlyZTp7IGRlZmF1bHRfa2V5OidsbW91c2UnfSwgcmVsb2FkOntkZWZhdWx0X2tleTo4Mn0gfSB9LFxuICAgIC8vMTNcbiAgICB7dHlwZTondHVycmV0JywgbmFtZTpcImJhY2sgdHVycmV0XCIsIHBvc2l0aW9uOiBbMCwwLDJdLCBtYWdhemluZV9jYXBhY2l0eTogMTAwLCB0dXJyZXRfc2hvb3RfcmF0ZToyMDAwLCB0dXJyZXRfcmVsb2FkX3JhdGU6MTAwMDAsIHNob290X2ltcHVsc2U6MzIwLCBhY3Rpb25zOntmaXJlOnsgZGVmYXVsdF9rZXk6J2xtb3VzZSd9LCByZWxvYWQ6e2RlZmF1bHRfa2V5OjgyfSB9IH0sXG4gICAgLy8xNFxuICAgIHt0eXBlOlwidmlydHVhbFwiLCBuYW1lOlwiRm9yZWlnbiBhY3Rpb24gdmlydHVhbCBkZXZpY2VcIiwgYWN0aW9uczp7XCJwcm9jZXNzXCI6e319fSxcbiAgICAvLzE1XG4gICAge3R5cGU6XCJodWxsXCIsIG5hbWU6XCJIdWxsIGhwXCIsIHNoaWVsZF90eXBlOidodWxsJywgY2FwYWNpdHk6MTAwMCwgYWN0aW9uczp7fX1cbiAgICBcblxuICAgIF1cblx0dmFyIHNoaWVsZHMgPSB7XG5cdFx0XCJhcm1vclwiOls5XSxcblx0XHRcInNoaWVsZFwiOlsxMF0sXG5cdFx0dGhlcm1hbDpbXVxuXHR9O1xuXHRlbmdpbmVzID0ge1xuXHRcdCdyb3RhdGlvbic6WzAsMSwyLDMsNCw1XSxcblx0XHQncHJvcHVsc2lvbic6WzYsN10sXG5cdH1cblx0dmFyIGRlZl9zaGlwMSA9IHt0eXBlOidzaGlwJyxcblx0XHRcdFx0XHQgXCJzaGlwX3R5cGVcIjpcIkRlZmF1bHRcIixcblx0XHRcdFx0XHRcdCBtb2RlbF8zZDonL21vZGVscy9TdGFyQ3J1aXNlci5qcycsXG5cdFx0XHRcdFx0XHQgcGh5c2ljYWw6e1xuXHRcdFx0XHRcdFx0XHQgcG9zOnAxLFxuXHRcdFx0XHRcdFx0XHQgcm90Ont0bzpwMn0sXG5cdFx0XHRcdFx0XHQgfSxcblx0XHRcdFx0XHQgXG5cdFx0XHRcdFx0XHQgXCJjYW1lcmFzXCI6e1xuXHRcdFx0XHRcdFx0XHRcdFwiZnJvbnRcIjp7XG5cdFx0XHRcdFx0XHRcdFx0XHRcImxhYmVsXCI6XCJtYWluXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInBvc2l0aW9uXCI6IFswLDAuNSwwXSxcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGlyZWN0aW9uXCI6WzAsMCwtMV1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XCJiYWNrXCI6e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcImxhYmVsXCI6XCJtYWluXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFwicG9zaXRpb25cIjogWzAsMC41LDJdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcImRpcmVjdGlvblwiOlswLDAsMV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlczpkZXZpY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJfc291cmNlOjgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JlaWduX3Byb2Nlc3NvcjoxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1bGxfZGV2aWNlOjE1LFxuXHRcdFx0XHRcdFx0XCJ3b3JrcG9pbnRzXCI6e1xuXHRcdFx0XHRcdFx0XHRcIlBpbG90aW5nXCI6e1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJ2aWV3c1wiOiBbXCJmcm9udFwiLFwiYmFja1wiXSxcblx0XHRcdFx0XHRcdFx0XHRcdFwidHlwZVwiOlwicGlsb3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZXM6WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTFdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcIkZyb250IHR1cnJldFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJ2aWV3c1wiOltcImZyb250XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cdFx0XHRcdFx0XHRcdFx0XHRcInR5cGVcIjpcInR1cnJldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJ0dXJyZXRcIjpcImZyb250XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZXM6WzEyXVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcIkJhY2sgdHVycmV0XCI6e1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJ2aWV3c1wiOltcImJhY2tcIl0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcInR5cGVcIjpcInR1cnJldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJ0dXJyZXRcIjpcImJhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZXM6WzEzXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcblx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0Ly9cInBvd2VyX3NvdXJjZVwiOnBzb3VyY2UsXG5cdFx0XHRcdFx0XHRcdFx0c2hpZWxkczpzaGllbGRzLFxuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0ICdlbmdpbmVzJzogZW5naW5lcyAsXG5cdFx0XHRcdFx0XHQnbWFzcyc6IDEwMDAwLFxuXHRcdFx0XHRcdFx0J0dVSUQnOnUubWFrZV9ndWlkKClcblx0XHRcdFx0XHR9XG5cdHZhciBkZWZfc2hpcDIgPSB7dHlwZTonc2hpcCcsXG4gXHRcdFx0XHRcdCBcInNoaXBfdHlwZVwiOlwiRGVmYXVsdFwiLFxuXHRcblx0XHRcdFx0XHRcdCBtb2RlbF8zZDonL21vZGVscy9TdGFyQ3J1aXNlci5qcycsXG5cdFx0XHRcdFx0XHQgcGh5c2ljYWw6e1xuXHRcdFx0XHRcdFx0XHQgcG9zOnAyLFxuXHRcdFx0XHRcdFx0XHQgcm90Ont0bzpwMX0sXG5cdFx0XHRcdFx0XHQgXG5cdFx0XHRcdFx0XHQgfSxcblx0XHRcdCBcdFx0XHRcImNhbWVyYXNcIjp7XG5cdFx0XHQgXHRcdFx0XHRcdFwiZnJvbnRcIjp7XG5cdFx0XHQgXHRcdFx0XHRcdFx0XCJsYWJlbFwiOlwibWFpblwiLFxuXHRcdFx0IFx0XHRcdFx0XHRcdFwicG9zaXRpb25cIjogWzAsMC41LDBdLFxuXHRcdFx0IFx0XHRcdFx0XHRcdFwiZGlyZWN0aW9uXCI6WzAsMCwtMV1cblx0XHRcdCBcdFx0XHRcdFx0XHR9LFxuXHRcdFx0IFx0XHRcdFx0XHRcImJhY2tcIjp7XG5cdFx0XHQgXHRcdFx0XHRcdFx0XHRcImxhYmVsXCI6XCJtYWluXCIsXG5cdFx0XHQgXHRcdFx0XHRcdFx0XHRcInBvc2l0aW9uXCI6IFswLDAuNSwyXSxcblx0XHRcdCBcdFx0XHRcdFx0XHRcdFwiZGlyZWN0aW9uXCI6WzAsMCwxXVxuXHRcdFx0IFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlczpkZXZpY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJfc291cmNlOjgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JlaWduX3Byb2Nlc3NvcjoxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh1bGxfZGV2aWNlOjE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcIndvcmtwb2ludHNcIjp7XG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFwiUGlsb3RpbmdcIjp7XG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFx0XHRcInZpZXdzXCI6IFtcImZyb250XCIsXCJiYWNrXCJdLFxuICAgICAgICAgICAgXHRcdFx0XHRcdFx0XHRcdFx0XCJ0eXBlXCI6XCJwaWxvdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlczpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMV1cbiAgICAgICAgICAgIFx0XHRcdFx0XHRcdFx0XHRcdH0sXG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFwiRnJvbnQgdHVycmV0XCI6XG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFx0XHR7XG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFx0XHRcInZpZXdzXCI6W1wiZnJvbnRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFx0XHRcdFx0XHRcdFx0XHRcdFwidHlwZVwiOlwidHVycmV0XCIsXG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFx0XHRcInR1cnJldFwiOlwiZnJvbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlczpbMTJdXG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFwiQmFjayB0dXJyZXRcIjp7XG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFx0XHRcInZpZXdzXCI6W1wiYmFja1wiXSxcbiAgICAgICAgICAgIFx0XHRcdFx0XHRcdFx0XHRcdFwidHlwZVwiOlwidHVycmV0XCIsXG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFx0XHRcInR1cnJldFwiOlwiYmFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlczpbMTNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblx0XHRcdFx0XHRcdFxuICAgICAgICAgICAgXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFxuXHRcdFx0XG4gICAgICAgICAgICBcdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFwicG93ZXJfc291cmNlXCI6cHNvdXJjZSxcbiAgICAgICAgICAgIFx0XHRcdFx0XHRcdFx0XHRzaGllbGRzOnNoaWVsZHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICdlbmdpbmVzJzogZW5naW5lcyAsXG5cdFx0XHRcdFx0XHRcblx0XHRcdCBcdFx0XHQnbWFzcyc6IDEwMDAwLFxuXHRcdFx0XHRcdFx0J0dVSUQnOnUubWFrZV9ndWlkKClcblx0XHRcdFx0XHR9XG5cdC8vINCW0LXRgdGC0LrQviDQt9Cw0LTQsNC90L3Ri9C1INC60L7RgNCw0LHQu9C40LrQuCAtINCx0LXQtyDQv9C+0LfQuNGG0LjQuSDQuCDRgdC60L7RgNC+0YHRgtC10LlcdFxuXHR2YXIgcGl2b3Q9IFx0ZnVuY3Rpb24oeCx5LHope1xuXHRcdHJldHVybiB7dHlwZTonc3RhdGljJyxcblx0XHRcblx0XHRcdFx0XHRcdCBtb2RlbF8zZDonL21vZGVscy9zcC5qcycsXG5cdFx0XHRcdFx0XHQgcGh5c2ljYWw6e1xuXHRcdFx0XHRcdFx0XHQgcG9zOlt4LCB5LCB6XVxuXHRcdFx0XHRcdFx0XHQgLy9yb3Q6e3RvOiBbLTExMCwgMTAwLCA0MF19LFxuXHRcdFx0XHRcdFx0IFxuXHRcdFx0XHRcdFx0IH0sXG5cdFx0XHQgXHRcdFx0J21hc3MnOiAxMDAwMDAwLFxuXHRcdFx0XHRcdFx0J0dVSUQnOnUubWFrZV9ndWlkKClcblx0XHRcdFx0XHR9XG5cdH1cblx0dGhpcy5fZGgyID0gZGVmX3NoaXAyOyAvLyDQodC+0YXRgNCw0L3Rj9C10Lwg0LrQvtGA0LDQsdC70LjQuiAtINC/0L7RgtC+0LzRgyDRh9GC0L4g0L/QvtC60LAg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GMINC90LUg0LLRi9Cx0LjRgNCw0LXRgiDQutC+0YDQsNCx0LvRjCAtINC+0L0g0LXQvNGDINC90LDQt9C90LDRh9Cw0LXRgtGB0Y9cdFx0XG5cdHZhciBzbyA9IHt9XG5cdF8uZWFjaChbZGVmX3NoaXAxLGRlZl9zaGlwMl0sIGZ1bmN0aW9uKHMpe1xuXHRcdHNvW3MuR1VJRF0gPSBzXG5cdH0pXG5cdC8vINCX0LTQtdGB0Ywg0LzRiyDQv9GA0L7RgdGC0L4g0L3QsNC/0L7Qu9C90Y/QtdC8INGB0YbQtdC90Ysg0YjQsNGA0LjQutCw0LzQuCAtINC/0L4g0YPQvNGDLCDRjdGC0Lgg0YjQsNGA0LjQutC4INC90LDQtNC+INGB0L7Qt9C00LDQstCw0YLRjCDQvdC1INC30LTQtdGB0YwgLSDQsCDQuNC90LbQtdC60YLQuNGC0Ywg0LjQtyDQvNC40YDQsFxuXHQvKlxuXHR2YXIgaW5jID0gMFxuXHR2YXIgc3RlcCA9IDIwMDtcblx0Zm9yICh2YXIgeD0tMjAwOyB4PD0gMjAwOyB4Kz1zdGVwKXtcblx0XHRmb3IgKHZhciB5PS0yMDA7IHk8PSAyMDA7IHkrPXN0ZXApe1xuXHRcdFx0Zm9yICh2YXIgej0tMjAwOyB6PD0gMjAwOyB6Kz1zdGVwKXtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhpbmMsXCJ4LHkselwiLHgseSx6KVxuXHRcdFx0XHRpbmMgKz0xO1xuXHRcdFx0XHR2YXIgcCA9cGl2b3QoeCx5LHopXG5cdFx0XHRcdHNvW3AuR1VJRF0gPSBwXG5cdFx0XHR9XG5cdFx0fVxuXHR9Ki9cblx0Ly8gLS0tINCd0LDQv9C+0LvQvdC10L3QuNC1INGB0YbQtdC90Ytcblx0dmFyIG1pc3Npb24gPSB7XG5cdFx0YWN0b3JzIDoge30sXG5cdFx0Y29tbWFuZHM6WydyZWQnLCAnYmx1ZSddLFxuXHRcdF9jb21tYW5kc19hbW91bnQ6WzEsMF0sXG5cdFx0bWF4X3Blcl9jb21tYW5kOjEsXG5cdFx0bWluX3Blcl9jb21tYW5kOjEsXG5cdFx0Y29vcmRzIDogWzEwMCwgNTAwLCAzMDBdLCAvLyBHbG9iYWwgY29vcmRzIG9mIG1pc3Npb24gb3JpZ2luXG5cdFx0c2hhcmVkX29iamVjdHM6IHNvLFxuXHRcdG9iamVjdHNfZm9yX2NvbW1hbmQ6e1wicmVkXCI6W2RlZl9zaGlwMS5HVUlEXSxcImJsdWVcIjpbZGVmX3NoaXAyLkdVSURdfVxuXHRcdFxuXHR9XG5cdHJldHVybiBtaXNzaW9uXG59XG52YXIgTWlzc2lvbiA9IGZ1bmN0aW9uKHR5cGUpe1xuXHR0aGlzLmRlc2NyID0gXCJNaXNzaW9uXCJcblx0dGhpcy5taXNzaW9uID0gZ2V0TWlzc2lvblR5cGUodHlwZSk7XG5cdC8vY29uc29sZS5sb2codGhpcy5taXNzaW9uKTtcblx0XG59XG5cbk1pc3Npb24ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogTWlzc2lvbixcblx0XG5cblxuXHRjcmVhdGUgOmZ1bmN0aW9uKGNyZWF0b3JfaWQsIGNhbGxiYWNrKXtcblx0XG5cdFx0Ly8gTm8gcGFyYW1zIC0gb25seSBvbmUgbWlzc2lvbiBhdmFpbGFibGVcblx0XHR2YXIgc2VsZiA9IHRoaXMgO1xuXHRcdHRoaXMuR1VJRCA9IHUubWFrZV9ndWlkKCk7XG5cdFx0dGhpcy5jcmVhdG9yID0gY3JlYXRvcl9pZDtcblx0XHR0aGlzLnJlYWR5X3RvX3N0YXJ0ID0gZmFsc2Vcblx0XHR0aGlzLmlzX3N0YXJ0ZWQgPSBmYWxzZVxuXHRcdHRoaXMuX3VzZXJzID0ge307XG5cdFx0dGhpcy5fcG9zaXRpb25fYmluZHMgPSB7fTtcblx0XHR0aGlzLl90b3RhbF9hY3RvcnMgPSAwO1xuXHRcdHRoaXMuX3RvdGFsX2xvZ2lucyA9IDA7XG5cdFx0XG5cblx0XG5cblx0XHRzZWxmLl9taXNzaW9uX2xvZ2lucyA9IFtdO1xuXHRcdHNlbGYuX21pc3Npb25fb2JqZWN0cyA9IHt9XG5cdFx0XG5cdFx0c2VsZi5fbWlzc2lvbl9yZWFkeSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRjYWxsYmFjayhzZWxmKTtcblx0XHRcblx0XHRcblx0XHR9XG5cdFx0Ly8gc2VsZi5wcmVwYXJlX3NjZW5lKCk7XG5cdFx0c2VsZi5fbWlzc2lvbl9yZWFkeSgpO1xuXHRcdHJldHVybiB0aGlzXG5cdH0sXG5cdGdldFNjZW5lOiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiB0aGlzLl9zY2VuZTtcblx0fSxcblx0cHJlcGFyZV9zY2VuZSA6IGZ1bmN0aW9uKGJjYXN0ZXIpe1xuXHRcblx0XHQvLyBjb25zb2xlLmxvZyhTY2VuZSk7XG5cdFx0aWYoISB0aGlzLl9zY2VuZV9sb2FkZWQpe1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJETyBQUkVQIFNDRU5FXCIpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRUVFwiLGJjYXN0ZXIpO1xuXHRcdFx0dGhpcy5fc2NlbmUgPSBuZXcgU2NlbmUoYmNhc3Rlcik7XG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5neCA9IHRoaXMubWlzc2lvbi5jb29yZHNbMF07XG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5neSA9IHRoaXMubWlzc2lvbi5jb29yZHNbMV07XG4gICAgICAgICAgICB0aGlzLl9zY2VuZS5neiA9IHRoaXMubWlzc2lvbi5jb29yZHNbMl07XG5cdFx0XHQvL2NyZWF0ZV9mcm9tX3dvcmxkKHRoaXMubWlzc2lvbi5jb29yZHNbMF0sXG5cdFx0XHQvL1x0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5taXNzaW9uLmNvb3Jkc1sxXSxcblx0XHRcdC8vXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1pc3Npb24uY29vcmRzWzJdICk7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRfLmVhY2godGhpcy5taXNzaW9uLnNoYXJlZF9vYmplY3RzLCBmdW5jdGlvbihvYmope1xuXHRcdFx0XHRzZWxmLl9zY2VuZS5qb2luX29iamVjdChvYmopXG5cdFxuXHRcdFx0fSlcdFx0XG5cdFx0XHR2YXIgYWN0b3JzID0gdGhpcy5wcmVwYXJlX2FjdG9ycygpXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0Xy5lYWNoKGFjdG9ycywgZnVuY3Rpb24oYXMpeyAvLyDQnNC40YHRgdC40Y8g0LTQviDRjdGC0L7Qs9C+INCy0YDQtdC80LXQvdC4INC90LUg0LjQvNC10LvQsCDRgdGG0LXQvdGLIC0g0L3QsNC00L4g0LTQsNGC0Ywg0LXRkSDQutCw0LbQtNC+0LzRgyDQsNC60YLQvtGA0YMg0LfQtNC10YHRjFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKGEpXG5cdFx0XHRcdGFzLnNjZW5lID0gc2VsZi5fc2NlbmUuR1VJRFxuXHRcdFx0XHRzZWxmLl9zY2VuZS5qb2luX2FjdG9yKGFzKTtcblx0XHRcdH0pXG5cdFx0XHR0aGlzLl9zY2VuZV9sb2FkZWQ9IHRydWU7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcIlByZXBkXCIpXG5cdFx0fVxuXHRcdFxuXHRcdFx0XHRcdFx0XHRcblx0fSxcblx0cHJlcGFyZV9hY3RvcnM6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBhY3RvcnMgPSBbXVxuXHRcdF8uZWFjaCh0aGlzLl91c2VycywgZnVuY3Rpb24ocG9zaXRpb25zX29mX3VzZXIsIHVzZXJfaWQpe1xuXHRcdFx0Xy5lYWNoKHBvc2l0aW9uc19vZl91c2VyLCBmdW5jdGlvbihwb3NpdGlvbil7XG5cdFx0XHRcdFxuXHRcdFx0XHRhY3RvcnMucHVzaChzZWxmLl9tYWtlX2FjdG9yKHBvc2l0aW9uLCB1c2VyX2lkKSk7XG5cdFx0XHRcdFxuXHRcdFx0fSlcblx0XHR9KVxuXHRcdHJldHVybiBhY3RvcnM7XG5cdH0sXG5cdF9tYWtlX2FjdG9yOiBmdW5jdGlvbihwb3NfaWQsIHVzZXJfaWQpe1xuXHRcdHZhciBwb3MgPSB0aGlzLl9wb3NpdGlvbnNbcG9zX2lkXVxuXHRcdHZhciBuZXdfYWN0b3JfZ3VpZCA9IHUubWFrZV9zaG9ydF9ndWlkKClcblx0XHR2YXIgY29udHJvbGxhYmxlID0ge29iamVjdF9ndWlkOnBvcy5vYmplY3RfZ3VpZCwgd29ya3BvaW50OnBvcy53b3JrcG9pbnQsIHR5cGU6IHBvcy5jb250cm9sX3R5cGV9IC8vIHZpZXdwb3J0Oidmcm9udCcsIGNvbnRyb2xzOlsnUGlsb3QnLCAnVHVycmV0J119IFxuXHRcdGNvbnNvbGUubG9nKFwibWFrZSBhY3RvclwiLCAgcG9zKTtcblx0XHRyZXR1cm4ge2NvbW1hbmQ6cG9zLmNvbW1hbmQsIHVzZXJfaWQ6IHVzZXJfaWQsIGNvbnRyb2w6IGNvbnRyb2xsYWJsZSwgR1VJRDogIG5ld19hY3Rvcl9ndWlkfVxuXHRcdFxuXHR9LFxuXHRcblx0am9pbl9wbGF5ZXIgOmZ1bmN0aW9uKHVzZXJfaWQsIHBvc2l0aW9uX2lkICl7Ly8gbG9naW4sIGNvbW1hbmQsIG9iamVjdF9ndWlkLCBwbGFjZSl7XG5cdFx0aWYgKHRoaXMuX3Bvc2l0aW9uc1twb3NpdGlvbl9pZF0uYnVzeSl7cmV0dXJuO307XG5cdFx0XG5cdFx0aWYodGhpcy5fdXNlcnNbdXNlcl9pZF0gPT09IHVuZGVmaW5lZCl7IC8vINCe0LTQuNC9INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjCDQvNC+0LbQtdGCINC40LzQtdGC0Ywg0L3QtdGB0LrQvtC70YzQutC+INC/0L7Qt9C40YbQuNC5XG5cdFx0XHR0aGlzLl91c2Vyc1t1c2VyX2lkXSA9IFtwb3NpdGlvbl9pZF07XG5cdFx0XHRcblx0XHR9ZWxzZXtcblx0XHRcdHRoaXMuX3VzZXJzW3VzZXJfaWRdLnB1c2gocG9zaXRpb25faWQpO1xuXHRcdFx0XG5cdFx0fVxuXHRcdHRoaXMuX3Bvc2l0aW9uX2JpbmRzW3Bvc2l0aW9uX2lkXSA9IHVzZXJfaWQgLy8g0J/QvtC30LjRhtC40LXQuSDQvNC+0LbQtdGCINGD0L/RgNCw0LLQu9GP0YLRjCAtINC90LAg0L3QtdC5INGB0LjQtNC10YLRjCAtINGC0L7Qu9GM0LrQviDQvtC00LjQvSDQv9C+0LvRjNC30L7QstCw0YLQtdC70Yxcblx0XHR0aGlzLl9wb3NpdGlvbnNbcG9zaXRpb25faWRdLmJ1c3kgPSB0cnVlO1xuXHRcdHRoaXMuX3Bvc2l0aW9uc1twb3NpdGlvbl9pZF0udXNlcl9pZCA9IHVzZXJfaWQ7XG5cdFx0XG5cdFx0aWYodGhpcy5pc19zdGFydGVkKXtcblx0XHRcdHZhciBhY3RvciA9IHRoaXMuX21ha2VfYWN0b3IocG9zaXRpb25faWQsIHVzZXJfaWQpO1xuXHRcdFx0YWN0b3Iuc2NlbmUgPSB0aGlzLl9zY2VuZS5HVUlEO1xuXHRcdFx0dGhpcy5fc2NlbmUuam9pbl9hY3RvcihhY3Rvcilcblx0XHR9XG5cdFx0XG5cdFx0Lypcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIE0gPSBzZWxmLm1pc3Npb247XG5cdFx0dmFyIGNvbW1hbmQ7XG5cdFx0Ly8gR2V0IGZpcnN0IGF2YWlsYWJsZSBjb21tYW5kXG5cdFx0Ly8gY29uc29sZS5sb2coXCJMT0dJTlwiLCBsb2dpbilcblx0XHRpZiAoc2VsZi5fbWlzc2lvbl9vYmplY3RzW29iamVjdF9ndWlkXSA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdHNlbGYuX21pc3Npb25fb2JqZWN0c1tvYmplY3RfZ3VpZF0gPSB7fVxuXHRcdH1cblx0XHQvL18uZWFjaChwbGFjZXMsIGZ1bmN0aW9uKHApeyAvLyDQrdGC0L7RgiDQutGN0Ygg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINC/0YDQuCDQt9Cw0L/QvtC70L3QtdC90LjQuCDQvNC10YHRgiDQvdCwINC60L7RgNCw0LHQu9C4XG5cdFx0XHRzZWxmLl9taXNzaW9uX29iamVjdHNbb2JqZWN0X2d1aWRdW3BsYWNlXSA9IGxvZ2luO1xuXHRcdFx0XG5cdFx0XHQvL30pXG5cdFx0Ly8gVE9ETyDQl9C00LXRgdGMINC90LDQtNC+INCy0YHRgtCw0LLQu9GP0YLRjCDQuNCz0YDQvtC60L7QsiAtINC90LXQt9Cw0LLQuNGB0LjQvNC+INC+0YIg0YLQvtCz0L4sINGB0LrQvtC70YzQutC+INC70L7Qs9C40L3QvtCyXG5cdFx0Ly8gVE9ETyDQndCw0LTQviDQv9GA0L7QstC10YDRj9GC0Ywg0L3QsNC70LjRh9C40LUg0LvQvtCz0LjQvdC+0LIg0Lgg0LXRgdC70Lgg0LXRgdGC0YwgLSDQvdC1INGC0YPQv9C+INC00L7QsdCw0LLQu9GP0YLRjCwg0LAg0LTQvtCx0LDQstC70Y/RgtGMINC10LzRgyDQstC+0YDQutC/0L7QuNC90YJcblx0XHQvLyDQn9C+INC30LDQvdGP0YLRi9C8INCy0L7RgNC60L/QvtC40L3RgtCw0Lwg0YHQuNGH0YLQsNGC0Ywg0LPQvtGC0L7QstC90L7RgdGC0Yxcblx0XHR2YXIgY29udHJvbGxhYmxlID0ge29iamVjdF9ndWlkOm9iamVjdF9ndWlkLCB3b3JrcG9pbnQ6cGxhY2V9IC8vIHZpZXdwb3J0Oidmcm9udCcsIGNvbnRyb2xzOlsnUGlsb3QnLCAnVHVycmV0J119IFxuXHRcdHZhciBuZXdfYWN0b3JfZ3VpZCA9IHUubWFrZV9ndWlkKClcblx0XHR2YXIgYWN0b3IgPSB7Y29tbWFuZDpjb21tYW5kLCBsb2dpbjpsb2dpbiwgY29udHJvbDogY29udHJvbGxhYmxlLCBHVUlEOiAgbmV3X2FjdG9yX2d1aWR9XG5cdFx0Ly8g0JTQvtCx0LDQstC70Y/QtdC8INCw0LrRgtC+0YDQsCAtINC40L3QtNC10LrRgdC40YDRg9GPINC/0L4g0LvQvtCz0LjQvdGDXG5cdFx0aWYgKHNlbGYubWlzc2lvbi5hY3RvcnNbbmV3X2FjdG9yX2d1aWRdID09PSB1bmRlZmluZWQpe1xuXHRcdFx0c2VsZi5taXNzaW9uLmFjdG9yc1tuZXdfYWN0b3JfZ3VpZF0gPSBbYWN0b3JdXG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLm1pc3Npb24uYWN0b3JzW25ld19hY3Rvcl9ndWlkXS5wdXNoKGFjdG9yKVxuXHRcdH1cblx0XHRcblx0XHRzZWxmLl90b3RhbF9hY3RvcnMgKz0gMVxuXHRcdGlmKHNlbGYuX3RvdGFsX2FjdG9ycyA+PSAyKXtcblx0XHRcdGNvbnNvbGUubG9nKFwiTE9HSU5TXCIsIHNlbGYuX21pc3Npb25fbG9naW5zKTtcblx0XHRcdHNlbGYucmVhZHlfdG9fc3RhcnQgPSB0cnVlO1xuXHRcdH1lbHNle1xuXHRcdFx0Y29uc29sZS5sb2coXCJUT1RBTF9BQ1RPUlNcIiwgc2VsZi5fdG90YWxfYWN0b3JzKTtcblx0XHR9XG5cdFx0XG5cdFx0Y29uc29sZS5sb2coXCJUQVwiLHNlbGYuX3RvdGFsX2FjdG9ycyk7XG5cdFx0Ly8gY29uc29sZS5sb2coXCJBQ1RPUlNcIiwgc2VsZi5taXNzaW9uLmFjdG9ycyk7XG5cdFx0aWYgKHNlbGYuX3NjZW5lKXtcblx0XHRcdGFjdG9yLnNjZW5lID0gc2VsZi5fc2NlbmUuR1VJRFxuXHRcdFx0c2VsZi5fc2NlbmUuam9pbl9hY3RvcihhY3Rvcilcblx0XHR9XG5cdFx0cmV0dXJuIG5ld19hY3Rvcl9ndWlkXG5cdFx0Ki9cblx0fSxcblx0dG9fanNvbjpmdW5jdGlvbigpe1xuXHRcdHZhciByZXQgPSB7fTtcblx0XHRfLmV4dGVuZChyZXQsIHRoaXMubWlzc2lvbik7XG5cdFx0cmV0LnBvc2l0aW9ucyA9IHRoaXMucG9zaXRpb25zKClcblx0XHRyZXQuR1VJRCA9IHRoaXMuR1VJRDtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRwb3NpdGlvbnM6IGZ1bmN0aW9uKGNiKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0Ly9jb25zb2xlLmxvZyh0aGlzKTtcblx0XHR2YXIgcGxhY2VzID0gW107XG5cdFx0aWYoc2VsZi5fcG9zaXRpb25zKXtcblx0XHRcdGlmKGNiKWNiKHNlbGYuX3Bvc2l0aW9ucyk7XG5cdFx0XHRyZXR1cm4gc2VsZi5fcG9zaXRpb25zO1xuXHRcdFx0XG5cdFx0fWVsc2V7XG5cdFx0XHRzZWxmLl9wb3NpdGlvbnMgPSBbXVxuXHRcdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdFx0Xy5lYWNoKHNlbGYubWlzc2lvbi5jb21tYW5kcywgZnVuY3Rpb24oY29tbWFuZCl7XG5cdFx0XHRcdF8uZWFjaChzZWxmLm1pc3Npb24ub2JqZWN0c19mb3JfY29tbWFuZFtjb21tYW5kXSwgZnVuY3Rpb24ob2JqZWN0X2d1aWQpe1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGNvbW1hbmQsIHNlbGYubWlzc2lvbi5zaGFyZWRfb2JqZWN0cyk7XG5cdFx0XHRcdFx0dmFyIG9iamVjdCA9IHNlbGYubWlzc2lvbi5zaGFyZWRfb2JqZWN0c1tvYmplY3RfZ3VpZF1cblx0XHRcdFx0XHRfLmVhY2gob2JqZWN0Lndvcmtwb2ludHMsIGZ1bmN0aW9uKHdvcmtwb2ludCwgd3BfbGFiZWwpe1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0dmFyIHBsYWNlID0geydjb21tYW5kJzpjb21tYW5kLFxuXHRcdFx0XHRcdFx0IFx0XHRcdCAnb2JqZWN0X3R5cGUnOiBvYmplY3QudHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdCAnb2JqZWN0X3N1YnR5cGUnOm9iamVjdC5zaGlwX3R5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHQgJ29iamVjdF9ndWlkJzogb2JqZWN0LkdVSUQsXG5cdFx0XHRcdFx0XHRcdFx0IFx0ICd3b3JrcG9pbnQnOndwX2xhYmVsLFxuXHRcdFx0XHRcdFx0XHRcdFx0ICdjb250cm9sX3R5cGUnOiB3b3JrcG9pbnQudHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdCAnTUdVSUQnIDogc2VsZi5HVUlEXG5cdFx0XHRcdFx0XHRcdFx0IFxuXHRcdFx0XHRcdFx0XHRcdCB9XG5cdFx0XHRcdFx0XHRcdFx0IHBsYWNlLmlkID0gY291bnRlcjtcblx0XHRcdFx0XHRcdFx0XHQgY291bnRlciArPSAxO1xuXHQgXHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdCBcblx0XHRcdFx0XHRcdHNlbGYuX3Bvc2l0aW9ucy5wdXNoKHBsYWNlKVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFxuXHRcdFx0XHRcblx0XHRcdFx0fSlcblx0XHRcdFxuXHRcdFx0fSlcblx0XHRcdGlmKGNiKWNiKHBsYWNlcyk7XG5cdFx0XHRyZXR1cm4gc2VsZi5fcG9zaXRpb25zO1xuXHRcdFx0XG5cdFx0fVxuXHR9XG5cdFxufVxuLy9jb25zb2xlLmxvZyhNaXNzaW9uKTtcbm1vZHVsZS5leHBvcnRzID0gTWlzc2lvblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9taXNzaW9ucy5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBUSFIgPSByZXF1aXJlKCd0aHJlZScpO1xudmFyIEVRID0gcmVxdWlyZShcIi4vZXZlbnRfcXVldWVcIik7XG52YXIgXyAgICAgPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG52YXIgQ29udHJvbGxlciA9IHJlcXVpcmUoXCIuL2NvbnRyb2xsZXJcIik7XG5cblxuXG4vLyAvLyBDTChUSFIsIFRIUkVFKTtcbmlmKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKXtcblx0Ly8gdmFyIEFPYmplY3QgPSB7fTsgVEhSLk1lc2g7XG5cdFxuXHQvLyBBT2JqZWN0LnByb3RvdHlwZS5USFJFRSA9IFRIUiAvLyBTYXZlaW5nIFRIUkVFLmpzIGFzIHBhcnQgb2Ygc2NlbmUgLSB0aGlzIHN0ZXAgY291bGQgYmUgZG9uZSBvbiBhIGNlcnRhaW4gcGxhdGZvcm1cblx0dmFyIEwgPSB7c2V0VmFsdWU6ZnVuY3Rpb24oKXt9fTtcblx0dmFyIGdldF90aHJlZSA9IGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIFRIUjtcblx0fVxuXHQvL3ZhciBUSFJFRSA9IFRIUjtcblx0Ly8gQU9iamVjdC5wcm90b3R5cGUuZG9fcHJlcGFyZV9yZW5kZXJpbmcgPSBmYWxzZTtcblx0IFxuXHRcbn1lbHNle1xuXHR2YXIgZ2V0X3RocmVlID0gZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gVEhSRUU7XG5cdH1cblx0dmFyIEwgPSBTTDtcblx0XG5cdC8vIC8vIENMKCdsb2FkZWQnLCBUSFJFRSApXG5cdC8vdmFyIEFPYmplY3QgPSAgVEhSRUUuTWVzaDtcblx0Ly8gQU9iamVjdC5wcm90b3R5cGUuVEhSRUUgPSBUSFJFRVxuXHQvL0FPYmplY3QucHJvdG90eXBlLmRvX3ByZXBhcmVfcmVuZGVyaW5nID0gdHJ1ZTtcblx0XG59XG5cbi8vIC8vIENMKFwiSG9seSBjcmFwXCIsIEFPYmplY3QpXG5cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0KHNjZW5lLCBtYXQsIGdlb20pe1xuXHRcblx0dmFyIFRIUkVFID0gZ2V0X3RocmVlKCk7XG5cdHZhciBtID0gVEhSRUUuTWVzaDtcblx0bS5wcm90b3R5cGUuX3NjZW5lID0gc2NlbmU7XG5cdG0ucHJvdG90eXBlLnNvbWVfY291bnRlciA9IDA7XG5cdG0ucHJvdG90eXBlLl9mb3JlaWduX3Byb2NzID0ge307XG4gICAgXG5cdFxuXHRtLnByb3RvdHlwZS5yZWxvYWRfc2F2ZWRfc3RhdGU9IGZ1bmN0aW9uKCl7XG5cdFx0Ly8g0JfQtNC10YHRjCDQvNGLINCy0L7Qt9Cy0YDQsNGJ0LDQtdC8INGB0L7RhdGA0LDQvdC10L3QvdC+0LUg0YDQsNC90LXQtSDRgdC+0YHRgtC+0Y/QvdC40LUgLSDRgdC+0YHRgtC+0Y/QvdC40LUsINC60L7RgtC+0YDQvtC1INCx0YvQu9C+INGBINGN0YLQuNC8INC+0LHRitC10LrRgtC+0Lwg0LrQvtCz0LTQsC3RgtC+INC00LDQstC90L5cbiAgICAgICAgLypcblx0XHRwcmV2X3N0YXRlX19fID0ge3dvcmtwb2ludHM6e1xuXHRcdFx0XCJGcm9udCB0dXJyZXRcIjoge1xuXHRcdFx0XHRcIm1hZ2F6aW5lXCI6IDMwLFxuXHRcdFx0XHRcImxhc3Rfc2hvdF90aW1lXCI6MCxcblx0XHRcdH0sXG5cdFx0XHRcIkJhY2sgdHVycmV0XCI6IHtcblx0XHRcdFx0XCJtYWdhemluZVwiOiA1MCxcblx0XHRcdFx0XCJsYXN0X3Nob3RfdGltZVwiOjAsXG5cdFx0XHR9XG5cdFx0XHRcIlBpbG90aW5nXCI6e1xuXHRcdFx0XHRcImNhcGFjaXRvclwiOjAsXG5cdFx0XHRcdFwiZW5nX3JvdGF0aW9uX3grX3Bvd2VyXCI6IDEsXG5cdFx0XHRcdFwiZW5nX3JvdGF0aW9uX3krX3Bvd2VyXCI6IDEsXG5cdFx0XHRcdFwiZW5nX3JvdGF0aW9uX3orX3Bvd2VyXCI6IDEsXG5cdFx0XHRcdFwiZW5nX3JvdGF0aW9uX3gtX3Bvd2VyXCI6IDEsXG5cdFx0XHRcdFwiZW5nX3JvdGF0aW9uX3ktX3Bvd2VyXCI6IDEsXG5cdFx0XHRcdFwiZW5nX3JvdGF0aW9uX3otX3Bvd2VyXCI6IDEsXG5cblx0XHRcdFx0XCJlbmdfcHJvcHVsc2lvbl94LV9wb3dlclwiOiAxLFxuXHRcdFx0XHRcImVuZ19wcm9wdWxzaW9uX3ktX3Bvd2VyXCI6IDEsXG5cdFx0XHRcdFwiZW5nX3Byb3B1bHNpb25fei1fcG93ZXJcIjogMSxcblx0XHRcdFx0XCJlbmdfcHJvcHVsc2lvbl94K19wb3dlclwiOiAxLFxuXHRcdFx0XHRcImVuZ19wcm9wdWxzaW9uX3krX3Bvd2VyXCI6IDEsXG5cdFx0XHRcdFwiZW5nX3Byb3B1bHNpb25feitfcG93ZXJcIjogMSxcblx0XHRcdFx0XG5cdFx0XHRcdCdzX2FybW9yMF9wb3dlcic6MC4xLFxuXHRcdFx0XHQnc19zaGllbGQwX3Bvd2VyJzowLjMsXG5cdFx0XHRcdFxuXHRcdFx0XHQnc19hcm1vcjBfc3RhdGUnOmZhbHNlLFxuXHRcdFx0XHQnc19hcm1vcjBfY2FwJzogNDAwLFxuXHRcdFx0XHQnc19hcm1vcjBfcmNhcCc6MCxcblx0XHRcdFx0J3Nfc2hpZWxkMF9zdGF0ZSc6ZmFsc2UsXG5cdFx0XHRcdCdzX3NoaWVsZDBfY2FwJzo1MDAsXG5cdFx0XHRcdCdzX3NoaWVsZDBfcmNhcCc6MCxcblx0XHRcdFx0XG5cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9fTtcblx0XHRcblx0XHRwcmV2X3N0YXRlID0ge1xuXHRcdFx0d29ybGQ6e1x0XG5cdFx0XHRcdHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLnRvQXJyYXkoKSxcblx0XHRcdFx0cm90YXRpb246IHRoaXMucm90YXRpb24udG9BcnJheSgpLFxuXHRcdFx0XHRpbXB1bHNlOiAgdGhpcy5pbXB1bHNlLnRvQXJyYXkoKSxcblx0XHRcdFx0YW5ndWxhcl9pbXB1bHNlOiB0aGlzLmFuZ3VsYXJfaW1wdWxzZS50b0FycmF5KClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcblx0XHRcdGRldmljZXM6W1xuXHRcdFx0XHR7cG93ZXI6MX0sXG5cdFx0XHRcdHtwb3dlcjoxfSxcblx0XHRcdFx0e3Bvd2VyOjF9LFxuXHRcdFx0XHR7cG93ZXI6MX0sXG5cdFx0XHRcdHtwb3dlcjoxfSxcblx0XHRcdFx0e3Bvd2VyOjF9LFxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdFx0e3Bvd2VyOjF9LFxuXHRcdFx0XHR7cG93ZXI6MX0sXG5cdFx0XHRcblx0XHRcdFx0e2NhcGFjaXRvcjowLCBwb3dlcjoxfSxcblx0XHRcdFxuXHRcdFx0XHR7cG93ZXI6MC4xLCBjYXBhY2l0eToxMDAsIHN0YXRlOmZhbHNlLCByZXNlcnZlX2NhcGFjaXR5OjB9LFxuXHRcdFx0XHR7cG93ZXI6MC4xLCBjYXBhY2l0eToxMDAsIHN0YXRlOmZhbHNlLCByZXNlcnZlX2NhcGFjaXR5OjB9LFxuXHRcdFx0XHR7cG93ZXI6MC4wLCBjYXBhY2l0eTowfSxcblx0XHRcdFxuXHRcdFx0XHR7bWFnYXppbmU6MzAsIGxhc3Rfc2hvdF90aW1lOjAsIGlzX3JlbG9hZGluZzowfSxcblx0XHRcdFx0e21hZ2F6aW5lOjMwLCBsYXN0X3Nob3RfdGltZTowLCBpc19yZWxvYWRpbmc6MH0sXG5cdFx0XHRcdHt9LFxuXHRcdFx0XHR7Y2FwYWNpdHk6MjAwfVxuXHRcdFx0XVx0XG5cdFx0fTtcbiAgICAgICAgKi9cbiAgICAgICAgXG4gICAgICAgIC8vIC8vIENMKFwiVFRUVFRUVFRUVFRUVFRcIix0aGlzLnR5cGUpXG5cdFx0dGhpcy5yZXN0b3JlU3RhdGUodGhpcy5qc29uLmxhc3Rfc3RhdGUpO1xuXHRcdFxuXHR9XG5cdC8qXG5cdG0ucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24oKXtcblx0XHRpZih0aGlzLnNvbWVfY291bnRlciA8IDEwMCl7XG5cdFx0XHQvLyAvLyBDTChcIkxhc3QgUHJvY2VzcyB3aGlsZSBzdGF0ZVwiICsgdGhpcy5ldmVudE1hbmFnZXIuX21lc2hfaWQsIHRoaXMuZXZlbnRNYW5hZ2VyLl9sYXN0X3Byb2Nlc3NlZCk7XG5cdFx0XHR0aGlzLnNvbWVfY291bnRlciArPTE7XG5cdFx0fVxuXHRcdHZhciBjdXJyZW50X3N0YXRlID0ge1x0XG5cdFx0XHRzZXJ2ZXJfdHM6IHRoaXMuZXZlbnRNYW5hZ2VyLl9sYXN0X3Byb2Nlc3NlZCAsIFxuXHRcdFx0d29ybGQ6e1x0XG5cdFx0XHRcdHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLnRvQXJyYXkoKSxcblx0XHRcdFx0cm90YXRpb246IHRoaXMucm90YXRpb24udG9BcnJheSgpLFxuXHRcdFx0XHRpbXB1bHNlOiAgdGhpcy5pbXB1bHNlLnRvQXJyYXkoKSxcblx0XHRcdFx0YW5ndWxhcl9pbXB1bHNlOiB0aGlzLmFuZ3VsYXJfaW1wdWxzZS50b0FycmF5KCl9LH07XG5cdFx0XHRcdFx0XHRcdFxuXHRcdGlmICh0aGlzLndvcmtwb2ludF9zdGF0ZXMpe1xuXHRcdFx0Y3VycmVudF9zdGF0ZS53b3JrcG9pbnRzID0ge31cblx0XHRcdGZvciAod29ya3BvaW50IGluIHRoaXMud29ya3BvaW50X3N0YXRlcyl7XG5cdFx0XHRcdGN1cnJlbnRfc3RhdGUud29ya3BvaW50c1t3b3JrcG9pbnRdID0ge307XG5cdFx0XHRcdGZvciAocGFyYW0gaW4gdGhpcy53b3JrcG9pbnRfc3RhdGVzW3dvcmtwb2ludF0pe1xuXHRcdFx0XHRcdGN1cnJlbnRfc3RhdGUud29ya3BvaW50c1t3b3JrcG9pbnRdW3BhcmFtXSA9IHRoaXMud29ya3BvaW50X3N0YXRlc1t3b3JrcG9pbnRdW3BhcmFtXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY3VycmVudF9zdGF0ZTtcblx0XHRcblx0fVxuXHQqL1xuXHRtLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGN1cnJlbnRfc3RhdGUgPSB7XHRcblx0XHRcdHNlcnZlcl90czogdGhpcy5ldmVudE1hbmFnZXIuX2xhc3RfcHJvY2Vzc2VkICwgXG5cdFx0XHR3b3JsZDp7XHRcblx0XHRcdFx0cG9zaXRpb246IHRoaXMucG9zaXRpb24udG9BcnJheSgpLFxuXHRcdFx0XHRyb3RhdGlvbjogdGhpcy5yb3RhdGlvbi50b0FycmF5KCksXG5cdFx0XHRcdGltcHVsc2U6ICB0aGlzLmltcHVsc2UudG9BcnJheSgpLFxuXHRcdFx0XHRhbmd1bGFyX2ltcHVsc2U6IHRoaXMuYW5ndWxhcl9pbXB1bHNlLnRvQXJyYXkoKX19O1xuXHRcdFx0XHRcdFx0XHRcblx0XHRpZiAodGhpcy5kZXZpY2VzKXtcblx0XHRcdGN1cnJlbnRfc3RhdGUuZGV2aWNlcyA9IHt9XG5cdFx0XHRmb3IgKGRldiBpbiB0aGlzLmRldmljZXMpe1xuXHRcdFx0XHRjdXJyZW50X3N0YXRlLmRldmljZXNbZGV2XSA9IHt9O1xuXHRcdFx0XHRmb3IgKHBhcmFtIGluIHRoaXMuZGV2aWNlc1tkZXZdKXtcblx0XHRcdFx0XHRjdXJyZW50X3N0YXRlLmRldmljZXNbZGV2XVtwYXJhbV0gPSB0aGlzLmRldmljZXNbZGV2XVtwYXJhbV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGN1cnJlbnRfc3RhdGU7XG5cdH1cblx0bS5wcm90b3R5cGUucmVzdG9yZVN0YXRlID0gZnVuY3Rpb24oc3RhdGUpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRmb3IodiBpbiBzdGF0ZS53b3JsZCl7XG4gICAgICAgICAgICBpZih0aGlzW3ZdID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgdGhpc1t2XSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7IFxuICAgICAgICAgICAgfVxuXHRcdFx0dGhpc1t2XS5mcm9tQXJyYXkoc3RhdGUud29ybGRbdl0pO1xuXHRcdH1cblx0XHRpZihzdGF0ZS5kZXZpY2VzKXtcbiAgICAgICAgICAgIFxuXHRcdFx0Xy5lYWNoKHN0YXRlLmRldmljZXMsIGZ1bmN0aW9uKGRldl9zdCwgaXgpe1xuICAgICAgICAgICAgICAgIGlmKHNlbGYuZGV2aWNlc1tpeF0gPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGV2aWNlc1tpeF0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cdFx0XHRcdF8uZWFjaChkZXZfc3QsIGZ1bmN0aW9uKHZhbCwgbmFtZSl7XG5cdFx0XHRcdFx0c2VsZi5kZXZpY2VzW2l4XVtuYW1lXT12YWw7XG5cdFx0XHRcdFxuXHRcdFx0XHR9KVxuXHRcdFx0fSlcblx0XHRcdFxuXHRcdH1cblx0fVxuXHQvKlxuXHRtLnByb3RvdHlwZS5yZXN0b3JlU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSApe1xuXHRcdGZvcih2IGluIHN0YXRlLndvcmxkKXtcblx0XHRcdHRoaXNbdl0uZnJvbUFycmF5KHN0YXRlLndvcmxkW3ZdKTtcblx0XHR9XG5cdFx0aWYoc3RhdGUud29ya3BvaW50cyl7XG5cdFx0XHRpZih0eXBlb2YgdGhpcy53b3JrcG9pbnRfc3RhdGVzID09PSAndW5kZWZpbmVkJyl7XG5cdFx0XHRcdHRoaXMud29ya3BvaW50X3N0YXRlcyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgd3AgaW4gc3RhdGUud29ya3BvaW50cyl7XG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy53b3JrcG9pbnRfc3RhdGVzW3dwXSA9PT0ndW5kZWZpbmVkJyl7XG5cdFx0XHRcdFx0dGhpcy53b3JrcG9pbnRfc3RhdGVzW3dwXSA9IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvcih2YXIgcCBpbiBzdGF0ZS53b3JrcG9pbnRzW3dwXSl7XG5cdFx0XHRcdFx0dGhpcy53b3JrcG9pbnRfc3RhdGVzW3dwXVtwXSA9IHN0YXRlLndvcmtwb2ludHNbd3BdW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHR9XG5cdCovXG5cdFxuXHRtLnByb3RvdHlwZS5zZXREZXZpY2VTZXR0aW5nID0gZnVuY3Rpb24oZGV2LCBuYW1lLCB2YWx1ZSl7XG5cdFx0dGhpcy5kZXZpY2VzW2Rldl1bbmFtZV0gPSB2YWx1ZTtcblx0fVxuXHRtLnByb3RvdHlwZS5nZXREZXZpY2VTZXR0aW5nID0gZnVuY3Rpb24oZGV2LCBuYW1lKXtcbiAgICAgICAgLy8gQ0wodGhpcy5kZXZpY2VzLCBkZXYsIG5hbWUpO1xuXHRcdHJldHVybiB0aGlzLmRldmljZXNbZGV2XVtuYW1lXSA7XG5cdH1cblx0bS5wcm90b3R5cGUuYWx0ZXJEZXZpY2VTZXR0aW5nID0gZnVuY3Rpb24oZGV2LCBuYW1lLCBjYWxsYmFjayl7XG5cdFx0aWYgKHRoaXMuZGV2aWNlc1tkZXZdKXtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZGV2aWNlc1tkZXZdW25hbWVdO1xuXHRcdFx0dmFyIG5ld192YWx1ZSA9IGNhbGxiYWNrKHZhbHVlKTtcblx0XHRcdGlmIChuZXdfdmFsdWUgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdC8vIEwuc2V0VmFsdWUoXCIgc2V0IFwiICsgcGFyYW0sIG5ld192YWx1ZSApO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy5kZXZpY2VzW2Rldl1bbmFtZV0gPSBuZXdfdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHR9XG5cdG0ucHJvdG90eXBlLnNhdmVXb3JrcG9pbnRWYWx1ZSA9IGZ1bmN0aW9uKHdwLCBwYXJhbSwgdmFsdWUpe1xuXHRcdGlmKHR5cGVvZiB0aGlzLndvcmtwb2ludF9zdGF0ZXNbd3BdID09PSAndW5kZWZpbmVkJyl7XG5cdFx0XHR0aGlzLndvcmtwb2ludF9zdGF0ZXNbd3BdID0ge307XG5cdFx0XHR0aGlzLndvcmtwb2ludF9zdGF0ZXNbd3BdW3BhcmFtXSA9IHZhbHVlXG5cdFx0fWVsc2V7XG5cdFx0XHR0aGlzLndvcmtwb2ludF9zdGF0ZXNbd3BdW3BhcmFtXSA9IHZhbHVlXG5cdFx0XHRcblx0XHR9XG5cdH1cblx0bS5wcm90b3R5cGUuZ2V0V29ya3BvaW50VmFsdWUgPSBmdW5jdGlvbih3cCwgcGFyYW0pe1xuXHRcdGlmICh0aGlzLndvcmtwb2ludF9zdGF0ZXNbd3BdKXtcblx0XHRcdHJldHVybiB0aGlzLndvcmtwb2ludF9zdGF0ZXNbd3BdW3BhcmFtXTtcblx0XHR9XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXHRtLnByb3RvdHlwZS5hbHRlcldvcmtwb2ludFZhbHVlID0gZnVuY3Rpb24od3AsIHBhcmFtLCBtb2RpZmllcil7XG5cdFx0aWYgKHRoaXMud29ya3BvaW50X3N0YXRlc1t3cF0pe1xuXHRcdFx0dmFsdWUgPSB0aGlzLndvcmtwb2ludF9zdGF0ZXNbd3BdW3BhcmFtXTtcblx0XHRcdG5ld192YWx1ZSA9IG1vZGlmaWVyKHZhbHVlKTtcblx0XHRcdGlmIChuZXdfdmFsdWUgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdC8vIEwuc2V0VmFsdWUoXCIgc2V0IFwiICsgcGFyYW0sIG5ld192YWx1ZSApO1xuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy53b3JrcG9pbnRfc3RhdGVzW3dwXVtwYXJhbV0gPSBuZXdfdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XG5cdH1cblx0bS5wcm90b3R5cGUucmVjYWxjdWxhdGVfdGlsbF9zZXJ2ZXJfcmVwb3J0ID0gZnVuY3Rpb24oc2VydmVyX3JlcG9ydCwgdGltZV9kaWZmKXtcblx0XHR2YXIgc3RhdGUgPSBzZXJ2ZXJfcmVwb3J0O1xuXHRcdHZhciBsYXN0X3RzID0gc3RhdGUuc2VydmVyX3RzO1xuXHRcdHRoaXMucmVzdG9yZVN0YXRlKHN0YXRlKTtcblx0XHRcblx0XHRjdXJyZW50X3RzID0gbGFzdF90cyAvLyAtIHRpbWVfZGlmZjtcblx0XHRpZiAobGFzdF90cyAhPT0gMCl7XG5cdFx0XHR0aGlzLmV2ZW50TWFuYWdlci5zZXRfbGFzdF9wcm9jZXNzZWQoY3VycmVudF90cyk7XG5cdFx0XHR0aGlzLmV2ZW50TWFuYWdlci5yZW1vdmUoY3VycmVudF90cyk7XG5cdFx0fVxuXHR9O1xuXHRcblx0bS5wcm90b3R5cGUudXBkYXRlX3N0YXRpY19waHlzaWNhbF9kYXRhID0gZnVuY3Rpb24odGlsbF90aW1lKXtcblx0XHR2YXIgdGltZV9sZWZ0ID0gKHRpbGxfdGltZSAtIHRoaXMubGFzdF9wcm9jZXNzZWRfdGltZXN0YW1wKSAvIDEwMDAgLy8gdG8gc2Vjb25kcztcblx0XHQvLyAvLyBDTCh0aW1lX2xlZnQpO1xuXHRcdHZhciB1bSA9IDEgLyB0aGlzLm1hc3M7XG5cdFx0dmFyIHVtdCA9IHRpbWVfbGVmdCAqIHVtXG5cblx0XHR2YXIgcm90cyA9IHRoaXMuYW5ndWxhcl9pbXB1bHNlLmNsb25lKCkubXVsdGlwbHlTY2FsYXIodW10KVxuXHRcdHZhciBwb3NlcyA9IHRoaXMuaW1wdWxzZS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHVtdClcblxuXHRcdC8vIG1lc2gudmVsID0gbWVzaC5pbXB1bHNlLmNsb25lKCkubXVsdGlwbHlTY2FsYXIodW0pO1xuXG5cdFx0Ly8gLy8gQ0woXCJzdGF0aWNzIFwiLHJvdHMudG9BcnJheSgpLCBwb3Nlcy50b0FycmF5KCkpO1xuXHRcdHRoaXMucm90YXRlWChyb3RzLngpXG5cdFx0dGhpcy5yb3RhdGVZKHJvdHMueSlcblx0XHR0aGlzLnJvdGF0ZVoocm90cy56KTtcblxuXHRcdHRoaXMucG9zaXRpb24uYWRkKHBvc2VzKTtcblx0XHRcblx0XHR2YXIgcG93ZXJfcGxhbnRfY3VycmVudF9wb3dlciA9IHRoaXMuZ2V0RGV2aWNlU2V0dGluZyh0aGlzLnR5cGUucG93ZXJfc291cmNlLCAncG93ZXInKTtcblx0XHR2YXIgcHNvdXJjZV9kZXYgPSB0aGlzLnR5cGUuZGV2aWNlc1t0aGlzLnR5cGUucG93ZXJfc291cmNlXVxuXHRcdHZhciBtYXhfcG93ZXIgPSBwc291cmNlX2Rldi5tYXhfcG93ZXI7XG5cdFx0dmFyIHBvd2VyX3Byb2R1Y2VkID0gKG1heF9wb3dlciAqIHBvd2VyX3BsYW50X2N1cnJlbnRfcG93ZXIpICAqIHRpbWVfbGVmdCA7XG5cdFx0dmFyIG1heF9jYXBhY2l0b3IgPSBwc291cmNlX2Rldi5jYXBhY2l0b3Jcblx0XHQvLyBMLnNldFZhbHVlKFwiUE9XRVIgUFJPRFVDRURcIiwgcG93ZXJfcHJvZHVjZWQpO1xuXHRcdC8vIEwuc2V0VmFsdWUoXCJUSU1FIFwiLCB0aW1lX2xlZnQpO1xuXHRcdFxuXHRcdHRoaXMuYWx0ZXJEZXZpY2VTZXR0aW5nKHRoaXMudHlwZS5wb3dlcl9zb3VyY2UsIFwiY2FwYWNpdG9yXCIsIGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdGlmICh2YWx1ZSA8IG1heF9jYXBhY2l0b3Ipe1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIHZhbHVlICsgcG93ZXJfcHJvZHVjZWQ7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pXG5cdFx0XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdF8uZWFjaCh0aGlzLnR5cGUuc2hpZWxkcywgZnVuY3Rpb24oc2hpZWxkcywgdHlwZSl7XG5cdFx0XHRfLmVhY2goc2hpZWxkcywgZnVuY3Rpb24oc2hpZWxkX2lkKXtcblx0XHRcdFx0Ly8g0KHQndCQ0KfQkNCb0JAg0JfQkNCg0K/QltCQ0JXQnCDQmNClINCa0JDQn9CQ0KHQmNCi0J7QoNCrXG5cdFx0XHRcdHZhciBzaGllbGRfZGV2ID0gc2VsZi50eXBlLmRldmljZXNbc2hpZWxkX2lkXVxuXHRcdFx0XHR2YXIgcGVyZm9ybWFuY2UgPSAxO1xuXHRcdFx0XHR2YXIgY2hhcmdlX3Bvd2VyID0gc2VsZi5nZXREZXZpY2VTZXR0aW5nKHNoaWVsZF9pZCwgJ3Bvd2VyJyk7XG5cdFx0XHRcdHZhciByZXNlcnZlX2NhcF9hbW91bnQgPSBzZWxmLmdldERldmljZVNldHRpbmcoc2hpZWxkX2lkLCAncmVzZXJ2ZV9jYXBhY2l0eScpO1xuXHRcdFx0XHR2YXIgbWF4X3JjYXBfYW1vdW50ID0gc2hpZWxkX2Rldi5jYXBhY2l0b3I7XG5cdFx0XHRcdHZhciBjaGFyZ2Vfbm9taW5hbCA9IHNoaWVsZF9kZXYuY2hhcmdlX3JhdGUgKiBjaGFyZ2VfcG93ZXIgKiB0aW1lX2xlZnQ7XG5cdFx0XHRcdHZhciBjYXAgPSBzZWxmLmdldERldmljZVNldHRpbmcoc2VsZi50eXBlLnBvd2VyX3NvdXJjZSwgXCJjYXBhY2l0b3JcIik7XG5cdFx0XHRcdGlmKCByZXNlcnZlX2NhcF9hbW91bnQgPCBtYXhfcmNhcF9hbW91bnQgICl7XG5cdFx0XHRcdFx0dmFyIGNvbnN1bWVkID0gY2hhcmdlX25vbWluYWw7XG5cdFx0XHRcdFx0aWYoY2FwID49IGNvbnN1bWVkKXtcblx0XHRcdFx0XHRcdHZhciBhZGRlZCA9IGNvbnN1bWVkICogcGVyZm9ybWFuY2U7XG5cdFx0XHRcdFx0XHRzZWxmLmFsdGVyRGV2aWNlU2V0dGluZyhzaGllbGRfaWQsIFwicmVzZXJ2ZV9jYXBhY2l0eVwiLCBmdW5jdGlvbih2YWwpe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsICsgYWRkZWQ7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRzZWxmLmFsdGVyRGV2aWNlU2V0dGluZyhzZWxmLnR5cGUucG93ZXJfc291cmNlLCBcImNhcGFjaXRvclwiLCBmdW5jdGlvbih2YWwpe1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsIC0gY29uc3VtZWQ7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyDQotCV0J/QldCg0Kwg0J/QoNCe0JLQldCg0K/QnCDQodCe0KHQotCe0K/QndCYINCg0JDQkdCe0KLQq1xuXHRcdFx0XHRpZih0eXBlID09PSAnYXJtb3InKXtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZihzZWxmLmdldERldmljZVNldHRpbmcoc2hpZWxkX2lkLCAnc3RhdGUnKSApe1xuXHRcdFx0XHRcdFx0dmFyIGN1cl9hbSA9IHNlbGYuZ2V0RGV2aWNlU2V0dGluZyhzaGllbGRfaWQsIFwiY2FwYWNpdHlcIik7XG5cdFx0XHRcdFx0XHR2YXIgbWF4X2FtID0gc2hpZWxkX2Rldi5jYXBhY2l0eTtcblx0XHRcdFx0XHRcdGlmKGN1cl9hbSA8IG1heF9hbSl7XG5cdFx0XHRcdFx0XHRcdHZhciByciA9IHNoaWVsZF9kZXYucmVwYWlyX3JhdGUgKiB0aW1lX2xlZnQ7XG5cdFx0XHRcdFx0XHRcdHZhciBwZXJmID0gc2hpZWxkX2Rldi5wZXJmb3JtYW5jZTtcblx0XHRcdFx0XHRcdFx0dmFyIHJjYXAgPSBzZWxmLmdldERldmljZVNldHRpbmcoc2hpZWxkX2lkLCAncmVzZXJ2ZV9jYXBhY2l0eScpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Y29uc3VtZWQgPSByciAvIHBlcmY7XG5cdFx0XHRcdFx0XHRcdGlmKGNvbnN1bWVkID4gcmNhcCl7IFxuXHRcdFx0XHRcdFx0XHRcdGNvbnN1bWVkID0gcmNhcCBcblx0XHRcdFx0XHRcdFx0XHRyciA9IGNvbnN1bWVkICogcGVyZiA7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdHNlbGYuYWx0ZXJEZXZpY2VTZXR0aW5nKHNoaWVsZF9pZCwgXCJjYXBhY2l0eVwiLCBmdW5jdGlvbih2YWwpe1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWwgKyBycjtcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0c2VsZi5hbHRlckRldmljZVNldHRpbmcoc2hpZWxkX2lkLCBcInJlc2VydmVfY2FwYWNpdHlcIiwgZnVuY3Rpb24odmFsKXtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsIC0gY29uc3VtZWQ7XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0eXBlID09PSdzaGllbGQnKXtcblx0XHRcdFx0XHR2YXIgc3RhdGUgPSBzZWxmLmdldERldmljZVNldHRpbmcoc2hpZWxkX2lkLCBcInN0YXRlXCIpO1xuXHRcdFx0XHRcdHZhciBpc19vbiA9IHN0YXRlO1xuXHRcdFx0XHRcdEwuc2V0VmFsdWUoXCJpc19vblwiLCBpc19vbik7XG5cdFx0XHRcdFx0TC5zZXRWYWx1ZShcInN0YXRlXCIsIHN0YXRlKTtcblx0XHRcdFx0XHRpZiggaXNfb24gKXtcblx0XHRcdFx0XHRcdHZhciByY2FwID0gc2VsZi5nZXREZXZpY2VTZXR0aW5nKHNoaWVsZF9pZCwgXCJyZXNlcnZlX2NhcGFjaXR5XCIpO1xuXHRcdFx0XHRcdFx0dmFyIG5lZWQgPSBzaGllbGRfZGV2LnNldHVwX2VuZXJneTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYobmVlZCA8PXJjYXApe1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0dmFyIGNhcCA9IHNoaWVsZF9kZXYuY2FwYWNpdHk7XG5cdFx0XHRcdFx0XHRcdHNlbGYuYWx0ZXJEZXZpY2VTZXR0aW5nKHNoaWVsZF9pZCwgXCJjYXBhY2l0eVwiLCBmdW5jdGlvbih2YWwpe1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBjYXA7XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdHNlbGYuYWx0ZXJEZXZpY2VTZXR0aW5nKHNoaWVsZF9pZCwgXCJyZXNlcnZlX2NhcGFjaXR5XCIsIGZ1bmN0aW9uKHZhbCl7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbCAtIG5lZWQ7XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHQvLyDQotC10L/QtdGA0Ywg0L3QsNC00L4g0LLRi9C60LvRjtGH0LjRgtGMLCDQv9GA0L7QstC10LTRjyDQv9C+INGB0LjRgdGC0LXQvNC1INGB0L7QvtCx0YnQtdC90LjQuVxuXHRcdFx0XHRcdFx0XHQvLyAvLyBDTChcIk1FU0ggQUNUT1JTXCIsIHNlbGYuYWN0b3JzKVxuXHRcdFx0XHRcdFx0XHRzZWxmLmF1dG9NZXNzYWdlKHNoaWVsZF9pZCwgXCJ0b2dnbGVcIiwgMCkgOy8vIFRoaXMgb25lIHNob3VsZCBnbyB0aHJvdWdoIG5ldHdvcmtpbmdcblx0XHRcdFx0XHRcdFx0Ly8gc2VsZi5fc2NlbmUuYWRkU2V0dGluZ1RvU2NlbmUoYWN0b3IsIHNldHQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH0pXG5cdFx0XG5cdFx0XG5cdFx0dmFyIGN1cnJfaHVsbCA9IHRoaXMuZ2V0RGV2aWNlU2V0dGluZyh0aGlzLnR5cGUuaHVsbF9kZXZpY2UsIFwiY2FwYWNpdHlcIik7XG5cdFx0aWYoY3Vycl9odWxsIDw9MCl7XG4gICAgICAgICAgICBcblx0XHRcdC8vIC8vIENMKFwiREVTVFJPWUVEXCIpO1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlT2JqZWN0KHNlbGYpO1xuICAgICAgICAgICAgXG5cdFx0fVxuXHRcdHRoaXMubGFzdF9wcm9jZXNzZWRfdGltZXN0YW1wID0gdGlsbF90aW1lXG5cdFx0XG5cdFx0XG5cdFx0XG5cdH1cblx0bS5wcm90b3R5cGUuY3JlYXRlRGV2aWNlQWN0aW9uID0gZnVuY3Rpb24oZGV2LG5hbWUsIHZhbCwgYWRkX3BhcmFtcyl7XG5cdFx0dmFyIGFjdGlvbiA9IHRoaXMudHlwZS5kZXZpY2VzW2Rldl0uYWN0aW9uc1tuYW1lXTtcblx0XHRjb25zb2xlLmxvZyhcIkdVSURcIiwgdGhpcy5HVUlELCB0aGlzLnR5cGUuR1VJRCApXG5cdFx0aWYoYWN0aW9uLmlzX3N3aXRjaCl7XG5cdFx0XHR2YXIgYWN0ID0ge1xuXHRcdFx0XHRtZXNoIDogdGhpcy5HVUlELFxuXHRcdFx0XHRkZXYgOiBkZXYsXG5cdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdHRzIDpuZXcgRGF0ZSgpLmdldFRpbWUoKSxcblx0XHRcdH07XG5cdFx0XHRcblx0XHR9ZWxzZXtcblx0XHRcdHZhciBhY3QgPSB7XG5cdFx0XHRcdG1lc2ggOiB0aGlzLkdVSUQsXG5cdFx0XHRcdGRldiA6IGRldixcblx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0dHMgOm5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuXHRcdFx0XHRkZWx0YTogMCxcblx0XHRcdFx0dmFsdWU6IHZhbFxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdH1cblx0XHRpZihhZGRfcGFyYW1zKXtcblx0XHRcdGZvcihpIGluIGFkZF9wYXJhbXMpe1xuXHRcdFx0XHRhY3RbaV0gPSBhZGRfcGFyYW1zW2ldO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fVxuXHRcdFxuXHRcdGlmICh0aGlzLl9zY2VuZS5XKXtcblx0XHRcdGFjdC5pZGVudCA9IGFjdC50cyArIHRoaXMuX3NjZW5lLlcuX3RpbWVfZGlmZjtcblx0XHR9ZWxzZXtcblx0XHRcdGFjdC5pZGVudCA9IGFjdC50cztcblx0XHR9XG5cdFx0cmV0dXJuIGFjdFxuXHR9XG5cdG0ucHJvdG90eXBlLnN0YXJ0RGV2aWNlQWN0aW9uID0gZnVuY3Rpb24oZGV2LCBuYW1lLCB2YWwsIGFkZF9wYXJhbXMpe1xuXHRcdHZhciBhY3QgPSB0aGlzLmNyZWF0ZURldmljZUFjdGlvbihkZXYsIG5hbWUsIHZhbCwgYWRkX3BhcmFtcyk7XG5cdFx0Ly8gLy8gQ0woXCJ0aGlzIGlzIGEgY3JlYXRlZGUgYWN0aW9uXCIsIGFjdClcblx0XHR0aGlzLmV2ZW50TWFuYWdlci5hZGQoYWN0LCBhY3QudHMpXG5cdFx0dGhpcy5fc2NlbmUuX2FkZFRvU2VydmVyUXVldWUoYWN0KVxuXHRcdFxuXHR9O1xuXHRtLnByb3RvdHlwZS5zdGFydFZpcnR1YWxEZXZpY2VBY3Rpb24gPSBmdW5jdGlvbihwcm9jLCB0cywgaWRlbnQpe1xuXHRcdHRoaXMuX2ZvcmVpZ25fcHJvY3NbdHNdID0gcHJvYztcblx0XHR2YXIgYWN0ID0ge1xuXHRcdFx0ZGV2IDogdGhpcy50eXBlLmZvcmVpZ25fcHJvY2Vzc29yLFxuXHRcdFx0bmFtZTogJ3Byb2Nlc3MnLFxuXHRcdFx0dHMgOnRzLFxuXHRcdFx0aWRlbnQ6aWRlbnQsXG5cdFx0fTtcblx0XHR0aGlzLmV2ZW50TWFuYWdlci5hZGQoYWN0KTtcblx0XHRcblx0fVxuXHRtLnByb3RvdHlwZS5hdXRvTWVzc2FnZSA9IGZ1bmN0aW9uKGRldiwgbmFtZSwgdmFsKXtcblx0XHR2YXIgYWN0ID0gdGhpcy5jcmVhdGVEZXZpY2VBY3Rpb24oZGV2LCBuYW1lLCB2YWwpXG5cdFx0dGhpcy5ldmVudE1hbmFnZXIuYWRkKGFjdCwgYWN0LnRzKTtcblx0XHQvLyB0aGlzLl9zY2VuZS5tYWtlU2NlbmVCcm9hZGNhc3QoYWN0KTtcblx0fVxuXHRcblx0bS5wcm90b3R5cGUuZG93blN0cmVhbU1lc3NhZ2UgPSBmdW5jdGlvbihkZXYsIG5hbWUsIHZhbCl7XG5cdFx0dmFyIGFjdCA9IHRoaXMuY3JlYXRlRGV2aWNlQWN0aW9uKGRldiwgbmFtZSwgdmFsKVxuXHRcdHRoaXMuZXZlbnRNYW5hZ2VyLmFkZChhY3QsIGFjdC50cyk7XG5cdFx0dGhpcy5fc2NlbmUubWFrZVNjZW5lQnJvYWRjYXN0KGFjdCk7XG5cdH1cblx0XG5cdG0ucHJvdG90eXBlLmVucXVldWVfYXV0b19zZXR0aW5nX2FjdGlvbiA9IGZ1bmN0aW9uKHdwLCBzZXR0aW5nLCB2YWx1ZSwgaXNfc3dpdGNoKXtcblx0XHRhY3QgPSB7XG5cdFx0XHR0eXBlOiAxMDAwLFxuXHRcdFx0bmFtZTpzZXR0aW5nLFxuXHRcdFx0dmFsdWU6dmFsdWUsXG5cdFx0XHR3cCA6IHdwLFxuXHRcdFx0YWN0b3I6IHRoaXMuYWN0b3JzW3dwXS5HVUlELFxuXHRcdFx0b2JqZWN0X2d1aWQ6IHRoaXMuR1VJRCxcblx0XHRcdHNjZW5lOiB0aGlzLl9zY2VuZS5HVUlELFxuXHRcdFx0dHM6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuXHRcdFx0Y29udHJvbGxlcjogXCJzZXR0aW5nc1wiXG5cdFx0fVxuXHRcdGlmIChpc19zd2l0Y2gpe1xuXHRcdFx0YWN0LnN3aXRjaCA9IHRydWU7XG5cdFx0XHRkZWxldGUgYWN0LnZhbHVlO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fc2NlbmUuVyl7XG5cdFx0XHRhY3QuaWRlbnQgPSBhY3QudHMgKyB0aGlzLl9zY2VuZS5XLl90aW1lX2RpZmY7XG5cdFx0fWVsc2V7XG5cdFx0XHRhY3QuaWRlbnQgPSBhY3QudHM7XG5cdFx0fVxuXHRcdFxuXHRcdC8vINCt0YLQsCDQsNC60YbQuNGPINC00L7Qu9C20L3QsCDQsdGL0YLRjCDRgdC+0LfQtNCw0L3QsCDQvdC10LfQsNCy0LjRgdC40LzQviDQuCDQvdCwINC60LvQuNC10L3RgtC1INC4INC90LAg0YHQtdGA0LLQtdGA0LUsINGA0LDQtyDRg9C2INC+0L3QsCDQtNC+0LvQtdGC0LXQu9CwINC00L4g0YHQtdGA0LLQtdGA0LBcblx0XHQvLyDQotC+0LPQtNCwIFxuXHRcdC8vIHRoaXMuX3NjZW5lLl9hZGRUb1NlcnZlclF1ZXVlLmNhbGwodGhpcy5fc2NlbmUsIGFjdCk7IFxuXHRcdHRoaXMuZXZlbnRNYW5hZ2VyLmFkZChhY3QsIGFjdC50cylcblx0fVxuXHRcblx0XG5cdG0ucHJvdG90eXBlLmxvYWRfanNvbiA9IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0XHR2YXIgb2JqZWN0ID0gc2VsZi5qc29uXG4gICAgICAgIHNlbGYuR1VJRCA9IHNlbGYuanNvbi5HVUlEO1xuXHRcblx0XHQvLyAvLyBDTChcIkxvYWRpbmdcIiwgKVxuXHRcblx0XHRzZWxmLmV2ZW50TWFuYWdlciA9IG5ldyBFUSggb2JqZWN0LkdVSUQgKTtcblx0XHRzZWxmLnBlbmRpbmdfYWN0aW9ucyA9IFtdO1xuXHRcdHNlbGYud29ya3BvaW50X3N0YXRlcyA9IHt9O1xuXHRcdHNlbGYuX3Byb2Nlc3NlZF9hY3Rpb25zID0gW107XG5cdFx0c2VsZi5fYWN0aW9uc19pbmRleCA9IHt9O1xuXHRcdHNlbGYuX3ByZXZpb3VzX3N0YXRlcyA9IFtdXG5cdFx0c2VsZi5fcHJldmlvdXNfc3RhdGVzX2luZGV4ID0ge31cblx0XHRzZWxmLnRvdGFsX2FuZ3VsYXJfaW1wdWxzZXMgPSBbXTtcblx0XHRcdFx0Ly8gLy8gQ0woaSwgbWVzaC50b3RhbF90b3JxdWVzLCBtZXNoLnRvdGFsX3Bvd2Vycylcblx0XHRzZWxmLnR5cGU9b2JqZWN0LnN1Yl90eXBlXG5cdFx0Ly92YXIgb2JqZWN0X3JvdGF0ZWQgPSBmYWxzZVxuXHRcdC8vIFNldHRpbmcgZGVmYXVsdHMgXG5cdFx0Ly9zZWxmLmF2ZWwgPSBuZXcgVEhSRUUuVmVjdG9yMygwLDAsMClcblx0XHQvL3NlbGYuYWFjYyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwwKVxuXHRcdC8vc2VsZi52ZWwgPSBuZXcgVEhSRUUuVmVjdG9yMygwLDAsMClcblx0XHQvL3NlbGYuYWNjID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwwLDApXG5cdFxuICAgICAgXG5cdCAgICAvKlxuXHRcdGlmICggb2JqZWN0LnBoeXNpY2FsICl7XG5cdFx0XHRmb3IoaSBpbiBvYmplY3QucGh5c2ljYWwpe1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIF9pcyA9ICd0bycgaW4gb2JqZWN0LnBoeXNpY2FsW2ldXG5cdFx0XHRcdGlmICghX2lzKXtcblx0XHRcdFx0XHRpZihpICE9J3JvdGF0aW9uJyl7XG5cdFx0XHRcdFx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKClcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0dmFyIHYgPSBuZXcgVEhSRUUuRXVsZXIoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2LnNldC5hcHBseSh2LCBvYmplY3QucGh5c2ljYWxbaV0pXG5cdFx0XHRcdFx0c2VsZltpXSA9IHZcblx0XHRcdFx0XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHZhciBwID0gbmV3IFRIUkVFLlZlY3RvcjMob2JqZWN0LnBoeXNpY2FsW2ldLnRvWzBdLCBvYmplY3QucGh5c2ljYWxbaV0udG9bMV0sIG9iamVjdC5waHlzaWNhbFtpXS50b1syXSlcblx0XHRcdFx0XHQvLyBUcnkgdG8gcm90YXRlIHAgb24gMTgwIFxuXHRcdFx0XHRcdC8vcC5yb3RhdGVYKDIqIE1hdGguUEkpO1xuXHRcdFx0XHRcdHNlbGYubG9va0F0KHAubmVnYXRlKCkpXG5cdFx0XHRcdFx0Ly8gbWVzaC5yb3RhdGVYKDIqTWF0aC5QSSlcblx0XHRcdFx0XHRzZWxmLnJvdCA9IG5ldyBUSFJFRS5WZWN0b3IzKHNlbGYucm90YXRpb24ueCwgc2VsZi5yb3RhdGlvbi55LCBzZWxmLnJvdGF0aW9uLnopO1xuXHRcdFx0XHRcdG9iamVjdF9yb3RhdGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1lbHNle1xuXHRcdFx0dmFyIHBpMiA9IE1hdGguUEkgKiAyO1xuXHRcdFx0c2VsZi5wb3MgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpICogMjAwLCBNYXRoLnJhbmRvbSgpICogMjAwLCBNYXRoLnJhbmRvbSgpICogMjAwKTtcblx0XHRcdHNlbGYucm90ID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSAqIHBpMiwgTWF0aC5yYW5kb20oKSAqIHBpMiwgTWF0aC5yYW5kb20oKSAqIHBpMik7XG5cdFx0XHRcblx0XHR9XG4gICAgICAgICovXG5cdFx0Lypcblx0XHRzZWxmLnBvc2l0aW9uID0gc2VsZi5wb3M7XG5cdFx0aWYgKCEgb2JqZWN0X3JvdGF0ZWQgJiYgICdyb3QnIGluIHNlbGYpe1xuXHRcdFx0XG5cdFx0XHR2YXIgdWVsID0gbmV3IHNlbGYuVEhSRUUuRXVsZXIoc2VsZi5yb3QueCwgc2VsZi5yb3QueSwgc2VsZi5yb3Queik7XG5cdFx0XHRzZWxmLnJvdGF0aW9uID0gdWVsO1xuXHRcdH1cbiAgICAgICAgKi9cblx0XHQvLyAvLyBDTChtZXNoLnBvc2l0aW9uKVxuICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIG9iamVjdFwiLCBzZWxmLnR5cGUpO1xuXHRcdHNlbGYuY2FtZXJhcyA9IHNlbGYudHlwZS5jYW1lcmFzO1xuXHRcdHNlbGYubWFzcyA9IHNlbGYudHlwZS5tYXNzO1xuXHRcdC8vIHNlbGYuYW5ndWxhcl9pbXB1bHNlID0gc2VsZi5hdmVsLmNsb25lKCkubXVsdGlwbHlTY2FsYXIob2JqZWN0Lm1hc3MpXG5cdFx0Ly8gc2VsZi5pbXB1bHNlID0gc2VsZi52ZWwuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihvYmplY3QubWFzcylcblx0XHRcblxuXHRcdFxuXHRcdHNlbGYubGFzdF9wcm9jZXNzZWRfdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XG5cdFx0Ly8g0J/Qvi3Qu9GO0LHQvtC80YMg0LfQtNC10YHRjCDQv9GA0LjQtNC10YLRgdGPINC60LXRiNC40YDQvtCy0LDRgtGMINCw0LrRgtC+0YDQvtCyINCyINGN0YLQvtC8INC80LXRiNC1XG5cdFx0Ly8g0JHQm9Cv0JTQrCFcblx0XHRzZWxmLmFjdG9ycyA9IHt9XG5cdFx0Xy5lYWNoKHNlbGYuX3NjZW5lLmFjdG9ycywgZnVuY3Rpb24oYWN0b3IsIGFpZCl7XG5cdFx0XHRpZihhY3Rvci5jb250cm9sLm9iamVjdF9ndWlkID09IHNlbGYuanNvbi5HVUlEKXtcblx0XHRcdFx0c2VsZi5hY3RvcnNbYWN0b3IuY29udHJvbC53b3JrcG9pbnRdID0gYWN0b3I7XG5cdFx0XHR9XG5cdFx0fSlcblx0XHRcblx0XHQvLyDQodC+0LfQtNCw0LTQuNC8INC60LDRgNGC0Ysg0YHQtdGC0YLQuNC90LPQvtCyINC00LvRjyDRg9GB0YLRgNC+0LnRgdGC0LJcblx0XHQvLyDRgtCw0LrQttC1INGB0L7Qt9C00LDQtdC8INC60LDRgNGC0YMg0LrQvtC90YLRgNC+0LvQu9C10YDQvtCyINC00LXQstCw0LnRgdC+0LJcblx0XHRcblx0XHRzZWxmLmRldmljZXMgPSBbXTtcblx0XHRzZWxmLmNvbnRyb2xsZXJzPVtdO1xuXHRcdHNlbGYuYXJtb3JzID0gW107XG5cdFx0c2VsZi5zaGllbGRzID0gW107XG5cdFx0c2VsZi51aXMgPSBbXTtcbiAgICAgICAgLy8gQ0woXCJsb2FkaW5nIGRldmljZXNcIiwgc2VsZi50eXBlLmRldmljZXMpO1xuXHRcdF8uZWFjaChzZWxmLnR5cGUuZGV2aWNlcywgZnVuY3Rpb24oZGV2LGl4KXtcblx0XHRcdHNlbGYuZGV2aWNlcy5wdXNoKHt9KTtcblx0XHRcdGlmIChkZXYudHlwZSA9PSAnc2hpZWxkJyl7XG5cdFx0XHRcdGlmKGRldi5zaGllbGRfdHlwZSA9PSAnc2hpZWxkJyl7IHNlbGYuc2hpZWxkcy5wdXNoKGl4KX1cblx0XHRcdFx0aWYoZGV2LnNoaWVsZF90eXBlID09ICdhcm1vcicpeyBzZWxmLmFybW9ycy5wdXNoKGl4KX1cblx0XHRcdFx0aWYoZGV2LnNoaWVsZF90eXBlID09ICd0aGVybWFsJyl7IC8qIG5vIHVzZSB5ZXQgKi99XG5cdFx0XHRcdFxuXHRcdFx0fVxuXHRcdFx0dmFyIEMgPSBDb250cm9sbGVyLmRldmljZUNvbnRyb2xsZXJzLmNvbnRyb2xsZXJzTWFwW2Rldi50eXBlXVxuXHRcdFx0aWYgKEMpe1xuXHRcdFx0XHR2YXIgY29udHIgPSBuZXcgQyhzZWxmLCBpeCk7XG5cdFx0XHRcdHNlbGYuY29udHJvbGxlcnMucHVzaChjb250cilcblx0XHRcdFx0aWYoc2VsZi5fc2NlbmUuVyl7XG5cdFx0XHRcdFx0c2VsZi51aXMucHVzaChjb250ci5nZXRVSShzZWxmLl9zY2VuZS5XKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcbiAgICAgICAgXG5cdFx0c2VsZi5yZWxvYWRfc2F2ZWRfc3RhdGUoKTtcblxuXHRcdFxuXHRcdFxuXHRcblx0fVxuXHRtLnByb3RvdHlwZS5nZXRVSUZvcldQPWZ1bmN0aW9uKHdwKXtcblx0XHR2YXIgc2VsZiA9dGhpcztcblx0XHR2YXIgdWlfbGlzdD1bXTtcbiAgICAgICAgdmFyIF93cCA9IHRoaXMudHlwZS53b3JrcG9pbnRzW3dwXTtcblx0XHRfLmVhY2goX3dwLmRldmljZXMsIGZ1bmN0aW9uKGRfaWQpe1xuXHRcdFx0dmFyICB1aSA9IHNlbGYudWlzW2RfaWRdXG5cdFx0XHRpZiAodWkpe1xuXHRcdFx0XHR1aV9saXN0LnB1c2godWkpXG5cdFx0XHR9XG5cdFx0fSlcbiAgICAgICAgcmV0dXJuIHVpX2xpc3Q7XG5cdFx0XG5cdH07XG5cdG0ucHJvdG90eXBlLmdldEFjdGlvbkxpc3QgPSBmdW5jdGlvbigpe1xuXHRcdC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdC80YvQuSDQvtCx0YrQtdC60YJcblx0XHQvLyBcblx0XHQvLyBcblx0XHQvLyAge3dwOiBbYWN0aW9uc10gfVxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgb2JqID0ge31cblx0XHRfLmVhY2godGhpcy50eXBlLndvcmtwb2ludHMsIGZ1bmN0aW9uKHdwLCB3cF9uYW1lKXtcblx0XHRcdGF2X2FjdF9saXN0ID0gW11cblx0XHRcdF8uZWFjaCh3cC5kZXZpY2VzLCBmdW5jdGlvbihkZXZfaXgpe1xuXHRcdFx0XHR2YXIgZGV2ICA9IHNlbGYudHlwZS5kZXZpY2VzW2Rldl9peF07XG5cdFx0XHRcdF8uZWFjaChkZXYuYWN0aW9ucywgZnVuY3Rpb24oYWN0LCBhY3RfbmFtZSl7XG5cdFx0XHRcdFx0dmFyIGEgPSB7bWVzaDpzZWxmLkdVSUQsIGRldmljZTogZGV2X2l4LCBuYW1lOmFjdF9uYW1lfTtcblx0XHRcdFx0XHRpZiAoYWN0LmRlZmF1bHRfa2V5KXtcblx0XHRcdFx0XHRcdGEuZGVmYXVsdF9rZXkgPSBhY3QuZGVmYXVsdF9rZXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGF2X2FjdF9saXN0LnB1c2goYSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC8vIC8vIENMKFwiQUFcIix3cF9uYW1lLCBkZXYudHlwZSwgIGRldi5hY3Rpb25zKVxuXHRcdFx0fSlcblx0XHRcdG9ialsgd3BfbmFtZSBdID0gYXZfYWN0X2xpc3Q7XG5cdFx0XHRcblx0XHR9KVxuXHRcdHJldHVybiBvYmo7XG5cblx0fTtcbiAgICBtLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX3NjZW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG5cbiAgICB9XG5cdHJldHVybiAobmV3IG0obWF0LCBnZW9tKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvb2JqZWN0LmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGZzICAgID0gcmVxdWlyZSgnZnMnKTtcbnZhciB1ID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIFRIUiA9IHJlcXVpcmUoJ3RocmVlJyk7XG52YXIgQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vY29udHJvbGxlcicpO1xudmFyIEFPYmplY3QgPSByZXF1aXJlKCcuL29iamVjdCcpO1xudmFyIEVRID0gcmVxdWlyZShcIi4vZXZlbnRfcXVldWVcIik7XG5cbnZhciBfICAgICA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxudmFyIFNjZW5lT2JqZWN0ID0gZnVuY3Rpb24odGhyZWVTY2VuZSwgVyl7XG5cdHRoaXMuZGVzY3JpcHRpb249IFwiU2NlbmUgcm91dGluZXNcIjtcblx0dGhpcy5HVUlEID0gIHUubWFrZV9ndWlkKCk7XG5cdC8vIHRoaXMuYnJvYWRjYXN0ZXIgPSBicm9hZGNhc3RlcjtcblxuXG4gICAgdGhpcy51c2VfY2xpZW50X3JlbmRlcmluZyA9IGZhbHNlO1xuICAgIGlmKHRocmVlU2NlbmUgIT09IHVuZGVmaW5lZCAmJiBXICE9PSB1bmRlZmluZWQpe1xuICAgICAgICB0aGlzLmlucHV0U2VydmljZSA9IElucHV0U2VydmljZUdldHRlcigpO1xuICAgIFx0dGhpcy5XID0gVztcbiAgICBcdHRoaXMudGhyZWVfc2NlbmUgPSB0aHJlZVNjZW5lO1xuICAgICAgICB0aGlzLnVzZV9jbGllbnRfcmVuZGVyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgXG5cdHRoaXMuX2NyZWF0ZSgpO1xuXHRcbn07XG5TY2VuZSA9IHtjb25zdHJ1Y3RvcjogU2NlbmVPYmplY3R9XG5pZih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyl7XG5cdFNjZW5lLlRIUkVFID0gVEhSOyAvLyBTYXZlaW5nIFRIUkVFLmpzIGFzIHBhcnQgb2Ygc2NlbmUgLSB0aGlzIHN0ZXAgY291bGQgYmUgZG9uZSBvbiBhIGNlcnRhaW4gcGxhdGZvcm1cblx0U2NlbmUuZG9fcHJlcGFyZV9yZW5kZXJpbmcgPSBmYWxzZVxuXHRTY2VuZS5hamF4X2xvYWRfbW9kZWxzID0gZmFsc2Vcblx0U2NlbmUubmVlZF91cGRhdGVfbWF0cml4ID0gdHJ1ZVxuXHRTY2VuZS5sb2NhbEFjdGlvbnMgPSBmYWxzZVxuXHR2YXIgaXNfYnJvd3NlciA9IGZhbHNlO1xuXHRcblx0XG59ZWxzZXtcblx0dmFyIGlzX2Jyb3dzZXIgPSB0cnVlO1xuXHRTY2VuZS5USFJFRSA9IFRIUkVFO1xuXHRTY2VuZS5kb19wcmVwYXJlX3JlbmRlcmluZyA9IHRydWU7XG5cdFNjZW5lLmFqYXhfbG9hZF9tb2RlbHMgPSB0cnVlO1xuXHRTY2VuZS5uZWVkX3VwZGF0ZV9tYXRyaXggPSBmYWxzZTtcblx0U2NlbmUubG9jYWxBY3Rpb25zID0gdHJ1ZTtcblx0U2NlbmUuSU5QVVRfVElNRVNURVAgPSAwLjA3MDA7IC8vIHNlY29uZHNcblx0U2NlbmUudGltZV9zaW5jZV9sYXN0X2FjdGlvbnNfYWNxdWlyZWQgPSAwO1xuXHRcblx0Ly8gU2NlbmUuc2F2ZV9tZXNoZXNfcGFzdCA9IHRydWVcblx0XG5cdFxufVxuXG5TY2VuZS5nZXRfYWN0b3IgPSBmdW5jdGlvbihhY3Rvcl9ndWlkKXtcblx0cmV0dXJuIHRoaXMuZ2V0X2FjdG9ycygpW2FjdG9yX2d1aWRdO1xufVxuXG5cblNjZW5lLm1lc2hfZm9yID0gZnVuY3Rpb24oYWN0b3JfZ3VpZCl7XG5cdHZhciBhY3RvciA9IHRoaXMuYWN0b3JzW2FjdG9yX2d1aWRdO1xuXHRyZXR1cm4gdGhpcy5tZXNoZXNbYWN0b3IuY29udHJvbC5vYmplY3RfZ3VpZF1cbn1cblxuU2NlbmUuY3JlYXRlID0gZnVuY3Rpb24oKXtcblx0dGhpcy5fY3JlYXRlKCk7XG5cdFxuXHRyZXR1cm4gdGhpcztcbn1cblxuU2NlbmUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuY2xvY2sgPSBuZXcgKHRoaXMuVEhSRUUuQ2xvY2spKCk7XG5cdHRoaXMudGltZV9pbmMgID0gMDtcblx0dGhpcy50aWNrX2NvdW50ZXIgPSAwO1xuXHR0aGlzLl9zY2VuZV9vYmplY3RfY2FjaGUgPSB7fTtcblx0dGhpcy5fc2NlbmVfb2JqX2FjdG9ycz17fTtcblx0dGhpcy5fbmV0d29ya19tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMuX2xhc3RfdXNlcl9hY3Rpdml0eSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR0aGlzLl9sYXN0X3NlcnZlcl9yZXBvcnQgPSB7fTtcblx0dGhpcy5sb2FkZWRfb2JqZWN0c19jb3VudCA9IDA7XG5cdHRoaXMuX21vZGVsX2NhY2hlID0ge307XG4gICAgXG4gICAgXG5cdHRoaXMuX3NlcnZlcl9zeW5jX3F1ZXVlID0gW107XG5cdHRoaXMuX3NlcnZlcl9sYXN0X3NlbmRlZCA9IDA7XG5cdHRoaXMubWVzaGVzID0ge307XG4gICAgdGhpcy5hY3RvcnMgPSB7fTtcblx0dGhpcy5sb2FkZXIgPSAgbmV3IHRoaXMuVEhSRUUuSlNPTkxvYWRlcigpO1xuXHR0aGlzLnRvdGFsX29iamVjdHNfY291bnQgPSAwO1xuXHRcblx0dGhpcy5tZXNoX2xhc3Rfc3RhdGVzID0ge31cblx0dGhpcy5tZXNoX2FjdGlvbnMgPSB7fTtcblx0dGhpcy5fdGFyZ2V0X2FxID0gMC4wMTsgLy8gc2Vjb25kcyB0byBnZXQgdG8gc3luYyB0YXJnZXRcblx0dGhpcy5pc19sb2FkZWQgPSBmYWxzZVxuXHR0aGlzLl9kID0gZmFsc2VcbiAgICBcblx0XG59XG4vKlxuU2NlbmUudXBkYXRlX2Zyb21fd29ybGQgPSBmdW5jdGlvbigpe1xuXHQvLyBnbG9iYWx4LXkteiAtIGdhbGF4eSBjb29yZHMgd2l0aCAxIG1ldGVyIGFjY3VyYWN5XG5cdHZhciBjbG9zZXN0X3NjZW5lX3dpdGhfZGlzdGFuY2UgPSB0aGlzLmdldF9jbG9zZXN0X3NjZW5lKHRoaXMuZ3gsIHRoaXMuZ3ksIHRoaXMuZ3opO1xuXHQvLyBpZiBjbG9zZXN0X3NjZW5lIGlzIG5vdCBudWxsIC0gd2UgbXVzdCBpbmplY3Qgb2JqZWN0IHdpdGggYWN0b3JzIHRvIHRoYXQgc2NlbmUgLSBpdCdzIGFscmVhZHlfbG9hZGVkXG5cdC8vIGVsc2UgLSBXZSBmaW5kaW5nIG9iamVjdHMgZm9yIHRoYXQgc2NlbmVcblx0XHRcdFx0XG5cdHZhciBvYmplY3RzX3dpdGhpbl9jb29yZHMgPSB0aGlzLmdldF9vYmplY3RzX2luKHRoaXMuZ3gsIHRoaXMuZ3ksIHRoaXMuZ3opOyAvLyDQl9Cw0LPRgNGD0LfQutCwINC+0LHRitC10LrRgtC+0LIg0LIg0YHRhtC10L3RgyDQuNC3INCz0LvQvtCx0LDQu9GM0L3QvtCz0L4g0LzQuNGA0LBcblx0XG5cdHZhciBvYmplY3RzID0ge31cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0c193aXRoaW5fY29vcmRzLmxlbmd0aCA7IGkrKyApe1xuXHRcdG9iamVjdHNbIG9iamVjdHNfd2l0aGluX2Nvb3Jkc1tpXS5HVUlEIF0gPSAgIG9iamVjdHNfd2l0aGluX2Nvb3Jkc1tpXTtcblx0fVxuXHRfLmV4dGVuZCh0aGlzLl9zY2VuZS5vYmplY3RzLCBvYmplY3RzKVxuXHRcblx0dGhpcy5fc2NlbmUuc3VuRGlyZWN0aW9uID0gWzAsMSwwXVxuXHR0aGlzLl9zY2VuZS5zdW5MaWdodENvbG9yID0gW01hdGgucmFuZG9tKCksIDAuOCwgMC45XSAvLyBIU0xcblx0dGhpcy5fc2NlbmUuY29vcmRzID1bIHRoaXMuZ3gsIHRoaXMuZ3ksIHRoaXMuZ3ogXVxuXHRcbiAgICBcblx0XG5cdHJldHVybiB0aGlzXG5cdFxufVxuKi9cblxuU2NlbmUuZ2V0X2FjdG9ycyA9IGZ1bmN0aW9uKCl7XG5cdHJldHVybiB0aGlzLmFjdG9yc1xufVxuXG5TY2VuZS5nZXRfb2JqZWN0ID0gZnVuY3Rpb24oZ3VpZCl7XG5cdHJldHVybiB0aGlzLm1lc2hlc1tndWlkXS50eXBlO1xufVxuXG5TY2VuZS5nZXRfanNvbiA9IGZ1bmN0aW9uKCl7XG5cdHJldHVybiB0aGlzLl9zY2VuZVxufVxuU2NlbmUuZ2V0X2Nsb3Nlc3Rfc2NlbmUgPSBmdW5jdGlvbigpe1xuXHRyZXR1cm4gdW5kZWZpbmVkXG59XG5TY2VuZS5nZXRfb2JqZWN0c19pbiA9IGZ1bmN0aW9uKCl7XG5cdHJldHVybiBbXTtcbn1cblNjZW5lLmpvaW5fb2JqZWN0ID0gZnVuY3Rpb24oIG9iamVjdCApe1xuICAgIFxuXHR0aGlzLmxvYWRfb2JqZWN0KG9iamVjdCwgb2JqZWN0LkdVSUQpO1xuXHRcblxufVxuU2NlbmUuam9pbl9hY3RvciA9IGZ1bmN0aW9uKCBhY3RvciApe1xuXG5cblxuXHR0aGlzLmFjdG9yc1thY3Rvci5HVUlEXSA9IGFjdG9yO1xuXHRpZih0aGlzLmFjdG9yX3dwX2l4ID09PSB1bmRlZmluZWQpe1xuXHRcdHRoaXMuYWN0b3Jfd3BfaXggPSB7fVxuXHRcdFxuXHR9ZWxzZXtcblx0XHRpZiAodGhpcy5hY3Rvcl93cF9peFthY3Rvci5jb250cm9sLm9iamVjdF9ndWlkXSA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdHRoaXMuYWN0b3Jfd3BfaXhbYWN0b3IuY29udHJvbC5vYmplY3RfZ3VpZF0gPSB7fVxuXHRcdH1lbHNle1xuXHRcdFx0dGhpcy5hY3Rvcl93cF9peFthY3Rvci5jb250cm9sLm9iamVjdF9ndWlkXVthY3Rvci53cF0gPSBhY3Rvcjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXNcblx0XG4gICAgXG59XG5cblxuU2NlbmUuYWRkQWN0aW9ucyA9IGZ1bmN0aW9uKG1lc2hfZ3VpZCwgYWN0aW9ucyl7XG5cdHRoaXMubWVzaF9hY3Rpb25zW21lc2hfZ3VpZF0gPSBhY3Rpb25zXG59XG5TY2VuZS5nZXRBY3Rpb25zID0gZnVuY3Rpb24oKXtcblx0cmV0dXJuIHRoaXMubWVzaF9hY3Rpb25zO1xufVxuXG5TY2VuZS5sb2FkX29iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgaXgpe1xuICAgIFxuICAgIHZhciBzZWxmID0gdGhpcztcblx0c2VsZi50b3RhbF9vYmplY3RzX2NvdW50ICs9MTtcbiAgICBcblx0XG5cdGlmICghIHNlbGYuYWpheF9sb2FkX21vZGVscyl7XG5cdFx0dmFyIG0gPSBvYmplY3Quc3ViX3R5cGUubW9kZWxfM2Quc3BsaXQoJy8nKVsyXTtcblx0XHR2YXIgbW9kZWxfcGF0aD0gXCIuL3B1YmxpYy9tb2RlbHMvXCIgKyBtXG5cdH1cblxuXHRcblx0dmFyIHJmID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgd2l0aF9nZW9tX2FuZF9tYXQgPSBmdW5jdGlvbihnZW9tLCBtYXQpe1xuXHRcdFx0dmFyIG0gPSBuZXcgc2VsZi5USFJFRS5NYXRyaXg0KClcblx0XHRcdG0uaWRlbnRpdHkoKVxuXHRcdFxuXHRcdFx0XG5cdFx0XHR2YXIgbWVzaCA9IEFPYmplY3Qoc2VsZiwgZ2VvbSwgbWF0KSA7Ly9zZWxmLlRIUkVFLk1lc2goIGdlb20sIG1hdCApO1xuXHRcdFx0bWVzaC5qc29uID0gb2JqZWN0O1xuXHRcdFx0bWVzaC5sb2FkX2pzb24oKTtcblx0XHRcdHZhciBhY3Rpb25zID0gbWVzaC5nZXRBY3Rpb25MaXN0KCk7XG5cblxuXHRcdFx0c2VsZi5hZGRBY3Rpb25zKG9iamVjdC5HVUlELCBhY3Rpb25zKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNlbGYuZG9fcHJlcGFyZV9yZW5kZXJpbmcpe1xuXHRcdFx0XHRpZiAob2JqZWN0LnR5cGUgIT09J3N0YXRpYycpe1xuXG5cdFx0XHRcdFx0dmFyIGxhYmVsID0gU3ByaXRlVXRpbHMubWFrZVRleHRTcHJpdGUoXCJtZXNoOiBcIiArIGl4KTtcblx0XHRcdFx0XHRsYWJlbC5wb3NpdGlvbiA9IG5ldyBzZWxmLlRIUkVFLlZlY3RvcjMoMCwwLDApO1xuXHRcdFx0XHRcdG1lc2guYWRkKGxhYmVsKTtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYudGhyZWVfc2NlbmUuYWRkKCBtZXNoICk7XG5cdFx0XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHNlbGYubWVzaGVzWyBvYmplY3QuR1VJRCBdID0gbWVzaDtcblx0XHRcdHNlbGYubG9hZGVkX29iamVjdHNfY291bnQgKz0xO1xuXHRcdFx0c2VsZi5fbW9kZWxfbG9hZGVkKCBpeCApXG5cdFx0fVxuXHRcdFxuXHRcdFxuXHRcdGlmKHNlbGYuYWpheF9sb2FkX21vZGVscyl7XG5cdFx0XHRzZWxmLl9nZXRfbW9kZWwob2JqZWN0LnN1Yl90eXBlLm1vZGVsXzNkLHNlbGYuX2FqYXhfZ2V0dGVyLCB3aXRoX2dlb21fYW5kX21hdClcblx0XHR9ZWxzZXtcblx0XHRcdHNlbGYuX2dldF9tb2RlbChtb2RlbF9wYXRoLCBzZWxmLl9mc19nZXR0ZXIsIHdpdGhfZ2VvbV9hbmRfbWF0KVxuXG5cdFx0fVxuXHR9XG5cdHNldFRpbWVvdXQocmYsMSk7XG59XG5TY2VuZS5sb2FkID0gZnVuY3Rpb24ob25sb2FkLCB0aHJlZV9zY2VuZSwgVyl7XG5cdC8vIHRocmVlIHNjZW5lIC0gaXMgYSBwYXJhbSBmb3IgYWRkaW5nIG1lc2hlcyB0b1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0Ly8gREVCVUcgVEhJTkdTXG5cdC8vc2VsZi50b3RhbCA9IG5ldyBzZWxmLlRIUkVFLlZlY3RvcjMoKTtcblx0Ly9zZWxmLnRvdGFsX3Q9MDtcblx0Ly9zZWxmLmNvbnRyb2xsZXJfbWFwPSBDb250cm9sbGVyLkNvbnRyb2xsZXJzQWN0aW9uTWFwKClcblx0c2VsZi5fY2FsbF9iYWNrID0gb25sb2FkO1xuXHRcbiAgICB0aGlzLl9zZXJ2ZXJfc3luY19xdWV1ZSA9IFtdO1xuXHR0aGlzLl9zZXJ2ZXJfbGFzdF9zZW5kZWQgPSAwO1xuXHRzZWxmLm1lc2hlcyA9IHt9XG5cdHNlbGYubG9hZGVyID0gIG5ldyBzZWxmLlRIUkVFLkpTT05Mb2FkZXIoKTtcblx0c2VsZi50b3RhbF9vYmplY3RzX2NvdW50ID0gMDtcblx0XG5cdGlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKXtcblx0XHRzZWxmLnRocmVlX3NjZW5lID0gdGhyZWVfc2NlbmVcblx0XHRzZWxmLlcgPSBXO1xuXHR9XG5cdFxuXHRcblx0XG59LFxuU2NlbmUuX2FqYXhfZ2V0dGVyPWZ1bmN0aW9uKG5hbWUsIGNiKSB7XG5cblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRzZWxmLmxvYWRlci5sb2FkKCBuYW1lLCBmdW5jdGlvbihnZW9tLCBtYXQpe1xuXHRcdFxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKCBtYXQgKTtcblx0XHQvL3ZhciBhID0ge2dlb206Z2VvbSwgbWF0ZXJpYWw6bWF0ZXJpYWx9XG5cdFx0Y2IoZ2VvbSwgbWF0ZXJpYWwpO1xuXHRcdFxuXHR9KVxufVxuU2NlbmUuX2ZzX2dldHRlcj1mdW5jdGlvbihuYW1lLCBjYil7XG5cdHZhciBzZWxmID0gdGhpcztcblx0ZnMucmVhZEZpbGUobmFtZSwgZnVuY3Rpb24oZXJyLGRhdGEpe1xuXG5cdFx0aWYoZXJyKSB0aHJvdyBlcnI7XG5cdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgIHZhciByZXN1bHQgPSBzZWxmLmxvYWRlci5wYXJzZSgganNvbiwgJycgKTtcblxuXHRcdHZhciBsZCA9IChmdW5jdGlvbigpe1xuXHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IHNlbGYuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCggcmVzdWx0Lm1hdGVyaWFscyApO1xuXHRcdFx0Y2IocmVzdWx0Lmdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cdFx0XG5cdFx0fSlcblx0XHRzZXRUaW1lb3V0KGxkLDEpO1xuXHR9KTtcbn1cblxuU2NlbmUuX2dldF9tb2RlbCA9IGZ1bmN0aW9uKG5hbWUsIGdldHRlciwgd2l0aF9nZW9tX2FuZF9tYXQpe1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHZhciBtYXRfZ2VvbV9jYiA9IGZ1bmN0aW9uKGdlb20sIG1hdCl7XG5cdFx0c2VsZi5fbW9kZWxfY2FjaGVbbmFtZV0gPSB7Z2VvbTpnZW9tLCBtYXRlcmlhbDptYXR9XG5cdFx0d2l0aF9nZW9tX2FuZF9tYXQoZ2VvbSwgbWF0KVxuXHR9XG5cdGlmIChuYW1lIGluIHNlbGYuX21vZGVsX2NhY2hlKXtcblx0XHR2YXIgYT0gc2VsZi5fbW9kZWxfY2FjaGVbbmFtZV1cblx0XHR3aXRoX2dlb21fYW5kX21hdChhLmdlb20sIGEubWF0ZXJpYWwpXG5cdH1lbHNle1xuXHRcdGdldHRlci5hcHBseShzZWxmLFtuYW1lLCBtYXRfZ2VvbV9jYl0pXG5cdH1cblx0XHRcdFx0XG59XG5TY2VuZS5fZGVsZXRlX29iamVjdCA9IGZ1bmN0aW9uKGd1aWQpe1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdGlmKHNlbGYudGhyZWVfc2NlbmUpe1xuXHRcdHNlbGYudGhyZWVfc2NlbmUucmVtb3ZlKHNlbGYubWVzaGVzW2d1aWRdKSAvLyDRg9C00Y/Qu9GP0LXQvCDRj9C00YDQviDQuNC3INGB0YbQtdC90Ytcblx0fVxuXHRkZWxldGUgc2VsZi5tZXNoZXNbIGd1aWQgXTsgLy8gLi4uINC40Lcg0LzQtdGI0LXQuVxuXHRkZWxldGUgc2VsZi5fc2NlbmVfb2JqZWN0X2NhY2hlWyBndWlkIF1cblx0XG5cdFxufVxuU2NlbmUuX21vZGVsX2xvYWRlZCA9IGZ1bmN0aW9uKGl4KXtcblxuXHRpZiAodGhpcy5sb2FkZWRfb2JqZWN0c19jb3VudCA9PSB0aGlzLnRvdGFsX29iamVjdHNfY291bnQpe1xuXHRcdC8vIHNjZW5lIGxvYWRlZFxuXHRcdHRoaXMuaXNfbG9hZGVkID0gdHJ1ZTtcblx0XHRpZiAgKHRoaXMub25Mb2FkQ2FsbGJhY2spe1xuXHRcdFx0dGhpcy5vbkxvYWRDYWxsYmFjayh0aGlzKVxuXHRcdH1cblx0fWVsc2V7XG5cblxuXHR9XG59XG5TY2VuZS5zeW5jID0gZnVuY3Rpb24oc3luYyl7XG5cdHZhciBzZWxmID0gdGhpcztcblxuXHRzZWxmLl9sYXN0X3NlcnZlcl9yZXBvcnQgPSBzeW5jXG5cblxufVxuU2NlbmUuZ2V0ID0gZnVuY3Rpb24oKXtcblx0cmV0dXJuIHRoaXMuX3NjZW5lXG59XG5TY2VuZS5nZXRfYWxtYW5hY2ggPSBmdW5jdGlvbigpe1xuXG5cdHJldHVybiB0aGlzLm1lc2hfbGFzdF9zdGF0ZXNcblx0XG59XG5TY2VuZS5jcmVhdGVTZXR0aW5nQWN0aW9uID1mdW5jdGlvbihhY3Rvciwgc2V0dGluZ19uYW1lLCBzZXR0aW5nX3ZhbHVlLCBpc19zd2l0Y2gpe1xuXG5cdHZhciBhY3Rpb24gPSB7XG5cdFx0dHlwZTogMTAwMCxcblx0XHRuYW1lOnNldHRpbmdfbmFtZSxcblx0XHR2YWx1ZTpzZXR0aW5nX3ZhbHVlLFxuXHRcdGFjdG9yOmFjdG9yLkdVSUQsXG5cdFx0d3AgOiBhY3Rvci5jb250cm9sLndvcmtwb2ludCxcblx0XHRvYmplY3RfZ3VpZDogYWN0b3IuY29udHJvbC5vYmplY3RfZ3VpZCxcblx0XHRzY2VuZTogYWN0b3Iuc2NlbmUsXG5cdFx0dHM6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuXHRcdFxuXHRcdGNvbnRyb2xsZXI6IFwic2V0dGluZ3NcIlxuXHR9XG5cdGlmIChpc19zd2l0Y2gpe1xuXHRcdGFjdGlvbi5zd2l0Y2ggPSB0cnVlO1xuXHRcdGRlbGV0ZSBhY3Rpb24udmFsdWU7XG5cdH1cblx0YWN0aW9uLmlkZW50ID0gYWN0aW9uLnRzICsgdGhpcy5XLl90aW1lX2RpZmY7XG5cdHJldHVybiBhY3Rpb247XG5cdFxufVxuXG5TY2VuZS5tYWtlQWN0b3JTZXR0aW5nID0gZnVuY3Rpb24oYWN0b3IsIHNldHRpbmdfbmFtZSwgc2V0dGluZ192YWx1ZSwgaXNfc3dpdGNoKXtcblx0dGhpcy5fYWRkVG9TZXJ2ZXJRdWV1ZSh0aGlzLmNyZWF0ZVNldHRpbmdBY3Rpb24oYWN0b3Isc2V0dGluZ19uYW1lLHNldHRpbmdfdmFsdWUsaXNfc3dpdGNoKSk7XG59XG5TY2VuZS5hZGRTZXR0aW5nVG9TY2VuZSA9IGZ1bmN0aW9uKGFjdG9yLCBzZXR0aW5nX25hbWUsIHNldHRpbmdfdmFsdWUsIGlzX3N3aXRjaCl7XG5cdHZhciBhY3Rpb24gPSB0aGlzLmNyZWF0ZVNldHRpbmdBY3Rpb24oYWN0b3IsIHNldHRpbmdfbmFtZSwgc2V0dGluZ192YWx1ZSwgaXNfc3dpdGNoKTtcblx0dmFyIG1lc2ggPSB0aGlzLm1lc2hlc1thY3Rvci5jb250cm9sLm9iamVjdF9ndWlkXTtcblx0bWVzaC5ldmVudE1hbmFnZXIuYWRkKGFjdGlvbilcbn1cblNjZW5lLnNlbmRBY3Rpb249IGZ1bmN0aW9uKGFjdG9yLCBuYW1lLCB2YWwsIGlzX3N3aXRjaCl7XG5cdHZhciBhY3Rpb24gPSB0aGlzLmNyZWF0ZVNldHRpbmdBY3Rpb24oYWN0b3IsIG5hbWUsIHZhbCwgaXNfc3dpdGNoKTtcblx0dmFyIG1lc2ggPSB0aGlzLm1lc2hlc1thY3Rvci5jb250cm9sLm9iamVjdF9ndWlkXTtcblx0dGhpcy5fYWRkVG9TZXJ2ZXJRdWV1ZShhY3Rpb24pO1xuXHRtZXNoLmV2ZW50TWFuYWdlci5hZGQoYWN0aW9uKTtcblx0XG5cdFxufVxuXG5TY2VuZS51bmxvYWQgPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgY29uc29sZS5sb2coXCJXZSBtdXN0IG5vdyBzYXZlIGFsbCBvYmplY3Qgc3RhdGVzIGFuZCByZXBvcnQgd2l0aCBjYWxsYmFja1wiKTtcbiAgICBjYWxsYmFjaygpO1xufVxuXG5TY2VuZS50aWNrID0gZnVuY3Rpb24oKXtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRpZihzZWxmLnRpY2tfbnVtKXtcblx0XHRzZWxmLnRpY2tfbnVtKz0xO1xuXHR9ZWxzZXtcblx0XHRzZWxmLnRpY2tfbnVtID0gMDtcblx0fVxuXHR2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgXG5cblx0dmFyIHRpbWVfbGVmdCA9IHNlbGYuY2xvY2suZ2V0RGVsdGEoKTtcblx0c2VsZi50aW1lX2luYyArPSB0aW1lX2xlZnQ7XG5cdFxuXHRcblx0aWYoc2VsZi5sYXN0X3RzID09PSB1bmRlZmluZWQpe1xuXHRcdHNlbGYubGFzdF90cyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9XG5cdGlmKHNlbGYubG9jYWxBY3Rpb25zKXsgLy8g0JXRgdC70Lgg0Y3RgtC+INC60LvQuNC10L3RgiDQuCDQvNGLINC80L7QttC10Lwg0YPQv9GA0LDQstC70Y/RgtGMINGB0LrQu9Cw0LLQuNCw0YLRg9GA0Ytcblx0XHRcblx0XHRpZihzZWxmLnRpbWVfc2luY2VfbGFzdF9hY3Rpb25zX2FjcXVpcmVkID4gc2VsZi5JTlBVVF9USU1FU1RFUCl7XG5cdFx0XHRzZWxmLnRpbWVfc2luY2VfbGFzdF9hY3Rpb25zX2FjcXVpcmVkID0gMFxuXHRcdFx0dmFyIG5ld19hY3Rpb25zID0gc2VsZi5nZXRMb2NhbEFjdGlvbnMobm93KTtcblx0XHRcdFxuXHRcdFx0aWYobmV3X2FjdGlvbnMubGVuZ3RoID4gMCl7XG5cdFx0XHRcdFxuXHRcdFx0XHRfLmVhY2gobmV3X2FjdGlvbnMsIGZ1bmN0aW9uKGEpe1xuXG5cdFx0XHRcdFx0c2VsZi5fYWRkVG9TZXJ2ZXJRdWV1ZShhKTtcblxuXHRcdFx0XHRcdHNlbGYubWVzaGVzW2EubWVzaF0uZXZlbnRNYW5hZ2VyLmFkZChhLCBhLmlkZW50ICApO1xuICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICBcblx0XHRcdFx0XHRcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdFxuXHRcdH1lbHNle1xuXHRcdFx0c2VsZi50aW1lX3NpbmNlX2xhc3RfYWN0aW9uc19hY3F1aXJlZCArPSB0aW1lX2xlZnQ7XG5cdFx0XHRcblx0XHR9XG5cdH1cblx0dmFyIG5tID0gc2VsZi5nZXROZXR3b3JrQWN0aW9ucygpO1xuXHRfLmVhY2gobm0sZnVuY3Rpb24oYWN0aW9uKXtcbiAgICAgICAgLy8g0JXRgdC70Lgg0YMg0L3QsNGBINC10YHRgtGMINC+0LHRitC10LrRgiBXIC0g0YLQviDQvNGLINC00L7Qu9C20L3RiyDQuNGB0L/QvtC70L3Rj9GC0Ywg0LDQutGG0LjQuCDQv9C+INCy0YDQtdC80LXQvdC4INC90LUg0YPRh9C40YLRi9Cy0LDRjyDQstGA0LXQvNGPINC30LDQtNC10YDQttC60Lhcblx0XHR2YXIgbWVzaCA9IHNlbGYubWVzaGVzW2FjdGlvbi5tZXNoXTtcbiAgICAgICAgXG4gICAgICAgIC8vaWYoc2VsZi5XICE9PSB1bmRlZmluZWQpe1xuICAgIFx0XHQvL21lc2guZXZlbnRNYW5hZ2VyLmFkZChhY3Rpb24sIGFjdGlvbi5pZGVudCAtIFcuX3RpbWVfZGlmZik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vfWVsc2V7IC8vINCV0YHQu9C4INC90LXRgtGDIC0g0LfQvdCw0YfQuNGCINC90LAg0YHQtdGA0LLQtdGA0LUgLSDQuCDQt9C90LDRh9C40YIg0YHRgtGA0L7Qs9C+XG4gICAgXHRtZXNoLmV2ZW50TWFuYWdlci5hZGQoYWN0aW9uLCBhY3Rpb24uaWRlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL31cblx0fSlcblxuXHRcblx0Ly8gbGFzdEFjdGlvbnMgPSBnZXRMYXN0QWN0aW9uc1xuXHRfLmVhY2goc2VsZi5tZXNoZXMsIGZ1bmN0aW9uKG1lc2gsIGkpe1xuXHRcdFxuXHRcdGlmIChtZXNoLnR5cGUgPT0gJ3N0YXRpYycpIHJldHVybjtcblx0XHRpZihzZWxmLmxvY2FsQWN0aW9ucyAmJiAoaSBpbiBzZWxmLl9sYXN0X3NlcnZlcl9yZXBvcnQpICl7XG5cblx0XHRcdFxuXHRcdFx0bWVzaC5yZWNhbGN1bGF0ZV90aWxsX3NlcnZlcl9yZXBvcnQoc2VsZi5fbGFzdF9zZXJ2ZXJfcmVwb3J0W2ldICwgc2VsZi5XLl90aW1lX2RpZmYpO1xuXG5cdFx0XHRcblx0XHRcdGRlbGV0ZSBzZWxmLl9sYXN0X3NlcnZlcl9yZXBvcnRbaV07IFxuXHRcdFx0XG5cdFx0XHRcblx0XHR9XG5cblx0XHRpZihzZWxmLlcpe1xuXHRcdFx0dmFyIHFfbm93ID0gIG5vdyArIHNlbGYuVy5fdGltZV9kaWZmO1xuXHRcdH1lbHNle1xuXHRcdFx0dmFyIHFfbm93ID0gbm93O1xuXHRcdH1cblxuXHRcdG1lc2guZXZlbnRNYW5hZ2VyLnByb2Nlc3MocV9ub3csIGZ1bmN0aW9uKGV2ZW50KXtcblxuXHRcdFx0bWVzaC5jb250cm9sbGVyc1tldmVudC5kZXZdLnByb2Nlc3MoZXZlbnQpO1xuICAgICAgICAgICAgaWYoc2VsZi5XKXtcbiAgICAgICAgICAgICAgICBpZihtZXNoLnVpc1tldmVudC5kZXZdICYmIG1lc2gudWlzW2V2ZW50LmRldl0ub25BY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICBtZXNoLnVpc1tldmVudC5kZXZdLm9uQWN0aW9uKHNlbGYuVywgc2VsZi5HVUlELCBldmVudCApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblx0XHRcdFxuXHRcdH0pXG5cblx0XHRpZighIGlzX2Jyb3dzZXIpe1xuXG5cdFx0fVxuXHRcdFxuXG5cdFx0XG5cdFx0aWYoISAoc2VsZi5sb2NhbEFjdGlvbnMgKSl7XG5cdFx0XHRcblx0XHRcdHNlbGYubWVzaF9sYXN0X3N0YXRlc1tpXSA9IG1lc2guZ2V0U3RhdGUoKTtcblx0XHRcdFxuXHRcdH1cblx0XHRzZWxmLnByb2Nlc3NfcGh5c2ljYWwobWVzaCwgbm93KTtcblx0XHRcblx0XHRcblx0XHRcblx0XHRcblx0fSlcblx0c2VsZi5sYXN0X3RzID0gbm93XG4gICAgXG4gICAgXG5cdFxufVxuU2NlbmUuZ2V0TmV0d29ya0FjdGlvbnMgPSBmdW5jdGlvbigpe1xuXHR2YXIgcmV0ID0gXy5jbG9uZSh0aGlzLl9uZXR3b3JrX21lc3NhZ2VzKVxuXHR0aGlzLl9uZXR3b3JrX21lc3NhZ2VzID0gW107XG5cdHJldHVybiByZXQ7XG59XG5TY2VuZS5nZXRMb2NhbEFjdGlvbnMgPSBmdW5jdGlvbihub3cpe1xuICAgIHJldHVybiB0aGlzLmlucHV0U2VydmljZS5nZXRMYXRlc3RBY3Rpb25zKHRoaXMuR1VJRCwgbm93KTtcbn1cblNjZW5lLm1ha2VTY2VuZUJyb2FkY2FzdCA9IGZ1bmN0aW9uKGFjdGlvbil7XG5cdGlmKHRoaXMuYnJvYWRjYXN0ZXIpe1xuXHRcdHRoaXMuYnJvYWRjYXN0ZXIoXCJtZXNoLWFjdGlvblwiLCB0aGlzLmFjdG9ycywgYWN0aW9uKTtcblx0XHRcblx0fVxufVxuU2NlbmUucmVtb3ZlT2JqZWN0ID0gZnVuY3Rpb24gKG1lc2gpIHtcblxuICAgIGlmICh0aGlzLmRvX3ByZXBhcmVfcmVuZGVyaW5nKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlQmxhc3QoIG1lc2ggKTtcbiAgICAgICAgdGhpcy50aHJlZV9zY2VuZS5yZW1vdmUobWVzaCk7XG4gICAgICAgIFxuICAgIH1cbiAgICBkZWxldGUgdGhpcy5tZXNoZXNbbWVzaC5qc29uLkdVSURdO1xuICAgIFxuICAgIFxufVxuXG5TY2VuZS5jcmVhdGVCbGFzdCA9IGZ1bmN0aW9uIChtZXNoKSB7XG4gICAgdmFyIHRzID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICBTcHJpdGVVdGlscy5jcmVhdGVFeHBvc2lvbk9iamVjdChcbiAgICAgICAgXCIjXCIgKyBtZXNoLmpzb24uR1VJRCArIFwiX1wiICsgdHMgLCBcbiAgICAgICAgdHMsIFxuICAgICAgICBtZXNoLnBvc2l0aW9uLnRvQXJyYXkoKSwgXG4gICAgICAgIG1lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUucmFkaXVzICogMjAsXG4gICAgICAgIHRoaXMudGhyZWVfc2NlbmUsIFxuICAgICAgICB0aGlzLlcpO1xufVxuU2NlbmUucHJvY2Vzc19waHlzaWNhbCA9IGZ1bmN0aW9uKG1lc2gsIG5vdyl7XG5cdG1lc2gudXBkYXRlX3N0YXRpY19waHlzaWNhbF9kYXRhKG5vdyk7XG5cdFxufVxuU2NlbmUuX2FkZFRvU2VydmVyUXVldWUgPSBmdW5jdGlvbihhY3Rpb24pe1xuXHR0aGlzLlcuc2VuZEFjdGlvbih0aGlzLkdVSUQsIGFjdGlvbik7XG59XG5TY2VuZS5fZmx1c2hTZXJ2ZXJRdWV1ZSA9IGZ1bmN0aW9uKCl7XG5cdHZhciBzaXplID0gdGhpcy5fc2VydmVyX3N5bmNfcXVldWUubGVuZ3RoIDtcblx0dmFyIHJldCA9IHRoaXMuX3NlcnZlcl9zeW5jX3F1ZXVlLnNsaWNlKHRoaXMuX3NlcnZlcl9sYXN0X3NlbmRlZCk7XG5cblx0dGhpcy5fc2VydmVyX2xhc3Rfc2VuZGVkID0gc2l6ZTtcblx0cmV0dXJuIHtzY2VuZTp0aGlzLkdVSUQsIGFjdGlvbnM6cmV0fTtcbn1cblNjZW5lLmFkZE5ldHdvcmtNZXNzYWdlID0gZnVuY3Rpb24obWVzKXtcbiAgICB0aGlzLl9sYXN0X3VzZXJfYWN0aXZpdHkgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuXHR0aGlzLl9uZXR3b3JrX21lc3NhZ2VzLnB1c2gobWVzKSAvLyA9IHRoaXMuX25ldHdvcmtfbWVzc2FnZXMuY29uY2F0KG1lcylcbn07XG5TY2VuZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLm1lc2hlcyl7XG5cbiAgICAgICAgdGhpcy5tZXNoZXNbaV0uY2xlYXIoKTtcbiAgICAgICAgdGhpcy5tZXNoZXNbaV0gPSBudWxsO1xuXG4gICAgfTtcbiAgICB0aGlzLnRocmVlX3NjZW5lID0gbnVsbDtcbiAgICB0aGlzLmFjdG9ycyA9IG51bGw7XG4gICAgdGhpcy5XID0gbnVsbDtcbiAgICB0aGlzLm9uTG9hZENhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLl9zY2VuZV9vYmplY3RfY2FjaGUgPSBudWxsO1xuICAgIGZvciAodmFyIG1jIGluIHRoaXMuX21vZGVsX2NhY2hlKXtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21vZGVsX2NhY2hlW21jXTtcblxuICAgIH1cbn07XG5cblNjZW5lT2JqZWN0LnByb3RvdHlwZSA9IFNjZW5lO1xubW9kdWxlLmV4cG9ydHMgPSBTY2VuZU9iamVjdDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9zY2VuZS5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblxuXG5cblxudmFyIE1vZCA9IHtcbiAgICBcbiAgICBjcmVhdGVFeHBvc2lvbk9iamVjdCA6IGZ1bmN0aW9uKGlkLCB0cywgcG9zaXRpb24sIHNpemUsIHNjZW5lKXtcbiAgICAgICAgdmFyIGdlb20gID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoIDEsIDEgKTtcbiAgICAgICAgdmFyIFRJTUVfID0gMTQwMzY2MDAwMDAwMDtcbiAgICAgICAgdmFyIGV4cGxvc2lvbl90aW1lID0gNTAwMC47XG4gICAgICAgIFxuICAgICAgICB2YXIgdnNoYWRlciA9IFtcbiAgICAgICAgICd2YXJ5aW5nIHZlYzIgdlV2OycsXG4gICAgICAgICAndW5pZm9ybSB2ZWMzIHNjYWxlOycsXG4gICAgICAgICAndm9pZCBtYWluKCl7JyxcbiAgICAgICAgICcgICAgdlV2ID0gdXY7JyxcbiAgICAgICAgICcgICAgZmxvYXQgcm90YXRpb24gPSAwLjA7JyxcblxuICAgICAgICAgJyAgICB2ZWMzIGFsaWduZWRQb3NpdGlvbiA9IHZlYzMocG9zaXRpb24ueCAqIHNjYWxlLngsIHBvc2l0aW9uLnkgKiBzY2FsZS55LCBwb3NpdGlvbi56KnNjYWxlLnopOycsXG4gICAgICAgICAnICAgIHZlYzIgcG9zID0gYWxpZ25lZFBvc2l0aW9uLnh5OycsXG5cbiAgICAgICAgICcgICAgdmVjMiByb3RhdGVkUG9zaXRpb247JyxcbiAgICAgICAgICcgICAgcm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXG4gICAgICAgICAnICAgIHJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuXG4gICAgICAgICAnICAgIHZlYzQgZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgICAgICAnICAgIGZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxuICAgICAgICAgJyAgICBmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxuICAgICAgICAgJyAgICBmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIGZpbmFsUG9zaXRpb247JyxcblxuICAgICAgICAgJyAgICBnbF9Qb3NpdGlvbiA9ICBmaW5hbFBvc2l0aW9uOycsXG4gICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBmc2hhZGVyID0gW1xuICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgY3VyX3RpbWU7JyxcbiAgICAgICAgICd1bmlmb3JtIGZsb2F0IGJlZ190aW1lOycsXG4gICAgICAgICAndW5pZm9ybSBmbG9hdCBleHBsb3Npb25fdGltZTsnLFxuICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VXY7JyxcblxuICAgICAgICAgJ3ZvaWQgbWFpbigpeycsXG5cbiAgICAgICAgICcgICAgZmxvYXQgdGltZV9sZWZ0ID0gY3VyX3RpbWUgLSBiZWdfdGltZTsnLFxuICAgICAgICAgJyAgICBmbG9hdCBleHBsX3N0ZXAwID0gMC47JyxcbiAgICAgICAgICcgICAgZmxvYXQgZXhwbF9zdGVwMSA9IDAuMzsnLFxuICAgICAgICAgJyAgICBmbG9hdCBleHBsX21heCAgID0gMS47JyxcblxuICAgICAgICAgJyAgICBmbG9hdCBhczAgPSAwLjsnLFxuICAgICAgICAgJyAgICBmbG9hdCBhczEgPSAxLjsnLFxuICAgICAgICAgJyAgICBmbG9hdCBhczIgPSAwLjsnLFxuXG4gICAgICAgICAnICAgIGZsb2F0IHRpbWVfcGVyYyA9IGNsYW1wKCAodGltZV9sZWZ0IC8gZXhwbG9zaW9uX3RpbWUpLCAwLiwgMS4gKSA7JyxcblxuICAgICAgICAgJyAgICBmbG9hdCBhbHBoYXA7ICcsXG4gICAgICAgICAnICAgIGFscGhhcCA9IG1peChhczAsYXMxLCBzbW9vdGhzdGVwKGV4cGxfc3RlcDAsIGV4cGxfc3RlcDEsIHRpbWVfcGVyYykpOycsXG4gICAgICAgICAnICAgIGFscGhhcCA9IG1peChhbHBoYXAsYXMyLCBzbW9vdGhzdGVwKGV4cGxfc3RlcDEsIGV4cGxfbWF4LCB0aW1lX3BlcmMpKTsnLFxuXG4gICAgICAgICAnICAgIHZlYzIgcCA9IHZVdjsnLFxuICAgICAgICAgJyAgICB2ZWMyIGMgPSB2ZWMyKDAuNSwgMC41KTsnLFxuICAgICAgICAgJyAgICBmbG9hdCBtYXhfZyA9IDEuOycsXG4gICAgICAgICAnICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgocCAtIGMpICogMi4gOycsXG5cbiAgICAgICAgICcgICAgZmxvYXQgc3RlcDEgPSAwLjsnLFxuICAgICAgICAgJyAgICBmbG9hdCBzdGVwMiA9IDAuMjsnLFxuICAgICAgICAgJyAgICBmbG9hdCBzdGVwMyA9IDAuMzsnLFxuICAgICAgICAgXG4gICAgICAgICAnICAgIGZsb2F0IGEwID0gMS47JyxcbiAgICAgICAgICcgICAgZmxvYXQgYTEgPSAxLjsnLFxuICAgICAgICAgJyAgICBmbG9hdCBhMiA9IDAuNzsnLFxuICAgICAgICAgJyAgICBmbG9hdCBhMyA9IDAuMDsnLFxuICAgICAgICBcbiAgICAgICAgICcgICAgdmVjNCBjMCA9IHZlYzQoMS4sIDEuLCAxLiwgYTAgKiBhbHBoYXApOycsXG4gICAgICAgICAnICAgIHZlYzQgYzEgPSB2ZWM0KDAuOSwgMC45LCAxLiwgYTEgKiBhbHBoYXApOycsXG4gICAgICAgICAnICAgIHZlYzQgYzIgPSB2ZWM0KDAuNywgMC43LCAxLiwgYTIgKiBhbHBoYXApOycsXG4gICAgICAgICAnICAgIHZlYzQgYzMgPSB2ZWM0KDAuLCAwLiwgMC4sIDAuKTsnLFxuICAgICAgICAgXG4gICAgICAgICAnICAgIHZlYzQgY29sb3I7JyxcbiAgICAgICAgICcgICAgY29sb3IgPSBtaXgoYzAsIGMxLCBzbW9vdGhzdGVwKHN0ZXAxLCBzdGVwMiwgZGlzdCkpOycsXG4gICAgICAgICAnICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjMiwgc21vb3Roc3RlcChzdGVwMiwgc3RlcDMsIGRpc3QpKTsnLFxuICAgICAgICAgJyAgICBjb2xvciA9IG1peChjb2xvciwgYzMsIHNtb290aHN0ZXAoc3RlcDMsIG1heF9nLCBkaXN0KSk7JyxcblxuICAgICAgICAgJyAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjsgJyxcbiAgICAgICAgICd9J1xuICAgICAgICAgXG4gICAgICAgICBdLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRiZWdfdGltZTogICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogdHMgLSBUSU1FXyB9LFxuICAgICAgICAgICAgICAgICAgICBjdXJfdGltZTogeyB0eXBlOiBcImZcIiwgIHZhbHVlOiB0cyAtIFRJTUVfIH0sXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlIDogICB7dHlwZTpcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKX0sXG4gICAgICAgICAgICAgICAgICAgIGV4cGxvc2lvbl90aW1lOnsgdHlwZTonZicsIHZhbHVlOiBleHBsb3Npb25fdGltZSB9XG5cdFx0XHRcdFx0Ly9yZXNvbHV0aW9uOiAgIHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoKSB9XG5cdFx0XHRcdH07XG4gICAgICAgIHZhciB1cGRfdW5pZm9ybXMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGN0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBUSU1FXztcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVVVcIiwgY3QpXG4gICAgICAgICAgICB1bmlmb3Jtcy5jdXJfdGltZS52YWx1ZSA9IGN0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgbWF0ID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG5cdFx0XHRcdFx0dW5pZm9ybXM6IHVuaWZvcm1zLFxuXHRcdFx0XHRcdHZlcnRleFNoYWRlcjogdnNoYWRlcixcblx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogZnNoYWRlcixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nOlRIUkVFLkFkZGl0aXZlQmxlbmRpbmdcblxuXHRcdFx0XHR9ICk7XG4gICAgICAgIFxuICAgICAgICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb20sIG1hdClcbiAgICAgICAgbWVzaC5zY2FsZS5zZXQoc2l6ZSwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgIHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWVzaC5zY2FsZTtcbiAgICAgICAgbWVzaC5wb3NpdGlvbi5mcm9tQXJyYXkocG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgdmFyIHVuaWZvcm1VcGRhdGVyTmFtZSA9IFwiZXhwX1wiICsgaWQgKyBcIl9cIiArIHRzXG4gICAgICAgIHZhciB1bmlmb3JtVXBkYXRlcnMgPSBDdXN0b21VcGRhdGVyR2V0dGVyKCk7XG4gICAgICAgIFxuICAgICAgICB1bmlmb3JtVXBkYXRlcnMuYWRkKCB1bmlmb3JtVXBkYXRlck5hbWUsIHVwZF91bmlmb3Jtcyk7XG4gICAgICAgIHZhciBkZWxldGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdW5pZm9ybVVwZGF0ZXJzKHVuaWZvcm1VcGRhdGVyTmFtZSk7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUobWVzaClcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZGVsZXRlciwgZXhwbG9zaW9uX3RpbWUgKyA1MDApO1xuICAgICAgICBzY2VuZS5hZGQobWVzaCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbWVzaDtcbiAgICAgICAgXG4gICAgfSxcblx0bWFrZVRleHRTcHJpdGU6ZnVuY3Rpb24oIG1lc3NhZ2UsIHBhcmFtZXRlcnMgKXtcblx0XHRpZiAoIHBhcmFtZXRlcnMgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMgPSB7fTtcblx0XG5cdFx0dmFyIGZvbnRmYWNlID0gcGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShcImZvbnRmYWNlXCIpID8gXG5cdFx0XHRwYXJhbWV0ZXJzW1wiZm9udGZhY2VcIl0gOiBcIkFyaWFsXCI7XG5cdFxuXHRcdHZhciBmb250c2l6ZSA9IHBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoXCJmb250c2l6ZVwiKSA/IFxuXHRcdFx0cGFyYW1ldGVyc1tcImZvbnRzaXplXCJdIDogMTg7XG5cdFxuXHRcdHZhciBib3JkZXJUaGlja25lc3MgPSBwYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KFwiYm9yZGVyVGhpY2tuZXNzXCIpID8gXG5cdFx0XHRwYXJhbWV0ZXJzW1wiYm9yZGVyVGhpY2tuZXNzXCJdIDogNDtcblx0XG5cdFx0dmFyIGJvcmRlckNvbG9yID0gcGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShcImJvcmRlckNvbG9yXCIpID9cblx0XHRcdHBhcmFtZXRlcnNbXCJib3JkZXJDb2xvclwiXSA6IHsgcjowLCBnOjAsIGI6MCwgYToxLjAgfTtcblx0XG5cdFx0dmFyIGJhY2tncm91bmRDb2xvciA9IHBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoXCJiYWNrZ3JvdW5kQ29sb3JcIikgP1xuXHRcdFx0cGFyYW1ldGVyc1tcImJhY2tncm91bmRDb2xvclwiXSA6IHsgcjoyNTUsIGc6MjU1LCBiOjI1NSwgYToxLjAgfTtcblxuXHRcdC8vdmFyIHNwcml0ZUFsaWdubWVudCA9IFRIUkVFLlNwcml0ZUFsaWdubWVudC50b3BMZWZ0O1xuXHRcdFxuXHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGNvbnRleHQuZm9udCA9IFwiQm9sZCBcIiArIGZvbnRzaXplICsgXCJweCBcIiArIGZvbnRmYWNlO1xuICAgIFxuXHRcdC8vIGdldCBzaXplIGRhdGEgKGhlaWdodCBkZXBlbmRzIG9ubHkgb24gZm9udCBzaXplKVxuXHRcdHZhciBtZXRyaWNzID0gY29udGV4dC5tZWFzdXJlVGV4dCggbWVzc2FnZSApO1xuXHRcdHZhciB0ZXh0V2lkdGggPSBtZXRyaWNzLndpZHRoO1xuXHRcblx0XHQvLyBiYWNrZ3JvdW5kIGNvbG9yXG5cdFx0Y29udGV4dC5maWxsU3R5bGUgICA9IFwicmdiYShcIiArIGJhY2tncm91bmRDb2xvci5yICsgXCIsXCIgKyBiYWNrZ3JvdW5kQ29sb3IuZyArIFwiLFwiXG5cdFx0XHRcdFx0XHRcdFx0XHQgICsgYmFja2dyb3VuZENvbG9yLmIgKyBcIixcIiArIGJhY2tncm91bmRDb2xvci5hICsgXCIpXCI7XG5cdFx0Ly8gYm9yZGVyIGNvbG9yXG5cdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IFwicmdiYShcIiArIGJvcmRlckNvbG9yLnIgKyBcIixcIiArIGJvcmRlckNvbG9yLmcgKyBcIixcIlxuXHRcdFx0XHRcdFx0XHRcdFx0ICArIGJvcmRlckNvbG9yLmIgKyBcIixcIiArIGJvcmRlckNvbG9yLmEgKyBcIilcIjtcblxuXHRcdGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyVGhpY2tuZXNzO1xuXHRcdHRoaXMucm91bmRSZWN0KGNvbnRleHQsIGJvcmRlclRoaWNrbmVzcy8yLCBib3JkZXJUaGlja25lc3MvMiwgdGV4dFdpZHRoICsgYm9yZGVyVGhpY2tuZXNzLCBmb250c2l6ZSAqIDEuNCArIGJvcmRlclRoaWNrbmVzcywgNik7XG5cdFx0Ly8gMS40IGlzIGV4dHJhIGhlaWdodCBmYWN0b3IgZm9yIHRleHQgYmVsb3cgYmFzZWxpbmU6IGcsaixwLHEuXG5cdFxuXHRcdC8vIHRleHQgY29sb3Jcblx0XHRjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYSgwLCAwLCAwLCAxLjApXCI7XG5cblx0XHRjb250ZXh0LmZpbGxUZXh0KCBtZXNzYWdlLCBib3JkZXJUaGlja25lc3MsIGZvbnRzaXplICsgYm9yZGVyVGhpY2tuZXNzKTtcblx0XG5cdFx0Ly8gY2FudmFzIGNvbnRlbnRzIHdpbGwgYmUgdXNlZCBmb3IgYSB0ZXh0dXJlXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZShjYW52YXMpIFxuXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dmFyIHNwcml0ZU1hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCBcblx0XHRcdHsgbWFwOiB0ZXh0dXJlLCB1c2VTY3JlZW5Db29yZGluYXRlczogZmFsc2UgfSApO1xuXHRcdHZhciBzcHJpdGUgPSBuZXcgVEhSRUUuU3ByaXRlKCBzcHJpdGVNYXRlcmlhbCApO1xuXHRcdHNwcml0ZS5zY2FsZS5zZXQoMjAsMjAsMS4wKTtcblx0XHRyZXR1cm4gc3ByaXRlO1x0XG5cdH0sXG5cdHJvdW5kUmVjdDpmdW5jdGlvbihjdHgsIHgsIHksIHcsIGgsIHIpIFxuXHR7XG5cdCAgICBjdHguYmVnaW5QYXRoKCk7XG5cdCAgICBjdHgubW92ZVRvKHgrciwgeSk7XG5cdCAgICBjdHgubGluZVRvKHgrdy1yLCB5KTtcblx0ICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgrdywgeSwgeCt3LCB5K3IpO1xuXHQgICAgY3R4LmxpbmVUbyh4K3csIHkraC1yKTtcblx0ICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgrdywgeStoLCB4K3ctciwgeStoKTtcblx0ICAgIGN0eC5saW5lVG8oeCtyLCB5K2gpO1xuXHQgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeStoLCB4LCB5K2gtcik7XG5cdCAgICBjdHgubGluZVRvKHgsIHkrcik7XG5cdCAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4K3IsIHkpO1xuXHQgICAgY3R4LmNsb3NlUGF0aCgpO1xuXHQgICAgY3R4LmZpbGwoKTtcblx0XHRjdHguc3Ryb2tlKCk7ICAgXG5cdH1cbn1cbm1vZHVsZS5leHBvcnRzPU1vZFxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3Nwcml0ZV91dGlscy5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblxudmFyIFByZWRlZmluZWRPcmJpdGFsUGxhbmVzID0gW1swLDEsMF0sWzAsMSwwXSxbMCwxLDBdLFswLDEsMF0sWzAsMSwwXSxbMCwxLDBdLFswLDEsMF0sWzAsMSwwXSxbMCwxLDBdLFswLDEsMF0sWzAsMSwwXSxbLTAuMzA5MDE2OTk0Mzc0OTQ3NCwwLjk1MTA1NjUxNjI5NTE1MzUsMF0sWy0wLjI0OTk5OTk5OTk5OTk5OTk0LDAuOTUxMDU2NTE2Mjk1MTUzNSwwLjE4MTYzNTYzMjAwMTM0MDJdLFstMC4wOTU0OTE1MDI4MTI1MjYyNywwLjk1MTA1NjUxNjI5NTE1MzUsMC4yOTM4OTI2MjYxNDYyMzY1XSxbMC4wOTU0OTE1MDI4MTI1MjYyNywwLjk1MTA1NjUxNjI5NTE1MzUsMC4yOTM4OTI2MjYxNDYyMzY1XSxbMC4yNDk5OTk5OTk5OTk5OTk5MiwwLjk1MTA1NjUxNjI5NTE1MzUsMC4xODE2MzU2MzIwMDEzNDAyNV0sWzAuMzA5MDE2OTk0Mzc0OTQ3NCwwLjk1MTA1NjUxNjI5NTE1MzUsMy43ODQzNjY3Mjk0MTc3MTVlLTE3XSxbMC4yNDk5OTk5OTk5OTk5OTk5NCwwLjk1MTA1NjUxNjI5NTE1MzUsLTAuMTgxNjM1NjMyMDAxMzQwMTddLFswLjA5NTQ5MTUwMjgxMjUyNjMyLDAuOTUxMDU2NTE2Mjk1MTUzNSwtMC4yOTM4OTI2MjYxNDYyMzY1XSxbLTAuMDk1NDkxNTAyODEyNTI2MjMsMC45NTEwNTY1MTYyOTUxNTM1LC0wLjI5Mzg5MjYyNjE0NjIzNjVdLFstMC4yNDk5OTk5OTk5OTk5OTk5MiwwLjk1MTA1NjUxNjI5NTE1MzUsLTAuMTgxNjM1NjMyMDAxMzQwMjVdLFstMC4zMDkwMTY5OTQzNzQ5NDc0LDAuOTUxMDU2NTE2Mjk1MTUzNSwtNy41Njg3MzM0NTg4MzU0M2UtMTddLFstMC41ODc3ODUyNTIyOTI0NzMxLDAuODA5MDE2OTk0Mzc0OTQ3MywwXSxbLTAuNDc1NTI4MjU4MTQ3NTc2NzcsMC44MDkwMTY5OTQzNzQ5NDczLDAuMzQ1NDkxNTAyODEyNTI2M10sWy0wLjE4MTYzNTYzMjAwMTM0MDIsMC44MDkwMTY5OTQzNzQ5NDczLDAuNTU5MDE2OTk0Mzc0OTQ3NV0sWzAuMTgxNjM1NjMyMDAxMzQwMiwwLjgwOTAxNjk5NDM3NDk0NzMsMC41NTkwMTY5OTQzNzQ5NDc1XSxbMC40NzU1MjgyNTgxNDc1NzY2NSwwLjgwOTAxNjk5NDM3NDk0NzMsMC4zNDU0OTE1MDI4MTI1MjY0XSxbMC41ODc3ODUyNTIyOTI0NzMxLDAuODA5MDE2OTk0Mzc0OTQ3Myw3LjE5ODI5MzI3NjEyNjU5M2UtMTddLFswLjQ3NTUyODI1ODE0NzU3Njc3LDAuODA5MDE2OTk0Mzc0OTQ3MywtMC4zNDU0OTE1MDI4MTI1MjYyXSxbMC4xODE2MzU2MzIwMDEzNDAzLDAuODA5MDE2OTk0Mzc0OTQ3MywtMC41NTkwMTY5OTQzNzQ5NDczXSxbLTAuMTgxNjM1NjMyMDAxMzQwMTQsMC44MDkwMTY5OTQzNzQ5NDczLC0wLjU1OTAxNjk5NDM3NDk0NzVdLFstMC40NzU1MjgyNTgxNDc1NzY2NSwwLjgwOTAxNjk5NDM3NDk0NzMsLTAuMzQ1NDkxNTAyODEyNTI2NF0sWy0wLjU4Nzc4NTI1MjI5MjQ3MzEsMC44MDkwMTY5OTQzNzQ5NDczLC0xLjQzOTY1ODY1NTIyNTMxODVlLTE2XSxbLTAuODA5MDE2OTk0Mzc0OTQ3MywwLjU4Nzc4NTI1MjI5MjQ3MzEsMF0sWy0wLjY1NDUwODQ5NzE4NzQ3MzYsMC41ODc3ODUyNTIyOTI0NzMxLDAuNDc1NTI4MjU4MTQ3NTc2NzddLFstMC4yNDk5OTk5OTk5OTk5OTk5NCwwLjU4Nzc4NTI1MjI5MjQ3MzEsMC43Njk0MjA4ODQyOTM4MTMzXSxbMC4yNDk5OTk5OTk5OTk5OTk5NCwwLjU4Nzc4NTI1MjI5MjQ3MzEsMC43Njk0MjA4ODQyOTM4MTMzXSxbMC42NTQ1MDg0OTcxODc0NzM1LDAuNTg3Nzg1MjUyMjkyNDczMSwwLjQ3NTUyODI1ODE0NzU3NjhdLFswLjgwOTAxNjk5NDM3NDk0NzMsMC41ODc3ODUyNTIyOTI0NzMxLDkuOTA3NjAwNzIzNTA5ODU1ZS0xN10sWzAuNjU0NTA4NDk3MTg3NDczNiwwLjU4Nzc4NTI1MjI5MjQ3MzEsLTAuNDc1NTI4MjU4MTQ3NTc2NjVdLFswLjI1MDAwMDAwMDAwMDAwMDEsMC41ODc3ODUyNTIyOTI0NzMxLC0wLjc2OTQyMDg4NDI5MzgxMzJdLFstMC4yNDk5OTk5OTk5OTk5OTk4NiwwLjU4Nzc4NTI1MjI5MjQ3MzEsLTAuNzY5NDIwODg0MjkzODEzM10sWy0wLjY1NDUwODQ5NzE4NzQ3MzUsMC41ODc3ODUyNTIyOTI0NzMxLC0wLjQ3NTUyODI1ODE0NzU3NjhdLFstMC44MDkwMTY5OTQzNzQ5NDczLDAuNTg3Nzg1MjUyMjkyNDczMSwtMS45ODE1MjAxNDQ3MDE5NzFlLTE2XSxbLTAuOTUxMDU2NTE2Mjk1MTUzNSwwLjMwOTAxNjk5NDM3NDk0NzQsMF0sWy0wLjc2OTQyMDg4NDI5MzgxMzMsMC4zMDkwMTY5OTQzNzQ5NDc0LDAuNTU5MDE2OTk0Mzc0OTQ3NV0sWy0wLjI5Mzg5MjYyNjE0NjIzNjUsMC4zMDkwMTY5OTQzNzQ5NDc0LDAuOTA0NTA4NDk3MTg3NDczNl0sWzAuMjkzODkyNjI2MTQ2MjM2NSwwLjMwOTAxNjk5NDM3NDk0NzQsMC45MDQ1MDg0OTcxODc0NzM2XSxbMC43Njk0MjA4ODQyOTM4MTMyLDAuMzA5MDE2OTk0Mzc0OTQ3NCwwLjU1OTAxNjk5NDM3NDk0NzZdLFswLjk1MTA1NjUxNjI5NTE1MzUsMC4zMDkwMTY5OTQzNzQ5NDc0LDEuMTY0NzA4MzE4MTc2MjY1OWUtMTZdLFswLjc2OTQyMDg4NDI5MzgxMzMsMC4zMDkwMTY5OTQzNzQ5NDc0LC0wLjU1OTAxNjk5NDM3NDk0NzNdLFswLjI5Mzg5MjYyNjE0NjIzNjcsMC4zMDkwMTY5OTQzNzQ5NDc0LC0wLjkwNDUwODQ5NzE4NzQ3MzVdLFstMC4yOTM4OTI2MjYxNDYyMzY0LDAuMzA5MDE2OTk0Mzc0OTQ3NCwtMC45MDQ1MDg0OTcxODc0NzM2XSxbLTAuNzY5NDIwODg0MjkzODEzMiwwLjMwOTAxNjk5NDM3NDk0NzQsLTAuNTU5MDE2OTk0Mzc0OTQ3Nl0sWy0wLjk1MTA1NjUxNjI5NTE1MzUsMC4zMDkwMTY5OTQzNzQ5NDc0LC0yLjMyOTQxNjYzNjM1MjUzMTdlLTE2XSxbLTEsMCwwXSxbLTAuODA5MDE2OTk0Mzc0OTQ3MywwLDAuNTg3Nzg1MjUyMjkyNDczMV0sWy0wLjMwOTAxNjk5NDM3NDk0NzQsMCwwLjk1MTA1NjUxNjI5NTE1MzVdLFswLjMwOTAxNjk5NDM3NDk0NzQsMCwwLjk1MTA1NjUxNjI5NTE1MzVdLFswLjgwOTAxNjk5NDM3NDk0NzIsMCwwLjU4Nzc4NTI1MjI5MjQ3MzJdLFsxLDAsMS4yMjQ2NDY3OTg4MTg0MjhlLTE2XSxbMC44MDkwMTY5OTQzNzQ5NDczLDAsLTAuNTg3Nzg1MjUyMjkyNDczXSxbMC4zMDkwMTY5OTQzNzQ5NDc1NiwwLC0wLjk1MTA1NjUxNjI5NTE1MzRdLFstMC4zMDkwMTY5OTQzNzQ5NDczLDAsLTAuOTUxMDU2NTE2Mjk1MTUzNV0sWy0wLjgwOTAxNjk5NDM3NDk0NzIsMCwtMC41ODc3ODUyNTIyOTI0NzMyXSxbLTEsMCwtMi40NDkyOTM1OTc2MzY4NTZlLTE2XV1cblxudmFyIFV0aWxzID0ge1xuXHRtYWtlX3Nob3J0X2d1aWQgOmZ1bmN0aW9uKCl7XG5cdFx0dmFyIGd1aWQgPSAnNHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcblx0XHQgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpKjE2fDAsIHYgPSBjID09ICd4JyA/IHIgOiAociYweDN8MHg4KTtcblx0XHQgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBndWlkO1xuXHR9LFxuXHRcblx0bWFrZV9ndWlkIDpmdW5jdGlvbigpe1xuXHRcdHZhciBndWlkID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG5cdFx0ICAgIHZhciByID0gTWF0aC5yYW5kb20oKSoxNnwwLCB2ID0gYyA9PSAneCcgPyByIDogKHImMHgzfDB4OCk7XG5cdFx0ICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcblx0XHR9KTtcblx0XHRyZXR1cm4gZ3VpZDtcblx0fSxcbiAgICBvcmJpdGFsX25vcm1hbCA6IGZ1bmN0aW9uKGlkKXtcbiAgICAgICAgaWYoaWQgPCBQcmVkZWZpbmVkT3JiaXRhbFBsYW5lcy5sZW5ndGgpe1xuICAgICAgICAgICAgcmV0dXJuIFByZWRlZmluZWRPcmJpdGFsUGxhbmVzW2lkXTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb3JiaXRhbF9oZWlnaHQ6ZnVuY3Rpb24oaWQpe1xuICAgICAgICAvLyBvcmJpdHMgc3RhcnQgZnJvbSAyMDAga20gYW5kIHNwcmVkIHVwIHRvIDIgKiBjZWxlc3RpYWxfcmFkaXVzIHdpdGggc3RlcCAzMDBrbVxuICAgICAgICB2YXIgYmFzZSA9IDIwMDAwMDsgLy9tZXRlcnNcbiAgICAgICAgdmFyIHN0ZXAgPSAzMDAwMDA7XG4gICAgICAgIHJldHVybiBpZCpzdGVwICsgYmFzZTtcbiAgICAgICAgXG4gICAgfSxcbiAgICBpeF9hcnJheTogZnVuY3Rpb24oYXJyLCBpeCwgdmFsKXtcbiAgICAgICAgaWYoYXJyW2l4XSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGFycltpeF0gPSBbdmFsXVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGFycltpeF0ucHVzaCggdmFsICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBcbn1cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3V0aWxzLmpzXCIsXCIvXCIpIl19
